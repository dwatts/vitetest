import{ai as g,aj as f,al as X,ct as Y,b4 as Z,iL as D,iM as H,cx as _,iN as K,gM as A,iO as d,iP as V,iQ as k,iR as tt,iS as nt,iT as P,f5 as w,f4 as N,iU as et,iV as ot,b3 as rt,iW as O,iX as $,fA as S,iY as at,iZ as it,gg as x,i_ as st,eb as T,i$ as I,ap as lt,j0 as L,j1 as ct,j2 as B,j3 as ut,iJ as j,j4 as pt,j5 as gt,j6 as ft,j7 as ht,j8 as yt,j9 as mt,gj as xt,c3 as At,ja as $t,jb as wt,jc as jt}from"./index-86f9eeba.js";import{m as vt}from"./MeshGeoreferencedRelativeVertexSpace-76c6e1a4.js";import{m as bt,p as Mt}from"./MeshLocalVertexSpace-2c1f7c8b.js";var v;let p=v=class extends Y{constructor(t){super(t),this.translation=Z(),this.rotationAxis=D(H),this.rotationAngle=0,this.scale=_(1,1,1)}get rotation(){return K(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=A(d(t)),this.rotationAngle=V(t)}get localMatrix(){const t=w();return k(z,d(this.rotation),tt(this.rotation)),nt(t,z,this.translation,this.scale),t}get localMatrixInverse(){return P(w(),this.localMatrix)}applyLocal(t,n){return N(n,t,this.localMatrix)}applyLocalInverse(t,n){return N(n,t,this.localMatrixInverse)}equals(t){return this===t||t!=null&&et(this.localMatrix,t.localMatrix)}clone(){const t={translation:A(this.translation),rotationAxis:A(this.rotationAxis),rotationAngle:this.rotationAngle,scale:A(this.scale)};return new v(t)}};g([f({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"translation",void 0),g([f({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"rotationAxis",void 0),g([f({type:Number,nonNullable:!0,json:{write:!0}})],p.prototype,"rotationAngle",void 0),g([f({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"scale",void 0),g([f()],p.prototype,"rotation",null),g([f()],p.prototype,"localMatrix",null),g([f()],p.prototype,"localMatrixInverse",null),p=v=g([X("esri.geometry.support.MeshTransform")],p);const z=ot(),Rt=p;function G(t,n){return t.isGeographic||t.isWebMercator&&((n==null?void 0:n.geographic)??!0)}function Et(t,n,e){const o=!t.isGeoreferenced;(e==null?void 0:e.geographic)!=null&&e.geographic!==o&&rt.getLogger(n).warnOnce(`Specifying the 'geographic' parameter (${e.geographic}) for a Mesh vertex space of type "${t.type}" is not supported. This parameter will be ignored.`)}function M(t,n,e){return G(n.spatialReference,e)?St(t,n,e):Ot(t,n,e)}function W(t,n,e,o){const{position:a,normal:r,tangent:i}=t;if(!n.isRelative)return{position:a,normal:r,tangent:i};const l=(e==null?void 0:e.localMatrix)??$;return M({position:x(new Float64Array(a.length),a,l),normal:r!=null?wt(r,new Float32Array(r.length),l):null,tangent:i!=null?jt(i,new Float32Array(i.length),l):null},n.getOriginPoint(o),{geographic:!n.isGeoreferenced})}function Ft(t,n,e){if(e!=null&&e.useTransform){const{position:o,normal:a,tangent:r}=t,{x:i,y:l,z:c}=n,s=_(i,l,c??0);return{vertexAttributes:{position:o,normal:a,tangent:r},vertexSpace:e.geographic??1?new bt({origin:s}):new vt({origin:s}),transform:new Rt}}return{vertexAttributes:M(t,n,e),vertexSpace:new Mt,transform:null}}function b(t,n,e){return G(n.spatialReference,e)?Pt(t,n,e):q(t,n,e)}function dt(t,n,e,o,a){if(!n.isRelative)return b(t,o,a);const{spatialReference:r}=o,i=W(t,n,e,r);return o.equals(n.getOriginPoint(r))?q(i,o,a):b(i,o,a)}function Nt({positions:t,transform:n,vertexSpace:e,inSpatialReference:o,outSpatialReference:a,outPositions:r,local:i}){const l=e.isRelative?e.origin:O,c=e.isRelative?(n==null?void 0:n.localMatrix)??$:$;if(e.isGeoreferenced){const u=r??S(t.length);if(at(c,$)?it(u,t):x(u,t,c),!st(l,O)){const[J,Q,U]=l;for(let m=0;m<u.length;m+=3)u[m]+=J,u[m+1]+=Q,u[m+2]+=U}return T(u,o,0,u,a,0,u.length/3),u}const s=I(o),F=!i&&lt(o,s)?s:o;L(o,l,h,F),ct(h,h,c);const y=r??S(t.length);return x(y,t,h),T(y,F,0,y,a,0,y.length/3),y}function Ot(t,n,e){const o=new Float64Array(t.position.length),a=t.position,r=n.x,i=n.y,l=n.z??0,c=R(e?e.unit:null,n.spatialReference);for(let s=0;s<a.length;s+=3)o[s]=a[s]*c+r,o[s+1]=a[s+1]*c+i,o[s+2]=a[s+2]*c+l;return{position:o,normal:t.normal,tangent:t.tangent}}function St(t,n,e){const o=n.spatialReference,a=C(n,e,h),r=new Float64Array(t.position.length),i=Tt(t.position,a,o,r),l=B(E,a);return{position:i,normal:zt(i,r,t.normal,l,o),tangent:_t(i,r,t.tangent,l,o)}}function Tt(t,n,e,o){x(o,t,n);const a=new Float64Array(t.length);return ut(o,a,e)}function zt(t,n,e,o,a){if(e==null)return null;const r=new Float32Array(e.length);return j(r,e,o),pt(r,t,n,a,r),r}function _t(t,n,e,o,a){if(e==null)return null;const r=new Float32Array(e.length);j(r,e,o,4);for(let i=3;i<r.length;i+=4)r[i]=e[i];return gt(r,t,n,a,r),r}function q(t,n,e){const o=new Float64Array(t.position.length),a=t.position,r=n.x,i=n.y,l=n.z??0,c=R(e?e.unit:null,n.spatialReference);for(let s=0;s<a.length;s+=3)o[s]=(a[s]-r)/c,o[s+1]=(a[s+1]-i)/c,o[s+2]=(a[s+2]-l)/c;return{position:o,normal:t.normal,tangent:t.tangent}}function Pt(t,n,e){const o=n.spatialReference;C(n,e,h);const a=P(Gt,h),r=new Float64Array(t.position.length),i=It(t.position,o,a,r),l=B(E,a);return{position:i,normal:Lt(t.normal,t.position,r,o,l),tangent:Bt(t.tangent,t.position,r,o,l)}}function C(t,n,e){L(t.spatialReference,[t.x,t.y,t.z??0],e,I(t.spatialReference));const o=R(n?n.unit:null,t.spatialReference);return ft(e,e,[o,o,o]),e}function It(t,n,e,o){const a=ht(t,n,o),r=new Float64Array(a.length);return x(r,a,e),r}function Lt(t,n,e,o,a){if(t==null)return null;const r=yt(t,n,e,o,new Float32Array(t.length));return j(r,r,a),r}function Bt(t,n,e,o,a){if(t==null)return null;const r=mt(t,n,e,o,new Float32Array(t.length));return j(r,r,a,4),r}function R(t,n){if(t==null)return 1;const e=xt(n);return 1/At(e,"meters",t)}const h=w(),Gt=w(),E=$t(),Jt=Object.freeze(Object.defineProperty({__proto__:null,georeference:M,georeferenceApplyTransform:W,georeferenceByTransform:Ft,project:Nt,ungeoreference:b,ungeoreferenceByTransform:dt},Symbol.toStringTag,{value:"Module"}));export{b as D,dt as E,Nt as I,Rt as N,M as O,W as T,Jt as g,Et as o,Ft as q,G as r};
