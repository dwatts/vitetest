{
  "version": 3,
  "sources": ["../../@arcgis/core/chunks/EdgeDetect.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.27/esri/copyright.txt for details.\n*/\nimport{glsl as e}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as t}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as o}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{VertexAttribute as a}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{addResolutionUniform as r}from\"../views/3d/webgl-engine/shaders/SMAAPassParameters.js\";const l={threshold:.05,localConstrastAdaption:2};function s(){const s=new t,{attributes:d,varyings:x,vertex:i,fragment:c}=s;return d.add(a.POSITION,\"vec2\"),r(i),x.add(\"uv\",\"vec2\"),x.add(\"offsets[3]\",\"vec4\"),i.code.add(e`void main() {\nuv = position * 0.5 + vec2(0.5);\ngl_Position = vec4(position, 0, 1);\noffsets[0] = uv.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );\noffsets[1] = uv.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );\noffsets[2] = uv.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );\n}`),c.uniforms.add(new o(\"colorTexture\",(e=>e.colorTexture))),c.code.add(e`\n    float absMax3(vec3 v) {\n      vec3 t = abs(v);\n      return max(max(t.r, t.g), t.b);\n    }\n\n    void main() {\n      // Calculate color deltas:\n      vec4 delta;\n      vec3 C = texture(colorTexture, uv).rgb;\n\n      vec3 Cleft = texture(colorTexture, offsets[0].xy).rgb;\n      delta.x = absMax3(C - Cleft);\n\n      vec3 Ctop = texture(colorTexture, offsets[0].zw).rgb;\n      delta.y = absMax3(C - Ctop);\n\n      vec2 edges = step(vec2(${e.float(l.threshold)}), delta.xy);\n\n      // discard if there is no edge:\n      if (dot(edges, vec2(1.0)) == 0.0) {\n        discard;\n      }\n\n      // Calculate right and bottom deltas:\n      vec3 Cright = texture(colorTexture, offsets[1].xy).rgb;\n      delta.z = absMax3(C - Cright);\n\n      vec3 Cbottom  = texture(colorTexture, offsets[1].zw).rgb;\n      delta.w = absMax3(C - Cbottom);\n\n      // Calculate the maximum delta in the direct neighborhood:\n      float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\n\n      // Calculate left-left and top-top deltas:\n      vec3 Cleftleft  = texture(colorTexture, offsets[2].xy).rgb;\n      delta.z = absMax3(C - Cleftleft);\n\n      vec3 Ctoptop = texture(colorTexture, offsets[2].zw).rgb;\n      delta.w = absMax3(C - Ctoptop);\n\n      // Calculate the final maximum delta:\n      maxDelta = max(max(maxDelta, delta.z), delta.w);\n\n      // Local contrast adaptation in action:\n      edges.xy *= step(maxDelta, float(${e.float(l.localConstrastAdaption)}) * delta.xy);\n\n      fragColor = vec4(edges, 0.0, 0.0);\n    }\n  `),s}const d=Object.freeze(Object.defineProperty({__proto__:null,build:s},Symbol.toStringTag,{value:\"Module\"}));export{d as E,s as b};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAIyc,IAAM,IAAE,EAAC,WAAU,MAAI,wBAAuB,EAAC;AAAE,SAASA,KAAG;AAAC,QAAMA,KAAE,IAAI,KAAE,EAAC,YAAWC,IAAE,UAAS,GAAE,QAAOC,IAAE,UAAS,EAAC,IAAEF;AAAE,SAAOC,GAAE,IAAI,EAAE,UAAS,MAAM,GAAE,EAAEC,EAAC,GAAE,EAAE,IAAI,MAAK,MAAM,GAAE,EAAE,IAAI,cAAa,MAAM,GAAEA,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMjqB,GAAE,EAAE,SAAS,IAAI,IAAI,EAAE,gBAAgB,OAAG,EAAE,YAAa,CAAC,GAAE,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAiB1C,EAAE,MAAM,EAAE,SAAS,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yCA4BV,EAAE,MAAM,EAAE,sBAAsB,CAAC;AAAA;AAAA;AAAA;AAAA,GAIvE,GAAEF;AAAC;AAAC,IAAM,IAAE,OAAO,OAAO,OAAO,eAAe,EAAC,WAAU,MAAK,OAAMA,GAAC,GAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,CAAC;",
  "names": ["s", "d", "i"]
}
