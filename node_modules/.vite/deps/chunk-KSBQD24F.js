import {
  n as n2,
  s as s2
} from "./chunk-2SZNVP5H.js";
import {
  T as T2,
  i
} from "./chunk-FIBWCATC.js";
import {
  c
} from "./chunk-NETCTS4Y.js";
import {
  e as e2
} from "./chunk-CW7LIPBH.js";
import {
  e
} from "./chunk-VN2IXVGV.js";
import {
  B,
  a,
  g,
  o as o2
} from "./chunk-JB7FDW5N.js";
import {
  yn,
  zn
} from "./chunk-BNBT4QTW.js";
import {
  S,
  z
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import {
  f2 as f
} from "./chunk-ZEEBL7ZN.js";
import {
  P,
  T,
  o2 as o
} from "./chunk-RTDN6KAT.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/projection.js
var g2 = s.getLogger("esri.geometry.support.meshUtils.normalProjection");
function _(r, e3, t, o3, n3) {
  return k(o3) ? (V(U.TO_PCPF, i.fromTypedArray(r), T2.fromTypedArray(e3), T2.fromTypedArray(t), o3, i.fromTypedArray(n3)), n3) : (g2.error("Cannot convert spatial reference to PCPF"), n3);
}
function j(r, e3, t, o3, n3) {
  return k(o3) ? (V(U.FROM_PCPF, i.fromTypedArray(r), T2.fromTypedArray(e3), T2.fromTypedArray(t), o3, i.fromTypedArray(n3)), n3) : (g2.error("Cannot convert to spatial reference from PCPF"), n3);
}
function h(r, e3, t) {
  return yn(r, e3, 0, t, c(e3), 0, r.length / 3), t;
}
function E(r, e3, t) {
  return yn(r, c(t), 0, e3, t, 0, r.length / 3), e3;
}
function M(r, o3, n3) {
  return g(N, n3), n2(o3, r, N), B(N) || s2(o3, o3), o3;
}
function O(r, o3, n3) {
  if (g(N, n3), n2(o3, r, N, 4), B(N) || s2(o3, o3, 4), r !== o3)
    for (let e3 = 3; e3 < r.length; e3 += 4)
      o3[e3] = r[e3];
  return o3;
}
function R(r, e3, t, o3, n3) {
  if (!k(o3))
    return g2.error("Cannot convert spatial reference to PCPF"), n3;
  V(U.TO_PCPF, i.fromTypedArray(r, 4 * Float32Array.BYTES_PER_ELEMENT), T2.fromTypedArray(e3), T2.fromTypedArray(t), o3, i.fromTypedArray(n3, 4 * Float32Array.BYTES_PER_ELEMENT));
  for (let f2 = 3; f2 < r.length; f2 += 4)
    n3[f2] = r[f2];
  return n3;
}
function v(r, e3, t, o3, n3) {
  if (!k(o3))
    return g2.error("Cannot convert to spatial reference from PCPF"), n3;
  V(U.FROM_PCPF, i.fromTypedArray(r, 16), T2.fromTypedArray(e3), T2.fromTypedArray(t), o3, i.fromTypedArray(n3, 16));
  for (let f2 = 3; f2 < r.length; f2 += 4)
    n3[f2] = r[f2];
  return n3;
}
function V(r, e3, t, f2, a2, i2) {
  if (!e3)
    return;
  const m = t.count, y = c(a2);
  if (b(a2))
    for (let c2 = 0; c2 < m; c2++)
      f2.getVec(c2, B2), e3.getVec(c2, S2), zn(y, B2, w, y), a(N, w), r === U.FROM_PCPF && o2(N, N), S(S2, S2, N), i2.setVec(c2, S2);
  else
    for (let u = 0; u < m; u++) {
      f2.getVec(u, B2), e3.getVec(u, S2), zn(y, B2, w, y), a(N, w);
      const a3 = f(t.get(u, 1));
      let m2 = Math.cos(a3);
      r === U.TO_PCPF && (m2 = 1 / m2), N[0] *= m2, N[1] *= m2, N[2] *= m2, N[3] *= m2, N[4] *= m2, N[5] *= m2, r === U.FROM_PCPF && o2(N, N), S(S2, S2, N), z(S2, S2), i2.setVec(u, S2);
    }
  return i2;
}
function k(r) {
  return b(r) || L(r);
}
function b(r) {
  return r.isWGS84 || o(r) || T(r) || P(r);
}
function L(r) {
  return r.isWebMercator;
}
var U;
!function(r) {
  r[r.TO_PCPF = 0] = "TO_PCPF", r[r.FROM_PCPF = 1] = "FROM_PCPF";
}(U || (U = {}));
var B2 = n();
var S2 = n();
var w = e2();
var N = e();

export {
  _,
  j,
  h,
  E,
  M,
  O,
  R,
  v
};
//# sourceMappingURL=chunk-KSBQD24F.js.map
