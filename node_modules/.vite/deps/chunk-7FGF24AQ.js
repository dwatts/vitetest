import {
  l
} from "./chunk-HB2SQRT2.js";

// node_modules/@arcgis/core/views/3d/terrain/RenderOrder.js
var O;
!function(O2) {
  O2[O2.BACK_TO_FRONT = -1] = "BACK_TO_FRONT", O2[O2.NONE = 0] = "NONE", O2[O2.FRONT_TO_BACK = 1] = "FRONT_TO_BACK";
}(O || (O = {}));

// node_modules/@arcgis/core/views/3d/terrain/tileUtils.js
var n = class {
  constructor() {
    this._queue = new l(), this.remove = () => {
    };
  }
  get done() {
    return 0 === this._queue.length && (!this._last || this._last.isLeaf);
  }
  resetOne(t) {
    this._queue.clear(), this._queue.push(t), this._last = void 0;
  }
  reset(t = null) {
    this._queue.clear(), null != t && this._queue.pushArray(t), this._last = void 0;
  }
  skipSubtree() {
    this._last = void 0;
  }
  next() {
    var _a;
    const t = (_a = this._last) == null ? void 0 : _a.children;
    return t && t[0] && this._queue.pushArray(t), this._last = this._queue.pop(), this._last;
  }
};
var r = class {
  constructor() {
    this._q = new l();
  }
  get done() {
    return 0 === this._q.length;
  }
  reset(t) {
    if (this._q.clear(), null != t) {
      this._q.pushArray(t);
      for (let t2 = 0; t2 < this._q.length; ++t2) {
        const e = this._q.data[t2];
        e.isLeaf || this._q.pushArray(e.children);
      }
    }
  }
  next() {
    return this._q.pop();
  }
};
function o(t, e, n2) {
  if (null == e || null == e.fullExtent)
    return false;
  const r2 = e.fullExtent, s = t.extent;
  if (n2) {
    if (s[0] < r2.xmin || s[1] < r2.ymin || s[2] > r2.xmax || s[3] > r2.ymax)
      return false;
  } else if (r2.xmin > s[2] || r2.ymin > s[3] || r2.xmax < s[0] || r2.ymax < s[1])
    return false;
  const i = t.surface.tilingScheme.levels[t.level].scale, o2 = e.minScale;
  if (o2 > 0 && i > 1.00000001 * o2)
    return false;
  const l3 = e.maxScale;
  return !(l3 > 0 && i < 0.99999999 * l3);
}
function l2(t, e) {
  const n2 = t.lij, r2 = e.lij;
  return n2[0] - r2[0] || n2[1] - r2[1] || n2[2] - r2[2];
}
function u(t, n2, r2 = null) {
  null == r2 || 0 === r2.length ? t === O.BACK_TO_FRONT ? n2.sort(c) : n2.sort(f) : n2.sort((e, n3) => a(e, n3, t, r2));
}
function c(t, e) {
  const n2 = e.screenDepth - t.screenDepth;
  if (0 !== n2)
    return n2;
  const r2 = t.lij, s = e.lij;
  return r2[0] - s[0] || r2[1] - s[1] || r2[2] - s[2];
}
function f(t, e) {
  const n2 = t.screenDepth - e.screenDepth;
  if (0 !== n2)
    return n2;
  const r2 = t.lij, s = e.lij;
  return r2[0] - s[0] || r2[1] - s[1] || r2[2] - s[2];
}
function h(t, e, n2) {
  const r2 = t.screenDepth, s = e.screenDepth;
  return r2 < s ? -n2 : r2 > s ? n2 : l2(t, e);
}
function a(t, e, n2, r2) {
  return _(t, r2) === _(e, r2) ? h(t, e, n2) : t ? n2 : -n2;
}
function _(t, e) {
  for (const n2 of e)
    if (t.intersectsExtent(n2))
      return true;
  return false;
}
function p(t, e) {
  const n2 = t.distanceToPOI - e.distanceToPOI;
  if (0 !== n2)
    return n2;
  const r2 = t.lij, s = e.lij;
  return r2[0] - s[0] || r2[1] - s[1] || r2[2] - s[2];
}
function d(t, e) {
  const n2 = t.length;
  for (let r2 = 0; r2 < n2; ++r2) {
    t.at(r2).updateDistanceToPOI(e);
  }
  t.sort(p);
}
function m(t, e, n2) {
  let r2 = 1, s = 0, i = 0;
  for (; t !== e; )
    if (r2 *= 0.5, s *= 0.5, i *= 0.5, 1 & t.lij[2] && (s += 0.5), 0 == (1 & t.lij[1]) && (i += 0.5), null == (t = t.parent))
      throw new Error("tile was not a descendant of upsampleTile");
  n2.init(e, s, i, r2);
}
function q(t) {
  for (let e = 0; e < t.length; e++) {
    const n2 = t[e], r2 = n2.parent;
    if (r2)
      for (let t2 = 0; t2 < 4; t2++) {
        const e2 = r2.children[t2];
        if (e2 && e2 !== n2)
          return true;
      }
  }
  return false;
}
function x(t, e) {
  if (!t || !e || t[0] === e[0])
    return false;
  const n2 = t[0] < e[0], r2 = n2 ? t : e, s = n2 ? e : t, i = 1 << s[0] - r2[0];
  return Math.floor(s[1] / i) === r2[1] && Math.floor(s[2] / i) === r2[2];
}

export {
  O,
  n,
  r,
  o,
  l2 as l,
  u,
  h,
  d,
  m,
  q,
  x
};
//# sourceMappingURL=chunk-7FGF24AQ.js.map
