import {
  c as c5,
  y as y3
} from "./chunk-V7DVK56X.js";
import {
  $,
  F as F2,
  a as a3,
  a2 as a4,
  d as d4,
  e as e7,
  v2
} from "./chunk-SUS6FVXM.js";
import "./chunk-AWHGPLMH.js";
import {
  c as c4,
  i as i2,
  s as s4,
  t2 as t6,
  u as u4,
  u2 as u5
} from "./chunk-W2MFIVLD.js";
import "./chunk-2O3MFNAT.js";
import "./chunk-A4OLVRMJ.js";
import "./chunk-HIKCANPA.js";
import "./chunk-HUWHMZKL.js";
import "./chunk-BTHQ4EZE.js";
import "./chunk-XW6BCJUG.js";
import "./chunk-2NUCTFTS.js";
import {
  f,
  l as l3,
  u as u2
} from "./chunk-DJNU6MHD.js";
import {
  c as c3,
  g as g3,
  s as s3
} from "./chunk-67UNUI4B.js";
import "./chunk-2735WBYK.js";
import {
  B,
  b as b2,
  m as m2
} from "./chunk-UXOJL4UN.js";
import {
  i as i3
} from "./chunk-2KRMZDXT.js";
import {
  l as l4
} from "./chunk-Y3PBROKK.js";
import "./chunk-6HOJZLKI.js";
import "./chunk-6WY3ZZYN.js";
import "./chunk-CS6BZGQO.js";
import "./chunk-YZTKL3LQ.js";
import "./chunk-I7EXY23J.js";
import "./chunk-SCHIU6CT.js";
import {
  n as n6
} from "./chunk-MUANV6E3.js";
import "./chunk-SFIT2AUF.js";
import "./chunk-DBIFU6GO.js";
import {
  A,
  i,
  t as t5
} from "./chunk-V33FVMPT.js";
import "./chunk-U67EYFX3.js";
import "./chunk-5GYSL2SB.js";
import "./chunk-PLKG3UR7.js";
import "./chunk-4BA5YJ7C.js";
import {
  nt
} from "./chunk-WRC5WFEM.js";
import "./chunk-2EO2WRP7.js";
import "./chunk-EPDLDPS4.js";
import "./chunk-NBYHM3OO.js";
import "./chunk-CERU5LKM.js";
import "./chunk-JZVYLVFO.js";
import "./chunk-FAOMDC3K.js";
import "./chunk-SCAYUERS.js";
import "./chunk-YEDW7SLL.js";
import "./chunk-N4JKQR77.js";
import "./chunk-BDX5TRUE.js";
import "./chunk-LIXBKTBN.js";
import "./chunk-VDSNHCMM.js";
import "./chunk-6LC2JTLC.js";
import "./chunk-XM3YSFN6.js";
import "./chunk-NIZWDAMQ.js";
import "./chunk-DU3C7D26.js";
import "./chunk-ROPKVK6V.js";
import "./chunk-KM375BNF.js";
import "./chunk-H3DKDGMJ.js";
import "./chunk-FB6EWBGE.js";
import "./chunk-3TDCCT2R.js";
import "./chunk-Z2RTGLQI.js";
import "./chunk-V6CD66ZZ.js";
import "./chunk-6FHMQNMS.js";
import "./chunk-5ZW42GDY.js";
import "./chunk-D7YAG5U3.js";
import "./chunk-LGDKASPG.js";
import "./chunk-YQDOKTNT.js";
import "./chunk-SH6HJSS2.js";
import "./chunk-KFDARCTS.js";
import "./chunk-TRGMWULG.js";
import "./chunk-WTPQKRQM.js";
import {
  o2 as o
} from "./chunk-SMDDCTGQ.js";
import "./chunk-NU4UASX6.js";
import "./chunk-JHDKOKT6.js";
import "./chunk-YLTVH2K4.js";
import "./chunk-FB4A6PBH.js";
import "./chunk-CG3URTR2.js";
import "./chunk-UX3LCC3X.js";
import "./chunk-AB23UNQC.js";
import "./chunk-RDWKBYTH.js";
import "./chunk-IBJTEQQG.js";
import "./chunk-SADO52IH.js";
import "./chunk-WVOBJDWI.js";
import "./chunk-LIO6VZRI.js";
import "./chunk-7DFZCT3D.js";
import "./chunk-ASBUA7EG.js";
import "./chunk-FY4ZONHH.js";
import "./chunk-73PNWDTS.js";
import "./chunk-PKS3ZVLN.js";
import "./chunk-N3RXOITN.js";
import "./chunk-DOR4M5EA.js";
import "./chunk-3ROGWJVH.js";
import "./chunk-BUCIQGFS.js";
import "./chunk-CR5XNTAP.js";
import "./chunk-Z6IKMUOC.js";
import "./chunk-PV5KBAYL.js";
import "./chunk-YVVROPAO.js";
import "./chunk-GYNE34WO.js";
import "./chunk-QS45OHBM.js";
import "./chunk-IVMJPIWO.js";
import "./chunk-3I3GE5YW.js";
import "./chunk-WRFNQB7U.js";
import "./chunk-UUW6REOV.js";
import "./chunk-2US5EKDI.js";
import "./chunk-Z3NHJA5D.js";
import "./chunk-BO2REVMA.js";
import "./chunk-V66LHQVK.js";
import "./chunk-JP7O2ZWE.js";
import "./chunk-Z6R62RNV.js";
import "./chunk-3LLZ72VA.js";
import {
  b,
  v
} from "./chunk-4SIKLJSS.js";
import "./chunk-WDZ5AAFL.js";
import "./chunk-UM64E5NS.js";
import {
  I as I2
} from "./chunk-2XKILFME.js";
import "./chunk-G4LSNP77.js";
import "./chunk-BA6PBZHC.js";
import "./chunk-M7PTINEZ.js";
import "./chunk-Z7LZRT7C.js";
import "./chunk-SGBMUZSF.js";
import "./chunk-3TMT4LDG.js";
import "./chunk-BDWD2ZNU.js";
import "./chunk-FF5LS3YE.js";
import "./chunk-BCDDCNQ2.js";
import "./chunk-FIBWCATC.js";
import "./chunk-YC5U2RV5.js";
import "./chunk-ZNQYDNXF.js";
import "./chunk-FLVP2XLK.js";
import "./chunk-6S2FCH6S.js";
import "./chunk-3TTW7E7W.js";
import "./chunk-FOEAKQNX.js";
import {
  d as d3,
  h as h4,
  j as j2,
  k,
  t as t3
} from "./chunk-LEDSC236.js";
import "./chunk-OKABUMQT.js";
import {
  e as e6
} from "./chunk-CW7LIPBH.js";
import "./chunk-TYOIANOD.js";
import "./chunk-VN2IXVGV.js";
import "./chunk-WWUAHPIM.js";
import "./chunk-BN6X2OXK.js";
import {
  h as h2
} from "./chunk-OZL6Q7O2.js";
import "./chunk-YGUWDSEH.js";
import "./chunk-ZWFMUHG3.js";
import "./chunk-EFRTD25L.js";
import "./chunk-GSS6WNQU.js";
import "./chunk-C2EHS6UI.js";
import {
  t as t4
} from "./chunk-AAWIXPYE.js";
import {
  n as n5,
  u as u3
} from "./chunk-NEBQZ6AZ.js";
import "./chunk-7JB7RSO7.js";
import "./chunk-CEUJOC5P.js";
import "./chunk-63ERNIOV.js";
import {
  F,
  I
} from "./chunk-KRCNIFX2.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-M6OG7C2T.js";
import "./chunk-GOK5MP3B.js";
import "./chunk-NLWV7Q6F.js";
import "./chunk-RVS5HU2K.js";
import "./chunk-JB7FDW5N.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-5IYCCZ54.js";
import {
  c as c2
} from "./chunk-GDZM4A6K.js";
import "./chunk-XWGNMTES.js";
import "./chunk-6NNEHJYI.js";
import {
  kn,
  tn
} from "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-JNDFAMXY.js";
import "./chunk-NTEKJWGF.js";
import "./chunk-TFIKV5RU.js";
import "./chunk-KW6QQDGN.js";
import "./chunk-AQ7R6V4L.js";
import {
  d as d2
} from "./chunk-DOQ3SAAR.js";
import "./chunk-4BXK4H4L.js";
import "./chunk-SLVNG7FV.js";
import "./chunk-4CZO65BK.js";
import {
  d
} from "./chunk-SVCGLUNW.js";
import "./chunk-DEZCXTA3.js";
import {
  h as h3
} from "./chunk-RRJGZKNX.js";
import "./chunk-PL5Q4C6Y.js";
import "./chunk-KFSY6ZZH.js";
import {
  V
} from "./chunk-7EQSYZHW.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import "./chunk-4OR73Y2R.js";
import {
  C,
  g as g2,
  j
} from "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import {
  G,
  J,
  U,
  e as e5,
  g,
  r,
  u,
  x,
  z
} from "./chunk-TPJLFGOT.js";
import {
  e as e4,
  n as n3,
  t as t2
} from "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-Z2ZUNW5S.js";
import "./chunk-7L7Z2HXM.js";
import "./chunk-75NKPXTR.js";
import "./chunk-EUVARFSM.js";
import "./chunk-3VUFACNT.js";
import {
  x2
} from "./chunk-ZEEBL7ZN.js";
import "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-5EXFDBQJ.js";
import "./chunk-SJ2GJCS2.js";
import {
  h,
  l as l2,
  w
} from "./chunk-H7RDAEPY.js";
import "./chunk-ODFH3BSN.js";
import {
  n as n4
} from "./chunk-7KH4CLS5.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-JL3TJGVW.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import {
  m,
  t2 as t,
  y3 as y2
} from "./chunk-V76KGJFU.js";
import {
  a2,
  e as e3,
  n as n2
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import {
  y
} from "./chunk-7I33FAWS.js";
import {
  c,
  e as e2,
  l,
  n
} from "./chunk-DWOEYHKS.js";
import {
  s2
} from "./chunk-HMVAPW5X.js";
import {
  a
} from "./chunk-IYZKKFJM.js";
import {
  s
} from "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightConfiguration.js
var s5 = class extends m {
  constructor(o3) {
    super(o3), this.innerWidth = 2, this.outerWidth = 8, this.visibleInnerColor = new h3([3, 252, 111, 1]), this.visibleOuterColor = new h3([3, 252, 111, 0.15]), this.occludedInnerColor = new h3([252, 3, 69, 1]), this.occludedOuterColor = new h3([252, 3, 69, 0.1]), this.undefinedInnerColor = new h3([255, 255, 255, 1]), this.undefinedOuterColor = new h3([127, 127, 127, 0.2]);
  }
};
e([y2({ type: Number })], s5.prototype, "innerWidth", void 0), e([y2({ type: Number })], s5.prototype, "outerWidth", void 0), e([y2({ type: h3 })], s5.prototype, "visibleInnerColor", void 0), e([y2({ type: h3 })], s5.prototype, "visibleOuterColor", void 0), e([y2({ type: h3 })], s5.prototype, "occludedInnerColor", void 0), e([y2({ type: h3 })], s5.prototype, "occludedOuterColor", void 0), e([y2({ type: h3 })], s5.prototype, "undefinedInnerColor", void 0), e([y2({ type: h3 })], s5.prototype, "undefinedOuterColor", void 0), s5 = e([a2("esri.views.3d.analysis.LineOfSight.LineOfSightConfiguration")], s5);

// node_modules/@arcgis/core/views/3d/analysis/LineOfSightAnalysisResult.js
var s6 = class extends m {
  constructor(o3) {
    super(o3), this.target = null, this.intersectedGraphic = null, this.intersectedLocation = null, this.elevationAlignedTargetLocation = null, this.visible = void 0;
  }
};
e([y2()], s6.prototype, "target", void 0), e([y2()], s6.prototype, "intersectedGraphic", void 0), e([y2()], s6.prototype, "intersectedLocation", void 0), e([y2()], s6.prototype, "elevationAlignedTargetLocation", void 0), e([y2({ type: Boolean })], s6.prototype, "visible", void 0), s6 = e([a2("esri.views.3d.analysis.LineOfSightAnalysisResult")], s6);

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightComputation.js
var i4 = class extends m {
  constructor(t7) {
    super(t7), this.elevationAlignedTargetLocation = null, this.inputPoints = { isValid: false, observer: n3(), observerSurfaceNormal: null, observerFeatureId: null, target: n3(), targetSurfaceNormal: null, targetFeatureId: null, observerAdjusted: n3(), targetAdjusted: n3() }, this.computationResult = { start: n3(), end: n3(), intersection: n3(), isValid: false, isTargetVisible: false }, this.result = null;
  }
  notifyResultChanged() {
    this.notifyChange("computationResult");
  }
  notifyInputPointsChanged() {
    this.notifyChange("inputPoints");
  }
};
e([y2()], i4.prototype, "target", void 0), e([y2()], i4.prototype, "elevationAlignedTargetLocation", void 0), e([y2()], i4.prototype, "inputPoints", void 0), e([y2()], i4.prototype, "computationResult", void 0), e([y2()], i4.prototype, "result", void 0), i4 = e([a2("esri.views.3d.analysis.LineOfSight.LineOfSightComputation")], i4);

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightIntersectionResult.js
var m3;
var y4 = m3 = class extends m {
  constructor(r2) {
    super(r2);
  }
  clone() {
    return new m3({ type: this.type, id: a(this.id), mapPoint: a(this.mapPoint), renderPoint: t2(this.renderPoint), normal: a(this.normal), ray: a(this.ray), graphic: this.graphic });
  }
  equals(r2) {
    return this.type === r2.type && this.id === r2.id && c(this.mapPoint, r2.mapPoint) && G(this.renderPoint, r2.renderPoint) && s(this.normal, r2.normal) && j2(this.ray, r2.ray) && this.graphic === r2.graphic;
  }
};
e([y2()], y4.prototype, "type", void 0), e([y2({ constructOnly: true })], y4.prototype, "id", void 0), e([y2({ constructOnly: true })], y4.prototype, "mapPoint", void 0), e([y2({ constructOnly: true })], y4.prototype, "renderPoint", void 0), e([y2({ constructOnly: true })], y4.prototype, "normal", void 0), e([y2({ constructOnly: true })], y4.prototype, "graphic", void 0), e([y2({ constructOnly: true })], y4.prototype, "ray", void 0), y4 = m3 = e([a2("esri.views.3d.analysis.LineOfSight.LineOfSightIntersectionResult")], y4);

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightRayIntersector.js
var R = class extends m {
  constructor(e9) {
    super(e9), this._terrainIntersectionOptionsLayerUids = /* @__PURE__ */ new Set(["terrain"]);
  }
  initialize() {
    this.intersector = A(this.view.state.viewingMode), this.intersector.options.hud = false, this.intersector.options.store = t5.MIN;
  }
  getScreenPointIntersection(e9) {
    const r2 = d2(e9, t3.get()), s7 = i3(this.view.state.camera, r2, L);
    return this._getRayIntersection(s7);
  }
  _getRayIntersection(e9, r2) {
    if (null == e9 || null == this.view.sceneIntersectionHelper)
      return null;
    this.intersector.options.store = t5.MIN, this.view.sceneIntersectionHelper.intersectToolIntersectorRay(e9, this.intersector, r2);
    const t7 = this.intersector.results.min, s7 = n3();
    if (!t7.getIntersectionPoint(s7))
      return null;
    const o3 = this.view.renderCoordsHelper.fromRenderCoords(s7, this.view.spatialReference), i5 = t2(t7.normal);
    if (l4(t7))
      return new y4({ type: i.OBJECT, id: `${t7.target.layerUid}/${t7.target.nodeIndex}/${t7.target.componentIndex}`, mapPoint: o3, renderPoint: s7, normal: i5, ray: k(e9), graphic: null });
    if (n6(t7))
      return new y4({ type: i.TERRAIN, id: t7.target.lij.slice(), mapPoint: o3, renderPoint: s7, normal: i5, ray: k(e9), graphic: null });
    const n7 = m2(t7, this.view);
    if (null != n7) {
      const r3 = n7.layer, t8 = n7.sourceLayer;
      let c8;
      if (t8)
        if ("scene" === t8.type)
          c8 = I2(n7, t8.objectIdField);
        else
          c8 = n7.uid;
      else
        c8 = n7.uid;
      return new y4({ type: i.OBJECT, id: `${r3 == null ? void 0 : r3.uid}/${c8}`, mapPoint: o3, renderPoint: s7, normal: i5, ray: k(e9), graphic: n7 });
    }
    return null;
  }
  updateFromGroundIntersection(e9, r2, t7) {
    const s7 = S, o3 = U2, l6 = O, m5 = C2;
    r(o3, e9), this.view.renderCoordsHelper.worldUpAtPosition(o3, l6), z(l6, l6);
    const u7 = this.view.basemapTerrain.visibleElevationBounds, h6 = u7 ? Math.abs(u7.max - u7.min) : 100, f3 = r2 >= 0 ? 1 : -1;
    g(m5, l6, f3 * (h6 + Math.abs(r2))), u(s7, o3, m5), h4(s7, o3, L);
    const y7 = this._getRayIntersection(L, { include: this._terrainIntersectionOptionsLayerUids });
    return null != y7 ? (g(m5, l6, f3 * r2), u(t7, y7.renderPoint, m5), t2(y7.normal)) : (r(t7, e9), null);
  }
};
e([y2()], R.prototype, "view", void 0), e([y2()], R.prototype, "intersector", void 0), R = e([a2("esri.views.3d.analysis.LineOfSight.LineOfSightRayIntersector")], R);
var S = n3();
var U2 = n3();
var O = n3();
var C2 = n3();
var L = d3();

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightController.js
var M = "esri.views.3d.analysis.LineOfSight.LineOfSightController";
var Z = s2.getLogger(M);
var q = class extends n4.EventedMixin(m) {
  constructor(e9) {
    super(e9), this.updateOnCameraChange = true, this._observerGroundOffsetRenderSpace = 0, this._effectiveObserverElevationMode = "absolute-height", this._observerFeatureId = null, this._updatingHandles = new c2(), this._frameTask = F, this._handles = new t(), this._computationHandles = new t(), this._externalObserverUpdate = true;
  }
  initialize() {
    var _a;
    const e9 = (_a = this.view.resourceController) == null ? void 0 : _a.scheduler;
    this._frameTask = e9 ? e9.registerTask(I.LINE_OF_SIGHT_TOOL) : F, this._intersector = new R({ view: this.view }), this._handles.add([this._connectObserver(), this._connectComputations(), this._connectTargets()]);
  }
  destroy() {
    this._handles.destroy(), this._computationHandles.destroy(), this._computations.removeAll(), this._updatingHandles.destroy();
  }
  get updating() {
    return this._frameTask.updating || this._updatingHandles.updating;
  }
  get priority() {
    return this._frameTask.priority;
  }
  set priority(e9) {
    this._frameTask.priority = e9;
  }
  get _computations() {
    return this.analysisViewData.computations;
  }
  get _elevationAlignedObserverPositionRenderSpace() {
    return this.analysisViewData.observerEngineLocation;
  }
  set _elevationAlignedObserverPositionRenderSpace(e9) {
    this.analysisViewData.observerEngineLocation = e9;
  }
  get _screenPixelSize() {
    return this.view.state.camera.computeScreenPixelSizeAt(this._elevationAlignedObserverPositionRenderSpace);
  }
  _computeResult(e9) {
    const t7 = e9.computation, { inputPoints: n7, computationResult: o3 } = t7, { observerAdjusted: i5, targetAdjusted: r2 } = n7, { start: s7, end: a5 } = o3;
    r(s7, i5), r(a5, r2);
    this._canCompute(t7) ? this._computeIntersection(e9) : this._interpolateIntersection(e9), t7.notifyResultChanged(), this.emit("result-changed", { target: e9.computation.target, result: t7.result });
  }
  _updateAdjustedPointsFromFeatures(e9) {
    const n7 = this.view, { sceneIntersectionHelper: o3 } = n7, { inputPoints: i5 } = e9, { observerAdjusted: r2, observerFeatureId: s7, targetFeatureId: a5, targetAdjusted: l6 } = i5;
    if (null == s7 && null == a5)
      return;
    const u7 = x(r2, l6), c8 = this._intersector.intersector, d6 = h4(i5.observer, i5.target, J2);
    c8.options.store = t5.ALL, o3.intersectToolIntersectorRay(d6, c8);
    let p = null, h6 = null, g5 = null, m5 = null;
    for (const v3 of c8.results.all) {
      const e10 = m2(v3, this.view);
      if (null == e10 || null == v3.distanceInRenderSpace)
        continue;
      const o4 = l3(e10);
      null != o4 && (null != s7 && o4 === s7 && (null == p && (p = this._getFeatureDistanceThreshold(v3, n7, u7)), v3.distanceInRenderSpace < p && (g5 = v3)), null != a5 && o4 === a5 && (null == h6 && (h6 = this._getFeatureDistanceThreshold(v3, n7, u7)), null == m5 && v3.distanceInRenderSpace < u7 && u7 - v3.distanceInRenderSpace < h6 && (m5 = v3)));
    }
    null != g5 && g5.getIntersectionPoint(r2) && (i5.observerSurfaceNormal = g5.getTransformedNormal(n3())), null != m5 && m5.getIntersectionPoint(l6) && (i5.targetSurfaceNormal = m5.getTransformedNormal(n3()));
  }
  _getFeatureDistanceThreshold(e9, t7, n7) {
    if (B(e9)) {
      const o3 = b2(e9, t7);
      if (null != o3)
        return Math.min(o3 * Q, n7);
    }
    return 1e-5 * n7;
  }
  _adjustStartEndPositions(e9) {
    const t7 = this._screenPixelSize, n7 = this.view, { inputPoints: o3 } = e9, { observer: i5, observerSurfaceNormal: r2, target: s7, targetSurfaceNormal: a5, observerAdjusted: l6, targetAdjusted: u7 } = o3, c8 = W;
    r(l6, i5), r(u7, s7), this._updateAdjustedPointsFromFeatures(e9), null != r2 ? r(c8, r2) : e5(c8, u7, l6);
    const d6 = t7;
    z(c8, c8), g(c8, c8, Math.min(d6, 1)), u(l6, l6, c8), null != a5 ? r(c8, a5) : e5(c8, l6, u7);
    const p = n7.state.camera.computeScreenPixelSizeAt(u7);
    z(c8, c8), g(c8, c8, Math.min(p, 1)), u(u7, u7, c8);
  }
  _computeIntersection({ computation: e9, interpolationInfo: t7 }) {
    const { view: n7 } = this, { sceneIntersectionHelper: o3, renderCoordsHelper: i5 } = n7;
    if (null == o3)
      return;
    const r2 = this._intersector.intersector, { computationResult: s7, inputPoints: a5 } = e9, { observer: l6, target: u7 } = a5, { start: c8, end: d6 } = s7, p = h4(c8, d6, J2);
    r2.options.store = t5.MIN, o3.intersectToolIntersectorRay(p, r2);
    const h6 = r2.results.min, v3 = s7.intersection, m5 = W;
    let f3 = true;
    if (null != h6 && h6.getIntersectionPoint(v3)) {
      r(t7.originalIntersection, v3), r(t7.originalObserver, c8), r(t7.originalTarget, d6), i5.fromRenderCoords(v3, m5, n7.spatialReference);
      const e10 = 1 - U(d6, u7) / U(c8, u7);
      f3 = U(l6, v3) >= e10 * U(l6, u7);
    }
    const _2 = new x2(m5, n7.spatialReference);
    {
      const { result: t8, target: o4 } = e9;
      null != t8 ? (t8.target = o4, t8.intersectedGraphic = f3 ? null : m2(h6, n7), t8.intersectedLocation = f3 ? null : _2, t8.visible = f3) : e9.result = new s6({ target: o4, elevationAlignedTargetLocation: e9.elevationAlignedTargetLocation, intersectedGraphic: f3 ? null : m2(h6, n7), intersectedLocation: f3 ? null : _2, visible: f3 });
    }
    s7.isValid = a5.isValid = true, s7.isTargetVisible = f3;
  }
  _interpolateIntersection({ computation: e9, interpolationInfo: t7 }) {
    const { computationResult: n7, inputPoints: o3 } = e9, { start: i5, end: r2, intersection: s7 } = n7, { originalIntersection: a5, originalObserver: l6, originalTarget: u7 } = t7;
    if (r(s7, a5), o3.isValid) {
      const e10 = W, t8 = U(l6, a5) / U(l6, u7);
      J(e10, i5, l6), g(e10, e10, 1 - t8), u(s7, s7, e10), J(e10, r2, u7), g(e10, e10, t8), u(s7, s7, e10), n7.isValid = true;
    } else
      e9.result = null, n7.isValid = false, n7.isTargetVisible = false;
  }
  _canCompute(e9) {
    const t7 = this.analysisViewData.elevationAlignedObserver, n7 = this.view.frustum;
    if (null == t7 || null == e9.elevationAlignedTargetLocation || null == n7)
      return false;
    const { observerAdjusted: o3, targetAdjusted: i5 } = e9.inputPoints, r2 = n7.intersectsPoint(o3), s7 = n7.intersectsPoint(i5);
    return r2 && s7;
  }
  _onObserverPositionChange(e9, n7, o3, i5, r2) {
    if (this._externalObserverUpdate = r2, null == e9)
      return this.analysisViewData.elevationAlignedObserver = null, void (this._observerFeatureId = null);
    if (null == n7)
      return t6(this.analysis, e9.spatialReference, Z), void (this.analysisViewData.elevationAlignedObserver = null);
    const s7 = this._getEffectiveElevationInfo(n7, o3), { absoluteZ: a5, elevation: l6 } = g3(n7.x, n7.y, n7.z, this.view.spatialReference, this.view, s7), u7 = n7.clone();
    u7.z = a5, this._effectiveObserverElevationMode = s7.mode, this.analysisViewData.elevationAlignedObserver = u7;
    const c8 = n3();
    this.view.renderCoordsHelper.toRenderCoords(u7, c8), this._elevationAlignedObserverPositionRenderSpace = c8, this._observerGroundOffsetRenderSpace = a5 - l6, this._observerFeatureId = l3(i5), this.priority = I.LINE_OF_SIGHT_TOOL_INTERACTIVE;
  }
  _onObserverRenderSpacePositionChangeForComputation(e9, t7, n7, o3, i5) {
    const { inputPoints: r2 } = e9;
    switch (r(r2.observer, t7), r2.observerFeatureId = i5, r2.observerSurfaceNormal = null, o3) {
      case "on-the-ground":
      case "relative-to-ground": {
        const e10 = this._intersector.updateFromGroundIntersection(r2.observer, n7, r2.observer);
        null == r2.observerFeatureId && (r2.observerSurfaceNormal = e10);
      }
    }
    this._adjustStartEndPositions(e9), e9.notifyInputPointsChanged(), this.priority = I.LINE_OF_SIGHT_TOOL_INTERACTIVE;
  }
  _onTargetPositionChange(e9, n7, o3, i5, r2, s7 = true) {
    const a5 = e9.inputPoints;
    if (s7 && (a5.isValid = false), null == o3)
      return null != n7 && t6(this.analysis, n7.spatialReference, Z), e9.elevationAlignedTargetLocation = null, void e9.notifyInputPointsChanged();
    const l6 = this._getEffectiveElevationInfo(o3, i5), { absoluteZ: u7, elevation: c8 } = g3(o3.x, o3.y, o3.z, this.view.spatialReference, this.view, l6), d6 = o3.clone();
    switch (d6.z = u7, e9.elevationAlignedTargetLocation = d6, this.view.renderCoordsHelper.toRenderCoords(e9.elevationAlignedTargetLocation, a5.target), a5.targetFeatureId = l3(r2), a5.targetSurfaceNormal = null, l6.mode) {
      case "on-the-ground":
      case "relative-to-ground": {
        const e10 = this._intersector.updateFromGroundIntersection(a5.target, u7 - c8, a5.target);
        null == a5.targetFeatureId && (a5.targetSurfaceNormal = e10);
      }
    }
    this._adjustStartEndPositions(e9), e9.notifyInputPointsChanged(), this.priority = I.LINE_OF_SIGHT_TOOL_INTERACTIVE;
  }
  _connectComputationToTarget(e9) {
    return n2([this._updatingHandles.add(() => ({ computation: e9, targetPosition: e9.target.position, targetElevationInfo: e9.target.elevationInfo, targetFeatureInfo: e9.target.feature, projectedTargetPosition: tn(e9.target.position, this.view.spatialReference) }), ({ computation: e10, targetPosition: t7, targetElevationInfo: n7, targetFeatureInfo: o3, projectedTargetPosition: i5 }) => {
      null == i5.pending ? this._onTargetPositionChange(e10, t7, i5.geometry, n7, o3) : this._updatingHandles.addPromise(i5.pending);
    }, h)]);
  }
  _connectComputationToObserver(e9) {
    return this._updatingHandles.add(() => ({ computation: e9, observer: this.analysisViewData.elevationAlignedObserver }), ({ computation: e10 }) => {
      this._externalObserverUpdate && (e10.inputPoints.isValid = false, e10.notifyInputPointsChanged());
    }, h);
  }
  _connectComputationToRenderSpaceObserver(e9) {
    return this._updatingHandles.add(() => ({ computation: e9, observer: this._elevationAlignedObserverPositionRenderSpace, observerGroundOffset: this._observerGroundOffsetRenderSpace, observerElevationMode: this._effectiveObserverElevationMode, observerFeatureId: this._observerFeatureId }), ({ computation: e10, observer: t7, observerGroundOffset: n7, observerElevationMode: o3, observerFeatureId: i5 }) => {
      this._onObserverRenderSpacePositionChangeForComputation(e10, t7, n7, o3, i5);
    }, h);
  }
  _connectComputationToCamera(e9) {
    return this._updatingHandles.add(() => ({ camera: this.view.state.camera, isDirty: this._isCameraDirty }), ({ isDirty: t7 }) => {
      !this.updateOnCameraChange || e9.inputPoints.isValid && !t7 || e9.notifyInputPointsChanged();
    });
  }
  _connectComputationToSlicePlane(e9) {
    return this._updatingHandles.add(() => this.view.slicePlane, () => {
      e9.inputPoints.isValid = false, e9.notifyInputPointsChanged();
    });
  }
  _connectComputationToElevation(e9) {
    const t7 = (n7, o3) => {
      const i5 = this.analysis.observer, r2 = e9.target;
      let s7 = null, a5 = null, l6 = null, u7 = null, c8 = null, d6 = null;
      if (null != i5 && null != i5.position) {
        const e10 = tn(i5.position, this.view.spatialReference);
        if (null != e10.pending)
          return this._updatingHandles.addPromise(e10.pending), void e10.pending.finally(() => t7(n7, o3));
        s7 = e10.geometry, a5 = i5.elevationInfo, l6 = i5.feature;
      }
      if (null != r2.position) {
        const e10 = tn(r2.position, this.view.spatialReference);
        if (null != e10.pending)
          return this._updatingHandles.addPromise(e10.pending), void e10.pending.finally(() => t7(n7, o3));
        u7 = e10.geometry, c8 = r2.elevationInfo, d6 = r2.feature;
      }
      null == s7 && null == u7 || (kn(n7, o3, K, this.view.spatialReference), null != s7 && j(K, s7) && this._onObserverPositionChange(null != i5 ? i5.position : null, s7, a5, l6, false), null != u7 && j(K, u7) && this._onTargetPositionChange(e9, r2.position, u7, c8, d6, false), null != s7 && null != u7 && g2(K, s7, u7) && e9.notifyInputPointsChanged());
    };
    return this.view.elevationProvider.on("elevation-change", (e10) => t7(e10.extent, e10.spatialReference));
  }
  _connectComputationToTask(e9) {
    let t7 = null;
    const n7 = { computation: e9, interpolationInfo: { originalIntersection: n3(), originalObserver: n3(), originalTarget: n3() } };
    return n2([this._updatingHandles.add(() => e9.inputPoints, () => {
      t7 = e2(t7), t7 = d(async (e10) => {
        await y(this._frameTask.schedule(() => this._computeResult(n7), e10));
      });
    }, { initial: true, equals: () => false }), e3(() => t7 = e2(t7))]);
  }
  _connectComputation(e9) {
    const t7 = this._computationHandles;
    t7.has(e9) || t7.add([this._connectComputationToTarget(e9), this._connectComputationToObserver(e9), this._connectComputationToRenderSpaceObserver(e9), this._connectComputationToCamera(e9), this._connectComputationToSlicePlane(e9), this._connectComputationToElevation(e9), this._connectComputationToTask(e9)], e9);
  }
  _disconnectComputation(e9) {
    this._computationHandles.remove(e9);
  }
  _onComputationCollectionChange({ added: e9, removed: t7 }) {
    for (const n7 of t7)
      this._disconnectComputation(n7);
    for (const n7 of e9)
      this._connectComputation(n7);
  }
  _onTargetCollectionChange({ added: e9, removed: t7 }) {
    for (const n7 of t7)
      this._removeTarget(n7);
    for (const n7 of e9)
      this._addTarget(n7);
  }
  _onCursorTargetChange(e9, t7) {
    null != t7 && this._removeTarget(t7), null != e9 && this._addTarget(e9);
  }
  _addTarget(e9) {
    this._computations.some((t7) => t7.target === e9) || this._computations.add(new i4({ target: e9 }));
  }
  _removeTarget(e9) {
    const t7 = this._computations.findIndex((t8) => t8.target === e9);
    this._computations.removeAt(t7);
  }
  _connectObserver() {
    return n2([this._updatingHandles.add(() => ({ observerPosition: null != this.analysis.observer ? this.analysis.observer.position : null, projectedObserverPosition: tn(null != this.analysis.observer ? this.analysis.observer.position : null, this.view.spatialReference), observerElevationInfo: null != this.analysis.observer ? this.analysis.observer.elevationInfo : null, observerFeatureInfo: null != this.analysis.observer ? this.analysis.observer.feature : null }), ({ observerPosition: e9, projectedObserverPosition: t7, observerElevationInfo: n7, observerFeatureInfo: o3 }) => {
      null == t7.pending ? this._onObserverPositionChange(e9, t7.geometry, n7, o3, true) : this._updatingHandles.addPromise(t7.pending);
    }, h)]);
  }
  _connectComputations() {
    return this._updatingHandles.addOnCollectionChange(() => this._computations, (e9) => this._onComputationCollectionChange(e9), { initial: true, final: true });
  }
  _connectTargets() {
    return n2([this._updatingHandles.addOnCollectionChange(() => this.analysis.targets, (e9) => this._onTargetCollectionChange(e9), { initial: true, final: true }), this._updatingHandles.add(() => this.analysisViewData.cursorTarget, (e9, t7) => {
      this._onCursorTargetChange(e9, t7);
    })]);
  }
  get _isCameraDirty() {
    const e9 = this.analysisViewData.elevationAlignedObserver, { view: t7 } = this, { renderCoordsHelper: n7 } = t7;
    if (null == e9 || null == n7)
      return false;
    const o3 = W;
    n7.toRenderCoords(e9, o3);
    const i5 = t7.state.camera.computeScreenPixelSizeAt(o3);
    return Math.abs((i5 - this._screenPixelSize) / this._screenPixelSize) > B2;
  }
  _getEffectiveElevationInfo(e9, t7) {
    return e9.hasZ ? t7 ?? { mode: "absolute-height", offset: 0 } : { mode: "on-the-ground", offset: 0 };
  }
};
e([y2({ constructOnly: true })], q.prototype, "analysis", void 0), e([y2({ constructOnly: true })], q.prototype, "analysisViewData", void 0), e([y2({ constructOnly: true })], q.prototype, "view", void 0), e([y2()], q.prototype, "updating", null), e([y2()], q.prototype, "priority", null), e([y2()], q.prototype, "updateOnCameraChange", void 0), e([y2()], q.prototype, "_computations", null), e([y2()], q.prototype, "_elevationAlignedObserverPositionRenderSpace", null), e([y2()], q.prototype, "_observerGroundOffsetRenderSpace", void 0), e([y2()], q.prototype, "_effectiveObserverElevationMode", void 0), e([y2()], q.prototype, "_observerFeatureId", void 0), e([y2()], q.prototype, "_screenPixelSize", null), e([y2({ readOnly: true })], q.prototype, "_updatingHandles", void 0), e([y2()], q.prototype, "_frameTask", void 0), e([y2()], q.prototype, "_isCameraDirty", null), q = e([a2(M)], q);
var B2 = 0.1;
var W = n3();
var J2 = d3();
var K = C();
var Q = 0.05;

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightToolConfiguration.js
var l5 = class extends m {
  constructor(o3) {
    super(o3), this.enabled = true, this.glowColor = i2(), this.glowWidth = 8, this.innerColor = u4(), this.innerWidth = 0.75, this.globalAlpha = c4(0.75);
  }
};
e([y2({ type: Boolean })], l5.prototype, "enabled", void 0), e([y2({ type: h3 })], l5.prototype, "glowColor", void 0), e([y2({ type: Number })], l5.prototype, "glowWidth", void 0), e([y2({ type: h3 })], l5.prototype, "innerColor", void 0), e([y2({ type: Number })], l5.prototype, "innerWidth", void 0), e([y2({ type: Number })], l5.prototype, "globalAlpha", void 0), l5 = e([a2("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightLaserLineConfiguration")], l5);
var d5 = class extends m {
  constructor(o3) {
    super(o3), this.size = 0.5, this.color = i2(0.75);
  }
};
e([y2({ type: Number })], d5.prototype, "size", void 0), e([y2({ type: h3 })], d5.prototype, "color", void 0), d5 = e([a2("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightObserverConfiguration")], d5);
var y5 = class extends m {
  constructor(o3) {
    super(o3), this.size = 0.5, this.visibleColor = new h3([3, 252, 111, 0.75]), this.occludedColor = new h3([252, 3, 69, 0.75]), this.undefinedColor = new h3([127, 127, 127, 0.75]);
  }
};
e([y2({ type: Number })], y5.prototype, "size", void 0), e([y2({ type: h3 })], y5.prototype, "visibleColor", void 0), e([y2({ type: h3 })], y5.prototype, "occludedColor", void 0), e([y2({ type: h3 })], y5.prototype, "undefinedColor", void 0), y5 = e([a2("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightTargetConfiguration")], y5);
var c6 = class extends m {
  constructor(o3) {
    super(o3), this.innerWidth = 2, this.outerWidth = 8, this.visibleInnerColor = new h3([3, 252, 111, 1]), this.visibleOuterColor = new h3([3, 252, 111, 0.15]), this.occludedInnerColor = new h3([252, 3, 69, 1]), this.occludedOuterColor = new h3([252, 3, 69, 0.1]), this.undefinedInnerColor = new h3([255, 255, 255, 1]), this.undefinedOuterColor = new h3([127, 127, 127, 0.2]);
  }
};
e([y2({ type: Number })], c6.prototype, "innerWidth", void 0), e([y2({ type: Number })], c6.prototype, "outerWidth", void 0), e([y2({ type: h3 })], c6.prototype, "visibleInnerColor", void 0), e([y2({ type: h3 })], c6.prototype, "visibleOuterColor", void 0), e([y2({ type: h3 })], c6.prototype, "occludedInnerColor", void 0), e([y2({ type: h3 })], c6.prototype, "occludedOuterColor", void 0), e([y2({ type: h3 })], c6.prototype, "undefinedInnerColor", void 0), e([y2({ type: h3 })], c6.prototype, "undefinedOuterColor", void 0);
var h5 = class extends m {
  constructor(o3) {
    super(o3), this.laserLine = new l5(), this.observer = new d5(), this.target = new y5(), this.lineOfSight = new c6();
  }
};
e([y2({ type: l5 })], h5.prototype, "laserLine", void 0), e([y2({ type: d5 })], h5.prototype, "observer", void 0), e([y2({ type: y5 })], h5.prototype, "target", void 0), e([y2({ type: c6 })], h5.prototype, "lineOfSight", void 0), h5 = e([a2("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightToolConfiguration")], h5);

// node_modules/@arcgis/core/views/3d/interactive/editingTools/manipulatorUtils.js
function o2(e9, n7) {
  let o3 = null;
  const t7 = e9.events.on("grab-changed", (t8) => {
    null != o3 && (o3.remove(), o3 = null), "start" === t8.action ? (o3 = e9.disableDisplay(), n7 && n7(t8)) : n7 && n7(t8);
  });
  return { remove() {
    null != o3 && o3.remove(), t7.remove();
  } };
}

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/lineOfSightToolUtils.js
function m4(t7, i5, n7) {
  return new e7(nt(F2(h3.toUnitRGBA(i5)), t7, 32, 32), n7);
}
function u6(o3) {
  const t7 = [];
  return o3.customColor1 && t7.push(m4(o3.size, o3.customColor1, u3.Custom1)), o3.customColor2 && t7.push(m4(o3.size, o3.customColor2, u3.Custom2)), o3.customColor3 && t7.push(m4(o3.size, o3.customColor3, u3.Custom3)), o3.color && t7.push(m4(o3.size, o3.color)), t7;
}
function c7(o3, r2) {
  const e9 = u6(r2), s7 = new $({ view: o3, renderObjects: e9, elevationInfo: { mode: "absolute-height", offset: 0 } });
  return o2(s7), s7;
}

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightTool.js
var D;
!function(e9) {
  e9.Ready = "ready", e9.Creating = "creating", e9.Created = "created";
}(D || (D = {}));
var E = class extends a3 {
  constructor(e9) {
    super(e9), this.removeIncompleteOnCancel = false, this.configuration = new h5(), this.analysisViewData = null, this._latestPointerMovePointerType = null, this._laserlineVisualElement = null, this._grabbedManipulator = null, this._analysisHandles = new t(), this._handles = new t(), this._updatingHandles = new c2(), this._manipulatorHandles = new t(), this._targetTrackerManipulator = null;
  }
  initialize() {
    this._intersector = new R({ view: this.view }), this._handles.add(l2(() => this.state, (e9) => {
      e9 === D.Created && this.finishToolCreation();
    }, w)), this._observerManipulator = this._createObserverManipulator(), this._handles.add([this._updatingHandles.add(() => ({ ...this.configuration.observer }), () => this._updateObserverManipulatorStyle()), this._updatingHandles.add(() => {
      var _a;
      return (_a = this.analysisViewData) == null ? void 0 : _a.elevationAlignedObserver;
    }, (e9) => this._onObserverLocationChange(e9), h), this._updatingHandles.add(() => ({ ...this.configuration.laserLine }), () => this._createVisualElements(), h), this._updatingHandles.add(() => this._laserLineRendererDependencies(), (e9) => this._updateLaserLineRenderer(e9)), this._connectComputations(), this._updatingHandles.addWhen(() => !this._shouldRenderTracker, () => this._clearCursorTracker(), h)]);
  }
  destroy() {
    this._updatingHandles = l(this._updatingHandles), this._handles = l(this._handles), this._manipulatorHandles = l(this._manipulatorHandles), this._analysisHandles = l(this._analysisHandles), this._observerManipulator = null, this._clearCursorTracker(), this._removeVisualElements(), this._intersector = null, this._set("analysis", null);
  }
  get state() {
    return this.active ? this.hasGrabbedManipulators ? D.Created : D.Creating : null != this.analysis.observer && null != this.analysis.observer.position ? D.Created : D.Ready;
  }
  get cursor() {
    return this.active && this._showTracker ? "crosshair" : null;
  }
  get updating() {
    return null != this.analysisViewData && this.analysisViewData.updating || this._updatingHandles.updating;
  }
  get _showTracker() {
    return this.active && "mouse" === this._latestPointerMovePointerType;
  }
  get _shouldRenderTracker() {
    return this._showTracker && null != this.analysis.observer && null != this.analysis.observer.position && !this.hasGrabbedManipulators;
  }
  continue() {
    this.view.activeTool = this;
  }
  stop() {
    this.view.activeTool = null;
  }
  onEditableChange() {
    this.analysisViewData.editable = this.internallyEditable;
  }
  onInputEvent(e9) {
    switch (e9.type) {
      case "immediate-double-click":
        this._doubleClickHandler(e9);
        break;
      case "key-down":
        this._keyDownHandler(e9);
        break;
      case "pointer-move":
        this._pointerMoveHandler(e9);
    }
  }
  onInputEventAfter(e9) {
    if ("immediate-click" === e9.type)
      this._clickHandler(e9);
  }
  onShow() {
  }
  onHide() {
  }
  onDeactivate() {
    this._clearCursorTracker();
  }
  _connectComputations() {
    return this._updatingHandles.addOnCollectionChange(() => this.analysisViewData.computations, (e9) => this._onComputationsCollectionChange(e9), { initial: true, final: true });
  }
  _onComputationsCollectionChange({ added: e9, removed: t7 }) {
    for (const i5 of t7)
      this._disconnectComputation(i5);
    for (const i5 of e9)
      this._connectComputation(i5);
  }
  _connectComputation(e9) {
    if (this.destroyed)
      return void s2.getLogger(this).warn("Attempting to connect an analysis to a destroyed LineOfSight tool. Ignoring.");
    const t7 = this._analysisHandles;
    if (t7.has(e9))
      return;
    const i5 = this._createTargetManipulator(e9.target);
    null == this._targetTrackerManipulator && i5.metadata.target === this.analysisViewData.cursorTarget && (this._targetTrackerManipulator = i5, this._targetTrackerManipulator.available = false, this._targetTrackerManipulator.interactive = false, this._updateLaserLineRenderer()), t7.add([this._updatingHandles.add(() => this._getLineOfSightManipulatorStateDependencies(e9), () => this._updateManipulatorState(i5, e9), h), this._updatingHandles.add(() => e9.elevationAlignedTargetLocation, (e10) => this._onTargetLocationChange(e10, i5), h)], e9);
  }
  _disconnectComputation(e9) {
    if (this.destroyed)
      return void s2.getLogger(this).warn("Attempting to disconnect an analysis from a destroyed LineOfSight tool. Ignoring.");
    this._analysisHandles.remove(e9);
    const t7 = this._getTargetManipulator(e9.target);
    null != t7 && (this.manipulators.remove(t7), this._manipulatorHandles.remove(t7), null != this._targetTrackerManipulator && this._targetTrackerManipulator === t7 && (this._targetTrackerManipulator = null));
  }
  _clearCursorTracker() {
    this.analysisViewData.cursorTarget = l(this.analysisViewData.cursorTarget);
  }
  _createManipulator(e9, t7, i5) {
    const a5 = c7(this.view, e9);
    return a5.metadata = i5, this._manipulatorHandles.add([t7(a5), a5.events.on("grab-changed", (e10) => this._manipulatorGrabChanged(a5, e10)), a5.events.on("immediate-click", (e10) => this._manipulatorClick(a5, e10))], a5), this.manipulators.add(a5), a5;
  }
  _createTargetManipulator(e9) {
    const t7 = this.configuration, i5 = { size: t7.target.size, customColor1: t7.target.visibleColor, customColor2: t7.target.occludedColor, customColor3: t7.target.undefinedColor, visible: true }, a5 = { target: e9, type: "target" }, r2 = this._createManipulator(i5, (e10) => this._createTargetManipulatorDragPipeline(e10), a5);
    return null != e9.position ? r2.elevationAlignedLocation = e9.position : r2.available = false, r2;
  }
  _getTargetManipulator(e9) {
    let t7 = null;
    return this.manipulators.forEach((i5) => {
      const a5 = i5.manipulator;
      null == t7 && "target" === a5.metadata.type && a5.metadata.target === e9 && (t7 = a5);
    }), t7;
  }
  _createObserverManipulator() {
    const e9 = this.configuration, t7 = { size: e9.observer.size, color: e9.observer.color, visible: true };
    return this._createManipulator(t7, (e10) => this._createObserverManipulatorDragPipeline(e10), { type: "observer", intersection: null });
  }
  _updateObserverManipulatorStyle() {
    const e9 = this._observerManipulator, t7 = this.configuration.observer, i5 = { size: t7.size, color: t7.color, visible: e9.available };
    e9.renderObjects = u6(i5);
  }
  _screenToIntersection() {
    return (e9) => {
      const t7 = this._intersector.getScreenPointIntersection(e9.screenEnd);
      return null == t7 ? null : { ...e9, intersection: t7 };
    };
  }
  _createTargetManipulatorDragPipeline(e9) {
    return d4(e9, (t7, i5, a5) => {
      i5.next(this._screenToIntersection()).next(this._updateTargetDragStep(e9)).next(() => this._updateLaserLineRenderer()), a5.next(this._cancelTargetDragStep(e9.metadata.target)).next(() => this._updateLaserLineRenderer());
    });
  }
  _createObserverManipulatorDragPipeline(e9) {
    return d4(e9, (e10, t7, i5) => {
      t7.next(this._screenToIntersection()).next(this._updateObserverDragStep()).next(() => this._updateLaserLineRenderer()), i5.next(this._cancelObserverDragStep()).next(() => this._updateLaserLineRenderer());
    });
  }
  _updateObserverDragStep() {
    return (e9) => (null != e9.intersection.mapPoint ? (null == this.analysis.observer && (this.analysis.observer = new u2()), this._updateFromIntersection(this.analysis.observer, e9.intersection)) : this.analysis.observer = null, e9);
  }
  _cancelObserverDragStep() {
    const e9 = null != this.analysis.observer && null != this.analysis.observer.position ? this.analysis.observer.clone() : null;
    return (t7) => (this.analysis.observer = e9, t7);
  }
  _updateTargetDragStep(e9) {
    return (t7) => {
      this._updateFromIntersection(e9.metadata.target, t7.intersection);
      const i5 = t7.intersection.mapPoint;
      return null != i5 && (e9.elevationAlignedLocation = i5), t7;
    };
  }
  _cancelTargetDragStep(e9) {
    const t7 = n(e9.position, (e10) => e10.clone());
    return (i5) => (e9.position = t7, i5);
  }
  _manipulatorGrabChanged(e9, t7) {
    switch (t7.action) {
      case "start":
        this._grabbedManipulator = e9;
        break;
      case "end":
        this._grabbedManipulator === e9 && (this._grabbedManipulator = null);
    }
  }
  _updateManipulatorState(e9, t7) {
    const { isValid: i5, isTargetVisible: a5 } = t7.computationResult;
    e9.state = i5 ? a5 ? u3.Custom1 : u3.Custom2 : u3.Custom3;
  }
  _getLineOfSightManipulatorStateDependencies(e9) {
    const { isValid: t7, isTargetVisible: i5 } = e9.computationResult;
    return { isValid: t7, isTargetVisible: i5 };
  }
  _laserLineRendererDependencies() {
    return { laserlineVisualElement: this._laserlineVisualElement, grabbedManipulator: this._grabbedManipulator, shouldRenderTracker: this._shouldRenderTracker, observerPosition: null != this.analysis.observer ? this.analysis.observer.position : null, visible: this.visible };
  }
  _updateLaserLineRenderer(e9 = this._laserLineRendererDependencies()) {
    const { laserlineVisualElement: t7, grabbedManipulator: i5, shouldRenderTracker: a5, observerPosition: r2, visible: n7 } = e9;
    if (null == t7)
      return;
    const s7 = null != i5 ? i5 : a5 && null != r2 ? this._targetTrackerManipulator : null;
    this.configuration.laserLine.enabled && null != s7 && n7 ? (t7.visible = true, t7.heightManifoldTarget = s7.renderLocation, s7 !== this._observerManipulator ? t7.lineVerticalPlaneSegment = b(this._observerManipulator.renderLocation, s7.renderLocation, I3) : t7.lineVerticalPlaneSegment = null) : (t7.visible = false, t7.heightManifoldTarget = null, t7.lineVerticalPlaneSegment = null);
  }
  _createVisualElements() {
    const e9 = this.configuration.laserLine;
    this._removeVisualElements(), this._laserlineVisualElement = new c5({ view: this.view, attached: true, visible: this.visible, style: { glowColor: h3.toUnitRGB(e9.glowColor), glowWidth: e9.glowWidth, innerColor: h3.toUnitRGB(e9.innerColor), innerWidth: e9.innerWidth, globalAlpha: e9.globalAlpha } });
  }
  _removeVisualElements() {
    null != this._laserlineVisualElement && (this._laserlineVisualElement.destroy(), this._laserlineVisualElement = null);
  }
  _onObserverLocationChange(e9) {
    null != e9 ? (this._observerManipulator.metadata.intersection = null, this._observerManipulator.available = true, this._observerManipulator.elevationAlignedLocation = e9) : this._observerManipulator.available = false;
  }
  _onTargetLocationChange(e9, t7) {
    null != e9 ? (t7.elevationAlignedLocation = e9, t7 !== this._targetTrackerManipulator && (t7.available = true)) : t7.available = false;
  }
  _addPointFromClickEvent(e9) {
    const t7 = this._intersector.getScreenPointIntersection(e9);
    if (null != t7 && null != t7.mapPoint)
      if (null != this.analysis.observer && null != this.analysis.observer.position) {
        this._clearCursorTracker();
        const e10 = new f();
        this._updateFromIntersection(e10, t7), this.analysis.targets.add(e10);
      } else {
        const e10 = new u2();
        this._updateFromIntersection(e10, t7), this.analysis.observer = e10;
      }
  }
  _clickHandler(e9) {
    this.active && e9.button !== t4.Right && (this._addPointFromClickEvent(n5(e9)), e9.stopPropagation());
  }
  _doubleClickHandler(e9) {
    this.active && e9.button !== t4.Right && (this.stop(), e9.stopPropagation());
  }
  _keyDownHandler(e9) {
    this.active && "Escape" === e9.key && (this.stop(), e9.stopPropagation());
  }
  _pointerMoveHandler(e9) {
    if (this.hasGrabbedManipulators)
      return;
    if (this._latestPointerMovePointerType = e9.pointerType, this._updateLaserLineRenderer(), !this._showTracker || null == this.analysis.observer || null == this.analysis.observer.position)
      return;
    const t7 = n5(e9), i5 = this._intersector.getScreenPointIntersection(t7);
    null != i5 && null != i5.mapPoint && (null == this.analysisViewData.cursorTarget && (this.analysisViewData.cursorTarget = new f()), this._updateFromIntersection(this.analysisViewData.cursorTarget, i5), this._updateLaserLineRenderer());
  }
  _updateFromIntersection(e9, t7) {
    if (null == t7.mapPoint)
      return e9.position = null, e9.elevationInfo = null, void (e9.feature = null);
    switch (t7.type) {
      case i.OBJECT:
        if (null != t7.graphic) {
          const i6 = t7.graphic, a5 = s3(i6);
          "on-the-ground" === a5.mode && (a5.mode = "relative-to-ground", a5.offset = 0), e9.elevationInfo = new h2(a5), e9.feature = i6;
        } else
          e9.elevationInfo = null, e9.feature = null;
        break;
      case i.TERRAIN:
      case i.I3S:
        e9.elevationInfo = new h2({ mode: "on-the-ground" }), e9.feature = null;
        break;
      default:
        e9.elevationInfo = null, e9.feature = null;
    }
    const i5 = t7.mapPoint.clone();
    i5.z = c3(this.view, i5, { mode: "absolute-height", offset: 0 }, e9.elevationInfo), e9.position = i5;
  }
  _manipulatorClick(e9, t7) {
    if ("observer" === e9.metadata.type || e9.grabbing || e9.dragging || t7.button !== t4.Right || this.analysis.targets.length <= 1)
      return;
    const { target: i5 } = e9.metadata;
    this.analysis.targets.remove(i5), t7.stopPropagation();
  }
  get testInfo() {
    return { laserLineVisualElement: this._laserlineVisualElement, getTargetManipulator: (e9) => this._getTargetManipulator(e9) };
  }
};
e([y2({ constructOnly: true })], E.prototype, "view", void 0), e([y2({ constructOnly: true })], E.prototype, "analysis", void 0), e([y2({ readOnly: true })], E.prototype, "state", null), e([y2({ readOnly: true })], E.prototype, "cursor", null), e([y2()], E.prototype, "removeIncompleteOnCancel", void 0), e([y2({ readOnly: true })], E.prototype, "updating", null), e([y2({ type: h5 })], E.prototype, "configuration", void 0), e([y2({ constructOnly: true })], E.prototype, "analysisViewData", void 0), e([y2({ readOnly: true })], E.prototype, "_showTracker", null), e([y2()], E.prototype, "_latestPointerMovePointerType", void 0), e([y2()], E.prototype, "_shouldRenderTracker", null), e([y2()], E.prototype, "_laserlineVisualElement", void 0), e([y2()], E.prototype, "_grabbedManipulator", void 0), E = e([a2("esri.views.3d.interactive.analysisTools.lineOfSight.LineOfSightTool")], E);
var I3 = v();

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightVisualElement.js
var e8 = class {
  constructor(e9, i5, t7, s7) {
    this.visibleLineVisualElement = e9, this.occludedLineVisualElement = i5, this.undefinedLineVisualElement = t7, this.targetVisualElement = s7;
  }
  destroy() {
    this.visibleLineVisualElement.destroy(), this.occludedLineVisualElement.destroy(), this.undefinedLineVisualElement.destroy(), this.targetVisualElement.destroy();
  }
};

// node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightVisualization.js
var b3 = class extends m {
  constructor(i5) {
    super(i5), this._lineOfSightVisualElements = new Array(), this._computationHandles = new t(), this._updatingHandles = new c2();
  }
  initialize() {
    this.addHandles(this._connectComputations()), this._createObserverVisualization();
  }
  destroy() {
    this._updatingHandles = l(this._updatingHandles), this._computationHandles = l(this._computationHandles), this._observerVisualElement = l(this._observerVisualElement);
  }
  get visible() {
    return this.analysisViewData.visible;
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get interactiveAndEditable() {
    return this.analysisViewData.interactive && this.analysisViewData.editable;
  }
  get test() {
    return { disablePartialOcclusion: () => {
      for (const i5 of this._lineOfSightVisualElements)
        i5.visibleLineVisualElement.renderOccluded = o.Occlude, i5.occludedLineVisualElement.renderOccluded = o.Occlude, i5.undefinedLineVisualElement.renderOccluded = o.Occlude;
    }, visualizations: this._lineOfSightVisualElements };
  }
  get _configuration() {
    return this.analysisViewData.configuration;
  }
  _createLineOfSightVisualization() {
    const i5 = this._configuration, t7 = this.view, n7 = { view: t7, attached: true, width: i5.outerWidth, innerWidth: i5.innerWidth }, o3 = h3.toUnitRGBA(i5.visibleOuterColor), s7 = h3.toUnitRGBA(i5.visibleInnerColor), r2 = h3.toUnitRGBA(i5.occludedOuterColor), a5 = h3.toUnitRGBA(i5.occludedInnerColor), l6 = h3.toUnitRGBA(i5.undefinedOuterColor), c8 = h3.toUnitRGBA(i5.undefinedInnerColor), u7 = new u5({ ...n7, color: o3, innerColor: s7 }), d6 = new u5({ ...n7, color: r2, innerColor: a5 }), m5 = new u5({ ...n7, color: l6, innerColor: c8 }), h6 = new y3({ view: t7, attached: true, ..._, size: 8 }), f3 = new e8(u7, d6, m5, h6);
    return this._lineOfSightVisualElements.push(f3), f3;
  }
  _destroyLineOfSightVisualization(i5) {
    i5.destroy(), this._lineOfSightVisualElements.splice(this._lineOfSightVisualElements.indexOf(i5), 1);
  }
  _updateLineOfSightVisualization(i5, t7, n7) {
    const o3 = this._configuration, { computationResult: s7, inputPoints: r2 } = i5, { start: a5, end: l6, intersection: c8, isValid: m5, isTargetVisible: h6 } = s7, { observer: p } = r2, g5 = C3;
    g5[12] = p[0], g5[13] = p[1], g5[14] = p[2];
    const v3 = e5(O2, a5, p), f3 = e5(V2, l6, p), b4 = e5(y6, c8, p), { visibleLineVisualElement: _2, occludedLineVisualElement: E2, undefinedLineVisualElement: w2, targetVisualElement: A2 } = t7, S2 = null == this.analysisViewData.elevationAlignedObserver || null == i5.elevationAlignedTargetLocation, j3 = this.visible && !S2;
    _2.visible = j3, E2.visible = j3, w2.visible = j3, A2.visible = j3, A2.attached = !n7.interactiveAndEditable, j3 && (_2.geometry = null, E2.geometry = null, w2.geometry = null, A2.geometry = i5.elevationAlignedTargetLocation, m5 ? h6 ? (_2.geometry = [[e4(v3), e4(f3)]], _2.transform = g5, _2.color = h3.toUnitRGBA(o3.visibleOuterColor), A2.color = h3.toUnitRGBA(o3.visibleInnerColor)) : (_2.geometry = [[e4(v3), e4(b4)]], _2.transform = g5, _2.color = h3.toUnitRGBA(o3.occludedOuterColor), E2.geometry = [[e4(b4), e4(f3)]], E2.transform = g5, A2.color = h3.toUnitRGBA(o3.occludedInnerColor)) : (w2.geometry = [[e4(v3), e4(f3)]], w2.transform = g5, A2.color = h3.toUnitRGBA(o3.undefinedInnerColor)));
  }
  _getLineOfSightVisualizationDependencies(i5) {
    const { computationResult: e9 } = i5, { occludedOuterColor: t7, visibleOuterColor: n7 } = this._configuration;
    return { computationResult: e9, occludedOuterColor: t7, visibleOuterColor: n7, visible: this.visible, interactiveAndEditable: this.interactiveAndEditable };
  }
  _connectComputation(i5) {
    const e9 = this._computationHandles;
    if (e9.has(i5))
      return;
    const t7 = this._createLineOfSightVisualization();
    e9.add([this._updatingHandles.add(() => this._getLineOfSightVisualizationDependencies(i5), (e10) => this._updateLineOfSightVisualization(i5, t7, e10), { initial: true, equals: () => false }), e3(() => this._destroyLineOfSightVisualization(t7))], i5);
  }
  _disconnectComputation(i5) {
    this._computationHandles.remove(i5);
  }
  _connectComputations() {
    return this._updatingHandles.addOnCollectionChange(() => this.analysisViewData.computations, (i5) => this._onComputationsCollectionChange(i5), { initial: true, final: true });
  }
  _onComputationsCollectionChange({ added: i5, removed: e9 }) {
    for (const t7 of e9)
      this._disconnectComputation(t7);
    for (const t7 of i5)
      this._connectComputation(t7);
  }
  _createObserverVisualization() {
    const i5 = h3.toUnitRGBA(this._configuration.visibleInnerColor), t7 = new y3({ view: this.view, attached: false, color: i5, ..._ });
    this._observerVisualElement = t7, this.addHandles(this._updatingHandles.add(() => ({ observer: this.analysisViewData.elevationAlignedObserver, interactiveAndEditable: this.interactiveAndEditable, visible: this.visible }), ({ observer: i6, interactiveAndEditable: e9, visible: n7 }) => {
      null != i6 && !e9 && n7 ? (t7.geometry = i6, this._observerVisualElement.attached = true) : t7.attached = false;
    }, h));
  }
};
e([y2({ constructOnly: true })], b3.prototype, "analysis", void 0), e([y2({ constructOnly: true })], b3.prototype, "analysisViewData", void 0), e([y2({ constructOnly: true })], b3.prototype, "view", void 0), e([y2({ readOnly: true })], b3.prototype, "visible", null), e([y2()], b3.prototype, "updating", null), e([y2()], b3.prototype, "interactiveAndEditable", null), e([y2()], b3.prototype, "test", null), e([y2()], b3.prototype, "_configuration", null), b3 = e([a2("esri.views.3d.analysis.LineOfSight.LineOfSightVisualization")], b3);
var _ = { size: 6, pixelSnappingEnabled: false, primitive: "circle", elevationInfo: { mode: "absolute-height", offset: 0 }, outlineSize: 0 };
var O2 = n3();
var V2 = n3();
var y6 = n3();
var C3 = e6();

// node_modules/@arcgis/core/views/3d/analysis/LineOfSightAnalysisView3D.js
var g4 = class extends s4(n4.EventedMixin(m)) {
  constructor(t7) {
    super(t7), this.type = "line-of-sight-view-3d", this.analysis = null, this.tool = null, this.computations = new V(), this.elevationAlignedObserver = null, this.configuration = new s5(), this.observerEngineLocation = n3(), this.cursorTarget = null, this.editable = true;
  }
  initialize() {
    const t7 = this.view, i5 = this.analysis;
    this._analysisController = new q({ analysis: i5, analysisViewData: this, view: t7 }), this._analysisVisualization = new b3({ analysis: i5, analysisViewData: this, view: t7 }), this.addHandles([this._analysisController.on("result-changed", (t8) => {
      t8.target !== this.cursorTarget && this.emit("result-changed", t8);
    }), a4(this, E)]);
  }
  destroy() {
    v2(this), this._analysisController = l(this._analysisController), this._analysisVisualization = l(this._analysisVisualization);
  }
  get results() {
    return this.computations.map((t7) => t7.result);
  }
  get priority() {
    return this._analysisController.priority;
  }
  set priority(t7) {
    this._analysisController.priority = t7;
  }
  get updating() {
    return null != this._analysisController && this._analysisController.updating || null != this._analysisVisualization && this._analysisVisualization.updating;
  }
  getResultForTarget(t7) {
    const i5 = this.computations.find((i6) => i6.target === t7);
    return n(i5, (t8) => t8.result);
  }
  get testInfo() {
    return { visualization: this._analysisVisualization, controller: this._analysisController };
  }
};
e([y2({ readOnly: true })], g4.prototype, "type", void 0), e([y2({ constructOnly: true, nonNullable: true })], g4.prototype, "analysis", void 0), e([y2()], g4.prototype, "tool", void 0), e([y2({ readOnly: true })], g4.prototype, "results", null), e([y2()], g4.prototype, "priority", null), e([y2()], g4.prototype, "computations", void 0), e([y2()], g4.prototype, "elevationAlignedObserver", void 0), e([y2()], g4.prototype, "configuration", void 0), e([y2()], g4.prototype, "observerEngineLocation", void 0), e([y2()], g4.prototype, "cursorTarget", void 0), e([y2()], g4.prototype, "updating", null), e([y2()], g4.prototype, "editable", void 0), e([y2()], g4.prototype, "_analysisController", void 0), e([y2()], g4.prototype, "_analysisVisualization", void 0), g4 = e([a2("esri.views.3d.analysis.LineOfSightAnalysisView3D")], g4);
var f2 = g4;
export {
  f2 as default
};
//# sourceMappingURL=LineOfSightAnalysisView3D-CSAEZIHO.js.map
