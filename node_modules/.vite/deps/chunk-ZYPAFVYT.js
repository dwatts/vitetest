import {
  i
} from "./chunk-TEHNQYQD.js";
import {
  g,
  o,
  s
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";

// node_modules/@arcgis/core/views/navigation/FilteredFiniteDifference.js
var t = class {
  constructor(t3) {
    this._gain = t3, this.lastValue = void 0, this.filteredDelta = void 0;
  }
  update(t3) {
    if (this.hasLastValue()) {
      const e = this.computeDelta(t3);
      this._updateDelta(e);
    }
    this.lastValue = t3;
  }
  reset() {
    this.lastValue = void 0, this.filteredDelta = void 0;
  }
  hasLastValue() {
    return void 0 !== this.lastValue;
  }
  hasFilteredDelta() {
    return void 0 !== this.filteredDelta;
  }
  computeDelta(t3) {
    return void 0 === this.lastValue ? NaN : t3 - this.lastValue;
  }
  _updateDelta(t3) {
    void 0 !== this.filteredDelta ? this.filteredDelta = (1 - this._gain) * this.filteredDelta + this._gain * t3 : this.filteredDelta = t3;
  }
};

// node_modules/@arcgis/core/views/navigation/Momentum.js
var t2 = class {
  constructor(t3, i2, o2) {
    this._initialVelocity = t3, this._stopVelocity = i2, this._friction = o2, this._duration = Math.abs(Math.log(Math.abs(this._initialVelocity) / this._stopVelocity) / Math.log(1 - this._friction));
  }
  get duration() {
    return this._duration;
  }
  isFinished(t3) {
    return t3 > this.duration;
  }
  get friction() {
    return this._friction;
  }
  value(t3) {
    return this.valueFromInitialVelocity(this._initialVelocity, t3);
  }
  valueDelta(t3, i2) {
    const o2 = this.value(t3);
    return this.value(t3 + i2) - o2;
  }
  valueFromInitialVelocity(t3, i2) {
    i2 = Math.min(i2, this.duration);
    const o2 = 1 - this.friction;
    return t3 * (o2 ** i2 - 1) / Math.log(o2);
  }
};

// node_modules/@arcgis/core/views/navigation/PanPlanarMomentumEstimator.js
var c = class extends t2 {
  constructor(e, t3, i2, s4, n2) {
    super(e, t3, i2), this._sceneVelocity = s4, this.direction = n2;
  }
  value(e) {
    return super.valueFromInitialVelocity(this._sceneVelocity, e);
  }
};
var l = class {
  constructor(e = 300, t3 = 12, i2 = 0.84) {
    this._minimumInitialVelocity = e, this._stopVelocity = t3, this._friction = i2, this.enabled = true, this._time = new t(0.6), this._screen = [new t(0.4), new t(0.4)], this._scene = [new t(0.6), new t(0.6), new t(0.6)], this._tmpDirection = n();
  }
  add(e, t3, i2) {
    if (this.enabled) {
      if (this._time.hasLastValue()) {
        if (this._time.computeDelta(i2) < 0.015)
          return;
      }
      this._screen[0].update(e[0]), this._screen[1].update(e[1]), this._scene[0].update(t3[0]), this._scene[1].update(t3[1]), this._scene[2].update(t3[2]), this._time.update(i2);
    }
  }
  reset() {
    this._screen[0].reset(), this._screen[1].reset(), this._scene[0].reset(), this._scene[1].reset(), this._scene[2].reset(), this._time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this._screen[0].hasFilteredDelta() || !this._time.hasFilteredDelta())
      return null;
    const e = this._screen[0].filteredDelta, t3 = this._screen[1].filteredDelta, i2 = null == e || null == t3 ? 0 : Math.sqrt(e * e + t3 * t3), s4 = this._time.filteredDelta, n2 = null == s4 || null == i2 ? 0 : i2 / s4;
    return Math.abs(n2) < this._minimumInitialVelocity ? null : this.createMomentum(n2, this._stopVelocity, this._friction);
  }
  createMomentum(s4, n2, r2) {
    o(this._tmpDirection, this._scene[0].filteredDelta ?? 0, this._scene[1].filteredDelta ?? 0, this._scene[2].filteredDelta ?? 0);
    const l2 = s(this._tmpDirection);
    l2 > 0 && g(this._tmpDirection, this._tmpDirection, 1 / l2);
    const h = this._time.filteredDelta;
    return new c(s4, n2, r2, null == h ? 0 : l2 / h, this._tmpDirection);
  }
};

// node_modules/@arcgis/core/views/navigation/MomentumEstimator.js
var s2 = class {
  constructor(t3 = 2.5, i2 = 0.01, s4 = 0.95, l2 = 12) {
    this._minimumInitialVelocity = t3, this._stopVelocity = i2, this._friction = s4, this._maxVelocity = l2, this.enabled = true, this.value = new t(0.8), this.time = new t(0.3);
  }
  add(t3, e) {
    if (this.enabled && null != e) {
      if (this.time.hasLastValue()) {
        if (this.time.computeDelta(e) < 0.01)
          return;
        if (this.value.hasFilteredDelta()) {
          const e2 = this.value.computeDelta(t3);
          this.value.filteredDelta * e2 < 0 && this.value.reset();
        }
      }
      this.time.update(e), this.value.update(t3);
    }
  }
  reset() {
    this.value.reset(), this.time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this.value.hasFilteredDelta() || !this.time.hasFilteredDelta())
      return null;
    let e = this.value.filteredDelta / this.time.filteredDelta;
    return e = i(e, -this._maxVelocity, this._maxVelocity), Math.abs(e) < this._minimumInitialVelocity ? null : this.createMomentum(e, this._stopVelocity, this._friction);
  }
  createMomentum(t3, e, s4) {
    return new t2(t3, e, s4);
  }
};

// node_modules/@arcgis/core/views/navigation/RotationMomentumEstimator.js
var a = class extends s2 {
  constructor(t3 = 3, a2 = 0.01, s4 = 0.95, o2 = 12) {
    super(t3, a2, s4, o2);
  }
  add(t3, a2) {
    const s4 = this.value.lastValue;
    if (null != s4) {
      let a3 = t3 - s4;
      for (; a3 > Math.PI; )
        a3 -= 2 * Math.PI;
      for (; a3 < -Math.PI; )
        a3 += 2 * Math.PI;
      t3 = s4 + a3;
    }
    super.add(t3, a2);
  }
};

// node_modules/@arcgis/core/views/navigation/ZoomMomentumEstimator.js
var r = class extends t2 {
  constructor(e, t3, r2) {
    super(e, t3, r2);
  }
  value(e) {
    const t3 = super.value(e);
    return Math.exp(t3);
  }
  valueDelta(e, t3) {
    const r2 = super.value(e), s4 = super.value(e + t3) - r2;
    return Math.exp(s4);
  }
};
var s3 = class extends s2 {
  constructor(e = 2.5, t3 = 0.01, r2 = 0.95, s4 = 12) {
    super(e, t3, r2, s4);
  }
  add(e, t3) {
    super.add(Math.log(e), t3);
  }
  createMomentum(e, t3, s4) {
    return new r(e, t3, s4);
  }
};

export {
  t,
  t2,
  l,
  a,
  s3 as s
};
//# sourceMappingURL=chunk-ZYPAFVYT.js.map
