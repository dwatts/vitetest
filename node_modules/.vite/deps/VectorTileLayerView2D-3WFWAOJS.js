import {
  f as f2
} from "./chunk-IVHBK5M6.js";
import {
  i as i6
} from "./chunk-X6M7YYU3.js";
import "./chunk-HMHRXSML.js";
import "./chunk-JXKASHKJ.js";
import "./chunk-WGM2OLIG.js";
import {
  e as e6,
  h as h3,
  i as i5,
  l as l5,
  t as t3
} from "./chunk-MLHA2Q2M.js";
import "./chunk-3MPC6MVT.js";
import "./chunk-UBY6VMKB.js";
import "./chunk-ULFDJHIR.js";
import {
  d as d2
} from "./chunk-TYEEWKIN.js";
import "./chunk-FKUVQAN6.js";
import {
  l as l4
} from "./chunk-FXRNYI6X.js";
import "./chunk-2735WBYK.js";
import "./chunk-NVZXNBIH.js";
import "./chunk-XYJMHUDA.js";
import "./chunk-CSLWFQJE.js";
import "./chunk-MRDUXF66.js";
import "./chunk-IVABPLLZ.js";
import "./chunk-RKM5MXYH.js";
import "./chunk-A4HFWKMU.js";
import {
  T
} from "./chunk-TBHRKIAA.js";
import "./chunk-BPITJIFG.js";
import "./chunk-J6SRKANJ.js";
import "./chunk-JORCYNDS.js";
import "./chunk-BZUKDBTT.js";
import {
  d as d3,
  i as i3,
  s as s3
} from "./chunk-3VN6RF6P.js";
import {
  r as r2
} from "./chunk-7YCGPGGL.js";
import {
  i as i4
} from "./chunk-GPABU246.js";
import "./chunk-KILCBNKU.js";
import "./chunk-K4WBDIIJ.js";
import {
  u
} from "./chunk-H3DKDGMJ.js";
import {
  c as c2
} from "./chunk-FB6EWBGE.js";
import "./chunk-TRGMWULG.js";
import "./chunk-WTPQKRQM.js";
import {
  c,
  e as e4
} from "./chunk-AER5JAFS.js";
import {
  I as I2
} from "./chunk-FKEHFW5J.js";
import {
  a as a4,
  i as i2
} from "./chunk-7HZ72XIE.js";
import "./chunk-WDZ5AAFL.js";
import "./chunk-PR2OEILG.js";
import "./chunk-TDXHXKUI.js";
import "./chunk-IG234GCS.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import {
  t as t2
} from "./chunk-FF5LS3YE.js";
import {
  C as C2,
  E,
  F,
  I,
  O,
  R
} from "./chunk-BCDDCNQ2.js";
import {
  a as a3,
  s as s2
} from "./chunk-Z3GCSCQI.js";
import "./chunk-UU2XJGLA.js";
import {
  e as e2
} from "./chunk-467UETSR.js";
import "./chunk-SHFLRM67.js";
import "./chunk-YGUWDSEH.js";
import "./chunk-LO3LAMAS.js";
import "./chunk-W2YWKOK7.js";
import "./chunk-O62OS3ME.js";
import {
  y as y2
} from "./chunk-XG5SDOKD.js";
import "./chunk-UQHDCOJC.js";
import "./chunk-MF3HZ6GV.js";
import {
  l as l3
} from "./chunk-SNAARWF3.js";
import {
  e as e5
} from "./chunk-D5NSNTGJ.js";
import "./chunk-63ERNIOV.js";
import "./chunk-5KLICR5E.js";
import {
  e as e3
} from "./chunk-YYTXJF6W.js";
import "./chunk-NLWV7Q6F.js";
import "./chunk-DSWGERIY.js";
import "./chunk-Y2ZDD3I4.js";
import {
  M,
  f,
  r
} from "./chunk-JB7FDW5N.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-B4D7M7HT.js";
import "./chunk-3T2ETA25.js";
import "./chunk-5IYCCZ54.js";
import "./chunk-VMTVUE47.js";
import "./chunk-GDZM4A6K.js";
import {
  h as h2
} from "./chunk-XWGNMTES.js";
import "./chunk-6NNEHJYI.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-JNDFAMXY.js";
import "./chunk-NTEKJWGF.js";
import "./chunk-TFIKV5RU.js";
import "./chunk-KW6QQDGN.js";
import "./chunk-AQ7R6V4L.js";
import "./chunk-DOQ3SAAR.js";
import "./chunk-4BXK4H4L.js";
import "./chunk-SLVNG7FV.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-DEZCXTA3.js";
import "./chunk-RRJGZKNX.js";
import "./chunk-PL5Q4C6Y.js";
import "./chunk-KFSY6ZZH.js";
import "./chunk-7EQSYZHW.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import "./chunk-4OR73Y2R.js";
import {
  i
} from "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-Z2ZUNW5S.js";
import "./chunk-7L7Z2HXM.js";
import "./chunk-75NKPXTR.js";
import "./chunk-EUVARFSM.js";
import "./chunk-3VUFACNT.js";
import "./chunk-ZEEBL7ZN.js";
import {
  S2 as S
} from "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-57CHUY45.js";
import "./chunk-SJ2GJCS2.js";
import {
  h,
  l as l2
} from "./chunk-H7RDAEPY.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-S5OISW44.js";
import {
  n
} from "./chunk-7KH4CLS5.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-JL3TJGVW.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import {
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import {
  C,
  d
} from "./chunk-7I33FAWS.js";
import {
  l,
  t
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import {
  a
} from "./chunk-IYZKKFJM.js";
import "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileManager.js
var l6 = 512;
var s4 = 1e-6;
var r3 = (e7, i7) => e7 + 1 / (1 << 2 * i7);
var o = class {
  constructor(i7, t5) {
    this._tiles = /* @__PURE__ */ new Map(), this._tileCache = new e2(40, (e7) => e7.dispose()), this._viewSize = [0, 0], this._visibleTiles = /* @__PURE__ */ new Map(), this.acquireTile = i7.acquireTile, this.releaseTile = i7.releaseTile, this.tileInfoView = i7.tileInfoView, this._container = t5;
  }
  destroy() {
    for (const [e7, i7] of this._tiles)
      i7.dispose();
    this._tiles = null, this._tileCache.clear(), this._tileCache = null;
  }
  update(e7) {
    this._updateCacheSize(e7);
    const l8 = this.tileInfoView, s5 = l8.getTileCoverage(e7.state, 0, true, "smallest"), { spans: r4, lodInfo: o2 } = s5, { level: n4 } = o2, a6 = this._tiles, c4 = /* @__PURE__ */ new Set(), h4 = /* @__PURE__ */ new Set();
    for (const { row: i7, colFrom: _2, colTo: f3 } of r4)
      for (let e8 = _2; e8 <= f3; e8++) {
        const l9 = e3.getId(n4, i7, o2.normalizeCol(e8), o2.getWorldForColumn(e8)), s6 = this._getOrAcquireTile(l9);
        c4.add(l9), s6.processed() ? this._addToContainer(s6) : h4.add(new e3(l9));
      }
    for (const [i7, t5] of a6)
      t5.isCoverage = c4.has(i7);
    for (const i7 of h4)
      this._findPlaceholdersForMissingTiles(i7, c4);
    let d4 = false;
    for (const [i7, t5] of a6)
      t5.neededForCoverage = c4.has(i7), t5.neededForCoverage || t5.isHoldingForFade && l8.intersects(s5, t5.key) && c4.add(i7), t5.isFading && (d4 = true);
    for (const [i7, t5] of this._tiles)
      c4.has(i7) || this._releaseTile(i7);
    return l3.pool.release(s5), !d4;
  }
  clear() {
    this._tiles.clear(), this._tileCache.clear(), this._visibleTiles.clear();
  }
  clearCache() {
    this._tileCache.clear();
  }
  _findPlaceholdersForMissingTiles(e7, i7) {
    const t5 = [];
    for (const [s5, r4] of this._tiles)
      this._addPlaceholderChild(t5, r4, e7, i7);
    const l8 = t5.reduce(r3, 0);
    Math.abs(1 - l8) < s4 || this._addPlaceholderParent(e7.id, i7);
  }
  _addPlaceholderChild(e7, i7, t5, l8) {
    i7.key.level <= t5.level || !i7.hasData() || a5(t5, i7.key) && (this._addToContainer(i7), l8.add(i7.id), e7.push(i7.key.level - t5.level));
  }
  _addPlaceholderParent(e7, i7) {
    const t5 = this._tiles;
    let l8 = e7;
    for (; ; ) {
      if (l8 = n2(l8), !l8 || i7.has(l8))
        return;
      const e8 = t5.get(l8);
      if (e8 && e8.hasData())
        return this._addToContainer(e8), void i7.add(e8.id);
    }
  }
  _getOrAcquireTile(e7) {
    let i7 = this._tiles.get(e7);
    return i7 || (i7 = this._tileCache.pop(e7), i7 || (i7 = this.acquireTile(new e3(e7))), this._tiles.set(e7, i7), i7);
  }
  _releaseTile(e7) {
    const i7 = this._tiles.get(e7);
    this.releaseTile(i7), this._removeFromContainer(i7), this._tiles.delete(e7), i7.hasData() ? this._tileCache.put(e7, i7, 1) : i7.dispose();
  }
  _addToContainer(e7) {
    let i7;
    const t5 = [], l8 = this._container;
    if (l8.contains(e7))
      return;
    const s5 = this._visibleTiles;
    for (const [r4, o2] of s5)
      this._canConnectDirectly(e7, o2) && t5.push(o2), null == i7 && this._canConnectDirectly(o2, e7) && (i7 = o2);
    if (null != i7) {
      for (const l9 of t5)
        i7.childrenTiles.delete(l9), e7.childrenTiles.add(l9), l9.parentTile = e7;
      i7.childrenTiles.add(e7), e7.parentTile = i7;
    } else
      for (const r4 of t5)
        e7.childrenTiles.add(r4), r4.parentTile = e7;
    s5.set(e7.id, e7), l8.addChild(e7);
  }
  _removeFromContainer(e7) {
    if (this._visibleTiles.delete(e7.id), this._container.removeChild(e7), null != e7.parentTile) {
      e7.parentTile.childrenTiles.delete(e7);
      for (const i7 of e7.childrenTiles)
        null != e7.parentTile && e7.parentTile.childrenTiles.add(i7);
    }
    for (const i7 of e7.childrenTiles)
      i7.parentTile = e7.parentTile;
    e7.parentTile = null, e7.childrenTiles.clear();
  }
  _canConnectDirectly(e7, i7) {
    const t5 = e7.key;
    let { level: l8, row: s5, col: r4, world: o2 } = i7.key;
    const n4 = this._visibleTiles;
    for (; l8 > 0; ) {
      if (l8--, s5 >>= 1, r4 >>= 1, t5.level === l8 && t5.row === s5 && t5.col === r4 && t5.world === o2)
        return true;
      if (n4.has(`${l8}/${s5}/${r4}/${o2}`))
        return false;
    }
    return false;
  }
  _updateCacheSize(e7) {
    const i7 = e7.state.size;
    if (i7[0] === this._viewSize[0] && i7[1] === this._viewSize[1])
      return;
    const t5 = Math.ceil(i7[0] / l6) + 1, s5 = Math.ceil(i7[1] / l6) + 1;
    this._viewSize[0] = i7[0], this._viewSize[1] = i7[1], this._tileCache.maxSize = 5 * t5 * s5;
  }
};
function n2(e7) {
  const [i7, t5, l8, s5] = e7.split("/"), r4 = parseInt(i7, 10);
  return 0 === r4 ? null : `${r4 - 1}/${parseInt(t5, 10) >> 1}/${parseInt(l8, 10) >> 1}/${parseInt(s5, 10)}`;
}
function a5(e7, i7) {
  const t5 = i7.level - e7.level;
  return e7.row === i7.row >> t5 && e7.col === i7.col >> t5 && e7.world === i7.world;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolFader.js
var c3 = 0.5;
var n3 = 1e-6;
var _ = class extends n {
  constructor(t5, e7) {
    super(), this.styleRepository = t5, this._tileToHandle = /* @__PURE__ */ new Map(), this._viewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._declutterViewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._completed = false, this._symbolRepository = new i5(4096, e7, () => new s3()), this._symbolDeclutterer = new e6(e7, this._symbolRepository, (t6, e8, i7) => new l5(t6, e8, i7, this.styleRepository, this._zoom, this._viewState.rotation), (t6, e8) => {
      t6.allSymbolsFadingOut = true, t6.lastOpacityUpdate = e8, i3(t6, e8, true), t6.decluttered = true, t6.requestRender();
    }, (t6, e8) => this.styleRepository.getStyleLayerByUID(t6.styleLayerUID).z - this.styleRepository.getStyleLayerByUID(e8.styleLayerUID).z, (t6) => {
      const e8 = this.styleRepository.getStyleLayerByUID(t6);
      if (this._zoom + n3 < e8.minzoom || this._zoom - n3 >= e8.maxzoom)
        return false;
      const i7 = e8.getLayoutProperty("visibility");
      return !i7 || i7.getValue() !== i2.NONE;
    });
  }
  addTile(t5) {
    t5.decluttered = false, this._tileToHandle.set(t5, t5.on("symbols-changed", () => {
      this._symbolRepository.add(t5), this.restartDeclutter();
    })), this._symbolRepository.add(t5), this.restartDeclutter();
  }
  removeTile(t5) {
    const e7 = this._tileToHandle.get(t5);
    e7 && (this._symbolRepository.removeTile(t5), this.restartDeclutter(), e7.remove(), this._tileToHandle.delete(t5));
  }
  update(t5, e7) {
    return this._zoom = t5, this._viewState = { scale: e7.scale, rotation: e7.rotation, center: [e7.center[0], e7.center[1]], size: [e7.size[0], e7.size[1]] }, this._continueDeclutter(), this._completed;
  }
  restartDeclutter() {
    this._completed = false, this._symbolDeclutterer.restart(), this._notifyUnstable();
  }
  clear() {
    this._completed = false, this._symbolRepository = null, this._symbolDeclutterer.restart(), this._tileToHandle.forEach((t5) => t5.remove()), this._tileToHandle.clear();
  }
  get stale() {
    return this._zoom !== this._declutterZoom || this._viewState.size[0] !== this._declutterViewState.size[0] || this._viewState.size[1] !== this._declutterViewState.size[1] || this._viewState.scale !== this._declutterViewState.scale || this._viewState.rotation !== this._declutterViewState.rotation;
  }
  deleteStyleLayers(t5) {
    this._symbolRepository.deleteStyleLayers(t5);
  }
  _continueDeclutter() {
    this._completed && !this.stale || (this._symbolDeclutterer.running || (this._declutterZoom = this._zoom, this._declutterViewState.center[0] = this._viewState.center[0], this._declutterViewState.center[1] = this._viewState.center[1], this._declutterViewState.rotation = this._viewState.rotation, this._declutterViewState.scale = this._viewState.scale, this._declutterViewState.size[0] = this._viewState.size[0], this._declutterViewState.size[1] = this._viewState.size[1], this._symbolDeclutterer.restart()), this._symbolDeclutterer.setScreenSize(this._viewState.size[0], this._viewState.size[1]), this._completed = this._symbolDeclutterer.continue(c), this._completed && this._scheduleNotifyStable());
  }
  _scheduleNotifyStable() {
    null != this._stableNotificationHandle && clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = setTimeout(() => {
      this._stableNotificationHandle = null, this.emit("fade-complete");
    }, (1 + c3) * e4);
  }
  _notifyUnstable() {
    null != this._stableNotificationHandle && (clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = null), this.emit("fade-start");
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/RenderableTile.js
var t4 = class extends r2 {
  _createTransforms() {
    return { dvs: e5(), tileMat3: e5() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileContainer.js
var y3 = 1e-6;
function p(e7, t5) {
  if (e7) {
    const s5 = e7.getLayoutProperty("visibility");
    if (!s5 || s5.getValue() !== i2.NONE && (void 0 === e7.minzoom || e7.minzoom < t5 + y3) && (void 0 === e7.maxzoom || e7.maxzoom >= t5 - y3))
      return true;
  }
  return false;
}
var m = class extends i6 {
  constructor(e7) {
    super(e7), this._backgroundTiles = [], this._pointToCallbacks = /* @__PURE__ */ new Map();
  }
  destroy() {
    var _a, _b;
    this.removeAllChildren(), (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = null, (_b = this._glyphMosaic) == null ? void 0 : _b.dispose(), this._glyphMosaic = null, null != this._symbolFader && (this._symbolFader.clear(), this._symbolFader = null), this._styleRepository = null, this._backgroundTiles = [], this._pointToCallbacks.clear();
  }
  setStyleResources(e7, t5, r4) {
    if (this._spriteMosaic = e7, this._glyphMosaic = t5, this._styleRepository = r4, null == this._symbolFader) {
      const e8 = new _(this._styleRepository, this.children);
      e8.on("fade-start", () => {
        this.emit("fade-start"), this.requestRender();
      }), e8.on("fade-complete", () => {
        this.emit("fade-complete"), this.requestRender();
      }), this._symbolFader = e8;
    }
    this._symbolFader.styleRepository = r4;
  }
  setSpriteMosaic(e7) {
    var _a;
    (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = e7;
  }
  deleteStyleLayers(e7) {
    null != this._symbolFader && this._symbolFader.deleteStyleLayers(e7);
  }
  async hitTest(t5) {
    const s5 = C();
    return this._pointToCallbacks.set(t5, s5), this.requestRender(), s5.promise;
  }
  enterTileInvalidation() {
    for (const e7 of this.children)
      e7.invalidating = true;
  }
  createRenderParams(e7) {
    return { ...super.createRenderParams(e7), renderPass: null, styleLayer: null, styleLayerUID: -1, glyphMosaic: this._glyphMosaic, spriteMosaic: this._spriteMosaic, hasClipping: !!this._clippingInfos };
  }
  doRender(e7) {
    !this.visible || e7.drawPhase !== T.MAP && e7.drawPhase !== T.DEBUG || void 0 === this._spriteMosaic || super.doRender(e7);
  }
  addChild(e7) {
    return super.addChild(e7), null != this._symbolFader ? this._symbolFader.addTile(e7) : e7.decluttered = true, this.requestRender(), e7;
  }
  removeChild(e7) {
    return null != this._symbolFader && this._symbolFader.removeTile(e7), this.requestRender(), super.removeChild(e7);
  }
  renderChildren(e7) {
    const { drawPhase: t5 } = e7;
    if (t5 !== T.DEBUG) {
      if (this._doRender(e7), this._pointToCallbacks.size > 0) {
        e7.drawPhase = T.HITTEST;
        const s5 = e7.painter.effects.hittestVTL;
        s5.bind(e7), this._doRender(e7), s5.draw(e7, this._pointToCallbacks), s5.unbind(e7), e7.drawPhase = t5;
      }
    } else
      super.renderChildren(e7);
  }
  removeAllChildren() {
    for (let e7 = 0; e7 < this.children.length; e7++) {
      const t5 = this.children[e7];
      null != this._symbolFader && this._symbolFader.removeTile(t5), t5.dispose();
    }
    super.removeAllChildren();
  }
  getStencilTarget() {
    return this.children.filter((e7) => e7.neededForCoverage && e7.hasData());
  }
  restartDeclutter() {
    null != this._symbolFader && this._symbolFader.restartDeclutter();
  }
  _doRender(e7) {
    const { context: t5 } = e7, s5 = this._styleRepository;
    if (!s5)
      return;
    const r4 = s5.layers;
    let i7 = true;
    e7.drawPhase === T.HITTEST && (i7 = false), s5.backgroundBucketIds.length > 0 && (e7.renderPass = "background", this._renderBackgroundLayers(e7, s5.backgroundBucketIds)), super.renderChildren(e7), e7.drawPhase === T.MAP && this._fade(e7.displayLevel, e7.state);
    const o2 = this.children.filter((e8) => e8.visible && e8.hasData());
    if (!o2 || 0 === o2.length)
      return t5.bindVAO(), t5.setStencilTestEnabled(true), void t5.setBlendingEnabled(true);
    for (const l8 of o2)
      l8.triangleCount = 0;
    t5.setStencilWriteMask(0), t5.setColorMask(true, true, true, true), t5.setStencilOp(O.KEEP, O.KEEP, O.REPLACE), t5.setStencilTestEnabled(true), t5.setBlendingEnabled(false), t5.setDepthTestEnabled(true), t5.setDepthWriteEnabled(true), t5.setDepthFunction(I.LEQUAL), t5.setClearDepth(1), t5.clear(t5.gl.DEPTH_BUFFER_BIT), e7.renderPass = "opaque";
    for (let l8 = r4.length - 1; l8 >= 0; l8--)
      this._renderStyleLayer(r4[l8], e7, o2);
    t5.setDepthWriteEnabled(false), t5.setBlendingEnabled(i7), t5.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e7.renderPass = "translucent";
    for (let l8 = 0; l8 < r4.length; l8++)
      this._renderStyleLayer(r4[l8], e7, o2);
    t5.bindVAO(), t5.setStencilTestEnabled(true), t5.setBlendingEnabled(true);
  }
  _fade(e7, t5) {
    null != this._symbolFader && (this._symbolFader.update(e7, t5) || this.requestRender());
  }
  _renderStyleLayer(e7, t5, s5) {
    const { painter: l8, renderPass: o2 } = t5;
    if (void 0 === e7)
      return;
    const n4 = e7.getLayoutProperty("visibility");
    if (n4 && n4.getValue() === i2.NONE)
      return;
    let a6;
    switch (e7.type) {
      case a4.BACKGROUND:
        return;
      case a4.FILL:
        if ("opaque" !== o2 && "translucent" !== t5.renderPass)
          return;
        a6 = "vtlFill";
        break;
      case a4.LINE:
        if ("translucent" !== o2)
          return;
        a6 = "vtlLine";
        break;
      case a4.CIRCLE:
        if ("translucent" !== o2)
          return;
        a6 = "vtlCircle";
        break;
      case a4.SYMBOL:
        if ("translucent" !== o2)
          return;
        a6 = "vtlSymbol";
    }
    if (s5 = e7.type === a4.SYMBOL ? s5.filter((e8) => e8.decluttered) : s5.filter((e8) => e8.neededForCoverage), "vtlSymbol" !== a6) {
      const r4 = t5.displayLevel;
      if (0 === s5.length || void 0 !== e7.minzoom && e7.minzoom >= r4 + y3 || void 0 !== e7.maxzoom && e7.maxzoom < r4 - y3)
        return;
    }
    const d4 = e7.uid;
    t5.styleLayerUID = d4, t5.styleLayer = e7;
    for (const r4 of s5)
      if (r4.layerData.has(d4)) {
        l8.renderObjects(t5, s5, a6);
        break;
      }
  }
  _renderBackgroundLayers(e7, s5) {
    const { context: r4, displayLevel: n4, painter: u3, state: y4 } = e7, m2 = this._styleRepository;
    let f3 = false;
    for (const t5 of s5) {
      if (m2.getLayerById(t5).type === a4.BACKGROUND && p(m2.getLayerById(t5), n4)) {
        f3 = true;
        break;
      }
    }
    if (!f3)
      return;
    const _2 = this._tileInfoView.getTileCoverage(e7.state, 0, true, "smallest"), { spans: b, lodInfo: g2 } = _2, { level: T2 } = g2, E2 = i(), C3 = [];
    if (this._renderPasses) {
      const t5 = this._renderPasses[0];
      null != this._clippingInfos && (t5.brushes[0].prepareState(e7), t5.brushes[0].drawMany(e7, this._clippingInfos));
    }
    const L2 = this._backgroundTiles;
    let v, R2 = 0;
    for (const { row: i7, colFrom: l8, colTo: a6 } of b)
      for (let e8 = l8; e8 <= a6; e8++) {
        if (R2 < L2.length)
          v = L2[R2], v.key.set(T2, i7, g2.normalizeCol(e8), g2.getWorldForColumn(e8)), this._tileInfoView.getTileBounds(E2, v.key, false), v.x = E2[0], v.y = E2[3], v.resolution = this._tileInfoView.getTileResolution(T2);
        else {
          const s6 = new e3(T2, i7, g2.normalizeCol(e8), g2.getWorldForColumn(e8)), r5 = this._tileInfoView.getTileBounds(i(), s6), l9 = this._tileInfoView.getTileResolution(T2);
          v = new t4(s6, l9, r5[0], r5[3], 512, 512, 4096, 4096), L2.push(v);
        }
        v.setTransform(y4), C3.push(v), R2++;
      }
    r4.setStencilWriteMask(0), r4.setColorMask(true, true, true, true), r4.setStencilOp(O.KEEP, O.KEEP, O.REPLACE), r4.setStencilFunction(I.EQUAL, 0, 255);
    let S2 = true;
    e7.drawPhase === T.HITTEST && (S2 = false), r4.setStencilTestEnabled(S2);
    for (const t5 of s5) {
      const s6 = m2.getLayerById(t5);
      s6.type === a4.BACKGROUND && p(s6, n4) && (e7.styleLayerUID = s6.uid, e7.styleLayer = s6, u3.renderObjects(e7, C3, "vtlBackground"));
    }
    l3.pool.release(_2);
  }
};

// node_modules/@arcgis/core/views/2d/layers/support/DebugOverlay.js
var u2 = { geometry: [new t2("a_PositionAndFlags", 3, C2.SHORT, 0, 6)] };
var p2 = /* @__PURE__ */ new Map();
p2.set("a_PositionAndFlags", 0);
var g = { vsPath: "debug/overlay", fsPath: "debug/overlay", attributes: p2 };
var l7 = class extends i4 {
  constructor(e7) {
    super(), this._conf = e7;
  }
  static makeFlags(e7, t5) {
    return e7 | t5 << 2;
  }
  _createTransforms() {
    return { dvs: e5() };
  }
  doRender(e7) {
    this._updateTransforms(e7), this._ensureResources(e7);
    const { context: t5 } = e7;
    t5.useProgram(this._program), this._program.setUniformMatrix3fv("u_dvsMat3", this.transforms.dvs), this._program.setUniform4fv("u_colors", this._conf.getColors(e7)), this._program.setUniform1fv("u_opacities", this._conf.getOpacities(e7));
    const { vertexData: r4, indexData: s5 } = this._conf.getMesh(e7);
    this._vertexBuffer.setData(r4), this._indexBuffer.setData(s5), t5.bindVAO(this._vertexArray), t5.setBlendingEnabled(true), t5.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), t5.setDepthTestEnabled(false), t5.setStencilTestEnabled(false), t5.setColorMask(true, true, true, true), t5.drawElements(E.TRIANGLES, s5.length, C2.UNSIGNED_INT, 0);
  }
  onDetach() {
    this._vertexArray = t(this._vertexArray);
  }
  _updateTransforms(e7) {
    r(this.transforms.dvs), M(this.transforms.dvs, this.transforms.dvs, [-1, 1]), f(this.transforms.dvs, this.transforms.dvs, [2 / e7.state.size[0], -2 / e7.state.size[1], 1]);
  }
  _ensureResources(e7) {
    const { context: t5 } = e7;
    this._program || (this._program = e7.painter.materialManager.getProgram(g)), this._vertexBuffer || (this._vertexBuffer = c2.createVertex(t5, F.STREAM_DRAW)), this._indexBuffer || (this._indexBuffer = c2.createIndex(t5, F.STREAM_DRAW)), this._vertexArray || (this._vertexArray = new u(t5, p2, u2, { geometry: this._vertexBuffer }, this._indexBuffer));
  }
};

// node_modules/@arcgis/core/views/2d/layers/VectorTileLayerView2D.js
var D = class extends f2(d2) {
  constructor() {
    super(...arguments), this._styleChanges = [], this._fetchQueue = null, this._parseQueue = null, this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._collisionOverlay = null, this.fading = false, this._getCollidersMesh = (e7) => {
      const { pixelRatio: t5 } = e7.state;
      let i7 = 0;
      const s5 = [], r4 = [];
      for (const a6 of this._vectorTileContainer.children)
        if (a6.symbols)
          for (const [e8, l8] of a6.symbols)
            for (const a7 of l8)
              for (const e9 of a7.colliders) {
                const l9 = (e9.xScreen + e9.dxScreen) * t5, n4 = (e9.yScreen + e9.dyScreen) * t5, o2 = e9.width * t5, h4 = e9.height * t5, u3 = a7.unique.parts[e9.partIndex].targetOpacity > 0.5;
                if (!u3 && "all" !== this.layer.showCollisionBoxes)
                  continue;
                const c4 = 3, y4 = 1, p3 = 3, d4 = 0, _2 = u3 ? 2 : 0, f3 = u3 ? 3 : 0, g2 = l7.makeFlags(_2, f3);
                s5.push(l9, n4, g2, l9 + o2, n4, g2, l9, n4 + h4, g2, l9 + o2, n4 + h4, g2), r4.push(i7, i7 + 1, i7 + 2, i7 + 1, i7 + 3, i7 + 2), i7 += 4;
                const m2 = u3 ? c4 : y4, C3 = u3 ? p3 : d4, T2 = l7.makeFlags(m2, C3);
                s5.push(l9, n4, T2, l9 + o2, n4, T2, l9, n4 + 1, T2, l9 + o2, n4 + 1, T2), r4.push(i7, i7 + 1, i7 + 2, i7 + 1, i7 + 3, i7 + 2), i7 += 4, s5.push(l9, n4 + h4 - 1, T2, l9 + o2, n4 + h4 - 1, T2, l9, n4 + h4, T2, l9 + o2, n4 + h4, T2), r4.push(i7, i7 + 1, i7 + 2, i7 + 1, i7 + 3, i7 + 2), i7 += 4, s5.push(l9, n4, T2, l9 + 1, n4, T2, l9, n4 + h4, T2, l9 + 1, n4 + h4, T2), r4.push(i7, i7 + 1, i7 + 2, i7 + 1, i7 + 3, i7 + 2), i7 += 4, s5.push(l9 + o2 - 1, n4, T2, l9 + o2, n4, T2, l9 + o2 - 1, n4 + h4, T2, l9 + o2, n4 + h4, T2), r4.push(i7, i7 + 1, i7 + 2, i7 + 1, i7 + 3, i7 + 2), i7 += 4;
              }
      return { vertexData: new Int16Array(s5), indexData: new Uint32Array(r4) };
    }, this._getCollidersColors = () => [1, 0.5, 0, 1, 1, 0, 0, 1, 0, 1, 0.5, 1, 0, 0.5, 0, 1], this._getCollidersOpacities = () => [0.05, 0.01, 0.15, 0.2];
  }
  async hitTest(e7, i7) {
    if (!this._tileHandlerPromise)
      return null;
    await this._tileHandlerPromise;
    const s5 = await this._vectorTileContainer.hitTest(i7);
    if (!s5 || 0 === s5.length)
      return null;
    const r4 = s5[0] - 1, a6 = this._styleRepository, l8 = a6.getStyleLayerByUID(r4);
    if (!l8)
      return null;
    const n4 = a6.getStyleLayerIndex(l8.id);
    return [{ type: "graphic", mapPoint: e7, layer: this.layer, graphic: new h2({ attributes: { layerId: n4, layerName: l8.id, layerUID: r4 }, layer: this.layer, sourceLayer: this.layer }) }];
  }
  update(e7) {
    if (this._tileHandlerPromise && this._isTileHandlerReady)
      return e7.pixelRatio !== this._tileHandler.devicePixelRatio ? (this._start(), void (this._tileHandler.devicePixelRatio = e7.pixelRatio)) : void (this._styleChanges.length > 0 ? this._tileHandlerPromise = this._applyStyleChanges() : (this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.state = e7.state, this._parseQueue.state = e7.state, this._tileManager.update(e7) || this.requestUpdate(), this._parseQueue.resume(), this._fetchQueue.resume()));
  }
  attach() {
    const { style: e7 } = this.layer.currentStyleInfo;
    this._styleRepository = new l4(e7), this._tileInfoView = new t3(this.layer.tileInfo, this.layer.fullExtent), this._vectorTileContainer = new m(this._tileInfoView), this._tileHandler = new h3(this.layer, this._styleRepository, window.devicePixelRatio || 1), this.container.addChild(this._vectorTileContainer), this._start(), this.addAttachHandles([this._vectorTileContainer.on("fade-start", () => {
      this.fading = true, this.notifyChange("updating"), this.requestUpdate();
    }), this._vectorTileContainer.on("fade-complete", () => {
      var _a;
      (_a = this._collisionOverlay) == null ? void 0 : _a.requestRender(), this.fading = false, this.notifyChange("updating"), this.requestUpdate();
    }), l2(() => this.layer.showCollisionBoxes, (e8) => {
      "none" !== e8 ? this._collisionOverlay || (this._collisionOverlay = new l7({ getMesh: this._getCollidersMesh, getColors: this._getCollidersColors, getOpacities: this._getCollidersOpacities }), this.container.addChild(this._collisionOverlay)) : this._collisionOverlay && (this.container.removeChild(this._collisionOverlay), this._collisionOverlay = null), this.container.requestRender();
    }, h), this.layer.on("paint-change", (e8) => {
      if (e8.isDataDriven)
        this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: e8 }), this.notifyChange("updating"), this.requestUpdate();
      else {
        const t5 = this._styleRepository, i7 = t5.getLayerById(e8.layer);
        if (!i7)
          return;
        const s5 = i7.type === a4.SYMBOL;
        t5.setPaintProperties(e8.layer, e8.paint), s5 && this._vectorTileContainer.restartDeclutter(), this._vectorTileContainer.requestRender();
      }
    }), this.layer.on("layout-change", (e8) => {
      const t5 = this._styleRepository, i7 = t5.getLayerById(e8.layer);
      if (!i7)
        return;
      const s5 = a3(i7.layout, e8.layout);
      if (null != s5) {
        if (s2(s5, "visibility") && 1 === Q(s5))
          return t5.setLayoutProperties(e8.layer, e8.layout), i7.type === a4.SYMBOL && this._vectorTileContainer.restartDeclutter(), void this._vectorTileContainer.requestRender();
        this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: e8 }), this.notifyChange("updating"), this.requestUpdate();
      }
    }), this.layer.on("style-layer-visibility-change", (e8) => {
      const t5 = this._styleRepository, i7 = t5.getLayerById(e8.layer);
      i7 && (t5.setStyleLayerVisibility(e8.layer, e8.visibility), i7.type === a4.SYMBOL && this._vectorTileContainer.restartDeclutter(), this._vectorTileContainer.requestRender());
    }), this.layer.on("style-layer-change", (e8) => {
      this._styleChanges.push({ type: I2.LAYER_CHANGED, data: e8 }), this.notifyChange("updating"), this.requestUpdate();
    }), this.layer.on("delete-style-layer", (e8) => {
      this._styleChanges.push({ type: I2.LAYER_REMOVED, data: e8 }), this.notifyChange("updating"), this.requestUpdate();
    }), this.layer.on("load-style", () => this._loadStyle()), this.layer.on("spriteSource-change", (e8) => {
      this._newSpriteSource = e8.spriteSource, this._styleChanges.push({ type: I2.SPRITES_CHANGED, data: null });
      const t5 = this._styleRepository.layers;
      for (const i7 of t5)
        switch (i7.type) {
          case a4.SYMBOL:
            i7.getLayoutProperty("icon-image") && this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: { layer: i7.id, layout: i7.layout } });
            break;
          case a4.LINE:
            i7.getPaintProperty("line-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i7.id, paint: i7.paint, isDataDriven: i7.isPainterDataDriven() } });
            break;
          case a4.FILL:
            i7.getLayoutProperty("fill-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i7.id, paint: i7.paint, isDataDriven: i7.isPainterDataDriven() } });
        }
      this.notifyChange("updating"), this.requestUpdate();
    })]);
  }
  detach() {
    this._stop(), this.container.removeAllChildren(), this._vectorTileContainer = l(this._vectorTileContainer), this._tileHandler = l(this._tileHandler);
  }
  moveStart() {
    this.requestUpdate();
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this._collisionOverlay && this._vectorTileContainer.restartDeclutter(), this.requestUpdate();
  }
  supportsSpatialReference(e7) {
    var _a;
    return S((_a = this.layer.tileInfo) == null ? void 0 : _a.spatialReference, e7);
  }
  canResume() {
    let e7 = super.canResume();
    const { currentStyleInfo: t5 } = this.layer;
    if (e7 && (t5 == null ? void 0 : t5.layerDefinition)) {
      const i7 = this.view.scale, { minScale: s5, maxScale: r4 } = t5.layerDefinition;
      t5 && t5.layerDefinition && (s5 && s5 < i7 && (e7 = false), r4 && r4 > i7 && (e7 = false));
    }
    return e7;
  }
  isUpdating() {
    const e7 = this._vectorTileContainer.children;
    return !this._isTileHandlerReady || !this._fetchQueue || !this._parseQueue || this._fetchQueue.updating || this._parseQueue.updating || e7.length > 0 && e7.some((e8) => e8.invalidating) || this.fading;
  }
  acquireTile(e7) {
    var _a;
    const t5 = this._createVectorTile(e7);
    return (_a = this._tileHandlerPromise) == null ? void 0 : _a.then(() => {
      this._fetchQueue.push(t5.key).then((e8) => this._parseQueue.push({ key: t5.key, data: e8 })).then((e8) => {
        t5.once("attach", () => this.requestUpdate()), t5.setData(e8), this.requestUpdate(), this.notifyChange("updating");
      }).catch((e8) => {
        this.notifyChange("updating"), d(e8) || s.getLogger(this).error(e8);
      });
    }), t5;
  }
  releaseTile(e7) {
    const t5 = e7.key.id;
    this._fetchQueue.abort(t5), this._parseQueue.abort(t5), this.requestUpdate();
  }
  _start() {
    if (this._stop(), this._tileManager = new o({ acquireTile: (e8) => this.acquireTile(e8), releaseTile: (e8) => this.releaseTile(e8), tileInfoView: this._tileInfoView }, this._vectorTileContainer), !this.layer.currentStyleInfo)
      return;
    const e7 = new AbortController(), t5 = this._tileHandler.start({ signal: e7.signal }).then(() => {
      this._fetchQueue = new y2({ tileInfoView: this._tileInfoView, process: (e8, t6) => this._getTileData(e8, t6), concurrency: 15 }), this._parseQueue = new y2({ tileInfoView: this._tileInfoView, process: (e8, t6) => this._parseTileData(e8, t6), concurrency: 8 }), this.requestUpdate(), this._isTileHandlerReady = true;
    });
    this._tileHandler.spriteMosaic.then((e8) => {
      this._vectorTileContainer.setStyleResources(e8, this._tileHandler.glyphMosaic, this._styleRepository), this.requestUpdate();
    }), this._tileHandlerAbortController = e7, this._tileHandlerPromise = t5;
  }
  _stop() {
    if (!this._tileHandlerAbortController || !this._vectorTileContainer)
      return;
    const e7 = this._tileHandlerAbortController;
    e7 && e7.abort(), this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._fetchQueue = l(this._fetchQueue), this._parseQueue = l(this._parseQueue), this._tileManager = l(this._tileManager), this._vectorTileContainer.removeAllChildren();
  }
  async _getTileData(e7, t5) {
    const i7 = await this._tileHandler.fetchTileData(e7, t5);
    return this.notifyChange("updating"), i7;
  }
  async _parseTileData(e7, t5) {
    return this._tileHandler.parseTileData(e7, t5);
  }
  async _applyStyleChanges() {
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this._tileManager.clearCache();
    const e7 = this._styleChanges;
    try {
      await this._tileHandler.updateStyle(e7);
    } catch (n4) {
      s.getLogger(this).error("error applying vector-tiles style update", n4.message), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true;
    }
    const t5 = this._styleRepository, i7 = [];
    e7.forEach((e8) => {
      if (e8.type !== I2.LAYER_REMOVED)
        return;
      const s5 = e8.data, r5 = t5.getLayerById(s5.layer);
      r5 && i7.push(r5.uid);
    });
    const r4 = [];
    let a6;
    e7.forEach((e8) => {
      const i8 = e8.type, s5 = e8.data;
      switch (i8) {
        case I2.PAINTER_CHANGED:
          t5.setPaintProperties(s5.layer, s5.paint), a6 = s5.layer;
          break;
        case I2.LAYOUT_CHANGED:
          t5.setLayoutProperties(s5.layer, s5.layout), a6 = s5.layer;
          break;
        case I2.LAYER_REMOVED:
          return void t5.deleteStyleLayer(s5.layer);
        case I2.LAYER_CHANGED:
          t5.setStyleLayer(s5.layer, s5.index), a6 = s5.layer.id;
          break;
        case I2.SPRITES_CHANGED:
          this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(this._newSpriteSource)), this._newSpriteSource = null, a6 = null;
      }
      const l9 = t5.getLayerById(a6);
      l9 && r4.push(l9.uid);
    });
    const l8 = this._vectorTileContainer.children;
    if (i7.length > 0) {
      this._vectorTileContainer.deleteStyleLayers(i7);
      for (const e8 of l8)
        e8.deleteLayerData(i7);
    }
    if (this._fetchQueue.resume(), this._parseQueue.resume(), r4.length > 0) {
      const e8 = [];
      for (const t6 of l8) {
        const i8 = this._fetchQueue.push(t6.key).then((e9) => this._parseQueue.push({ key: t6.key, data: e9, styleLayerUIDs: r4 })).then((e9) => t6.setData(e9));
        e8.push(i8);
      }
      await Promise.all(e8);
    }
    this._styleChanges = [], this._isTileHandlerReady = true, this.notifyChange("updating"), this.requestUpdate();
  }
  async _loadStyle() {
    const { style: e7 } = this.layer.currentStyleInfo, t5 = a(e7);
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this.notifyChange("updating"), this._styleRepository = new l4(t5), this._vectorTileContainer.destroy(), this._tileManager.clear(), this._tileHandlerAbortController.abort(), this._tileHandlerAbortController = new AbortController();
    const { signal: s5 } = this._tileHandlerAbortController;
    try {
      this._tileHandlerPromise = this._tileHandler.setStyle(this._styleRepository, t5), await this._tileHandlerPromise;
    } catch (l8) {
      if (!d(l8))
        throw l8;
    }
    if (s5.aborted)
      return this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, this.notifyChange("updating"), void this.requestUpdate();
    const r4 = await this._tileHandler.spriteMosaic;
    this._vectorTileContainer.setStyleResources(r4, this._tileHandler.glyphMosaic, this._styleRepository), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, this.notifyChange("updating"), this.requestUpdate();
  }
  _createVectorTile(e7) {
    const t5 = this._tileInfoView.getTileBounds(i(), e7), i7 = this._tileInfoView.getTileResolution(e7.level);
    return new d3(e7, i7, t5[0], t5[3], 512, 512, this._styleRepository);
  }
};
function Q(e7) {
  if (null == e7)
    return 0;
  switch (e7.type) {
    case "partial":
      return Object.keys(e7.diff).length;
    case "complete":
      return Math.max(Object.keys(e7.oldValue).length, Object.keys(e7.newValue).length);
    case "collection":
      return Object.keys(e7.added).length + Object.keys(e7.changed).length + Object.keys(e7.removed).length;
  }
}
e([y()], D.prototype, "_fetchQueue", void 0), e([y()], D.prototype, "_parseQueue", void 0), e([y()], D.prototype, "_isTileHandlerReady", void 0), e([y()], D.prototype, "fading", void 0), D = e([a2("esri.views.2d.layers.VectorTileLayerView2D")], D);
var L = D;
export {
  L as default
};
//# sourceMappingURL=VectorTileLayerView2D-3WFWAOJS.js.map
