import {
  I,
  L,
  s as s4
} from "./chunk-3LLZ72VA.js";
import {
  d,
  f2 as f
} from "./chunk-LEDSC236.js";
import {
  e as e3
} from "./chunk-CW7LIPBH.js";
import {
  n as n3,
  r as r2
} from "./chunk-YGUWDSEH.js";
import {
  E as E2,
  a as a3
} from "./chunk-NLWV7Q6F.js";
import {
  l as l2
} from "./chunk-RVS5HU2K.js";
import {
  r as r3
} from "./chunk-SS3YG6J3.js";
import {
  C,
  _ as _2,
  c,
  h,
  k,
  n as n2,
  o as o2
} from "./chunk-7EG7BYWF.js";
import {
  i,
  x as x2
} from "./chunk-DOQ3SAAR.js";
import {
  s as s3
} from "./chunk-TEHNQYQD.js";
import {
  F,
  H,
  J,
  P,
  X,
  Z,
  _,
  e as e2,
  g,
  o,
  r,
  s as s2,
  x,
  z
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import {
  D,
  E,
  a2,
  b,
  l,
  w
} from "./chunk-3CQBBMMD.js";
import {
  m,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/fov.js
function t(t2, a5, n5) {
  return 2 * Math.atan(Math.sqrt(a5 * a5 + n5 * n5) * Math.tan(0.5 * t2) / a5);
}
function a4(t2, a5, n5) {
  return 2 * Math.atan(Math.sqrt(a5 * a5 + n5 * n5) * Math.tan(0.5 * t2) / n5);
}
function n4(t2, a5, n5) {
  return 2 * Math.atan(a5 * Math.tan(0.5 * t2) / Math.sqrt(a5 * a5 + n5 * n5));
}
function r4(t2, a5, n5) {
  return 2 * Math.atan(n5 * Math.tan(0.5 * t2) / Math.sqrt(a5 * a5 + n5 * n5));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Camera.js
var Z2;
var $ = Z2 = class extends m {
  constructor(t2 = {}) {
    super(t2), this._center = n(), this._up = n(), this._viewUp = n(), this._viewForward = n(), this._viewRight = n(), this._ray = d(), this._viewport = r2(0, 0, 1, 1), this._padding = r2(0, 0, 0, 0), this._fov = 55 / 180 * Math.PI, this._nearFar = r3(1, 1e3), this._viewDirty = true, this._viewMatrix = e3(), this._viewProjectionDirty = true, this._viewProjectionMatrix = e3(), this._viewInverseTransposeMatrixDirty = true, this._viewInverseTransposeMatrix = e3(), this._frustumDirty = true, this._frustum = I(), this._fullViewport = n3(), this._pixelRatio = 1, this.relativeElevation = 0;
  }
  get pixelRatio() {
    return this._pixelRatio;
  }
  set pixelRatio(t2) {
    this._pixelRatio = t2 > 0 ? t2 : 1;
  }
  get eye() {
    return this._ray.origin;
  }
  set eye(t2) {
    this._compareAndSetView(t2, this._ray.origin);
  }
  get center() {
    return this._center;
  }
  set center(t2) {
    this._compareAndSetView(t2, this._center, "_center");
  }
  get ray() {
    return e2(this._ray.direction, this.center, this.eye), this._ray;
  }
  get up() {
    return this._up;
  }
  set up(t2) {
    this._compareAndSetView(t2, this._up, "_up");
  }
  get viewMatrix() {
    return this._ensureViewClean(), this._viewMatrix;
  }
  set viewMatrix(t2) {
    n2(this._viewMatrix, t2), this._viewDirty = false, this._viewInverseTransposeMatrixDirty = true, this._viewProjectionDirty = true, this._frustumDirty = true;
  }
  get viewForward() {
    return this._ensureViewClean(), this._viewForward;
  }
  get viewUp() {
    return this._ensureViewClean(), this._viewUp;
  }
  get viewRight() {
    return this._ensureViewClean(), this._viewRight;
  }
  get nearFar() {
    return this._nearFar;
  }
  get near() {
    return this._nearFar[0];
  }
  set near(t2) {
    this._nearFar[0] !== t2 && (this._nearFar[0] = t2, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_nearFar"));
  }
  get far() {
    return this._nearFar[1];
  }
  set far(t2) {
    this._nearFar[1] !== t2 && (this._nearFar[1] = t2, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_nearFar"));
  }
  get viewport() {
    return this._viewport;
  }
  set viewport(t2) {
    this.x = t2[0], this.y = t2[1], this.width = t2[2], this.height = t2[3];
  }
  get screenViewport() {
    if (1 === this.pixelRatio)
      return this._viewport;
    const t2 = l(n3(), this._viewport, 1 / this.pixelRatio), i2 = this._get("screenViewport");
    return i2 && E(t2, i2) ? i2 : t2;
  }
  get screenPadding() {
    if (1 === this.pixelRatio)
      return this._padding;
    const t2 = l(n3(), this._padding, 1 / this.pixelRatio), i2 = this._get("screenPadding");
    return i2 && E(t2, i2) ? i2 : t2;
  }
  get x() {
    return this._viewport[0];
  }
  set x(t2) {
    t2 += this._padding[ht.LEFT], this._viewport[0] !== t2 && (this._viewport[0] = t2, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_viewport"));
  }
  get y() {
    return this._viewport[1];
  }
  set y(t2) {
    t2 += this._padding[ht.BOTTOM], this._viewport[1] !== t2 && (this._viewport[1] = t2, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_viewport"));
  }
  get width() {
    return this._viewport[2];
  }
  set width(t2) {
    this._viewport[2] !== t2 && (this._viewport[2] = t2, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_viewport"));
  }
  get height() {
    return this._viewport[3];
  }
  set height(t2) {
    this._viewport[3] !== t2 && (this._viewport[3] = t2, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_viewport"));
  }
  get fullWidth() {
    return this._viewport[2] + this._padding[ht.RIGHT] + this._padding[ht.LEFT];
  }
  set fullWidth(t2) {
    this.width = t2 - (this._padding[ht.RIGHT] + this._padding[ht.LEFT]);
  }
  get fullHeight() {
    return this._viewport[3] + this._padding[ht.TOP] + this._padding[ht.BOTTOM];
  }
  set fullHeight(t2) {
    this.height = t2 - (this._padding[ht.TOP] + this._padding[ht.BOTTOM]);
  }
  get fullViewport() {
    return this._fullViewport[0] = this._viewport[0] - this._padding[ht.LEFT], this._fullViewport[1] = this._viewport[1] - this._padding[ht.BOTTOM], this._fullViewport[2] = this.fullWidth, this._fullViewport[3] = this.fullHeight, this._fullViewport;
  }
  get _aspect() {
    return this.width / this.height;
  }
  get padding() {
    return this._padding;
  }
  set padding(t2) {
    D(this._padding, t2) || (this._viewport[0] += t2[ht.LEFT] - this._padding[ht.LEFT], this._viewport[1] += t2[ht.BOTTOM] - this._padding[ht.BOTTOM], this._viewport[2] -= t2[ht.RIGHT] + t2[ht.LEFT] - (this._padding[ht.RIGHT] + this._padding[ht.LEFT]), this._viewport[3] -= t2[ht.TOP] + t2[ht.BOTTOM] - (this._padding[ht.TOP] + this._padding[ht.BOTTOM]), a2(this._padding, t2), this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_padding"), this.notifyChange("_viewport"));
  }
  get viewProjectionMatrix() {
    return this._viewProjectionDirty && (c(this._viewProjectionMatrix, this.projectionMatrix, this.viewMatrix), this._viewProjectionDirty = false), this._viewProjectionMatrix;
  }
  get projectionMatrix() {
    const t2 = this.width, i2 = this.height, e4 = this.near * Math.tan(this.fovY / 2), r5 = e4 * this._aspect, s5 = _2(e3(), -r5 * (1 + 2 * this._padding[ht.LEFT] / t2), r5 * (1 + 2 * this._padding[ht.RIGHT] / t2), -e4 * (1 + 2 * this._padding[ht.BOTTOM] / i2), e4 * (1 + 2 * this._padding[ht.TOP] / i2), this.near, this.far), h2 = this._get("projectionMatrix");
    return h2 && C(h2, s5) ? h2 : s5;
  }
  get inverseProjectionMatrix() {
    return h(e3(), this.projectionMatrix) || this._get("inverseProjectionMatrix") || e3();
  }
  get fov() {
    return this._fov;
  }
  set fov(t2) {
    this._fov = t2, this._viewProjectionDirty = true, this._frustumDirty = true;
  }
  get fovX() {
    return n4(this._fov, this.width, this.height);
  }
  set fovX(t2) {
    this._fov = t(t2, this.width, this.height), this._viewProjectionDirty = true, this._frustumDirty = true;
  }
  get fovY() {
    return r4(this._fov, this.width, this.height);
  }
  set fovY(t2) {
    this._fov = a4(t2, this.width, this.height), this._viewProjectionDirty = true, this._frustumDirty = true;
  }
  get distance() {
    return x(this.center, this.eye);
  }
  get frustum() {
    return this._recomputeFrustum(), this._frustum;
  }
  get viewInverseTransposeMatrix() {
    return (this._viewInverseTransposeMatrixDirty || this._viewDirty) && (h(this._viewInverseTransposeMatrix, this.viewMatrix), o2(this._viewInverseTransposeMatrix, this._viewInverseTransposeMatrix), this._viewInverseTransposeMatrixDirty = false), this._viewInverseTransposeMatrix;
  }
  depthNDCToWorld(t2) {
    const i2 = 2 * t2 - 1;
    return 2 * this.near * this.far / (this.far + this.near - i2 * (this.far - this.near));
  }
  get perRenderPixelRatio() {
    return Math.tan(this.fovX / 2) / (this.width / 2);
  }
  get perScreenPixelRatio() {
    return this.perRenderPixelRatio * this.pixelRatio;
  }
  get aboveGround() {
    return null != this.relativeElevation && this.relativeElevation >= 0;
  }
  copyFrom(t2) {
    r(this._ray.origin, t2.eye), this.center = t2.center, this.up = t2.up, a2(this._viewport, t2.viewport), this.notifyChange("_viewport"), a2(this._padding, t2.padding), this.notifyChange("_padding"), a3(this._nearFar, t2.nearFar), this.notifyChange("_nearFar"), this._fov = t2.fov, this.relativeElevation = t2.relativeElevation;
    const i2 = t2;
    return this._viewDirty = i2._viewDirty, this._viewDirty || (n2(this._viewMatrix, t2.viewMatrix), r(this._viewRight, t2.viewRight), r(this._viewUp, t2.viewUp), r(this._viewForward, t2.viewForward)), this._viewProjectionDirty = true, this._frustumDirty = i2._frustumDirty, this._frustumDirty || (L(this._frustum, t2.frustum), this._frustumDirty = false), i2._viewInverseTransposeMatrixDirty ? this._viewInverseTransposeMatrixDirty = true : (n2(this._viewInverseTransposeMatrix, t2.viewInverseTransposeMatrix), this._viewInverseTransposeMatrixDirty = false), a2(this._fullViewport, t2.fullViewport), this.pixelRatio = t2.pixelRatio, this;
  }
  copyViewFrom(t2) {
    this.eye = t2.eye, this.center = t2.center, this.up = t2.up;
  }
  clone() {
    return new Z2().copyFrom(this);
  }
  equals(t2) {
    return F(this.eye, t2.eye) && F(this.center, t2.center) && F(this.up, t2.up) && D(this._viewport, t2.viewport) && D(this._padding, t2.padding) && E2(this.nearFar, t2.nearFar) && this._fov === t2.fov && this.pixelRatio === t2.pixelRatio && this.relativeElevation === t2.relativeElevation;
  }
  almostEquals(t2) {
    if (Math.abs(t2.fov - this._fov) >= 1e-3 || b(t2.screenPadding, this.screenPadding) >= 1 || b(this.screenViewport, t2.screenViewport) >= 1)
      return false;
    J(et, t2.eye, t2.center), J(rt, this.eye, this.center);
    const i2 = P(et, rt), e4 = Z(et), r5 = Z(rt), s5 = 5e-4;
    return i2 * i2 >= (1 - 1e-10) * e4 * r5 && X(t2.eye, this.eye) < Math.max(e4, r5) * s5 * s5;
  }
  computeRenderPixelSizeAt(t2) {
    return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(t2));
  }
  computeRenderPixelSizeAtDist(t2) {
    return t2 * this.perScreenPixelRatio;
  }
  computeScreenPixelSizeAt(t2) {
    return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(t2));
  }
  _viewDirectionDistance(t2) {
    return Math.abs(f(this.viewForward, e2(et, t2, this.eye)));
  }
  computeScreenPixelSizeAtDist(t2) {
    return t2 * this.perScreenPixelRatio;
  }
  computeDistanceFromRadius(t2, i2) {
    return t2 / Math.tan(Math.min(this.fovX, this.fovY) / (2 * (i2 || 1)));
  }
  getScreenCenter(t2 = i()) {
    return t2[0] = (this.padding[ht.LEFT] + this.width / 2) / this.pixelRatio, t2[1] = (this.padding[ht.TOP] + this.height / 2) / this.pixelRatio, t2;
  }
  getRenderCenter(t2, i2 = 0.5, e4 = 0.5) {
    return t2[0] = this.padding[ht.LEFT] + this.width * i2, t2[1] = this.padding[ht.BOTTOM] + this.height * e4, t2[2] = 0.5, t2;
  }
  setGLViewport(t2) {
    const i2 = this.viewport, e4 = this.padding;
    t2.setViewport(i2[0] - e4[3], i2[1] - e4[2], i2[2] + e4[1] + e4[3], i2[3] + e4[0] + e4[2]);
  }
  applyProjection(t2, i2) {
    t2 !== tt && r(tt, t2), tt[3] = 1, w(tt, tt, this.projectionMatrix);
    const e4 = Math.abs(tt[3]);
    g(tt, tt, 1 / e4);
    const s5 = this.fullViewport;
    i2[0] = s3(0, s5[0] + s5[2], 0.5 + 0.5 * tt[0]), i2[1] = s3(0, s5[1] + s5[3], 0.5 + 0.5 * tt[1]), i2[2] = 0.5 * (tt[2] + 1), i2[3] = e4;
  }
  unapplyProjection(t2, i2) {
    const e4 = this.fullViewport;
    tt[0] = (t2[0] / (e4[0] + e4[2]) * 2 - 1) * t2[3], tt[1] = (t2[1] / (e4[1] + e4[3]) * 2 - 1) * t2[3], tt[2] = (2 * t2[2] - 1) * t2[3], tt[3] = t2[3], null != this.inverseProjectionMatrix && (w(tt, tt, this.inverseProjectionMatrix), i2[0] = tt[0], i2[1] = tt[1], i2[2] = tt[2]);
  }
  projectToScreen(t2, i2) {
    return this.projectToRenderScreen(t2, st), this.renderToScreen(st, i2), i2;
  }
  projectToRenderScreen(t2, i2) {
    if (tt[0] = t2[0], tt[1] = t2[1], tt[2] = t2[2], tt[3] = 1, w(tt, tt, this.viewProjectionMatrix), 0 === tt[3])
      return null;
    g(tt, tt, 1 / Math.abs(tt[3]));
    const e4 = this.fullViewport;
    return "x" in i2 ? (i2.x = s3(0, e4[0] + e4[2], 0.5 + 0.5 * tt[0]), i2.y = s3(0, e4[1] + e4[3], 0.5 + 0.5 * tt[1])) : (i2[0] = s3(0, e4[0] + e4[2], 0.5 + 0.5 * tt[0]), i2[1] = s3(0, e4[1] + e4[3], 0.5 + 0.5 * tt[1]), i2.length > 2 && (i2[2] = 0.5 * (tt[2] + 1))), i2;
  }
  unprojectFromScreen(t2, i2) {
    return this.unprojectFromRenderScreen(this.screenToRender(t2, st), i2);
  }
  unprojectFromRenderScreen(t2, i2) {
    if (c(it, this.projectionMatrix, this.viewMatrix), !h(it, it))
      return null;
    const e4 = this.fullViewport;
    return tt[0] = 2 * (t2[0] - e4[0]) / e4[2] - 1, tt[1] = 2 * (t2[1] - e4[1]) / e4[3] - 1, tt[2] = 2 * t2[2] - 1, tt[3] = 1, w(tt, tt, it), 0 === tt[3] ? null : (i2[0] = tt[0] / tt[3], i2[1] = tt[1] / tt[3], i2[2] = tt[2] / tt[3], i2);
  }
  constrainWindowSize(t2, i2, e4, r5) {
    const s5 = t2 * this.pixelRatio, h2 = i2 * this.pixelRatio, o3 = Math.max(s5 - e4 / 2, 0), n5 = Math.max(this.fullHeight - h2 - r5 / 2, 0), a5 = -Math.min(s5 - e4 / 2, 0), p = -Math.min(this.fullHeight - h2 - r5 / 2, 0);
    return [o3, n5, e4 - a5 - -Math.min(this.fullWidth - s5 - e4 / 2, 0), r5 - p - -Math.min(h2 - r5 / 2, 0)];
  }
  computeUp(t2) {
    t2 === l2.Global ? this._computeUpGlobal() : this._computeUpLocal();
  }
  screenToRender(t2, i2) {
    const e4 = t2[0] * this.pixelRatio, r5 = this.fullHeight - t2[1] * this.pixelRatio;
    return i2[0] = e4, i2[1] = r5, i2;
  }
  renderToScreen(t2, i2) {
    const e4 = t2[0] / this.pixelRatio, r5 = (this.fullHeight - t2[1]) / this.pixelRatio;
    i2[0] = e4, i2[1] = r5;
  }
  _computeUpGlobal() {
    e2(et, this.center, this.eye);
    const t2 = s2(this.center);
    t2 < 1 ? (o(this._up, 0, 0, 1), this._markViewDirty(), this.notifyChange("_up")) : Math.abs(P(et, this.center)) > 0.9999 * s2(et) * t2 || (_(this._up, et, this.center), _(this._up, this._up, et), z(this._up, this._up), this.notifyChange("_up"), this._markViewDirty());
  }
  _computeUpLocal() {
    H(et, this.eye, this.center), Math.abs(et[2]) <= 0.9999 && (g(et, et, et[2]), o(this._up, -et[0], -et[1], 1 - et[2]), z(this._up, this._up), this.notifyChange("_up"), this._markViewDirty());
  }
  _compareAndSetView(t2, i2, r5 = "") {
    "number" == typeof t2[0] && isFinite(t2[0]) && "number" == typeof t2[1] && isFinite(t2[1]) && "number" == typeof t2[2] && isFinite(t2[2]) ? F(t2, i2) || (r(i2, t2), this._markViewDirty(), r5.length && this.notifyChange(r5)) : s.getLogger("esri.views.3d.webgl-engine.lib.Camera").warn("Camera vector contains invalid number, ignoring value");
  }
  _markViewDirty() {
    this._viewDirty = true, this._frustumDirty = true, this._viewProjectionDirty = true;
  }
  _recomputeFrustum() {
    this._frustumDirty && (s4(this.viewMatrix, this.projectionMatrix, this._frustum), this._frustumDirty = false);
  }
  _ensureViewClean() {
    this._viewDirty && (k(this._viewMatrix, this.eye, this.center, this.up), o(this._viewForward, -this._viewMatrix[2], -this._viewMatrix[6], -this._viewMatrix[10]), o(this._viewUp, this._viewMatrix[1], this._viewMatrix[5], this._viewMatrix[9]), o(this._viewRight, this._viewMatrix[0], this._viewMatrix[4], this._viewMatrix[8]), this._viewDirty = false, this._viewInverseTransposeMatrixDirty = true);
  }
};
e([y()], $.prototype, "_center", void 0), e([y()], $.prototype, "_up", void 0), e([y()], $.prototype, "_viewport", void 0), e([y()], $.prototype, "_padding", void 0), e([y()], $.prototype, "_fov", void 0), e([y()], $.prototype, "_nearFar", void 0), e([y()], $.prototype, "_pixelRatio", void 0), e([y()], $.prototype, "pixelRatio", null), e([y()], $.prototype, "eye", null), e([y()], $.prototype, "center", null), e([y()], $.prototype, "up", null), e([y({ readOnly: true })], $.prototype, "nearFar", null), e([y()], $.prototype, "near", null), e([y()], $.prototype, "far", null), e([y()], $.prototype, "viewport", null), e([y({ readOnly: true })], $.prototype, "screenViewport", null), e([y({ readOnly: true })], $.prototype, "screenPadding", null), e([y()], $.prototype, "x", null), e([y()], $.prototype, "y", null), e([y()], $.prototype, "width", null), e([y()], $.prototype, "height", null), e([y()], $.prototype, "fullWidth", null), e([y()], $.prototype, "fullHeight", null), e([y({ readOnly: true })], $.prototype, "_aspect", null), e([y()], $.prototype, "padding", null), e([y({ readOnly: true })], $.prototype, "projectionMatrix", null), e([y({ readOnly: true })], $.prototype, "inverseProjectionMatrix", null), e([y()], $.prototype, "fov", null), e([y()], $.prototype, "fovX", null), e([y()], $.prototype, "fovY", null), $ = Z2 = e([a("esri.views.3d.webgl-engine.lib.Camera")], $);
var tt = n3();
var it = e3();
var et = n();
var rt = n();
var st = x2();
var ht;
!function(t2) {
  t2[t2.TOP = 0] = "TOP", t2[t2.RIGHT = 1] = "RIGHT", t2[t2.BOTTOM = 2] = "BOTTOM", t2[t2.LEFT = 3] = "LEFT";
}(ht || (ht = {}));

export {
  $,
  ht
};
//# sourceMappingURL=chunk-SFIT2AUF.js.map
