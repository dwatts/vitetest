import {
  n as n7,
  n2 as n8
} from "./chunk-HMHRXSML.js";
import {
  e as e7
} from "./chunk-WGM2OLIG.js";
import {
  e as e6
} from "./chunk-44OKOXKA.js";
import {
  c as c4
} from "./chunk-BSSEIP2H.js";
import {
  o as o3
} from "./chunk-4YQPCE3Y.js";
import {
  e2 as e4
} from "./chunk-OKNF37G2.js";
import {
  e as e2
} from "./chunk-NVZXNBIH.js";
import {
  e as e3,
  i as i3,
  o as o2
} from "./chunk-VF625TQS.js";
import {
  t as t2
} from "./chunk-XYJMHUDA.js";
import {
  Ie,
  de,
  fe,
  ie,
  le,
  me,
  ne,
  oe,
  pe,
  re,
  se,
  ue
} from "./chunk-RKM5MXYH.js";
import {
  T,
  _
} from "./chunk-TBHRKIAA.js";
import {
  t as t4
} from "./chunk-EFDT2ZDW.js";
import {
  t as t3
} from "./chunk-PM77FW2O.js";
import {
  n as n5
} from "./chunk-BPITJIFG.js";
import {
  Ae,
  B,
  C,
  X,
  Y,
  ae,
  ce
} from "./chunk-J6SRKANJ.js";
import {
  a as a4,
  l as l3,
  s as s6
} from "./chunk-ZYPAFVYT.js";
import {
  T as T3
} from "./chunk-X65XM5YN.js";
import {
  T as T2,
  e2 as e5
} from "./chunk-TRGMWULG.js";
import {
  o
} from "./chunk-WDZ5AAFL.js";
import {
  f as f2
} from "./chunk-XL7RF4A6.js";
import {
  d as d2
} from "./chunk-TDXHXKUI.js";
import {
  D,
  G,
  L,
  R
} from "./chunk-BCDDCNQ2.js";
import {
  u as u2
} from "./chunk-UQHDCOJC.js";
import {
  Rt,
  X as X2,
  _ as _3,
  dt,
  gt,
  l as l2,
  lt,
  wt
} from "./chunk-ICGBQNK3.js";
import {
  _ as _2
} from "./chunk-7JB7RSO7.js";
import {
  n as n6
} from "./chunk-5KLICR5E.js";
import {
  a as a3,
  r as r2,
  s as s5
} from "./chunk-NLWV7Q6F.js";
import {
  n as n4
} from "./chunk-SS3YG6J3.js";
import {
  a as a2
} from "./chunk-VMTVUE47.js";
import {
  c as c3,
  i as i2,
  u
} from "./chunk-DOQ3SAAR.js";
import {
  c as c2,
  i
} from "./chunk-TEHNQYQD.js";
import {
  g
} from "./chunk-TPJLFGOT.js";
import {
  n as n2,
  r
} from "./chunk-CQX57DED.js";
import {
  x2 as x
} from "./chunk-ZEEBL7ZN.js";
import {
  f
} from "./chunk-H7RDAEPY.js";
import {
  n as n3
} from "./chunk-7KH4CLS5.js";
import {
  j
} from "./chunk-43LWRDQS.js";
import {
  m as m2,
  n3 as n,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  c,
  d,
  m,
  s as s4,
  w
} from "./chunk-7I33FAWS.js";
import {
  l,
  t
} from "./chunk-DWOEYHKS.js";
import {
  s,
  s2,
  s3
} from "./chunk-HMVAPW5X.js";
import {
  has
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BitBlitPrograms.js
var e8 = { shaders: { vertexShader: n8("bitBlit/bitBlit.vert"), fragmentShader: n8("bitBlit/bitBlit.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_tex", 1]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/RectangleBinPack.js
var t5 = class {
  constructor(t9, e11) {
    this._width = 0, this._height = 0, this._free = [], this._width = t9, this._height = e11, this._free.push(new t2(0, 0, t9, e11));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(t9, e11) {
    if (t9 > this._width || e11 > this._height)
      return new t2();
    let i7 = null, s9 = -1;
    for (let h5 = 0; h5 < this._free.length; ++h5) {
      const r11 = this._free[h5];
      t9 <= r11.width && e11 <= r11.height && (null === i7 || r11.y <= i7.y && r11.x <= i7.x) && (i7 = r11, s9 = h5);
    }
    return null === i7 ? new t2() : (this._free.splice(s9, 1), i7.width < i7.height ? (i7.width > t9 && this._free.push(new t2(i7.x + t9, i7.y, i7.width - t9, e11)), i7.height > e11 && this._free.push(new t2(i7.x, i7.y + e11, i7.width, i7.height - e11))) : (i7.width > t9 && this._free.push(new t2(i7.x + t9, i7.y, i7.width - t9, i7.height)), i7.height > e11 && this._free.push(new t2(i7.x, i7.y + e11, t9, i7.height - e11))), new t2(i7.x, i7.y, t9, e11));
  }
  release(h5) {
    for (let t9 = 0; t9 < this._free.length; ++t9) {
      const e11 = this._free[t9];
      if (e11.y === h5.y && e11.height === h5.height && e11.x + e11.width === h5.x)
        e11.width += h5.width;
      else if (e11.x === h5.x && e11.width === h5.width && e11.y + e11.height === h5.y)
        e11.height += h5.height;
      else if (h5.y === e11.y && h5.height === e11.height && h5.x + h5.width === e11.x)
        e11.x = h5.x, e11.width += h5.width;
      else {
        if (h5.x !== e11.x || h5.width !== e11.width || h5.y + h5.height !== e11.y)
          continue;
        e11.y = h5.y, e11.height += h5.height;
      }
      this._free.splice(t9, 1), this.release(h5);
    }
    this._free.push(h5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphMosaic.js
var n9 = 256;
var o4 = (t9) => Math.floor(t9 / 256);
function c5(t9) {
  const e11 = /* @__PURE__ */ new Set();
  for (const i7 of t9)
    e11.add(o4(i7));
  return e11;
}
function l4(e11, i7, h5) {
  return e11.has(i7) || e11.set(i7, h5().then(() => {
    e11.delete(i7);
  }).catch((h6) => {
    e11.delete(i7), m(h6);
  })), e11.get(i7);
}
var g2 = (t9) => ({ rect: new t2(0, 0, 0, 0), page: 0, metrics: { left: 0, width: 0, height: 0, advance: 0, top: 0 }, code: t9, sdf: true });
var p = class {
  constructor(t9, e11, h5) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphCache = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this._preloadCache = {}, this.width = t9, this.height = e11, this._glyphSource = h5, this._binPack = new t5(t9 - 4, e11 - 4), this._glyphData.push(new Uint8Array(t9 * e11)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs();
  }
  dispose() {
    this._binPack = null;
    for (const t9 of this._textures)
      t9 && t9.dispose();
    this._textures.length = 0, this._glyphData.length = 0;
  }
  _initDecorationGlyphs() {
    const t9 = [117, 149, 181, 207, 207, 181, 149, 117], e11 = [], i7 = [];
    for (let r11 = 0; r11 < t9.length; r11++) {
      const h6 = t9[r11];
      for (let t10 = 0; t10 < 11; t10++) {
        const s10 = r11 >= 3 && r11 < 5 && t10 >= 3 && t10 < 8 ? 255 : 0;
        e11.push(h6), i7.push(s10);
      }
    }
    const h5 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(e11) }, s9 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(i7) };
    this._recordGlyph(h5), this._recordGlyph(s9);
  }
  async getGlyphItems(t9, e11, i7) {
    const h5 = this._getGlyphCache(t9);
    return await this._fetchRanges(t9, e11, i7), e11.map((e12) => this._getMosaicItem(h5, t9, e12));
  }
  bind(t9, e11, i7, h5) {
    const s9 = this._getTexture(t9, i7);
    s9.setSamplingMode(e11), this._dirties[i7] && (s9.setData(this._glyphData[i7]), this._dirties[i7] = false), t9.bindTexture(s9, h5);
  }
  preloadASCIIGlyphCache(t9) {
    const e11 = this._preloadCache[t9];
    if (null != e11)
      return e11;
    const i7 = this._glyphSource.preloadASCIIRange(t9).then(() => {
      const e12 = this._getGlyphCache(t9);
      for (let i8 = 0; i8 < 256; i8++)
        this._getMosaicItem(e12, t9, i8);
    });
    return this._preloadCache[t9] = i7, i7;
  }
  _getGlyphCache(t9) {
    return this._glyphCache[t9] || (this._glyphCache[t9] = {}), this._glyphCache[t9];
  }
  _getTexture(t9, e11) {
    if (!this._textures[e11]) {
      const i7 = new e5();
      i7.pixelFormat = G.ALPHA, i7.wrapMode = D.CLAMP_TO_EDGE, i7.width = this.width, i7.height = this.height, this._textures[e11] = new T2(t9, i7, new Uint8Array(this.width * this.height));
    }
    return this._textures[e11];
  }
  _invalidate() {
    this._dirties[this._currentPage] = true;
  }
  async _fetchRanges(t9, e11, i7) {
    const h5 = c5(e11), s9 = [];
    h5.forEach((e12) => {
      s9.push(this._fetchRange(t9, e12, i7));
    }), await Promise.all(s9);
  }
  async _fetchRange(t9, e11, i7) {
    if (e11 > n9)
      return;
    const h5 = t9 + e11;
    return l4(this._rangePromises, h5, () => this._glyphSource.getRange(t9, e11, i7));
  }
  _getMosaicItem(t9, e11, i7) {
    if (!t9[i7]) {
      const h5 = this._glyphSource.getGlyph(e11, i7);
      if (!h5 || !h5.metrics)
        return g2(i7);
      const s9 = this._recordGlyph(h5), r11 = this._currentPage, a10 = h5.metrics;
      t9[i7] = { rect: s9, page: r11, metrics: a10, code: i7, sdf: true }, this._invalidate();
    }
    return t9[i7];
  }
  _recordGlyph(t9) {
    const h5 = t9.metrics;
    let s9;
    if (0 === h5.width)
      s9 = new t2(0, 0, 0, 0);
    else {
      const e11 = 3, r11 = h5.width + 2 * e11, a10 = h5.height + 2 * e11;
      s9 = this._binPack.allocate(r11, a10), s9.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs(), this._binPack = new t5(this.width - 4, this.height - 4), s9 = this._binPack.allocate(r11, a10));
      const n15 = this._glyphData[this._currentPage], o7 = t9.bitmap;
      let c11, l9;
      if (o7)
        for (let t10 = 0; t10 < a10; t10++) {
          c11 = r11 * t10, l9 = this.width * (s9.y + t10) + s9.x;
          for (let t11 = 0; t11 < r11; t11++)
            n15[l9 + t11] = o7[c11 + t11];
        }
      has("esri-glyph-debug") && this._showDebugPage(n15);
    }
    return s9;
  }
  _showDebugPage(t9) {
    const e11 = document.createElement("canvas"), i7 = e11.getContext("2d"), h5 = new ImageData(this.width, this.height), s9 = h5.data;
    e11.width = this.width, e11.height = this.height, e11.style.border = "1px solid black";
    for (let r11 = 0; r11 < t9.length; ++r11)
      s9[4 * r11] = t9[r11], s9[4 * r11 + 1] = 0, s9[4 * r11 + 2] = 0, s9[4 * r11 + 3] = 255;
    i7.putImageData(h5, 0, 0), document.body.appendChild(e11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphSource.js
var a5 = class {
  constructor(e11) {
    for (this._metrics = [], this._bitmaps = []; e11.next(); )
      switch (e11.tag()) {
        case 1: {
          const t9 = e11.getMessage();
          for (; t9.next(); )
            switch (t9.tag()) {
              case 3: {
                const e12 = t9.getMessage();
                let a10, s9, r11, n15, i7, c11, g6;
                for (; e12.next(); )
                  switch (e12.tag()) {
                    case 1:
                      a10 = e12.getUInt32();
                      break;
                    case 2:
                      s9 = e12.getBytes();
                      break;
                    case 3:
                      r11 = e12.getUInt32();
                      break;
                    case 4:
                      n15 = e12.getUInt32();
                      break;
                    case 5:
                      i7 = e12.getSInt32();
                      break;
                    case 6:
                      c11 = e12.getSInt32();
                      break;
                    case 7:
                      g6 = e12.getUInt32();
                      break;
                    default:
                      e12.skip();
                  }
                e12.release(), a10 && (this._metrics[a10] = { width: r11, height: n15, left: i7, top: c11, advance: g6 }, this._bitmaps[a10] = s9);
                break;
              }
              default:
                t9.skip();
            }
          t9.release();
          break;
        }
        default:
          e11.skip();
      }
  }
  getMetrics(e11) {
    return this._metrics[e11];
  }
  getBitmap(e11) {
    return this._bitmaps[e11];
  }
};
var s7 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e11) {
    return this._ranges[e11];
  }
  addRange(e11, t9) {
    this._ranges[e11] = t9;
  }
};
var r3 = class {
  constructor(e11) {
    this._glyphInfo = {}, this._baseURL = e11;
  }
  getRange(s9, r11, n15) {
    const i7 = this._getFontStack(s9);
    if (i7.getRange(r11))
      return Promise.resolve();
    const c11 = 256 * r11, g6 = c11 + 255, o7 = this._baseURL.replace("{fontstack}", s9).replace("{range}", c11 + "-" + g6);
    return j(o7, { responseType: "array-buffer", ...n15 }).then((e11) => {
      i7.addRange(r11, new a5(new n5(new Uint8Array(e11.data), new DataView(e11.data))));
    });
  }
  async preloadASCIIRange(s9) {
    const r11 = this._getFontStack(s9), n15 = 0, i7 = 255, c11 = this._baseURL.replace("{fontstack}", s9).replace("{range}", n15 + "-" + i7), g6 = await j(c11, { responseType: "array-buffer" }), o7 = new a5(new n5(new Uint8Array(g6.data), new DataView(g6.data)));
    for (let e11 = n15; e11 <= i7; e11++)
      r11.getRange(e11) || r11.addRange(e11, o7);
  }
  getGlyph(e11, t9) {
    const a10 = this._getFontStack(e11);
    if (!a10)
      return;
    const s9 = Math.floor(t9 / 256), r11 = a10.getRange(s9);
    return r11 ? { metrics: r11.getMetrics(t9), bitmap: r11.getBitmap(t9) } : void 0;
  }
  _getFontStack(e11) {
    let t9 = this._glyphInfo[e11];
    return t9 || (t9 = this._glyphInfo[e11] = new s7()), t9;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SDFConverter.js
var i4 = 1e20;
var r4 = class {
  constructor(t9) {
    this._svg = null, this.size = t9;
    const e11 = document.createElement("canvas");
    e11.width = e11.height = t9, this._context = e11.getContext("2d"), this._gridOuter = new Float64Array(t9 * t9), this._gridInner = new Float64Array(t9 * t9), this._f = new Float64Array(t9), this._d = new Float64Array(t9), this._z = new Float64Array(t9 + 1), this._v = new Int16Array(t9);
  }
  dispose() {
    this._context = this._gridOuter = this._gridInner = this._f = this._d = this._z = this._v = null, this._svg && (document.body.removeChild(this._svg), this._svg = null);
  }
  draw(r11, h5, n15 = 31) {
    this._initSVG();
    const o7 = this.createSVGString(r11);
    return new Promise((r12, a10) => {
      const d9 = new Image();
      d9.src = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(o7), d9.onload = () => {
        d9.onload = null, this._context.clearRect(0, 0, this.size, this.size), this._context.drawImage(d9, 0, 0, this.size, this.size);
        const e11 = this._context.getImageData(0, 0, this.size, this.size), s9 = new Uint8Array(this.size * this.size * 4);
        for (let t9 = 0; t9 < this.size * this.size; t9++) {
          const s10 = e11.data[4 * t9 + 3] / 255;
          this._gridOuter[t9] = 1 === s10 ? 0 : 0 === s10 ? i4 : Math.max(0, 0.5 - s10) ** 2, this._gridInner[t9] = 1 === s10 ? i4 : 0 === s10 ? 0 : Math.max(0, s10 - 0.5) ** 2;
        }
        this._edt(this._gridOuter, this.size, this.size), this._edt(this._gridInner, this.size, this.size);
        for (let i7 = 0; i7 < this.size * this.size; i7++) {
          const e12 = this._gridOuter[i7] - this._gridInner[i7];
          o(0.5 - e12 / (2 * n15), s9, 4 * i7);
        }
        r12(s9);
      };
      const l9 = h5 && h5.signal;
      l9 && w(l9, () => a10(c()));
    });
  }
  _initSVG() {
    if (!this._svg) {
      const t9 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      t9.setAttribute("style", "position: absolute;"), t9.setAttribute("width", "0"), t9.setAttribute("height", "0"), t9.setAttribute("aria-hidden", "true"), t9.setAttribute("role", "presentation"), document.body.appendChild(t9), this._svg = t9;
    }
    return this._svg;
  }
  createSVGString(t9) {
    const e11 = this._initSVG(), s9 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    s9.setAttribute("d", t9), e11.appendChild(s9);
    const i7 = s9.getBBox(), r11 = i7.width / i7.height, h5 = this.size / 2;
    let n15, o7, a10, d9;
    if (r11 > 1) {
      o7 = n15 = h5 / i7.width;
      const t10 = h5 * (1 / r11);
      a10 = this.size / 4, d9 = h5 - t10 / 2;
    } else {
      n15 = o7 = h5 / i7.height;
      a10 = h5 - h5 * r11 / 2, d9 = this.size / 4;
    }
    const l9 = -i7.x * n15 + a10, _6 = -i7.y * o7 + d9;
    s9.setAttribute("style", `transform: matrix(${n15}, 0, 0, ${o7}, ${l9}, ${_6})`);
    const g6 = `<svg style="fill:red;" height="${this.size}" width="${this.size}" xmlns="http://www.w3.org/2000/svg">${e11.innerHTML}</svg>`;
    return e11.removeChild(s9), g6;
  }
  _edt(t9, e11, s9) {
    const i7 = this._f, r11 = this._d, h5 = this._v, n15 = this._z;
    for (let o7 = 0; o7 < e11; o7++) {
      for (let r12 = 0; r12 < s9; r12++)
        i7[r12] = t9[r12 * e11 + o7];
      this._edt1d(i7, r11, h5, n15, s9);
      for (let i8 = 0; i8 < s9; i8++)
        t9[i8 * e11 + o7] = r11[i8];
    }
    for (let o7 = 0; o7 < s9; o7++) {
      for (let s10 = 0; s10 < e11; s10++)
        i7[s10] = t9[o7 * e11 + s10];
      this._edt1d(i7, r11, h5, n15, e11);
      for (let s10 = 0; s10 < e11; s10++)
        t9[o7 * e11 + s10] = Math.sqrt(r11[s10]);
    }
  }
  _edt1d(t9, e11, s9, r11, h5) {
    s9[0] = 0, r11[0] = -i4, r11[1] = +i4;
    for (let n15 = 1, o7 = 0; n15 < h5; n15++) {
      let e12 = (t9[n15] + n15 * n15 - (t9[s9[o7]] + s9[o7] * s9[o7])) / (2 * n15 - 2 * s9[o7]);
      for (; e12 <= r11[o7]; )
        o7--, e12 = (t9[n15] + n15 * n15 - (t9[s9[o7]] + s9[o7] * s9[o7])) / (2 * n15 - 2 * s9[o7]);
      o7++, s9[o7] = n15, r11[o7] = e12, r11[o7 + 1] = +i4;
    }
    for (let i7 = 0, n15 = 0; i7 < h5; i7++) {
      for (; r11[n15 + 1] < i7; )
        n15++;
      e11[i7] = (i7 - s9[n15]) * (i7 - s9[n15]) + t9[s9[n15]];
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SpriteMosaic.js
function c6(t9) {
  return t9 && "static" === t9.type;
}
var n10 = class _n {
  constructor(t9, e11, i7 = 0) {
    this._mosaicPages = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = /* @__PURE__ */ new Map(), this._spriteCopyQueue = [], this.pixelRatio = 1, (t9 <= 0 || e11 <= 0) && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t9, this._pageHeight = e11, i7 > 0 && (this._maxItemSize = i7), this.pixelRatio = window.devicePixelRatio || 1, this._binPack = new t5(this._pageWidth, this._pageHeight);
    const s9 = Math.floor(this._pageWidth), o7 = Math.floor(this._pageHeight);
    this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(s9 * o7) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 });
  }
  getWidth(t9) {
    return t9 >= this._mosaicPages.length ? -1 : this._mosaicPages[t9].size[0];
  }
  getHeight(t9) {
    return t9 >= this._mosaicPages.length ? -1 : this._mosaicPages[t9].size[1];
  }
  getPageTexture(t9) {
    return t9 < this._mosaicPages.length ? this._mosaicPages[t9].texture : null;
  }
  has(t9) {
    return this._mosaicRects.has(t9);
  }
  get itemCount() {
    return this._mosaicRects.size;
  }
  getSpriteItem(t9) {
    return this._mosaicRects.get(t9);
  }
  addSpriteItem(t9, i7, a10, o7, r11, h5, n15 = 1) {
    if (this._mosaicRects.has(t9))
      return this._mosaicRects.get(t9);
    let g6, p3, m5;
    if (c6(a10))
      [g6, p3, m5] = this._allocateImage(i7[0], i7[1]);
    else {
      g6 = new t2(0, 0, i7[0], i7[1]), p3 = this._mosaicPages.length;
      const t10 = void 0;
      this._mosaicPages.push({ mosaicsData: a10, size: [i7[0] + 2 * ae, i7[1] + 2 * ae], dirty: true, texture: t10 });
    }
    if (g6.width <= 0 || g6.height <= 0)
      return null;
    const d9 = { rect: g6, width: i7[0], height: i7[1], sdf: r11, simplePattern: h5, pixelRatio: n15, page: p3 };
    return this._mosaicRects.set(t9, d9), c6(a10) && (has("esri-mosaic-debug") && this._showDebugSprite(i7, a10.data), this._copy({ rect: g6, spriteSize: i7, spriteData: a10.data, page: p3, pageSize: m5, repeat: o7, sdf: r11 })), d9;
  }
  hasItemsToProcess() {
    return 0 !== this._spriteCopyQueue.length;
  }
  processNextItem() {
    const t9 = this._spriteCopyQueue.pop();
    t9 && this._copy(t9);
  }
  getSpriteItems(t9) {
    const e11 = {};
    for (const i7 of t9)
      e11[i7] = this.getSpriteItem(i7);
    return e11;
  }
  getMosaicItemPosition(t9) {
    const i7 = this.getSpriteItem(t9), s9 = i7 && i7.rect;
    if (!s9)
      return null;
    s9.width = i7.width, s9.height = i7.height;
    const a10 = i7.width, o7 = i7.height, r11 = ae, h5 = this._mosaicPages[i7.page].size;
    return { size: [i7.width, i7.height], tl: [(s9.x + r11) / h5[0], (s9.y + r11) / h5[1]], br: [(s9.x + r11 + a10) / h5[0], (s9.y + r11 + o7) / h5[1]], page: i7.page };
  }
  bind(t9, e11, i7 = 0, s9 = 0) {
    const a10 = this._mosaicPages[i7], o7 = a10.mosaicsData;
    let r11 = a10.texture;
    if (r11 || (r11 = p2(t9, a10.size), a10.texture = r11), r11.setSamplingMode(e11), c6(o7))
      t9.bindTexture(r11, s9), a10.dirty && (r11.setData(new Uint8Array(o7.data.buffer)), r11.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(i7));
    else {
      o7.data.bindFrame(t9, r11, s9), r11.generateMipmap();
    }
    a10.dirty = false;
  }
  dispose() {
    this._binPack = null;
    for (const t9 of this._mosaicPages) {
      const e11 = t9.texture;
      e11 && e11.dispose();
      const i7 = t9.mosaicsData;
      if (!c6(i7)) {
        i7.data.destroy();
      }
    }
    this._mosaicPages = null, this._mosaicRects.clear();
  }
  static _copyBits(t9, e11, i7, s9, a10, o7, r11, h5, c11, n15, g6) {
    let p3 = s9 * e11 + i7, m5 = h5 * o7 + r11;
    if (g6) {
      m5 -= o7;
      for (let r12 = -1; r12 <= n15; r12++, p3 = ((r12 + n15) % n15 + s9) * e11 + i7, m5 += o7)
        for (let e12 = -1; e12 <= c11; e12++)
          a10[m5 + e12] = t9[p3 + (e12 + c11) % c11];
    } else
      for (let d9 = 0; d9 < n15; d9++) {
        for (let e12 = 0; e12 < c11; e12++)
          a10[m5 + e12] = t9[p3 + e12];
        p3 += e11, m5 += o7;
      }
  }
  _copy(i7) {
    if (i7.page >= this._mosaicPages.length)
      return;
    const s9 = this._mosaicPages[i7.page], a10 = s9.mosaicsData;
    if (!c6(s9.mosaicsData))
      throw new s3("mapview-invalid-resource", "unsuitable data type!");
    const o7 = i7.spriteData, r11 = a10.data;
    r11 && o7 || console.error("Source or target images are uninitialized!"), _n._copyBits(o7, i7.spriteSize[0], 0, 0, r11, i7.pageSize[0], i7.rect.x + ae, i7.rect.y + ae, i7.spriteSize[0], i7.spriteSize[1], i7.repeat), s9.dirty = true;
  }
  _allocateImage(t9, o7) {
    t9 += 2 * ae, o7 += 2 * ae;
    const r11 = Math.max(t9, o7);
    if (this._maxItemSize && this._maxItemSize < r11) {
      const e11 = 2 ** Math.ceil(e2(t9)), a10 = 2 ** Math.ceil(e2(o7)), r12 = new t2(0, 0, t9, o7);
      return this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(e11 * a10) }, size: [e11, a10], dirty: true, texture: void 0 }), [r12, this._mosaicPages.length - 1, [e11, a10]];
    }
    const h5 = this._binPack.allocate(t9, o7);
    if (h5.width <= 0) {
      const e11 = this._mosaicPages[this._currentPage];
      return !e11.dirty && c6(e11.mosaicsData) && (e11.mosaicsData.data = null), this._currentPage = this._mosaicPages.length, this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(this._pageWidth * this._pageHeight) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 }), this._binPack = new t5(this._pageWidth, this._pageHeight), this._allocateImage(t9, o7);
    }
    return [h5, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _showDebugSprite([t9, e11], i7) {
    const s9 = document.createElement("canvas");
    s9.width = t9, s9.height = e11, s9.setAttribute("style", `position: absolute; top: ${4 + 204 * g3++}px; right: 208px; width: 200px; height: 200px; border: 1px solid black;`);
    const a10 = s9.getContext("2d"), o7 = new ImageData(t9, e11);
    o7.data.set(new Uint8Array(i7.buffer)), a10.putImageData(o7, 0, 0), document.body.appendChild(s9);
  }
  _showDebugPage(t9) {
    const e11 = this._mosaicPages[t9], { size: [i7, s9], mosaicsData: a10 } = e11;
    if (!c6(a10))
      return void console.error("Could not show sprite mosaic debug for non-static resource");
    const o7 = `mosaicDebugPage${t9}`, r11 = document.getElementById(o7) ?? document.createElement("canvas");
    r11.id = o7, r11.width = i7, r11.height = s9, r11.setAttribute("style", `position: absolute; top: ${4 + 204 * t9}px; right: 4px; width: 200px; height: 200px; border: 1px solid black;`);
    const h5 = r11.getContext("2d"), n15 = new ImageData(i7, s9);
    n15.data.set(new Uint8Array(a10.data.buffer)), h5.putImageData(n15, 0, 0), document.body.appendChild(r11);
  }
};
var g3 = 0;
function p2(t9, e11) {
  const i7 = new e5();
  return i7.width = e11[0], i7.height = e11[1], i7.wrapMode = D.CLAMP_TO_EDGE, new T2(t9, i7, null);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/utils.js
function n11(e11) {
  return n(e11.frameDurations.reduce((t9, e12) => t9 + e12, 0));
}
function s8(t9) {
  const { width: e11, height: r11 } = t9;
  return { frameDurations: t9.frameDurations.reverse(), getFrame: (e12) => {
    const r12 = t9.frameDurations.length - 1 - e12;
    return t9.getFrame(r12);
  }, width: e11, height: r11 };
}
function o5(e11, r11) {
  const { width: i7, height: a10, getFrame: s9 } = e11, o7 = r11 / n11(e11);
  return { frameDurations: e11.frameDurations.map((e12) => n(e12 * o7)), getFrame: s9, width: i7, height: a10 };
}
function m3(e11, r11) {
  const { width: i7, height: a10, getFrame: n15 } = e11, s9 = e11.frameDurations.slice(), o7 = s9.shift();
  return s9.unshift(n(o7 + r11)), { frameDurations: s9, getFrame: n15, width: i7, height: a10 };
}
function h(e11, r11) {
  const { width: i7, height: a10, getFrame: n15 } = e11, s9 = e11.frameDurations.slice(), o7 = s9.pop();
  return s9.push(n(o7 + r11)), { frameDurations: s9, getFrame: n15, width: i7, height: a10 };
}
var c7 = class {
  constructor(t9, e11, r11, i7) {
    this._animation = t9, this._repeatType = r11, this._onFrameData = i7, this._direction = 1, this._currentFrame = 0, this.timeToFrame = this._animation.frameDurations[this._currentFrame];
    let a10 = 0;
    for (; e11 > a10; )
      a10 += this.timeToFrame, this.nextFrame();
    const n15 = this._animation.getFrame(this._currentFrame);
    this._onFrameData(n15);
  }
  nextFrame() {
    if (this._currentFrame += this._direction, this._direction > 0) {
      if (this._currentFrame === this._animation.frameDurations.length)
        switch (this._repeatType) {
          case d2.None:
            this._currentFrame -= this._direction;
            break;
          case d2.Loop:
            this._currentFrame = 0;
            break;
          case d2.Oscillate:
            this._currentFrame -= this._direction, this._direction = -1;
        }
    } else if (-1 === this._currentFrame)
      switch (this._repeatType) {
        case d2.None:
          this._currentFrame -= this._direction;
          break;
        case d2.Loop:
          this._currentFrame = this._animation.frameDurations.length - 1;
          break;
        case d2.Oscillate:
          this._currentFrame -= this._direction, this._direction = 1;
      }
    this.timeToFrame = this._animation.frameDurations[this._currentFrame];
    const t9 = this._animation.getFrame(this._currentFrame);
    this._onFrameData(t9);
  }
};
function u3(e11, u5, f4, l9) {
  let g6, { repeatType: F2 } = u5;
  if (null == F2 && (F2 = d2.Loop), true === u5.reverseAnimation && (e11 = s8(e11)), null != u5.duration && (e11 = o5(e11, n(1e3 * u5.duration))), null != u5.repeatDelay) {
    const i7 = 1e3 * u5.repeatDelay;
    F2 === d2.Loop ? e11 = h(e11, n(i7)) : F2 === d2.Oscillate && (e11 = m3(h(e11, n(i7 / 2)), n(i7 / 2)));
  }
  if (null != u5.startTimeOffset)
    g6 = n(1e3 * u5.startTimeOffset);
  else if (null != u5.randomizeStartTime) {
    const r11 = o2(f4), s9 = 82749913, o7 = null != u5.randomizeStartSeed ? u5.randomizeStartSeed : s9, m5 = e3(r11, o7);
    g6 = n(m5 * n11(e11));
  } else
    g6 = n(0);
  return new c7(e11, g6, F2, l9);
}
function f3(t9, e11, r11, i7) {
  const a10 = null == e11.playAnimation || e11.playAnimation, n15 = u3(t9, e11, r11, i7);
  let s9, o7 = n15.timeToFrame;
  function m5() {
    s9 = a10 ? setTimeout(() => {
      n15.nextFrame(), o7 = n15.timeToFrame, m5();
    }, o7) : void 0;
  }
  return m5(), { remove: () => {
    a10 && clearTimeout(s9);
  } };
}
var l5 = document.createElement("canvas");
var g4 = l5.getContext("2d");
function F(t9, r11, i7) {
  l5.width = r11, l5.height = i7;
  const a10 = [], n15 = t9.frameDurations.length;
  for (let s9 = 0; s9 < n15; s9++) {
    const n16 = t9.getFrame(s9);
    g4.clearRect(0, 0, r11, i7), n16 instanceof ImageData ? g4.drawImage(o3(n16), 0, 0, r11, i7) : g4.drawImage(n16, 0, 0, r11, i7), a10.push(g4.getImageData(0, 0, r11, i7));
  }
  return { width: r11, height: i7, frameDurations: t9.frameDurations, getFrame: (t10) => a10[t10] };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/AnimatableTextureResource.js
var i5 = class {
  constructor(t9, i7, e11, s9) {
    this._animation = t9, this._frameData = null;
    const h5 = (t10) => {
      this._frameData = t10, i7.requestRender();
    };
    this.frameCount = this._animation.frameDurations.length, this.width = this._animation.width, this.height = this._animation.height, this._playHandle = f3(this._animation, e11, s9, h5);
  }
  destroy() {
    this._playHandle.remove();
  }
  bindFrame(a10, i7, e11) {
    a10.bindTexture(i7, e11), null != this._frameData && (i7.updateData(0, ae, ae, this._frameData.width, this._frameData.height, this._frameData), this._frameData = null);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/symbolUtils.js
function e9(e11) {
  switch (e11.type) {
    case "esriSMS":
      return `${e11.style}.${e11.path}`;
    case "esriSLS":
      return `${e11.style}.${e11.cap}`;
    case "esriSFS":
      return `${e11.style}`;
    case "esriPFS":
    case "esriPMS":
      return e11.imageData ? `${e11.imageData}${e11.width}${e11.height}` : `${e11.url}${e11.width}${e11.height}`;
    default:
      return "mosaicHash" in e11 ? e11.mosaicHash : JSON.stringify(e11);
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureManager.js
var $ = n6();
var k = "arial-unicode-ms-regular";
var H = s2.getLogger("esri.views.2d.engine.webgl.TextureManager");
function O(e11, t9) {
  const i7 = Math.round(u(t9) * window.devicePixelRatio), s9 = i7 >= 128 ? 2 : 4;
  return Math.min(e11, i7 * s9);
}
var Q = (e11, t9, i7) => H.error(new s3(e11, t9, i7));
var V = class _V {
  static fromMosaic(e11, t9) {
    return new _V(e11, t9.page, t9.sdf);
  }
  constructor(e11, t9, i7) {
    this.mosaicType = e11, this.page = t9, this.sdf = i7;
  }
};
var Y2 = class {
  constructor(i7, r11, o7) {
    this._requestRender = i7, this.resourceManager = r11, this._allowNonPowerOfTwo = o7, this._invalidFontsMap = /* @__PURE__ */ new Map(), this._sdfConverter = new r4(ce), this._bindingInfos = new Array(), this._hashToBindingIndex = /* @__PURE__ */ new Map(), this._ongoingRasterizations = /* @__PURE__ */ new Map(), this._imageRequestQueue = new u2({ concurrency: 10, process: async (e11, i8) => {
      s4(i8);
      try {
        return await j(e11, { responseType: "image", signal: i8 });
      } catch (r12) {
        if (!d(r12))
          throw new s3("mapview-invalid-resource", `Could not fetch requested resource at ${e11}`, r12);
        throw r12;
      }
    } }), this._spriteMosaic = new n10(2048, 2048, 500), this._glyphSource = new r3(`${s.fontsUrl}/{fontstack}/{range}.pbf`), this._glyphMosaic = new p(1024, 1024, this._glyphSource), this._rasterizer = new c4(r11);
  }
  dispose() {
    this._spriteMosaic.dispose(), this._glyphMosaic.dispose(), this._rasterizer.dispose(), this._sdfConverter.dispose(), this._spriteMosaic = null, this._glyphMosaic = null, this._sdfConverter = null, this._hashToBindingIndex.clear(), this._hashToBindingIndex = null, this._bindingInfos = null, this._ongoingRasterizations.clear(), this._ongoingRasterizations = null, this._imageRequestQueue.clear(), this._imageRequestQueue = null;
  }
  get sprites() {
    return this._spriteMosaic;
  }
  get glyphs() {
    return this._glyphMosaic;
  }
  async rasterizeItem(e11, t9, i7, s9) {
    if (null == e11)
      return Q("mapview-null-resource", "Unable to rasterize null resource"), null;
    switch (e11.type) {
      case "text":
      case "esriTS": {
        const t10 = await this._rasterizeText(e11, i7, s9);
        return t10.forEach((e12) => this._setTextureBinding(_.GLYPH, e12)), { glyphMosaicItems: t10 };
      }
      default: {
        if (ue(e11))
          return Q("mapview-invalid-type", `MapView does not support symbol type: ${e11.type}`, e11), null;
        const i8 = await this._rasterizeSpriteSymbol(e11, t9, s9);
        return e4(i8) && i8 && this._setTextureBinding(_.SPRITE, i8), { spriteMosaicItem: i8 };
      }
    }
  }
  bindTextures(e11, t9, i7, s9 = false) {
    if (0 === i7.textureBinding)
      return;
    const r11 = this._bindingInfos[i7.textureBinding - 1], o7 = r11.page, n15 = s9 ? L.LINEAR_MIPMAP_LINEAR : L.LINEAR;
    switch (r11.mosaicType) {
      case _.SPRITE: {
        const i8 = this.sprites.getWidth(o7), s10 = this.sprites.getHeight(o7), r12 = r2($, i8, s10);
        return this._spriteMosaic.bind(e11, n15, o7, B), t9.setUniform1i("u_texture", B), void t9.setUniform2fv("u_mosaicSize", r12);
      }
      case _.GLYPH: {
        const i8 = this.glyphs.width, s10 = this.glyphs.height, r12 = r2($, i8, s10);
        return this._glyphMosaic.bind(e11, n15, o7, C), t9.setUniform1i("u_texture", C), void t9.setUniform2fv("u_mosaicSize", r12);
      }
      default:
        H.error("mapview-texture-manager", `Cannot handle unknown type ${r11.mosaicType}`);
    }
  }
  _hashMosaic(e11, t9) {
    return 1 | e11 << 1 | (t9.sdf ? 1 : 0) << 2 | t9.page << 3;
  }
  _setTextureBinding(e11, t9) {
    const i7 = this._hashMosaic(e11, t9);
    if (!this._hashToBindingIndex.has(i7)) {
      const s9 = V.fromMosaic(e11, t9), r11 = this._bindingInfos.length + 1;
      this._hashToBindingIndex.set(i7, r11), this._bindingInfos.push(s9);
    }
    t9.textureBinding = this._hashToBindingIndex.get(i7);
  }
  async _rasterizeText(e11, t9, s9) {
    let o7, n15;
    if ("cim" in e11) {
      const t10 = e11;
      o7 = t10.fontName, n15 = t10.text;
    } else {
      const t10 = e11;
      o7 = f2(t10.font), n15 = t10.text;
    }
    const a10 = this._invalidFontsMap.has(o7), h5 = t9 || pe(i3(n15)[0]);
    try {
      const e12 = a10 ? k : o7;
      return has("esri-2d-stabilize-glyphs") && await this._glyphMosaic.preloadASCIIGlyphCache(e12), await this._glyphMosaic.getGlyphItems(e12, h5, s9);
    } catch (c11) {
      return Q("mapview-invalid-resource", `Couldn't find font ${o7}. Falling back to Arial Unicode MS Regular`), this._invalidFontsMap.set(o7, true), this._glyphMosaic.getGlyphItems(k, h5, s9);
    }
  }
  async _rasterizeSpriteSymbol(e11, t9, i7) {
    if (le(e11))
      return;
    const r11 = e9(e11);
    if (this._spriteMosaic.has(r11))
      return this._spriteMosaic.getSpriteItem(r11);
    if (ne(e11) || re(e11) && !Ie(e11))
      return this._handleAsyncResource(r11, e11, i7);
    const o7 = Ae, n15 = this._rasterizer.rasterizeJSONResource(e11, o7);
    if (n15) {
      const { size: t10, image: i8, sdf: s9, simplePattern: o8, rasterizationScale: a10 } = n15;
      return this._addItemToMosaic(r11, t10, { type: "static", data: i8 }, fe(e11), s9, o8, a10);
    }
    return new s3("TextureManager", "unrecognized or null rasterized image");
  }
  async _handleAsyncResource(e11, t9, i7) {
    if (this._ongoingRasterizations.has(e11))
      return this._ongoingRasterizations.get(e11);
    let s9;
    s9 = ne(t9) ? this._handleSVG(t9, e11, i7) : this._handleImage(t9, e11, i7), this._ongoingRasterizations.set(e11, s9);
    try {
      await s9, this._ongoingRasterizations.delete(e11);
    } catch {
      this._ongoingRasterizations.delete(e11);
    }
    return s9;
  }
  async _handleSVG(e11, t9, i7) {
    const s9 = [ce, ce], r11 = await this._sdfConverter.draw(e11.path, i7);
    return this._addItemToMosaic(t9, s9, { type: "static", data: new Uint32Array(r11.buffer) }, false, true, true);
  }
  async _handleGIFOrPNG(e11, t9, i7) {
    const r11 = se(e11);
    await this.resourceManager.fetchResource(r11, i7);
    let o7 = this.resourceManager.getResource(r11);
    if (null == o7)
      return new s3("mapview-invalid-resource", `Could not fetch requested resource at ${r11}.`);
    let a10 = o7.width, h5 = o7.height;
    if (o7 instanceof HTMLImageElement) {
      "esriPMS" === e11.type && (a10 = Math.round(O(o7.width, de(e11))), h5 = Math.round(o7.height * (a10 / o7.width)));
      const i8 = "cim" in e11 ? e11.cim.colorSubstitutions : void 0, { size: s9, sdf: r12, image: n15 } = this._rasterizer.rasterizeImageResource(a10, h5, o7, i8);
      return this._addItemToMosaic(t9, s9, { type: "static", data: n15 }, fe(e11), r12, false);
    }
    this._allowNonPowerOfTwo || (a10 = c2(o7.width + 2 * ae) - 2 * ae, h5 = c2(o7.height + 2 * ae) - 2 * ae), a10 === o7.width && h5 === o7.height || (o7 = F(o7, a10, h5));
    const c11 = e11.animatedSymbolProperties || {}, u5 = e11.objectId, d9 = new i5(o7, this._requestRender, c11, u5);
    return this._addItemToMosaic(t9, [d9.width, d9.height], { type: "animated", data: d9 }, fe(e11), false, false);
  }
  async _handleImage(e11, t9, i7) {
    if (ie(e11) || oe(e11))
      return this._handleGIFOrPNG(e11, t9, i7);
    const r11 = se(e11);
    try {
      let s9;
      const o7 = this.resourceManager.getResource(r11);
      if (null != o7 && o7 instanceof HTMLImageElement)
        s9 = o7;
      else {
        const { data: e12 } = await this._imageRequestQueue.push(r11, { ...i7 });
        s9 = e12;
      }
      if (me(r11)) {
        if ("width" in e11 && "height" in e11)
          s9.width = u(e11.width), s9.height = u(e11.height);
        else if ("cim" in e11) {
          const t10 = e11.cim;
          s9.width = u(t10.width ?? t10.scaleX * t10.size), s9.height = u(t10.size);
        }
      }
      if (!s9.width || !s9.height)
        return null;
      let n15 = s9.width, a10 = s9.height;
      "esriPMS" === e11.type && (n15 = Math.round(O(s9.width, de(e11))), a10 = Math.round(s9.height * (n15 / s9.width)));
      const h5 = "cim" in e11 ? e11.cim.colorSubstitutions : void 0, { size: u5, sdf: d9, image: l9 } = this._rasterizer.rasterizeImageResource(n15, a10, s9, h5);
      return this._addItemToMosaic(t9, u5, { type: "static", data: l9 }, fe(e11), d9, false);
    } catch (Q2) {
      if (!d(Q2))
        return new s3("mapview-invalid-resource", `Could not fetch requested resource at ${r11}. ${Q2.message}`);
    }
  }
  _addItemToMosaic(e11, t9, i7, s9, r11, o7, n15) {
    return this._spriteMosaic.addSpriteItem(e11, t9, i7, s9, r11, o7, n15);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/StencilPrograms.js
var r5 = { shaders: { vertexShader: n8("stencil/stencil.vert"), fragmentShader: n8("stencil/stencil.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BlendPrograms.js
var r6 = (e11) => e11.replace("-", "_").toUpperCase();
var t6 = (e11) => `#define ${r6(e11)}
`;
function n12(r11) {
  return { attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_tex", 1]]), shaders: { vertexShader: t6(r11) + n8("blend/blend.vert"), fragmentShader: t6(r11) + n8("blend/blend.frag") } };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/BlendEffect.js
var c8 = s2.getLogger("esri.views.2d.engine.webgl.effects.blendEffects.BlendEffect");
var m4 = class {
  constructor() {
    this._size = [0, 0];
  }
  dispose(e11) {
    this._backBufferTexture = t(this._backBufferTexture), this._quad = t(this._quad);
  }
  draw(r11, t9, i7, a10, d9) {
    const { context: u5, drawPhase: f4 } = r11;
    if (this._setupShader(u5), a10 && "normal" !== a10 && f4 !== T.LABEL)
      return void this._drawBlended(r11, t9, i7, a10, d9);
    const m5 = n12("normal"), h5 = u5.programCache.acquire(m5.shaders.vertexShader, m5.shaders.fragmentShader, m5.attributes);
    if (!h5)
      return void c8.error(new s3("mapview-BlendEffect", 'Error creating shader program for blend mode "normal"'));
    u5.useProgram(h5), t9.setSamplingMode(i7), u5.bindTexture(t9, 0), h5.setUniform1i("u_layerTexture", 0), h5.setUniform1f("u_opacity", d9), u5.setBlendingEnabled(true), u5.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA);
    const l9 = this._quad;
    l9.draw(), l9.unbind(), h5.dispose();
  }
  _drawBlended(r11, t9, s9, i7, a10) {
    const { context: d9, state: u5, pixelRatio: f4, inFadeTransition: m5 } = r11, { size: h5 } = u5, l9 = d9.getBoundFramebufferObject();
    let _6, p3;
    null != l9 ? (_6 = l9.width, p3 = l9.height) : (_6 = Math.round(f4 * h5[0]), p3 = Math.round(f4 * h5[1])), this._createOrResizeTexture(r11, _6, p3);
    const b = this._backBufferTexture;
    l9.copyToTexture(0, 0, _6, p3, 0, 0, b), d9.setStencilTestEnabled(false), d9.setStencilWriteMask(0), d9.setBlendingEnabled(true), d9.setDepthTestEnabled(false), d9.setDepthWriteEnabled(false);
    const g6 = n12(i7), x2 = d9.programCache.acquire(g6.shaders.vertexShader, g6.shaders.fragmentShader, g6.attributes);
    if (!x2)
      return void c8.error(new s3("mapview-BlendEffect", `Error creating shader program for blend mode ${i7}`));
    d9.useProgram(x2), b.setSamplingMode(s9), d9.bindTexture(b, 0), x2.setUniform1i("u_backbufferTexture", 0), t9.setSamplingMode(s9), d9.bindTexture(t9, 1), x2.setUniform1i("u_layerTexture", 1), x2.setUniform1f("u_opacity", a10), x2.setUniform1f("u_inFadeOpacity", m5 ? 1 : 0), d9.setBlendFunction(R.ONE, R.ZERO);
    const T5 = this._quad;
    T5.draw(), T5.unbind(), x2.dispose(), d9.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA);
  }
  _setupShader(e11) {
    this._quad || (this._quad = new n7(e11, [-1, -1, 1, -1, -1, 1, 1, 1]));
  }
  _createOrResizeTexture(e11, r11, t9) {
    const { context: s9 } = e11;
    if (null === this._backBufferTexture || r11 !== this._size[0] || t9 !== this._size[1]) {
      if (this._backBufferTexture)
        this._backBufferTexture.resize(r11, t9);
      else {
        const e12 = new e5();
        e12.internalFormat = G.RGBA, e12.wrapMode = D.CLAMP_TO_EDGE, e12.width = r11, e12.height = t9, this._backBufferTexture = new T2(s9, e12);
      }
      this._size[0] = r11, this._size[1] = t9;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/HighlightPrograms.js
var t7 = { shaders: { vertexShader: n8("highlight/textured.vert"), fragmentShader: n8("highlight/highlight.frag") }, attributes: /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]) };
var r7 = { shaders: { vertexShader: n8("highlight/textured.vert"), fragmentShader: n8("highlight/blur.frag") }, attributes: /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/Profiler.js
var r8 = has("esri-2d-profiler");
var n13 = class {
  constructor(n15, i7) {
    if (this._events = new n3(), this._entries = /* @__PURE__ */ new Map(), this._timings = new t3(10), this._currentContainer = null, this._currentPass = null, this._currentBrush = null, this._currentSummary = null, !r8)
      return;
    this._ext = T3(n15.gl, {}), this._debugOutput = i7;
    const o7 = n15.gl;
    if (!this.enableCommandLogging)
      return;
    let a10;
    for (a10 in o7)
      if ("function" == typeof o7[a10]) {
        const e11 = o7[a10], t9 = a10.includes("draw");
        o7[a10] = (...s9) => (this._events.emit("command", { container: this._currentContainer, pass: this._currentPass, brush: this._currentBrush, method: a10, args: s9, isDrawCommand: t9 }), this._currentSummary && (this._currentSummary.commands++, t9 && this._currentSummary.drawCommands++), e11.apply(o7, s9));
      }
  }
  get enableCommandLogging() {
    return !("object" == typeof r8 && r8.disableCommands);
  }
  recordContainerStart(e11) {
    r8 && (this._currentContainer = e11);
  }
  recordContainerEnd() {
    r8 && (this._currentContainer = null);
  }
  recordPassStart(e11) {
    r8 && (this._currentPass = e11, this._initSummary());
  }
  recordPassEnd() {
    r8 && (this._currentPass = null, this._emitSummary());
  }
  recordBrushStart(e11) {
    r8 && (this._currentBrush = e11);
  }
  recordBrushEnd() {
    r8 && (this._currentBrush = null);
  }
  recordStart(e11) {
    if (r8 && null != this._ext) {
      if (this._entries.has(e11)) {
        const t10 = this._entries.get(e11), s9 = this._ext.resultAvailable(t10.query), r11 = this._ext.disjoint();
        if (s9 && !r11) {
          const s10 = this._ext.getResult(t10.query) / 1e6;
          let r12 = 0;
          if (null != this._timings.enqueue(s10)) {
            const e12 = this._timings.entries, t11 = e12.length;
            let s11 = 0;
            for (const r13 of e12)
              s11 += r13;
            r12 = s11 / t11;
          }
          const n15 = s10.toFixed(2), i7 = r12 ? r12.toFixed(2) : "--";
          this.enableCommandLogging ? (console.groupCollapsed(`Frame report for ${e11}, ${n15} ms (${i7} last 10 avg)
${t10.commandsLen} Commands (${t10.drawCommands} draw)`), console.log("RenderPass breakdown: "), console.table(t10.summaries), console.log("Commands: ", t10.commands), console.groupEnd()) : console.log(`Frame report for ${e11}, ${n15} ms (${i7} last 10 avg)`), this._debugOutput.innerHTML = `${n15} (${i7})`;
        }
        for (const e12 of t10.handles)
          e12.remove();
        this._ext.deleteQuery(t10.query), this._entries.delete(e11);
      }
      const t9 = { name: e11, query: this._ext.createQuery(), commands: [], commandsLen: 0, drawCommands: 0, summaries: [], handles: [] };
      this.enableCommandLogging && (t9.handles.push(this._events.on("command", (e12) => {
        t9.commandsLen++, t9.commands.push(e12), e12.isDrawCommand && t9.drawCommands++;
      })), t9.handles.push(this._events.on("summary", (e12) => {
        t9.summaries.push(e12);
      }))), this._ext.beginTimeElapsed(t9.query), this._entries.set(e11, t9);
    }
  }
  recordEnd(e11) {
    r8 && null != this._ext && this._entries.has(e11) && this._ext.endTimeElapsed();
  }
  _initSummary() {
    this.enableCommandLogging && (this._currentSummary = { container: this._currentContainer, pass: this._currentPass, drawCommands: 0, commands: 0 });
  }
  _emitSummary() {
    this.enableCommandLogging && this._currentSummary && this._events.emit("summary", this._currentSummary);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/CollisionGrid.js
var e10 = 2;
var i6 = 1;
var o6 = 0;
var h2 = 1;
var r9 = 2;
var l6 = class {
  constructor(t9, e11, o7) {
    this._debugMap = /* @__PURE__ */ new Map(), this._width = t9 * o7, this._height = e11 * o7, this._pixelRatio = o7;
    const h5 = Math.ceil(this._width / i6), r11 = Math.ceil(this._height / i6);
    this._cols = h5, this._rows = r11, this._cells = t4.create(h5 * r11);
  }
  insertMetrics(t9) {
    const s9 = this._hasCollision(t9);
    return s9 === o6 && this._markMetrics(t9), s9;
  }
  getCellId(t9, s9) {
    return t9 + s9 * this._cols;
  }
  has(t9) {
    return this._cells.has(t9);
  }
  hasRange(t9, s9) {
    return this._cells.hasRange(t9, s9);
  }
  set(t9) {
    this._cells.set(t9);
  }
  setRange(t9, s9) {
    this._cells.setRange(t9, s9);
  }
  _collide(s9, e11, l9, n15) {
    const c11 = s9 - l9 / 2, a10 = e11 - n15 / 2, _6 = c11 + l9, d9 = a10 + n15;
    if (_6 < 0 || d9 < 0 || c11 > this._width || a10 > this._height)
      return h2;
    const u5 = i(Math.floor(c11 / i6), 0, this._cols), p3 = i(Math.floor(a10 / i6), 0, this._rows), M = i(Math.ceil(_6 / i6), 0, this._cols), f4 = i(Math.ceil(d9 / i6), 0, this._rows);
    for (let t9 = p3; t9 <= f4; t9++)
      for (let s10 = u5; s10 <= M; s10++) {
        const e12 = this.getCellId(s10, t9);
        if (this.has(e12))
          return r9;
      }
    return o6;
  }
  _mark(s9, e11, o7, h5, r11) {
    const l9 = s9 - o7 / 2, n15 = e11 - h5 / 2, c11 = l9 + o7, a10 = n15 + h5, _6 = i(Math.floor(l9 / i6), 0, this._cols), d9 = i(Math.floor(n15 / i6), 0, this._rows), u5 = i(Math.ceil(c11 / i6), 0, this._cols), p3 = i(Math.ceil(a10 / i6), 0, this._rows);
    for (let t9 = d9; t9 <= p3; t9++)
      for (let s10 = _6; s10 <= u5; s10++) {
        const e12 = this.getCellId(s10, t9);
        this._debugMap.set(e12, r11), this.set(e12);
      }
    return false;
  }
  _hasCollision(t9) {
    const s9 = t9.id;
    let i7 = 0, l9 = 0;
    t9.save();
    do {
      const s10 = t9.boundsCount;
      i7 += s10;
      for (let i8 = 0; i8 < s10; i8++) {
        const s11 = t9.boundsComputedAnchorX(i8), o7 = t9.boundsComputedAnchorY(i8), n15 = (t9.boundsWidth(i8) + e10) * this._pixelRatio, c11 = (t9.boundsHeight(i8) + e10) * this._pixelRatio;
        switch (this._collide(s11, o7, n15, c11)) {
          case r9:
            return r9;
          case h2:
            l9++;
        }
      }
    } while (t9.peekId() === s9 && t9.next());
    return t9.restore(), i7 === l9 ? h2 : o6;
  }
  _markMetrics(t9) {
    const s9 = t9.id;
    t9.save();
    do {
      const s10 = t9.boundsCount;
      for (let i7 = 0; i7 < s10; i7++) {
        const s11 = t9.boundsComputedAnchorX(i7), o7 = t9.boundsComputedAnchorY(i7), h5 = (t9.boundsWidth(i7) + e10) * this._pixelRatio, r11 = (t9.boundsHeight(i7) + e10) * this._pixelRatio;
        this._mark(s11, o7, h5, r11, t9.id);
      }
    } while (t9.peekId() === s9 && t9.next());
    t9.restore();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/CollisionEngine.js
var r10 = 254;
var l7 = 255;
var a6 = 0;
function d3(e11, i7) {
  const t9 = [];
  e11.forEachTile((e12) => t9.push(e12)), t9.sort((e12, i8) => e12.instanceId - i8.instanceId), t9.forEach((e12) => {
    null != e12.labelMetrics && e12.isReady && i7(e12, e12.labelMetrics.getCursor());
  });
}
var c9 = class {
  run(e11, i7, t9) {
    const o7 = [];
    for (let s9 = e11.length - 1; s9 >= 0; s9--) {
      const i8 = e11[s9];
      i8.labelingCollisionInfos && o7.push(...i8.labelingCollisionInfos);
    }
    this._transformMetrics(o7), this._runCollision(o7, i7, t9);
  }
  _runCollision(e11, i7, o7) {
    const [s9, n15] = i7.state.size, r11 = new l6(s9, n15, i7.pixelRatio);
    for (const { tileRenderer: t9, deconflictionEnabled: c11, visible: f4 } of e11) {
      const e12 = t9.featuresView.attributeView;
      c11 ? f4 ? (this._prepare(t9), this._collideVisible(r11, t9, o7), this._collideInvisible(r11, t9)) : d3(t9, (i8, t10) => {
        for (; t10.nextId(); )
          e12.setLabelMinZoom(t10.id, l7);
      }) : d3(t9, (i8, t10) => {
        for (; t10.nextId(); )
          e12.setLabelMinZoom(t10.id, a6), f4 && r11.insertMetrics(t10);
      });
    }
  }
  _isFiltered(t9, o7, s9) {
    const n15 = o7.getFilterFlags(t9), r11 = !s9.hasFilter || !!(n15 & X), l9 = null == s9.featureEffect || s9.featureEffect.excludedLabelsVisible || !!(n15 & Y);
    return !(r11 && l9);
  }
  _prepare(e11) {
    const i7 = e11.featuresView.attributeView, t9 = /* @__PURE__ */ new Set();
    d3(e11, (o7, s9) => {
      for (; s9.nextId(); ) {
        if (t9.has(s9.id))
          continue;
        if (t9.add(s9.id), this._isFiltered(s9.id, i7, e11.layerView)) {
          i7.setLabelMinZoom(s9.id, r10);
          continue;
        }
        i7.getLabelMinZoom(s9.id) !== a6 ? i7.setLabelMinZoom(s9.id, l7) : i7.setLabelMinZoom(s9.id, a6);
      }
    });
  }
  _collideVisible(e11, i7, t9) {
    const l9 = i7.featuresView.attributeView, c11 = /* @__PURE__ */ new Set();
    d3(i7, (i8, d9) => {
      for (; d9.nextId(); )
        if (!c11.has(d9.id))
          if (i8.key.level === t9) {
            if (0 === l9.getLabelMinZoom(d9.id)) {
              switch (e11.insertMetrics(d9)) {
                case h2:
                  break;
                case r9:
                  l9.setLabelMinZoom(d9.id, r10), c11.add(d9.id);
                  break;
                case o6:
                  l9.setLabelMinZoom(d9.id, a6), c11.add(d9.id);
              }
            }
          } else
            l9.setLabelMinZoom(d9.id, r10);
    });
  }
  _collideInvisible(e11, i7) {
    const t9 = i7.featuresView.attributeView, r11 = /* @__PURE__ */ new Set();
    d3(i7, (i8, d9) => {
      for (; d9.nextId(); )
        if (!r11.has(d9.id) && t9.getLabelMinZoom(d9.id) === l7) {
          switch (e11.insertMetrics(d9)) {
            case h2:
              break;
            case r9:
              t9.setLabelMinZoom(d9.id, l7), r11.add(d9.id);
              break;
            case o6:
              t9.setLabelMinZoom(d9.id, a6), r11.add(d9.id);
          }
        }
    });
  }
  _transformMetrics(e11) {
    for (const { tileRenderer: i7, geometryType: t9, vvEvaluators: o7 } of e11)
      d3(i7, (e12, s9) => {
        const n15 = i7.featuresView.attributeView, r11 = e12.transforms.labelMat2d;
        r11[4] = Math.round(r11[4]), r11[5] = Math.round(r11[5]);
        const l9 = "polyline" === t9;
        for (; s9.next(); ) {
          const e13 = s9.boundsCount, i8 = s9.anchorX, t10 = s9.anchorY;
          let a10 = s9.size;
          const d9 = o7[0];
          if (null != d9) {
            const e14 = d9(n15.getVVSize(s9.id));
            a10 = isNaN(e14) || null == e14 || e14 === 1 / 0 ? a10 : e14;
          }
          const c11 = s9.directionX * (a10 / 2), f4 = s9.directionY * (a10 / 2);
          for (let o8 = 0; o8 < e13; o8++) {
            let e14 = i8, n16 = s9.anchorY;
            if (l9) {
              let i9 = e14 + s9.boundsX(o8) + c11, t11 = n16 + s9.boundsY(o8) + f4;
              i9 = r11[0] * i9 + r11[2] * t11 + r11[4], t11 = r11[1] * i9 + r11[3] * t11 + r11[5], s9.setBoundsComputedAnchorX(o8, Math.floor(i9)), s9.setBoundsComputedAnchorY(o8, Math.floor(t11));
            } else {
              e14 = r11[0] * i8 + r11[2] * t10 + r11[4], n16 = r11[1] * i8 + r11[3] * t10 + r11[5];
              const l10 = e14 + s9.boundsX(o8) + c11, a11 = n16 + s9.boundsY(o8) + f4;
              s9.setBoundsComputedAnchorX(o8, l10), s9.setBoundsComputedAnchorY(o8, a11);
            }
          }
        }
      });
  }
};

// node_modules/@arcgis/core/views/2d/LabelManager.js
var a7 = 32;
var d4 = class extends a2(m2) {
  constructor(e11) {
    super(e11), this.collisionEngine = new c9(), this.lastUpdateId = -1, this.updateRequested = false, this.view = null, this._applyVisibilityPass = e6((e12) => {
      const t9 = this.view;
      if (t9)
        try {
          const s9 = t9.featuresTilingScheme.getClosestInfoForScale(e12.state.scale).level;
          this.collisionEngine.run(t9.allLayerViews.items, e12, s9);
        } catch (s9) {
        }
    }, a7, this), this.addHandles(this._applyVisibilityPass);
  }
  get updating() {
    return has("esri-2d-log-updating") && console.log(`Updating LabelManager ${this.updateRequested}:
-> updateRequested: ${this.updateRequested}`), this.updateRequested;
  }
  update(e11) {
    this._applyVisibilityPass(e11);
  }
  viewChange() {
    this.requestUpdate();
  }
  requestUpdate() {
    var _a;
    this.updateRequested || (this.updateRequested = true, (_a = this.view) == null ? void 0 : _a.requestUpdate());
  }
  processUpdate(e11) {
    this.updateRequested && (this.updateRequested = false, this.update(e11));
  }
};
e([y()], d4.prototype, "updateRequested", void 0), e([y()], d4.prototype, "updating", null), e([y()], d4.prototype, "view", void 0), d4 = e([a("esri.views.2d.LabelManager")], d4);

// node_modules/@arcgis/core/views/2d/navigation/ZoomBox.js
var a8 = "esri-zoom-box";
var n14 = { container: `${a8}__container`, overlay: `${a8}__overlay`, background: `${a8}__overlay-background`, box: `${a8}__outline` };
var h3 = { zoom: "Shift", counter: "Ctrl" };
var l8 = class extends m2 {
  constructor(t9) {
    super(t9), this._container = null, this._overlay = null, this._backgroundShape = null, this._boxShape = null, this._box = { x: 0, y: 0, width: 0, height: 0 }, this._rafId = null, this._handles = null, this._redraw = this._redraw.bind(this);
  }
  destroy() {
    this.view = null;
  }
  set view(t9) {
    this._handles && this._handles.forEach((t10) => {
      t10.remove();
    }), this._handles = null, this._destroyOverlay(), this._set("view", t9), t9 && (t9.on("drag", [h3.zoom], (t10) => this._handleDrag(t10, 1), _2.INTERNAL), t9.on("drag", [h3.zoom, h3.counter], (t10) => this._handleDrag(t10, -1), _2.INTERNAL));
  }
  _start() {
    this._createContainer(), this._createOverlay(), this.navigation.begin();
  }
  _update(t9, e11, i7, r11) {
    this._box.x = t9, this._box.y = e11, this._box.width = i7, this._box.height = r11, this._rafId || (this._rafId = requestAnimationFrame(this._redraw));
  }
  _end(t9, e11, r11, s9, o7) {
    const a10 = this.view, n15 = a10.toMap(c3(t9 + 0.5 * r11, e11 + 0.5 * s9));
    let h5 = Math.max(r11 / a10.width, s9 / a10.height);
    -1 === o7 && (h5 = 1 / h5), this._destroyOverlay(), this.navigation.end(), a10.goTo({ center: n15, scale: a10.scale * h5 });
  }
  _updateBox(t9, e11, i7, r11) {
    const s9 = this._boxShape;
    s9.setAttributeNS(null, "x", "" + t9), s9.setAttributeNS(null, "y", "" + e11), s9.setAttributeNS(null, "width", "" + i7), s9.setAttributeNS(null, "height", "" + r11), s9.setAttributeNS(null, "class", n14.box);
  }
  _updateBackground(t9, e11, i7, r11) {
    this._backgroundShape.setAttributeNS(null, "d", this._toSVGPath(t9, e11, i7, r11, this.view.width, this.view.height));
  }
  _createContainer() {
    const t9 = document.createElement("div");
    t9.className = n14.container, this.view.root.appendChild(t9), this._container = t9;
  }
  _createOverlay() {
    const t9 = this.view.width, e11 = this.view.height, i7 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    i7.setAttributeNS(null, "d", "M 0 0 L " + t9 + " 0 L " + t9 + " " + e11 + " L 0 " + e11 + " Z"), i7.setAttributeNS(null, "class", n14.background);
    const r11 = document.createElementNS("http://www.w3.org/2000/svg", "rect"), s9 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    s9.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink"), s9.setAttributeNS(null, "class", n14.overlay), s9.appendChild(i7), s9.appendChild(r11), this._container.appendChild(s9), this._backgroundShape = i7, this._boxShape = r11, this._overlay = s9;
  }
  _destroyOverlay() {
    this._container && this._container.parentNode && this._container.parentNode.removeChild(this._container), this._container = this._backgroundShape = this._boxShape = this._overlay = null;
  }
  _toSVGPath(t9, e11, i7, r11, s9, o7) {
    const a10 = t9 + i7, n15 = e11 + r11;
    return "M 0 0 L " + s9 + " 0 L " + s9 + " " + o7 + " L 0 " + o7 + " ZM " + t9 + " " + e11 + " L " + t9 + " " + n15 + " L " + a10 + " " + n15 + " L " + a10 + " " + e11 + " Z";
  }
  _handleDrag(t9, e11) {
    const i7 = t9.x, r11 = t9.y, s9 = t9.origin.x, o7 = t9.origin.y;
    let a10, n15, h5, l9;
    switch (i7 > s9 ? (a10 = s9, h5 = i7 - s9) : (a10 = i7, h5 = s9 - i7), r11 > o7 ? (n15 = o7, l9 = r11 - o7) : (n15 = r11, l9 = o7 - r11), t9.action) {
      case "start":
        this._start();
        break;
      case "update":
        this._update(a10, n15, h5, l9);
        break;
      case "end":
        this._end(a10, n15, h5, l9, e11);
    }
    t9.stopPropagation();
  }
  _redraw() {
    if (!this._rafId)
      return;
    if (this._rafId = null, !this._overlay)
      return;
    const { x: t9, y: e11, width: i7, height: r11 } = this._box;
    this._updateBox(t9, e11, i7, r11), this._updateBackground(t9, e11, i7, r11), this._rafId = requestAnimationFrame(this._redraw);
  }
};
e([y()], l8.prototype, "navigation", void 0), e([y()], l8.prototype, "view", null), l8 = e([a("esri.views.2d.navigation.ZoomBox")], l8);
var c10 = l8;

// node_modules/@arcgis/core/views/2d/navigation/actions/Pan.js
var v = class extends m2 {
  constructor(t9) {
    super(t9), this.animationTime = 0, this.momentumEstimator = new l3(500, 6, 0.92), this.momentum = null, this.tmpMomentum = n2(), this.momentumFinished = false, this.viewpoint = new l2({ targetGeometry: new x(), scale: 0, rotation: 0 }), this._previousDrag = null, f(() => this.momentumFinished, () => this.navigation.stop());
  }
  begin(t9, i7) {
    this.navigation.begin(), this.momentumEstimator.reset(), this.addToEstimator(i7), this._previousDrag = i7;
  }
  update(t9, i7) {
    this.addToEstimator(i7);
    let o7 = i7.center.x, s9 = i7.center.y;
    const e11 = this._previousDrag;
    o7 = e11 ? e11.center.x - o7 : -o7, s9 = e11 ? s9 - e11.center.y : s9, t9.viewpoint = Rt(this.viewpoint, t9.viewpoint, [o7 || 0, s9 || 0]), this._previousDrag = i7;
  }
  end(t9, i7) {
    this.addToEstimator(i7);
    const o7 = t9.navigation.momentumEnabled;
    this.momentum = o7 ? this.momentumEstimator.evaluateMomentum() : null, this.animationTime = 0, this.momentum && this.onAnimationUpdate(t9), this._previousDrag = null, this.navigation.end();
  }
  addToEstimator(t9) {
    const i7 = t9.center.x, o7 = t9.center.y, s9 = i2(-i7, o7), m5 = r(-i7, o7, 0);
    this.momentumEstimator.add(s9, m5, 1e-3 * t9.timestamp);
  }
  onAnimationUpdate(t9) {
    var _a;
    (_a = this.navigation.animationManager) == null ? void 0 : _a.animateContinous(t9.viewpoint, (i7, o7) => {
      const { momentum: s9, animationTime: e11, tmpMomentum: m5 } = this, n15 = 1e-3 * o7;
      if (!(this.momentumFinished = !s9 || s9.isFinished(e11))) {
        const o8 = s9.valueDelta(e11, n15);
        g(m5, s9.direction, o8), Rt(i7, i7, m5), t9.constraints.constrainByGeometry(i7);
      }
      this.animationTime += n15;
    });
  }
  stopMomentumNavigation() {
    this.momentum && (this.momentumEstimator.reset(), this.momentum = null, this.navigation.stop());
  }
};
e([y()], v.prototype, "momentumFinished", void 0), e([y()], v.prototype, "viewpoint", void 0), e([y()], v.prototype, "navigation", void 0), v = e([a("esri.views.2d.navigation.actions.Pan")], v);
var d5 = v;

// node_modules/@arcgis/core/views/2d/navigation/actions/Pinch.js
var _4 = class extends m2 {
  constructor(t9) {
    super(t9), this._animationTime = 0, this._momentumFinished = false, this._previousAngle = 0, this._previousRadius = 0, this._previousCenter = null, this._rotationMomentumEstimator = new a4(0.6, 0.15, 0.95), this._rotationDirection = 1, this._startAngle = 0, this._startRadius = 0, this._updateTimestamp = null, this._zoomDirection = 1, this._zoomMomentumEstimator = new s6(), this._zoomOnly = null, this.zoomMomentum = null, this.rotateMomentum = null, this.viewpoint = new l2({ targetGeometry: new x(), scale: 0, rotation: 0 }), this.addHandles(f(() => this._momentumFinished, () => this.navigation.stop()));
  }
  begin(t9, o7) {
    this.navigation.begin(), this._rotationMomentumEstimator.reset(), this._zoomMomentumEstimator.reset(), this._zoomOnly = null, this._previousAngle = this._startAngle = o7.angle, this._previousRadius = this._startRadius = o7.radius, this._previousCenter = o7.center, this._updateTimestamp = null, t9.constraints.rotationEnabled && this.addToRotateEstimator(0, o7.timestamp), this.addToZoomEstimator(o7, 1);
  }
  update(t9, o7) {
    null === this._updateTimestamp && (this._updateTimestamp = o7.timestamp);
    const i7 = o7.angle, s9 = o7.radius, e11 = o7.center, n15 = Math.abs(180 * (i7 - this._startAngle) / Math.PI), m5 = Math.abs(s9 - this._startRadius), a10 = this._startRadius / s9;
    if (this._previousRadius && this._previousCenter) {
      const r11 = s9 / this._previousRadius;
      let h5 = 180 * (i7 - this._previousAngle) / Math.PI;
      this._rotationDirection = h5 >= 0 ? 1 : -1, this._zoomDirection = r11 >= 1 ? 1 : -1, t9.constraints.rotationEnabled ? (null === this._zoomOnly && o7.timestamp - this._updateTimestamp > 200 && (this._zoomOnly = m5 - n15 > 0), null === this._zoomOnly || this._zoomOnly ? h5 = 0 : this.addToRotateEstimator(i7 - this._startAngle, o7.timestamp)) : h5 = 0, this.addToZoomEstimator(o7, a10), this.navigation.setViewpoint([e11.x, e11.y], 1 / r11, h5, [this._previousCenter.x - e11.x, e11.y - this._previousCenter.y]);
    }
    this._previousAngle = i7, this._previousRadius = s9, this._previousCenter = e11;
  }
  end(t9) {
    this.rotateMomentum = this._rotationMomentumEstimator.evaluateMomentum(), this.zoomMomentum = this._zoomMomentumEstimator.evaluateMomentum(), this._animationTime = 0, (this.rotateMomentum || this.zoomMomentum) && this.onAnimationUpdate(t9), this.navigation.end();
  }
  addToRotateEstimator(t9, o7) {
    this._rotationMomentumEstimator.add(t9, 1e-3 * o7);
  }
  addToZoomEstimator(t9, o7) {
    this._zoomMomentumEstimator.add(o7, 1e-3 * t9.timestamp);
  }
  canZoomIn(t9) {
    const o7 = t9.scale, i7 = t9.constraints.effectiveMaxScale;
    return 0 === i7 || o7 > i7;
  }
  canZoomOut(t9) {
    const o7 = t9.scale, i7 = t9.constraints.effectiveMinScale;
    return 0 === i7 || o7 < i7;
  }
  onAnimationUpdate(t9) {
    var _a;
    (_a = this.navigation.animationManager) == null ? void 0 : _a.animateContinous(t9.viewpoint, (o7, i7) => {
      const s9 = !this.canZoomIn(t9) && this._zoomDirection > 1 || !this.canZoomOut(t9) && this._zoomDirection < 1, e11 = !this.rotateMomentum || this.rotateMomentum.isFinished(this._animationTime), n15 = s9 || !this.zoomMomentum || this.zoomMomentum.isFinished(this._animationTime), p3 = 1e-3 * i7;
      if (this._momentumFinished = e11 && n15, !this._momentumFinished) {
        const i8 = this.rotateMomentum ? Math.abs(this.rotateMomentum.valueDelta(this._animationTime, p3)) * this._rotationDirection * 180 / Math.PI : 0;
        let s10 = this.zoomMomentum ? Math.abs(this.zoomMomentum.valueDelta(this._animationTime, p3)) : 1;
        const e12 = n4(), n16 = n4();
        if (this._previousCenter) {
          r2(e12, this._previousCenter.x, this._previousCenter.y), _3(n16, t9.size, t9.padding), s5(e12, e12, n16);
          const { constraints: r11, scale: p4 } = t9, l9 = p4 * s10;
          s10 < 1 && !r11.canZoomInTo(l9) ? (s10 = p4 / r11.effectiveMaxScale, this.zoomMomentum = null, this.rotateMomentum = null) : s10 > 1 && !r11.canZoomOutTo(l9) && (s10 = p4 / r11.effectiveMinScale, this.zoomMomentum = null, this.rotateMomentum = null), wt(o7, t9.viewpoint, s10, i8, e12, t9.size), t9.constraints.constrainByGeometry(o7);
        }
      }
      this._animationTime += p3;
    });
  }
  stopMomentumNavigation() {
    (this.rotateMomentum || this.zoomMomentum) && (this.rotateMomentum && (this._rotationMomentumEstimator.reset(), this.rotateMomentum = null), this.zoomMomentum && (this._zoomMomentumEstimator.reset(), this.zoomMomentum = null), this.navigation.stop());
  }
};
e([y()], _4.prototype, "_momentumFinished", void 0), e([y()], _4.prototype, "viewpoint", void 0), e([y()], _4.prototype, "navigation", void 0), _4 = e([a("esri.views.2d.navigation.actions.Pinch")], _4);
var d6 = _4;

// node_modules/@arcgis/core/views/2d/navigation/actions/Rotate.js
var u4 = n4();
var d7 = n4();
var j2 = class extends m2 {
  constructor(t9) {
    super(t9), this._previousCenter = n4(), this.viewpoint = new l2({ targetGeometry: new x(), scale: 0, rotation: 0 });
  }
  begin(t9, e11) {
    this.navigation.begin(), r2(this._previousCenter, e11.center.x, e11.center.y);
  }
  update(t9, e11) {
    const { state: { size: o7, padding: r11 } } = t9;
    r2(u4, e11.center.x, e11.center.y), X2(d7, o7, r11), t9.viewpoint = gt(this.viewpoint, t9.state.paddedViewState.viewpoint, lt(d7, this._previousCenter, u4)), a3(this._previousCenter, u4);
  }
  end() {
    this.navigation.end();
  }
};
e([y()], j2.prototype, "viewpoint", void 0), e([y()], j2.prototype, "navigation", void 0), j2 = e([a("esri.views.2d.actions.Rotate")], j2);
var h4 = j2;

// node_modules/@arcgis/core/views/2d/navigation/MapViewNavigation.js
var v2 = 10;
var w2 = 1;
var g5 = new l2({ targetGeometry: new x() });
var _5 = [0, 0];
var d8 = 250;
var T4 = class extends m2 {
  constructor(t9) {
    super(t9), this._endTimer = null, this._lastEventTimestamp = null, this.animationManager = null, this.interacting = false;
  }
  initialize() {
    this.pan = new d5({ navigation: this }), this.rotate = new h4({ navigation: this }), this.pinch = new d6({ navigation: this }), this.zoomBox = new c10({ view: this.view, navigation: this });
  }
  destroy() {
    this.pan = l(this.pan), this.rotate = l(this.rotate), this.pinch = l(this.pinch), this.zoomBox = l(this.zoomBox), this.animationManager = null;
  }
  begin() {
    this._set("interacting", true);
  }
  end() {
    this._lastEventTimestamp = performance.now(), this._startTimer(d8);
  }
  async zoom(t9, i7 = this._getDefaultAnchor()) {
    if (this.stop(), this.begin(), this.view.constraints.snapToZoom && this.view.constraints.effectiveLODs)
      return t9 < 1 ? this.zoomIn(i7) : this.zoomOut(i7);
    this.setViewpoint(i7, t9, 0, [0, 0]);
  }
  async zoomIn(t9) {
    const i7 = this.view, o7 = i7.constraints.snapToNextScale(i7.scale);
    return this._zoomToScale(o7, t9);
  }
  async zoomOut(t9) {
    const i7 = this.view, o7 = i7.constraints.snapToPreviousScale(i7.scale);
    return this._zoomToScale(o7, t9);
  }
  setViewpoint(t9, i7, o7, n15) {
    this.begin(), this.view.stateManager.state.viewpoint = this._scaleRotateTranslateViewpoint(this.view.viewpoint, t9, i7, o7, n15), this.end();
  }
  setViewpointImmediate(t9, i7 = 0, o7 = [0, 0], n15 = this._getDefaultAnchor()) {
    this.view.stateManager.state.viewpoint = this._scaleRotateTranslateViewpoint(this.view.viewpoint, n15, t9, i7, o7);
  }
  continousRotateClockwise() {
    var _a;
    const t9 = this.get("view.viewpoint");
    (_a = this.animationManager) == null ? void 0 : _a.animateContinous(t9, (t10) => {
      gt(t10, t10, -w2);
    });
  }
  continousRotateCounterclockwise() {
    var _a;
    const t9 = this.get("view.viewpoint");
    (_a = this.animationManager) == null ? void 0 : _a.animateContinous(t9, (t10) => {
      gt(t10, t10, w2);
    });
  }
  resetRotation() {
    this.view.rotation = 0;
  }
  continousPanLeft() {
    this._continuousPan([-v2, 0]);
  }
  continousPanRight() {
    this._continuousPan([v2, 0]);
  }
  continousPanUp() {
    this._continuousPan([0, v2]);
  }
  continousPanDown() {
    this._continuousPan([0, -v2]);
  }
  stop() {
    var _a;
    this.pan.stopMomentumNavigation(), (_a = this.animationManager) == null ? void 0 : _a.stop(), this.end(), null !== this._endTimer && (clearTimeout(this._endTimer), this._endTimer = null, this._set("interacting", false));
  }
  _continuousPan(t9) {
    var _a;
    const i7 = this.view.viewpoint;
    (_a = this.animationManager) == null ? void 0 : _a.animateContinous(i7, (i8) => {
      Rt(i8, i8, t9), this.view.constraints.constrainByGeometry(i8);
    });
  }
  _startTimer(t9) {
    return null !== this._endTimer || (this._endTimer = setTimeout(() => {
      this._endTimer = null;
      const t10 = performance.now() - (this._lastEventTimestamp ?? 0);
      t10 < d8 ? this._endTimer = this._startTimer(t10) : this._set("interacting", false);
    }, t9)), this._endTimer;
  }
  _getDefaultAnchor() {
    const { size: t9, padding: { left: i7, right: o7, top: n15, bottom: e11 } } = this.view;
    return _5[0] = 0.5 * (t9[0] - o7 + i7), _5[1] = 0.5 * (t9[1] - e11 + n15), _5;
  }
  async _zoomToScale(t9, i7 = this._getDefaultAnchor()) {
    const { view: o7 } = this, { constraints: n15, scale: e11, viewpoint: s9, size: a10, padding: r11 } = o7, c11 = n15.canZoomInTo(t9), m5 = n15.canZoomOutTo(t9);
    if (!(t9 < e11 && !c11 || t9 > e11 && !m5))
      return dt(g5, s9, t9 / e11, 0, i7, a10, r11), n15.constrainByGeometry(g5), o7.goTo(g5, { animate: true });
  }
  _scaleRotateTranslateViewpoint(t9, i7, o7, n15, e11) {
    const { view: s9 } = this, { size: a10, padding: r11, constraints: m5, scale: p3, viewpoint: u5 } = s9, l9 = p3 * o7, v3 = m5.canZoomInTo(l9), w3 = m5.canZoomOutTo(l9);
    return (o7 < 1 && !v3 || o7 > 1 && !w3) && (o7 = 1), Rt(u5, u5, e11), dt(t9, u5, o7, n15, i7, a10, r11), m5.constrainByGeometry(t9);
  }
};
e([y()], T4.prototype, "animationManager", void 0), e([y({ type: Boolean, readOnly: true })], T4.prototype, "interacting", void 0), e([y()], T4.prototype, "pan", void 0), e([y()], T4.prototype, "pinch", void 0), e([y()], T4.prototype, "rotate", void 0), e([y()], T4.prototype, "view", void 0), e([y()], T4.prototype, "zoomBox", void 0), T4 = e([a("esri.views.2d.navigation.MapViewNavigation")], T4);
var y2 = T4;

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/MagnifierPrograms.js
var a9 = { shaders: { vertexShader: n8("magnifier/magnifier.vert"), fragmentShader: n8("magnifier/magnifier.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0]]) };
function t8(r11) {
  return e7(r11, a9);
}

export {
  e8 as e,
  Y2 as Y,
  r5 as r,
  m4 as m,
  t7 as t,
  r7 as r2,
  n13 as n,
  d4 as d,
  y2 as y,
  a9 as a,
  t8 as t2
};
//# sourceMappingURL=chunk-EDK6DVWD.js.map
