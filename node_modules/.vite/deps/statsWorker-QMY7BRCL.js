import {
  D,
  F,
  M,
  S,
  c,
  d as d2,
  f as f2,
  g,
  m as m2,
  x as x2,
  z
} from "./chunk-ZD5B6I7X.js";
import "./chunk-HAYOKZGJ.js";
import {
  L
} from "./chunk-BA6PBZHC.js";
import {
  m,
  y
} from "./chunk-UU2XJGLA.js";
import "./chunk-YGUWDSEH.js";
import {
  u
} from "./chunk-DOQ3SAAR.js";
import {
  i
} from "./chunk-4BXK4H4L.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import "./chunk-4OR73Y2R.js";
import "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-3VUFACNT.js";
import {
  f,
  x2 as x
} from "./chunk-ZEEBL7ZN.js";
import {
  C,
  d
} from "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import "./chunk-V76KGJFU.js";
import "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import "./chunk-7I33FAWS.js";
import "./chunk-DWOEYHKS.js";
import "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/smartMapping/statistics/support/utils.js
var p = null;
function h(e, t, n) {
  return e.x < 0 ? e.x += t : e.x > n && (e.x -= t), e;
}
function y2(e, t, n, s2) {
  const l = C(n) ? d(n) : null, a = l ? Math.round((l.valid[1] - l.valid[0]) / t.scale[0]) : null;
  return e.map((e2) => {
    const n2 = new x(e2.geometry);
    return L(t, n2, n2, n2.hasZ, n2.hasM), e2.geometry = l ? h(n2, a ?? 0, s2[0]) : n2, e2;
  });
}
function $(e, n = 18, r, i2, o, s2) {
  const l = new Float64Array(o * s2);
  n = Math.round(u(n));
  let f3 = Number.POSITIVE_INFINITY, c3 = Number.NEGATIVE_INFINITY, m3 = 0, d4 = 0, p3 = 0, h2 = 0;
  const y3 = y(i2, r);
  for (const { geometry: t, attributes: u2 } of e) {
    const { x: e2, y: r2 } = t, i3 = Math.max(0, e2 - n), $3 = Math.max(0, r2 - n), I2 = Math.min(s2, r2 + n), g2 = Math.min(o, e2 + n), j = +y3(u2);
    for (let t2 = $3; t2 < I2; t2++)
      for (let s3 = i3; s3 < g2; s3++) {
        const i4 = t2 * o + s3, u3 = m(s3 - e2, t2 - r2, n), y4 = l[i4];
        m3 = l[i4] += u3 * j;
        const $4 = m3 - y4;
        d4 += $4, p3 += $4 * $4, m3 < f3 && (f3 = m3), m3 > c3 && (c3 = m3), h2++;
      }
  }
  if (!h2)
    return { mean: 0, stddev: 0, min: 0, max: 0, mid: 0, count: 0 };
  const $2 = (c3 - f3) / 2;
  return { mean: d4 / h2, stdDev: Math.sqrt((p3 - d4 * d4 / h2) / h2), min: f3, max: c3, mid: $2, count: h2 };
}
async function I(e, t) {
  if (!t)
    return [];
  const { field: r, field2: i2, field3: o, fieldDelimiter: s2 } = e, l = e.valueExpression, a = e.normalizationType, u2 = e.normalizationField, d4 = e.normalizationTotal, h2 = [], y3 = e.viewInfoParams;
  let $2 = null, I2 = null;
  if (l) {
    if (!p) {
      const { arcadeUtils: e2 } = await i();
      p = e2;
    }
    p.hasGeometryOperations(l) && await p.enableGeometryOperations(), $2 = p.createFunction(l), I2 = y3 && p.getViewInfo({ viewingMode: y3.viewingMode, scale: y3.scale, spatialReference: new f(y3.spatialReference) });
  }
  const g2 = e.fieldInfos, j = !(t[0] && "declaredClass" in t[0] && "esri.Graphic" === t[0].declaredClass) && g2 ? { fields: g2 } : null;
  return t.forEach((e2) => {
    const t2 = e2.attributes;
    let n;
    if (l) {
      const t3 = j ? { ...e2, layer: j } : e2, r2 = p.createExecContext(t3, I2);
      n = p.executeFunction($2, r2);
    } else
      t2 && (n = t2[r], i2 && (n = `${c(n)}${s2}${c(t2[i2])}`, o && (n = `${n}${s2}${c(t2[o])}`)));
    if (a && "number" == typeof n && isFinite(n)) {
      const e3 = t2 && parseFloat(t2[u2]);
      n = z(n, a, e3, d4);
    }
    h2.push(n);
  }), h2;
}

// node_modules/@arcgis/core/smartMapping/statistics/support/statsWorker.js
async function d3(a) {
  const { attribute: e, features: s2 } = a, { normalizationType: r, normalizationField: m3, minValue: f3, maxValue: u2, fieldType: d4 } = e, p3 = await I({ field: e.field, valueExpression: e.valueExpression, normalizationType: r, normalizationField: m3, normalizationTotal: e.normalizationTotal, viewInfoParams: e.viewInfoParams, fieldInfos: e.fieldInfos }, s2), v2 = m2({ normalizationType: r, normalizationField: m3, minValue: f3, maxValue: u2 }), c3 = { value: 0.5, fieldType: d4 }, z3 = "esriFieldTypeString" === d4 ? f2({ values: p3, supportsNullCount: v2, percentileParams: c3 }) : d2({ values: p3, minValue: f3, maxValue: u2, useSampleStdDev: !r, supportsNullCount: v2, percentileParams: c3 });
  return g(z3, "esriFieldTypeDate" === d4);
}
async function p2(a) {
  const { attribute: e, features: n } = a, l = await I({ field: e.field, field2: e.field2, field3: e.field3, fieldDelimiter: e.fieldDelimiter, valueExpression: e.valueExpression, viewInfoParams: e.viewInfoParams, fieldInfos: e.fieldInfos }, n), o = x2(l);
  return F(o, e.domains, e.returnAllCodedValues, e.fieldDelimiter);
}
async function v(a) {
  const { attribute: e, features: n } = a, { field: l, normalizationType: o, normalizationField: t, normalizationTotal: s2, classificationMethod: r } = e, u2 = await I({ field: l, valueExpression: e.valueExpression, normalizationType: o, normalizationField: t, normalizationTotal: s2, viewInfoParams: e.viewInfoParams, fieldInfos: e.fieldInfos }, n), d4 = D(u2, { field: l, normalizationType: o, normalizationField: t, normalizationTotal: s2, classificationMethod: r, standardDeviationInterval: e.standardDeviationInterval, numClasses: e.numClasses, minValue: e.minValue, maxValue: e.maxValue });
  return S(d4, r);
}
async function c2(a) {
  const { attribute: e, features: n } = a, { field: l, normalizationType: o, normalizationField: t, normalizationTotal: s2, classificationMethod: r } = e, m3 = await I({ field: l, valueExpression: e.valueExpression, normalizationType: o, normalizationField: t, normalizationTotal: s2, viewInfoParams: e.viewInfoParams, fieldInfos: e.fieldInfos }, n);
  return M(m3, { field: l, normalizationType: o, normalizationField: t, normalizationTotal: s2, classificationMethod: r, standardDeviationInterval: e.standardDeviationInterval, numBins: e.numBins, minValue: e.minValue, maxValue: e.maxValue });
}
async function z2(i2) {
  const { attribute: n, features: l } = i2, { field: o, radius: t, fieldOffset: s2, transform: r, spatialReference: m3 } = n, f3 = n.size ?? [0, 0], u2 = y2(l ?? [], r, m3, f3), { count: d4, min: p3, max: v2, mean: c3, stdDev: z3 } = $(u2, t ?? void 0, s2, o, f3[0], f3[1]);
  return { count: d4, min: p3, max: v2, avg: c3, stddev: z3 };
}
export {
  v as classBreaks,
  z2 as heatmapStatistics,
  c2 as histogram,
  d3 as summaryStatistics,
  p2 as uniqueValues
};
//# sourceMappingURL=statsWorker-QMY7BRCL.js.map
