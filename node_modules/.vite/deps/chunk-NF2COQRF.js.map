{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTangent.glsl.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/terrain/TileBlendInput.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/terrain/TerrainTexture.glsl.js", "../../@arcgis/core/chunks/Terrain.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.27/esri/copyright.txt for details.\n*/\nimport{glsl as n}from\"../../shaderModules/interfaces.js\";function e(e,t){e.varyings.add(\"tbnTangent\",\"vec3\"),e.varyings.add(\"tbnBiTangent\",\"vec3\"),t.spherical?e.vertex.code.add(n`void forwardVertexTangent(vec3 n) {\ntbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), n));\ntbnBiTangent = normalize(cross(n, tbnTangent));\n}`):e.vertex.code.add(n`void forwardVertexTangent(vec3 n) {\ntbnTangent = vec3(1.0, 0.0, 0.0);\ntbnBiTangent = normalize(cross(n, tbnTangent));\n}`),e.fragment.code.add(n`mat3 getTBNMatrix(vec3 n) {\nreturn mat3(tbnTangent, tbnBiTangent, n);\n}`)}export{e as VertexTangent};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.27/esri/copyright.txt for details.\n*/\nvar o;!function(o){o[o.LayerOnly=0]=\"LayerOnly\",o[o.ColorComposite=1]=\"ColorComposite\",o[o.GridComposite=2]=\"GridComposite\",o[o.COUNT=3]=\"COUNT\"}(o||(o={}));export{o as TileBlendInput};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.27/esri/copyright.txt for details.\n*/\nimport{OverlayIndex as e}from\"../../../../terrain/interfaces.js\";import{OverlaySource as r}from\"../../../../terrain/Overlay.js\";import{ReadShadowMapPassParameters as o}from\"../shading/ReadShadowMap.glsl.js\";import{BackgroundGrid as t}from\"./BackgroundGrid.glsl.js\";import{overlay as s}from\"./Overlay.glsl.js\";import{TileBlendInput as a}from\"./TileBlendInput.js\";import{FloatPassUniform as c}from\"../../shaderModules/FloatPassUniform.js\";import{glsl as n}from\"../../shaderModules/interfaces.js\";import{Texture2DPassUniform as i}from\"../../shaderModules/Texture2DPassUniform.js\";import{Uniform as d}from\"../../shaderModules/Uniform.js\";class l extends o{constructor(){super(...arguments),this.overlayOpacity=1,this.overlaySource=r.None}}function u(r,o){r.vertex.uniforms.add(new m(\"overlayTexOffset\"),new m(\"overlayTexScale\")),r.fragment.uniforms.add(new c(\"overlayOpacity\",(e=>e.overlayOpacity)),new i(\"ovColorTex\",((r,o)=>0===o.overlays.length?null:o.overlays[e.INNER].getColorTexture(r.overlaySource)))),s(r,o)}function f(e,r){const{vertex:o,fragment:s,varyings:c}=e;c.add(\"vtc\",\"vec2\"),o.uniforms.add(new m(\"texOffsetAndScale\")),s.uniforms.add(new p(\"tex\")),s.uniforms.add(new v(\"textureOpacities\"));const i=r.textureFadingEnabled&&!r.renderOccluded;i&&(o.uniforms.add(new m(\"nextTexOffsetAndScale\")),c.add(\"nvtc\",\"vec2\"),s.uniforms.add(new p(\"texNext\")),s.uniforms.add(new v(\"nextTexOpacities\")),s.uniforms.add(new x(\"fadeFactor\")));const d=r.tileBlendInput===a.ColorComposite,l=r.tileBlendInput===a.GridComposite;l&&s.include(t),d&&s.uniforms.add(new v(\"backgroundColor\")),o.code.add(n`\n  void forwardTextureCoordinatesWithTransform(in vec2 uv) {\n    vtc = uv * texOffsetAndScale.zw + texOffsetAndScale.xy;\n    ${i?n`nvtc = uv * nextTexOffsetAndScale.zw + nextTexOffsetAndScale.xy;`:n``}\n  }`),s.code.add(n`\n    vec4 getColor(vec4 color, vec2 uv, vec3 opacities) {\n      ${l||d?n`\n              if (opacities.y <= 0.0) {\n                return color * opacities.z * opacities.x;\n              }\n              vec4 bg = vec4(${d?n`backgroundColor`:n`gridColor(uv)`} * opacities.y, opacities.y);\n              vec4 layer = color * opacities.z;\n              return (bg * (1.0 - layer.a) + layer) * opacities.x;`:n`return color;`}\n    }`),i?s.code.add(n`vec4 getTileColor() {\nvec4 color = getColor(texture(tex, vtc), vtc, textureOpacities);\nif (fadeFactor >= 1.0) {\nreturn color;\n}\nvec4 nextColor = getColor(texture(texNext, nvtc), nvtc, nextTexOpacities);\nreturn mix(nextColor, color, fadeFactor);\n}`):s.code.add(n`vec4 getTileColor() {\nreturn getColor(texture(tex, vtc), vtc, textureOpacities);\n}`)}class x extends d{constructor(e){super(e,\"float\")}}class v extends d{constructor(e){super(e,\"vec3\")}}class m extends d{constructor(e){super(e,\"vec4\")}}class p extends d{constructor(e){super(e,\"sampler2D\")}}export{v as Float3Uniform,u as OverlayTerrain,l as OverlayTerrainPassParameters,f as TerrainTexture,p as Texture2DUniform};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.27/esri/copyright.txt for details.\n*/\nimport{w as e}from\"./mat4.js\";import{c as r}from\"./mat4f64.js\";import{n as o,s as i}from\"./vec3.js\";import{c as a}from\"./vec3f64.js\";import{OverlayIndex as l}from\"../views/3d/terrain/interfaces.js\";import{addLinearDepth as t,addNearFar as n,ForwardLinearDepth as s}from\"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";import{ShaderOutput as d}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";import{SliceDraw as c}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{Transform as v}from\"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";import{NormalAttribute as m}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js\";import{PositionAttribute as g}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js\";import{TextureCoordinateAttribute as p}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";import{VertexTangent as w}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTangent.glsl.js\";import{OutputDepth as h}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";import{OutputHighlight as u}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";import{EvaluateAmbientOcclusion as f}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js\";import{EvaluateSceneLighting as b,addAmbientBoostFactor as y,addLightingGlobalFactor as C}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js\";import{addMainLightDirection as x,addMainLightIntensity as S}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js\";import{NormalUtils as O}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js\";import{PBRMode as j}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js\";import{ReadShadowMapDraw as L}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";import{OverlayMode as z}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js\";import{OverlayTerrainPassParameters as T,OverlayTerrain as P,TerrainTexture as M}from\"../views/3d/webgl-engine/core/shaderLibrary/terrain/TerrainTexture.glsl.js\";import{addProjViewLocalOrigin as N,addViewNormal as D,addCameraPosition as $}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float3PassUniform as W}from\"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";import{glsl as U}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4DrawUniform as V}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4DrawUniform.js\";import{ShaderBuilder as F}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as A}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";class _ extends T{}function k(r){const a=new F,{vertex:T,fragment:_,varyings:k}=a;a.include(g),a.include(m,r),a.include(p,r);const H=()=>{a.include(O,r),T.code.add(U`vec3 getNormal() {\nfloat z = 1.0 - abs(normalCompressed.x) - abs(normalCompressed.y);\nvec3 n = vec3(normalCompressed + vec2(normalCompressed.x >= 0.0 ? 1.0 : -1.0,\nnormalCompressed.y >= 0.0 ? 1.0 : -1.0) * min(z, 0.0), z);\nreturn normalize(n);\n}`)};N(T,r),a.include(v,r);const I=r.overlayMode!==z.Disabled,q=I&&r.invisible;switch(r.output){case d.Color:{a.include(M,r),a.include(b,r),I&&a.include(P,{...r,pbrMode:r.pbrMode===j.Terrain?j.TerrainWithWater:j.Water});const t=r.overlayMode===z.EnabledWithWater;t&&a.include(w,r),k.add(\"vnormal\",\"vec3\"),k.add(\"vpos\",\"vec3\"),k.add(\"vup\",\"vec3\"),H(),r.screenSizePerspective&&D(T);const n=r.receiveShadows&&!r.renderOccluded;n&&a.include(s,r),r.screenSizePerspective&&(k.add(\"screenSizeDistanceToCamera\",\"float\"),k.add(\"screenSizeCosAngle\",\"float\")),T.code.add(U`\n        void main(void) {\n          //Position\n          vpos = position;\n          vec3 positionWorld = position + localOrigin;\n          gl_Position = transformPosition(proj, view, vpos);\n\n          //Normal\n          vnormal = getNormal();\n\n          //Up\n          vup = getLocalUp(position, localOrigin);\n\n          ${t?U`forwardVertexTangent(vnormal);`:U``}\n\n          //Texture UV\n          vec2 uv = getUV0();\n          forwardTextureCoordinatesWithTransform(uv);\n          ${I?U`setOverlayVTC(uv);`:\"\"}\n          ${r.tileBorders?U`forwardTextureCoordinates();`:\"\"}\n\n          ${r.screenSizePerspective?U`\n          vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;\n          screenSizeDistanceToCamera = length(viewPos);\n          vec3 viewSpaceNormal = (viewNormal * vec4(normalize(positionWorld), 1.0)).xyz;\n          screenSizeCosAngle = abs(viewSpaceNormal.z);`:\"\"}\n\n          ${n?U`forwardLinearDepth();`:\"\"}\n\n        }\n      `),a.include(c,r),a.include(b,r),a.include(f,r),a.include(L,r),$(_,r),y(_),C(_),_.uniforms.add(T.uniforms.get(\"localOrigin\"),new W(\"viewDirection\",((e,r)=>o(E,i(E,r.camera.viewMatrix[12],r.camera.viewMatrix[13],r.camera.viewMatrix[14]))))),t&&_.uniforms.add(new A(\"ovWaterTex\",((e,r)=>0===r.overlays.length?null:r.overlays[l.INNER].getNormalTexture(e.overlaySource))),new V(\"view\",((r,o)=>e(B,o.camera.viewMatrix,r.origin)))),_.code.add(U`const float sliceOpacity = 0.2;\nfloat lum(vec3 c) {\nreturn (min(min(c.r, c.g), c.b) + max(max(c.r, c.g), c.b)) * 0.5;\n}`),x(_),S(_),_.code.add(U`\n        void main() {\n          vec3 normal = normalize(vnormal);\n          float vndl = dot(normal, mainLightDirection);\n\n          float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n          float shadow = ${r.receiveShadows&&!r.renderOccluded?\"readShadowMap(vpos, linearDepth)\":r.spherical?\"lightingGlobalFactor * (1.0 - additionalAmbientScale)\":\"0.0\"};\n\n          float ssao = evaluateAmbientOcclusionInverse();\n          vec4 tileColor = getTileColor();\n\n          ${I?U`\n              vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);\n              vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n              ${r.invisible?U`if (overlayColor.a == 0.0) { discard; }`:\"\"}\n              vec4 groundColor = tileColor;\n              tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;`:\"\"}\n\n          // If combined alpha is 0 we can discard pixel. The performance impact by having a discard here\n          // is neglectable because terrain typically renders first into the framebuffer.\n          if(tileColor.a <= 0.0) {\n            discard;\n          }\n\n          bool sliced = rejectBySlice(vpos);\n          if (sliced) {\n            tileColor *= sliceOpacity;\n          }\n\n          vec3 albedo = tileColor.rgb;\n\n          // heuristic shading function used in the old terrain, now used to add ambient lighting\n\n          vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n          ${r.pbrMode===j.Terrain||r.pbrMode===j.TerrainWithWater?U`fragColor = vec4(evaluateTerrainLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight, normalize(vpos - cameraPosition), vup), tileColor.a);`:U`fragColor = vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);`}\n          ${t?U`\n              vec4 overlayWaterMask = getOverlayColor(ovWaterTex, vtcOverlay);\n              float waterNormalLength = length(overlayWaterMask);\n              if (waterNormalLength > 0.95) {\n                mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);\n                vec4 waterOverlayColor = vec4(overlayColor.w > 0.0 ? overlayColorOpaque.xyz/overlayColor.w : vec3(1.0), overlayColor.w);\n                vec4 viewPosition = view*vec4(vpos, 1.0);\n                vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vpos - cameraPosition), shadow, vnormal, tbnMatrix, viewPosition.xyz,  vpos + localOrigin);\n                vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n                float opacity = sliced ? sliceOpacity : 1.0;\n                // un-gamma the ground color to mix in linear space\n                fragColor = mix(groundColor, waterColorNonLinear, waterColorLinear.w) * opacity;\n              }`:\"\"}\n          ${r.screenSizePerspective?U`\n            float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, vec4(0.0, 0.0, 0.0, 0.0));\n            if (perspectiveScale <= 0.25) {\n              fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n            }\n            else if (perspectiveScale <= 0.5) {\n              fragColor = mix(fragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n            }\n            else if (perspectiveScale >= 0.99) {\n              fragColor = mix(fragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n            }\n            else {\n              fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n            }`:\"\"}\n          ${r.visualizeNormals?r.spherical?U`\n                  vec3 localUp = normalize(vpos + localOrigin);\n                  vec3 right = normalize(cross(vec3(0.0, 0.0, 1.0), localUp));\n                  vec3 forward = normalize(cross(localUp, right));\n                  mat3 tbn = mat3(right, forward, localUp);\n                  vec3 tNormal = normalize(normal * tbn);\n                  fragColor = vec4(vec3(0.5) + 0.5 * tNormal, 0.0);\n              `:U`\n                  vec3 tNormal = normalize(normal);\n                  fragColor = vec4(vec3(0.5) + 0.5 * tNormal, 0.0);\n              `:\"\"}\n          ${r.tileBorders?U`\n              vec2 dVuv = fwidth(vuv0);\n              vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv0, 1.0 - vuv0));\n              float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n              fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);`:\"\"}\n          fragColor = highlightSlice(fragColor, vpos);\n        }\n      `)}break;case d.Depth:q&&a.include(P,r),a.include(h,r),t(a),n(a),T.code.add(U`\n              void main(void) {\n                ${q?U`setOverlayVTC(getUV0());`:\"\"}\n                gl_Position = transformPositionWithDepth(proj, view, position, nearFar, linearDepth);\n              }\n          `),_.code.add(U`\n              void main() {\n                ${q?U`if (getCombinedOverlayColor().a == 0.0) { discard; }`:\"\"}\n                outputDepth(linearDepth);\n              }\n          `);break;case d.Shadow:case d.ShadowHighlight:case d.ShadowExcludeHighlight:a.include(h,r),t(a),n(a),T.code.add(U`void main(void) {\ngl_Position = transformPositionWithDepth(proj, view, position, nearFar, linearDepth);\n}`),_.code.add(U`void main() {\noutputDepth(linearDepth);\n}`);break;case d.Normal:q&&a.include(P,r),k.add(\"vnormal\",\"vec3\"),D(T),H(),T.code.add(U`\n            void main(void) {\n              ${q?U`setOverlayVTC(getUV0());`:\"\"}\n              gl_Position = transformPosition(proj, view, position);\n              vnormal = normalize((viewNormal * vec4(getNormal(), 1.0)).xyz);\n            }\n        `),_.code.add(U`\n            void main() {\n              ${q?U`if (getCombinedOverlayColor().a == 0.0) { discard; }`:\"\"}\n              vec3 normal = normalize(vnormal);\n              if (gl_FrontFacing == false) {\n                normal = -normal;\n              }\n              fragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);\n            }\n        `);break;case d.Highlight:I&&a.include(P,r),T.code.add(U`\n          void main() {\n            ${I?U`setOverlayVTC(getUV0());`:\"\"}\n            gl_Position = transformPosition(proj, view, position);\n          }\n        `),a.include(u,r),_.code.add(U`\n          void main() {\n            ${I?U`if (getCombinedOverlayColor().a == 0.0) { discard; }`:\"\"}\n            outputHighlight();\n          }\n        `)}return r.output===d.ObjectAndLayerIdColor&&(a.include(P,{...r,pbrMode:j.Disabled}),T.code.add(U`void main(void) {\ngl_Position = transformPosition(proj, view, position);\nsetOverlayVTC(getUV0());\n}`),_.code.add(U`void main() {\nfragColor = getOverlayColorTexel(vtcOverlay);\n}`)),a}const B=r(),E=a(),H=Object.freeze(Object.defineProperty({__proto__:null,TerrainPassParameters:_,build:k},Symbol.toStringTag,{value:\"Module\"}));export{_ as T,H as a,k as b};\n"],
  "mappings": "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",
  "names": ["e", "t", "o", "o", "n", "u", "r", "o", "e", "f", "s", "c", "p", "v", "i", "d", "l", "t", "r", "a", "i", "_", "k", "o", "H", "f", "p", "u", "t", "e", "n", "h"]
}
