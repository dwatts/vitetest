import {
  m as m3,
  s as s5
} from "./chunk-GM6POGRC.js";
import {
  g as g2,
  m as m2
} from "./chunk-DEKAIZFC.js";
import {
  o as o5
} from "./chunk-QVPAZ7EL.js";
import {
  t as t5
} from "./chunk-23N5B2NF.js";
import {
  m
} from "./chunk-T52K6PNI.js";
import {
  i as i2
} from "./chunk-UPDSQXLR.js";
import {
  i as i4,
  t as t4
} from "./chunk-7BSXIYP2.js";
import {
  e2 as e5
} from "./chunk-ACTOBSLJ.js";
import {
  a,
  c as c2
} from "./chunk-XUU35WPC.js";
import {
  p,
  u
} from "./chunk-6QR5R4JX.js";
import {
  e as e4
} from "./chunk-3TDCCT2R.js";
import {
  o as o4
} from "./chunk-LGDKASPG.js";
import {
  r,
  t as t3
} from "./chunk-KFDARCTS.js";
import {
  f
} from "./chunk-4YXJLES6.js";
import {
  c,
  e as e3,
  l,
  s as s2
} from "./chunk-EHQZFPMP.js";
import {
  d,
  o as o2
} from "./chunk-VC3BY3DV.js";
import {
  a as a4
} from "./chunk-WH76OAIT.js";
import {
  g
} from "./chunk-JHDKOKT6.js";
import {
  n as n3
} from "./chunk-IBJTEQQG.js";
import {
  o as o3
} from "./chunk-SADO52IH.js";
import {
  d as d2,
  v
} from "./chunk-LIO6VZRI.js";
import {
  h
} from "./chunk-73PNWDTS.js";
import {
  t as t2
} from "./chunk-PKS3ZVLN.js";
import {
  _
} from "./chunk-N3RXOITN.js";
import {
  A,
  O
} from "./chunk-BUCIQGFS.js";
import {
  s as s3
} from "./chunk-BFVOSCOB.js";
import {
  a as a3
} from "./chunk-IVMJPIWO.js";
import {
  s as s4
} from "./chunk-Z3NHJA5D.js";
import {
  a as a2,
  i2 as i3
} from "./chunk-BO2REVMA.js";
import {
  o
} from "./chunk-V66LHQVK.js";
import {
  i,
  n as n2
} from "./chunk-JP7O2ZWE.js";
import {
  n
} from "./chunk-4CZO65BK.js";
import {
  e as e2,
  s,
  t
} from "./chunk-GJ7PJ7XG.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/collections/Component/Material/shader/VertexDiscardByOpacity.glsl.js
var a5;
function r2(r3, c3) {
  const i5 = r3.vertex;
  switch (i5.code.add(o`#define VERTEX_DISCARD_CUTOFF (1.0 - 1.0 / 255.0)`), c3.vertexDiscardMode) {
    case a5.None:
      i5.code.add(o`#define vertexDiscardByOpacity(_opacity_) {}`);
      break;
    case a5.Opaque:
      i5.code.add(o`#define vertexDiscardByOpacity(_opacity_) { if (_opacity_ >  VERTEX_DISCARD_CUTOFF) {  gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`);
      break;
    case a5.Transparent:
      i5.code.add(o`#define vertexDiscardByOpacity(_opacity_) { if (_opacity_ <= VERTEX_DISCARD_CUTOFF) {  gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`);
  }
}
!function(e6) {
  e6[e6.None = 0] = "None", e6[e6.Transparent = 1] = "Transparent", e6[e6.Opaque = 2] = "Opaque", e6[e6.COUNT = 3] = "COUNT";
}(a5 || (a5 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/collections/Component/Material/ComponentTechniqueConfiguration.js
var v2;
!function(o6) {
  o6[o6.None = 0] = "None", o6[o6.NoOverlay = 1] = "NoOverlay", o6[o6.ColorOverlay = 2] = "ColorOverlay", o6[o6.ColorOverlayWithWater = 3] = "ColorOverlayWithWater", o6[o6.COUNT = 4] = "COUNT";
}(v2 || (v2 = {}));
var m4 = class extends t3 {
  constructor() {
    super(...arguments), this.output = h.Color, this.textureCoordinateType = d.None, this.componentData = s5.Uniform, this.cullFace = n2.Back, this.vertexDiscardMode = a5.None, this.doubleSidedMode = i2.WindingOrder, this.alphaDiscardMode = i.Opaque, this.integratedMeshMode = v2.None, this.transparencyPassType = o3.NONE, this.ellipsoidMode = t5.Earth, this.pbrMode = c.Disabled, this.normalType = a.Attribute, this.spherical = false, this.doublePrecisionRequiresObfuscation = false, this.hasVertexColors = false, this.hasNormals = false, this.hasSlicePlane = false, this.hasBaseColorTexture = false, this.receiveAmbientOcclusion = true, this.receiveShadows = true, this.blendingEnabled = true, this.hasScreenSpaceReflections = false, this.hasPolygonOffset = false, this.hasMetallicRoughnessTexture = false, this.hasEmissionTexture = false, this.hasOcclusionTexture = false, this.hasNormalTexture = false, this.hasOccludees = false, this.hasMultipassTerrain = false, this.cullAboveGround = false, this.hasCloudsReflections = true, this.snowCover = false, this.objectAndLayerIdColor = false;
  }
};
e([r({ count: h.COUNT })], m4.prototype, "output", void 0), e([r({ count: d.COUNT })], m4.prototype, "textureCoordinateType", void 0), e([r({ count: s5.COUNT })], m4.prototype, "componentData", void 0), e([r({ count: n2.COUNT })], m4.prototype, "cullFace", void 0), e([r({ count: a5.COUNT })], m4.prototype, "vertexDiscardMode", void 0), e([r({ count: i2.COUNT })], m4.prototype, "doubleSidedMode", void 0), e([r({ count: i.COUNT })], m4.prototype, "alphaDiscardMode", void 0), e([r({ count: v2.COUNT })], m4.prototype, "integratedMeshMode", void 0), e([r({ count: o3.COUNT })], m4.prototype, "transparencyPassType", void 0), e([r({ count: t5.COUNT })], m4.prototype, "ellipsoidMode", void 0), e([r({ count: c.COUNT })], m4.prototype, "pbrMode", void 0), e([r({ count: a.COUNT })], m4.prototype, "normalType", void 0), e([r()], m4.prototype, "spherical", void 0), e([r()], m4.prototype, "doublePrecisionRequiresObfuscation", void 0), e([r()], m4.prototype, "hasVertexColors", void 0), e([r()], m4.prototype, "hasNormals", void 0), e([r()], m4.prototype, "hasSlicePlane", void 0), e([r()], m4.prototype, "hasBaseColorTexture", void 0), e([r()], m4.prototype, "receiveAmbientOcclusion", void 0), e([r()], m4.prototype, "receiveShadows", void 0), e([r()], m4.prototype, "blendingEnabled", void 0), e([r()], m4.prototype, "hasScreenSpaceReflections", void 0), e([r()], m4.prototype, "hasPolygonOffset", void 0), e([r()], m4.prototype, "hasMetallicRoughnessTexture", void 0), e([r()], m4.prototype, "hasEmissionTexture", void 0), e([r()], m4.prototype, "hasOcclusionTexture", void 0), e([r()], m4.prototype, "hasNormalTexture", void 0), e([r()], m4.prototype, "hasOccludees", void 0), e([r()], m4.prototype, "hasMultipassTerrain", void 0), e([r()], m4.prototype, "cullAboveGround", void 0), e([r()], m4.prototype, "hasCloudsReflections", void 0), e([r()], m4.prototype, "snowCover", void 0), e([r()], m4.prototype, "objectAndLayerIdColor", void 0), e([r({ constValue: a2.Draw })], m4.prototype, "pbrTextureBindType", void 0), e([r({ constValue: true })], m4.prototype, "hasSliceHighlight", void 0), e([r({ constValue: false })], m4.prototype, "hasSliceInVertexProgram", void 0), e([r({ constValue: false })], m4.prototype, "useCustomDTRExponentForWater", void 0), e([r({ constValue: false })], m4.prototype, "hasVertexTangents", void 0), e([r({ constValue: true })], m4.prototype, "supportsTextureAtlas", void 0), e([r({ constValue: false })], m4.prototype, "highStepCount", void 0), e([r({ constValue: false })], m4.prototype, "instancedDoublePrecision", void 0), e([r({ constValue: true })], m4.prototype, "useFillLights", void 0), e([r({ constValue: false })], m4.prototype, "objectAndLayerIdColorInstanced", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl.js
function l2(l4, s6) {
  l4.include(e4, s6), l4.fragment.include(i4);
  const i5 = l4.fragment;
  i5.uniforms.add(new o5("baseColor", (o6) => o6.baseColor)), i5.uniforms.add(new e5("objectOpacity", (o6) => o6.objectOpacity)), s6.hasVertexColors ? i5.code.add(o`vec3 _baseColor() {
return baseColor.rgb * vColor.rgb;
}
float _baseOpacity() {
return baseColor.a * vColor.a;
}`) : i5.code.add(o`vec3 _baseColor() {
return baseColor.rgb;
}
float _baseOpacity() {
return baseColor.a;
}`), i5.code.add(o`vec4 computeMaterialColor(vec4 textureColor, vec4 externalColor, int externalColorMixMode) {
vec3 baseColor = _baseColor();
float baseOpacity = _baseOpacity();
vec3 color = mixExternalColor(
baseColor,
textureColor.rgb,
externalColor.rgb,
externalColorMixMode
);
float opacity = objectOpacity * mixExternalOpacity(
baseOpacity,
textureColor.a,
externalColor.a,
externalColorMixMode
);
return vec4(color, opacity);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeShadingNormal.glsl.js
function l3(l4, n4) {
  const s6 = l4.fragment;
  switch (n4.doubleSidedMode) {
    case i2.None:
      s6.code.add(o`vec3 _adjustDoublesided(vec3 normal) {
return normal;
}`);
      break;
    case i2.View:
      l4.include(v, n4), s6.code.add(o`vec3 _adjustDoublesided(vec3 normal) {
return dot(normal, vPositionWorldCameraRelative) > 0.0 ? -normal : normal;
}`);
      break;
    case i2.WindingOrder:
      s6.code.add(o`vec3 _adjustDoublesided(vec3 normal) {
return gl_FrontFacing ? normal : -normal;
}`);
      break;
    default:
      n(n4.doubleSidedMode);
    case i2.COUNT:
  }
  switch (n4.normalType) {
    case a.Attribute:
    case a.Compressed:
      l4.include(c2, n4), s6.code.add(o`vec3 shadingNormalWorld() {
return _adjustDoublesided(normalize(vNormalWorld));
}
vec3 shadingNormal_view() {
vec3 normal = normalize(vNormalView);
return gl_FrontFacing ? normal : -normal;
}`);
      break;
    case a.ScreenDerivative:
      l4.include(v, n4), s6.code.add(o`vec3 shadingNormalWorld() {
return normalize(cross(
dFdx(vPositionWorldCameraRelative),
dFdy(vPositionWorldCameraRelative)
));
}
vec3 shadingNormal_view() {
return normalize(cross(dFdx(vPosition_view),dFdy(vPosition_view)));
}`);
      break;
    case a.Ground:
      n4.spherical ? (l4.include(v, n4), s6.code.add(o`vec3 shadingNormalWorld() {
return normalize(positionWorld());
}`)) : s6.code.add(o`vec3 shadingNormalWorld() {
return vec3(0.0, 0.0, 1.0);
}`), s6.code.add(o`vec3 shadingNormal_view() {
return normalize(cross(dFdx(vPosition_view),dFdy(vPosition_view))).xyz;
}`);
      break;
    default:
      n(n4.normalType);
    case a.COUNT:
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl.js
function d3(d4, i5) {
  const l4 = d4.fragment;
  if (i5.hasBaseColorTexture && (i5.output === h.Color || i5.alphaDiscardMode !== i.Opaque)) {
    d4.include(s2, i5);
    const e6 = i5.textureCoordinateType === d.Atlas;
    l4.uniforms.add(new s3("baseColorTexture", (e7) => e7.texture)), e6 ? (d4.include(e3), l4.code.add(o`vec4 readBaseColorTexture() {
return textureAtlasLookup(baseColorTexture, vuv0, vuvRegion);
}`)) : l4.code.add(o`vec4 readBaseColorTexture() {
return texture(baseColorTexture, vuv0);
}`);
  } else
    l4.code.add(o`vec4 readBaseColorTexture() { return vec4(1.0); }`);
}

// node_modules/@arcgis/core/chunks/ComponentShader.glsl.js
function V(a6) {
  const i5 = new i3();
  i5.include(v, a6), i5.include(c2, a6), i5.include(e4, a6), i5.include(o2, a6), i5.include(d2, a6), i5.include(m3, a6), i5.include(t4, a6), i5.include(_, a6), i5.include(d3, a6), i5.include(r2, a6);
  const { vertex: V2, fragment: F2 } = i5;
  a6.pbrMode !== c.Normal && a6.pbrMode !== c.Schematic || (i5.include(l, a6), a6.hasNormalTexture && i5.include(m, a6));
  const G = a6.output === h.Shadow || a6.output === h.ShadowHighlight || a6.output === h.ShadowExcludeHighlight;
  G && a6.componentData === s5.Varying ? V2.code.add(o`#define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`) : V2.code.add(o`#define discardShadows(castShadows) {}`);
  const H = a6.integratedMeshMode === v2.ColorOverlay || a6.integratedMeshMode === v2.ColorOverlayWithWater, k = H && a6.output === h.Color && a6.pbrMode === c.WaterOnIntegratedMesh;
  return H && (i5.include(p, a6), i5.include(m2, a6), a6.spherical ? V2.code.add(o`
      const float invEllipsoidRadius = ${o.float(1 / (a6.ellipsoidMode === t5.Earth ? s.radius : a6.ellipsoidMode === t5.Mars ? t.radius : e2.radius))};
      vec2 projectOverlay(vec3 pos) {
        return pos.xy / (1.0 + invEllipsoidRadius * pos.z);
      }
      `) : V2.code.add(o`vec2 projectOverlay(vec3 pos) { return pos.xy; }`)), k && (i5.varyings.add("tbnTangent", "vec3"), i5.varyings.add("tbnBiTangent", "vec3"), i5.varyings.add("groundNormal", "vec3")), V2.code.add(o`
    void main() {
      bool castShadows;
      vec4 externalColor = forwardExternalColor(castShadows);
      discardShadows(castShadows);

      vertexDiscardByOpacity(externalColor.a);

      ${a6.output === h.ObjectAndLayerIdColor ? o`externalColor.a = 1.0;` : ""}

      if (externalColor.a < ${o.float(t2)}) {
        // Discard this vertex
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }

      forwardPosition(readElevationOffset());
      forwardNormal();
      forwardTextureCoordinates();
      forwardVertexColor();
      forwardLinearDepth();
      ${a6.output === h.ObjectAndLayerIdColor ? o`forwardObjectAndLayerIdColor();` : ""}
      ${k ? a6.spherical ? o`
                groundNormal = normalize(positionWorld());
                tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));
                tbnBiTangent = normalize(cross(groundNormal, tbnTangent));` : o`
                groundNormal = vec3(0.0, 0.0, 1.0);
                tbnTangent = vec3(1.0, 0.0, 0.0);
                tbnBiTangent = vec3(0.0, 1.0, 0.0);` : ""}
      ${H ? o`setOverlayVTC(projectOverlay(position));` : ""}
    }
  `), a6.output === h.Alpha && (F2.include(a3), i5.include(n3, a6), i5.include(l2, a6), H && F2.uniforms.add(new s4("ovColorTex", (e6, o6) => g2(e6, o6))), F2.code.add(o`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);
        ${a6.hasMultipassTerrain ? o`terrainDepthTest(gl_FragCoord, vPosition_view.z);` : ""}

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        vec4 externalColor;
        int externalColorMixMode;
        readExternalColor(externalColor, externalColorMixMode);

        vec4 materialColor = computeMaterialColor(
          textureColor,
          externalColor,
          externalColorMixMode
        );
        ${H ? o`
                vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);
                materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;` : ""}

        fragColor = vec4(materialColor.a);
      }
    `)), a6.output === h.Color && (F2.include(a3), i5.include(n3, a6), i5.include(l2, a6), i5.include(l3, a6), i5.include(p, a6), a6.receiveShadows ? (i5.include(f, a6), F2.code.add(o`float evaluateShadow() {
return readShadowMap(vPositionWorldCameraRelative, linearDepth);
}`)) : F2.code.add(o`float evaluateShadow() { return 0.0; }`), H && F2.uniforms.add(new s4("ovColorTex", (e6, o6) => g2(e6, o6))), F2.code.add(o`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);
        ${a6.hasMultipassTerrain ? o`terrainDepthTest(gl_FragCoord, vPosition_view.z);` : ""}

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        vec4 externalColor;
        int externalColorMixMode;
        readExternalColor(externalColor, externalColorMixMode);

        vec4 materialColor = computeMaterialColor(
          textureColor,
          externalColor,
          externalColorMixMode
        );
        ${H ? o`vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);` : ""}
    `), a6.pbrMode === c.Normal || a6.pbrMode === c.Schematic ? (a4(F2), F2.code.add(o`
        ${a6.pbrMode === c.Normal ? o`
                applyPBRFactors();
                if (int(externalColorMixMode) == 3) {
                  mrr = vec3(0.0, 0.6, 0.2);
                }` : ""}
        vec3 normalVertex = shadingNormalWorld();
        float additionalIrradiance = 0.02 * mainLightIntensity[2];
      `), a6.hasNormalTexture ? F2.code.add(o`mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);
vec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);`) : F2.code.add(o`vec3 shadingNormal = normalVertex;`), F2.code.add(o`${a6.spherical ? o`vec3 normalGround = normalize(positionWorld());` : o`vec3 normalGround = vec3(0.0, 0.0, 1.0);`}
      `), F2.code.add(o`
        vec3 viewDir = normalize(vPositionWorldCameraRelative);
        float ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());

        ${a6.snowCover ? o`
                vec3 surfaceNormal = normalize(shadingNormalWorld());
                float snow = smoothstep(0.5, 0.55, dot(surfaceNormal, normalize(positionWorld())));
                materialColor.rgb = mix(materialColor.rgb, vec3(1), snow);

                shadingNormal = mix(shadingNormal, surfaceNormal, snow);
                ssao = mix(ssao, 0.0, snow);
                mrr = mix(mrr, vec3(0.0, 1.0, 0.04), snow);
                emission = mix(emission, vec3(0.0), snow);` : ""}

        ${H ? o` materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;` : ""}

        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());
        vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);
        `)) : (a6.receiveShadows ? F2.code.add(o`float shadow = evaluateShadow();`) : a6.spherical ? (u(F2), F2.code.add(o`float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());
float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);`)) : F2.code.add(o`float shadow = 0.0;`), k && F2.uniforms.add(new s4("ovNormalTex", (e6, o6) => I(o6))), a6.snowCover && F2.code.add(o`vec3 surfaceNormal = normalize(cross(dFdx(vPositionWorldCameraRelative), dFdy(vPositionWorldCameraRelative)));
float snow = smoothstep(0.5, 0.55, dot(surfaceNormal, normalize(positionWorld())));
materialColor.rgb = mix(materialColor.rgb, vec3(1), snow);`), F2.code.add(o`
        float ambientOcclusion = evaluateAmbientOcclusion();
        vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());

        ${H ? o` materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;` : ""}

        vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);
      ${k ? o`
              vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);
              float waterNormalLength = length(overlayWaterMask);
              if (waterNormalLength > 0.95) {
                mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);
                vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, vPosition_view, positionWorld());
                vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
                // un-gamma the ground color to mix in linear space
                shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);
              }` : ""}
      `)), F2.code.add(o`
        fragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);
        ${a6.transparencyPassType === o3.Color ? "fragColor = premultiplyAlpha(fragColor);" : ""}
      }
    `)), (a6.output === h.Depth || G) && (i5.include(o4, a6), F2.code.add(o`void main() {
discardBySlice(vPositionWorldCameraRelative);
vec4 textureColor = readBaseColorTexture();
discardOrAdjustAlpha(textureColor);
outputDepth(linearDepth);
}`)), a6.output === h.Normal && (i5.include(l3, a6), F2.code.add(o`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        // note: the alpha component needs to be 1.0 in order for this material
        // to influence ambient occlusion, see the ssao fragment shader
        float alpha = ${a6.normalType === a.Ground ? "0.0" : "1.0"};
        fragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);
      }
    `)), a6.output === h.ObjectAndLayerIdColor && i5.fragment.code.add(o`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        ${H ? o`fragColor = getOverlayColorTexel(vtcOverlay);` : "outputObjectAndLayerIdColor();"}
      }
    `), a6.output === h.Highlight && (i5.include(g, a6), F2.code.add(o`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        ${H ? o`
                vec4 overlayColor = getCombinedOverlayColor();
                if (overlayColor.a == 0.0) {
                  fragColor = vec4(0.0);
                  return;
                }` : ""}

        outputHighlight();
      }
    `)), i5;
}
function I(e6) {
  return 0 === e6.overlays.length ? null : e6.overlays[O.INNER].getValidTexture(A.Water);
}
var F = Object.freeze(Object.defineProperty({ __proto__: null, build: V, getOverlayNormalTexture: I }, Symbol.toStringTag, { value: "Module" }));

export {
  a5 as a,
  v2 as v,
  m4 as m,
  V,
  I,
  F
};
//# sourceMappingURL=chunk-37N7UY7F.js.map
