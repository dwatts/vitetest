import {
  g as g4
} from "./chunk-XIISWEMS.js";
import {
  H as H2,
  l as l7,
  n as n7
} from "./chunk-UTMCYWKC.js";
import {
  $,
  D,
  N,
  R as R4,
  U as U2,
  a as a5,
  a2 as a6,
  d as d4,
  e as e6,
  v2
} from "./chunk-SUS6FVXM.js";
import {
  a2 as a4,
  i as i6,
  r as r6,
  s as s5,
  t2 as t10,
  u as u3,
  u2 as u4
} from "./chunk-W2MFIVLD.js";
import "./chunk-2O3MFNAT.js";
import "./chunk-BTHQ4EZE.js";
import "./chunk-XW6BCJUG.js";
import "./chunk-2NUCTFTS.js";
import "./chunk-67UNUI4B.js";
import {
  C
} from "./chunk-PFUZUHLB.js";
import "./chunk-2735WBYK.js";
import {
  U as U3
} from "./chunk-DB3QP4OO.js";
import {
  i as i7,
  s as s6
} from "./chunk-2KRMZDXT.js";
import {
  h as h4
} from "./chunk-JQKL7AD5.js";
import {
  X
} from "./chunk-CS6BZGQO.js";
import {
  f as f4
} from "./chunk-YZTKL3LQ.js";
import "./chunk-I7EXY23J.js";
import "./chunk-SCHIU6CT.js";
import "./chunk-SFIT2AUF.js";
import {
  B
} from "./chunk-DBIFU6GO.js";
import {
  A as A3,
  t as t9
} from "./chunk-V33FVMPT.js";
import {
  H,
  J,
  W as W3,
  Z,
  ds,
  ms,
  ss
} from "./chunk-U67EYFX3.js";
import "./chunk-PLKG3UR7.js";
import "./chunk-4BA5YJ7C.js";
import {
  at,
  ht,
  lt,
  pt
} from "./chunk-WRC5WFEM.js";
import {
  c as c5,
  e as e5
} from "./chunk-2EO2WRP7.js";
import "./chunk-CERU5LKM.js";
import "./chunk-JZVYLVFO.js";
import "./chunk-FAOMDC3K.js";
import "./chunk-SCAYUERS.js";
import "./chunk-YEDW7SLL.js";
import "./chunk-N4JKQR77.js";
import {
  r2 as r5
} from "./chunk-BDX5TRUE.js";
import "./chunk-LIXBKTBN.js";
import "./chunk-VDSNHCMM.js";
import {
  E as E2
} from "./chunk-6LC2JTLC.js";
import "./chunk-XM3YSFN6.js";
import "./chunk-NIZWDAMQ.js";
import "./chunk-DU3C7D26.js";
import "./chunk-3TDCCT2R.js";
import "./chunk-Z2RTGLQI.js";
import {
  e as e4,
  i as i5,
  t as t6
} from "./chunk-V6CD66ZZ.js";
import {
  W as W2,
  _ as _2,
  l as l6
} from "./chunk-6FHMQNMS.js";
import "./chunk-D7YAG5U3.js";
import "./chunk-LGDKASPG.js";
import "./chunk-YQDOKTNT.js";
import "./chunk-SH6HJSS2.js";
import {
  t as t7
} from "./chunk-KFDARCTS.js";
import "./chunk-TRGMWULG.js";
import "./chunk-WTPQKRQM.js";
import {
  o2 as o4
} from "./chunk-SMDDCTGQ.js";
import {
  E
} from "./chunk-NU4UASX6.js";
import "./chunk-JHDKOKT6.js";
import "./chunk-YLTVH2K4.js";
import {
  t as t5
} from "./chunk-FB4A6PBH.js";
import "./chunk-CG3URTR2.js";
import "./chunk-AB23UNQC.js";
import "./chunk-RDWKBYTH.js";
import "./chunk-IBJTEQQG.js";
import "./chunk-SADO52IH.js";
import "./chunk-WVOBJDWI.js";
import "./chunk-LIO6VZRI.js";
import "./chunk-7DFZCT3D.js";
import "./chunk-ASBUA7EG.js";
import "./chunk-FY4ZONHH.js";
import {
  h as h3
} from "./chunk-73PNWDTS.js";
import "./chunk-PKS3ZVLN.js";
import "./chunk-N3RXOITN.js";
import "./chunk-DOR4M5EA.js";
import "./chunk-3ROGWJVH.js";
import "./chunk-BUCIQGFS.js";
import "./chunk-CR5XNTAP.js";
import "./chunk-Z6IKMUOC.js";
import "./chunk-PV5KBAYL.js";
import "./chunk-YVVROPAO.js";
import "./chunk-QS45OHBM.js";
import "./chunk-IVMJPIWO.js";
import "./chunk-3I3GE5YW.js";
import "./chunk-WRFNQB7U.js";
import "./chunk-UUW6REOV.js";
import "./chunk-Z3NHJA5D.js";
import "./chunk-BO2REVMA.js";
import {
  n as n5
} from "./chunk-V66LHQVK.js";
import {
  n as n4
} from "./chunk-JP7O2ZWE.js";
import "./chunk-Z6R62RNV.js";
import "./chunk-3LLZ72VA.js";
import "./chunk-4SIKLJSS.js";
import "./chunk-WDZ5AAFL.js";
import "./chunk-UM64E5NS.js";
import "./chunk-2XKILFME.js";
import "./chunk-G4LSNP77.js";
import "./chunk-BA6PBZHC.js";
import "./chunk-Z7LZRT7C.js";
import "./chunk-SGBMUZSF.js";
import "./chunk-3TMT4LDG.js";
import "./chunk-BDWD2ZNU.js";
import {
  I,
  R as R2
} from "./chunk-BCDDCNQ2.js";
import "./chunk-FIBWCATC.js";
import {
  g as g3
} from "./chunk-YC5U2RV5.js";
import "./chunk-ZNQYDNXF.js";
import "./chunk-GTUBINZG.js";
import "./chunk-SLMR4CTS.js";
import "./chunk-BFVDDR4R.js";
import "./chunk-LJ3FBGIN.js";
import "./chunk-QPXU3YKY.js";
import "./chunk-FLVP2XLK.js";
import "./chunk-XKENZ7D5.js";
import "./chunk-GZTS5346.js";
import "./chunk-EK3Y2IYO.js";
import "./chunk-6S2FCH6S.js";
import "./chunk-BZL5MAFP.js";
import "./chunk-XY26YCFX.js";
import "./chunk-3TTW7E7W.js";
import {
  P as P2,
  R as R3,
  T,
  W,
  h as h2,
  q2 as q
} from "./chunk-FOEAKQNX.js";
import {
  c as c4,
  d as d3,
  f as f3,
  i as i4,
  n as n3,
  o as o3,
  t as t4
} from "./chunk-LEDSC236.js";
import "./chunk-NETCTS4Y.js";
import {
  Q
} from "./chunk-OKABUMQT.js";
import {
  e as e3
} from "./chunk-CW7LIPBH.js";
import "./chunk-TYOIANOD.js";
import "./chunk-VN2IXVGV.js";
import "./chunk-WWUAHPIM.js";
import "./chunk-BN6X2OXK.js";
import "./chunk-3C6NSN3C.js";
import "./chunk-J7GVLYC6.js";
import "./chunk-HWCVRBK2.js";
import "./chunk-WQH5IZQP.js";
import "./chunk-LCS4FL4K.js";
import "./chunk-4JFWLHWB.js";
import "./chunk-Y7OTFSYN.js";
import "./chunk-S7JBLP35.js";
import "./chunk-DZRIMGKU.js";
import "./chunk-MRYR5ID7.js";
import "./chunk-I3MRHING.js";
import "./chunk-RWWB77SD.js";
import "./chunk-Y7MP63H6.js";
import "./chunk-2WJ2SRK2.js";
import "./chunk-ZVHSORNP.js";
import "./chunk-XUV5GLNE.js";
import "./chunk-ZMFGNDTK.js";
import "./chunk-UL64BLDS.js";
import "./chunk-EG6CFIHA.js";
import "./chunk-CMNAZRWU.js";
import "./chunk-KE6VYSDW.js";
import "./chunk-SJEOKSSU.js";
import "./chunk-5GE3CZPD.js";
import "./chunk-WZRJMJNH.js";
import "./chunk-GDP6ZU2A.js";
import "./chunk-XIYY37WZ.js";
import "./chunk-P4PDTNIU.js";
import "./chunk-SRDSGSDW.js";
import "./chunk-IMXPH7BL.js";
import "./chunk-ENOZ3X2B.js";
import "./chunk-DRCIVBVA.js";
import "./chunk-CEFGWR5H.js";
import "./chunk-NX5NNI52.js";
import "./chunk-G2DTL6AE.js";
import "./chunk-Q6HN54VB.js";
import "./chunk-NDKDK4Y5.js";
import "./chunk-O443WBFA.js";
import "./chunk-RGS3ANC3.js";
import "./chunk-Z3GCSCQI.js";
import "./chunk-PPNAO2PM.js";
import "./chunk-UU2XJGLA.js";
import "./chunk-CGJNVOU3.js";
import "./chunk-YA7WDOJK.js";
import "./chunk-C6OHOFP6.js";
import "./chunk-ZX45U24W.js";
import "./chunk-KYWX7M3R.js";
import "./chunk-7H2AXTDH.js";
import "./chunk-QC2JMJXZ.js";
import "./chunk-GFPASUQP.js";
import "./chunk-KDACHJ5G.js";
import "./chunk-IQRLZSBX.js";
import "./chunk-OZL6Q7O2.js";
import "./chunk-FVR25IMN.js";
import "./chunk-EV77QZBT.js";
import "./chunk-QZ6WR57P.js";
import "./chunk-467UETSR.js";
import "./chunk-SHFLRM67.js";
import {
  l as l5,
  r as r4
} from "./chunk-YGUWDSEH.js";
import "./chunk-6RU2CUTK.js";
import "./chunk-GOK4EI36.js";
import "./chunk-LO3LAMAS.js";
import "./chunk-ZWFMUHG3.js";
import "./chunk-EFRTD25L.js";
import "./chunk-EAGDM3GO.js";
import "./chunk-GSS6WNQU.js";
import "./chunk-C2EHS6UI.js";
import {
  n as n6,
  t as t8,
  u as u2
} from "./chunk-NEBQZ6AZ.js";
import "./chunk-63ERNIOV.js";
import {
  s as s3
} from "./chunk-XABSD6D5.js";
import "./chunk-NLWV7Q6F.js";
import "./chunk-RVS5HU2K.js";
import "./chunk-JB7FDW5N.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-H37COY3W.js";
import "./chunk-NVGPNIR6.js";
import "./chunk-B4D7M7HT.js";
import "./chunk-3T2ETA25.js";
import "./chunk-5IYCCZ54.js";
import "./chunk-JLSXEPY6.js";
import "./chunk-VMTVUE47.js";
import "./chunk-GDZM4A6K.js";
import "./chunk-XWGNMTES.js";
import "./chunk-6NNEHJYI.js";
import {
  En
} from "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import "./chunk-W4KI5YEI.js";
import "./chunk-CAFGOFIE.js";
import {
  A as A2,
  R,
  c as c2,
  d,
  f as f2,
  g as g2,
  i as i2,
  l as l4,
  r as r3,
  x as x2
} from "./chunk-7EG7BYWF.js";
import "./chunk-JNDFAMXY.js";
import "./chunk-NTEKJWGF.js";
import {
  i
} from "./chunk-TFIKV5RU.js";
import "./chunk-KW6QQDGN.js";
import "./chunk-AQ7R6V4L.js";
import {
  c as c3,
  d as d2,
  i as i3,
  p
} from "./chunk-DOQ3SAAR.js";
import "./chunk-4BXK4H4L.js";
import "./chunk-SLVNG7FV.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-DKJBDKGA.js";
import {
  n as n2
} from "./chunk-4CZO65BK.js";
import "./chunk-SVCGLUNW.js";
import {
  b
} from "./chunk-3KEIFTQ6.js";
import "./chunk-DEZCXTA3.js";
import {
  h
} from "./chunk-RRJGZKNX.js";
import "./chunk-PL5Q4C6Y.js";
import "./chunk-A6VKJXIH.js";
import "./chunk-KFSY6ZZH.js";
import "./chunk-7EQSYZHW.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import "./chunk-4OR73Y2R.js";
import "./chunk-EKJ2DJIR.js";
import {
  M,
  m as m2
} from "./chunk-TEHNQYQD.js";
import {
  O,
  P,
  _,
  e as e2,
  g,
  o as o2,
  r as r2,
  s as s2,
  u,
  v,
  z
} from "./chunk-TPJLFGOT.js";
import {
  n,
  r,
  t as t3
} from "./chunk-CQX57DED.js";
import {
  a2 as a3
} from "./chunk-3CQBBMMD.js";
import "./chunk-2CTB7MKH.js";
import "./chunk-Z2ZUNW5S.js";
import "./chunk-7L7Z2HXM.js";
import "./chunk-75NKPXTR.js";
import "./chunk-EUVARFSM.js";
import "./chunk-3VUFACNT.js";
import {
  x2 as x
} from "./chunk-ZEEBL7ZN.js";
import "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-5EXFDBQJ.js";
import "./chunk-57CHUY45.js";
import "./chunk-SJ2GJCS2.js";
import {
  U,
  l as l3,
  w
} from "./chunk-H7RDAEPY.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-S5OISW44.js";
import "./chunk-7KH4CLS5.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-JL3TJGVW.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import {
  s as s4
} from "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import {
  l as l2
} from "./chunk-MP6GH2AC.js";
import {
  A,
  m,
  t2 as t,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import {
  a
} from "./chunk-3R7FAT25.js";
import {
  t as t2
} from "./chunk-7I33FAWS.js";
import {
  c,
  f,
  l,
  o
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  has
} from "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/analysis/SlicePlane.js
var c6 = class extends i(l2) {
  constructor(o5) {
    super(o5), this.type = "plane", this.position = null, this.heading = 0, this.tilt = 0, this.width = 10, this.height = 10;
  }
  equals(o5) {
    return this.heading === o5.heading && this.tilt === o5.tilt && c(this.position, o5.position) && this.width === o5.width && this.height === o5.height;
  }
};
e([y({ readOnly: true, json: { read: false, write: true } })], c6.prototype, "type", void 0), e([y({ type: x }), g3()], c6.prototype, "position", void 0), e([y({ type: Number, nonNullable: true, range: { min: 0, max: 360 } }), g3(), s4((o5) => s3.normalize(a(o5), 0, true))], c6.prototype, "heading", void 0), e([y({ type: Number, nonNullable: true, range: { min: 0, max: 360 } }), g3(), s4((o5) => s3.normalize(a(o5), 0, true))], c6.prototype, "tilt", void 0), e([y({ type: Number, nonNullable: true }), g3()], c6.prototype, "width", void 0), e([y({ type: Number, nonNullable: true }), g3()], c6.prototype, "height", void 0), c6 = e([a2("esri.analysis.SlicePlane")], c6);
var h5 = c6;

// node_modules/@arcgis/core/views/3d/analysis/Slice/settings.js
var r7 = class {
  constructor() {
    this.color = i6();
  }
};
var c7 = class {
  constructor() {
    this.color = new h([0, 0, 0, 0.04]), this.gridColor = i6(0.5), this.outlineColor = i6(0.7);
  }
};
var i8 = class {
  constructor() {
    this.color = i6();
  }
};
var l8 = class {
  constructor() {
    this.color = i6(0.5), this.contrastColor = u3();
  }
};
var n8 = class {
  constructor() {
    this.color = u3(), this.outlineColor = i6();
  }
};
var e7 = class {
  constructor() {
    this.callouts = new r7(), this.plane = new c7(), this.resizeManipulators = new i8(), this.rotateManipulators = new l8(), this.shiftManipulator = new n8();
  }
};
var a7 = new e7();

// node_modules/@arcgis/core/views/3d/analysis/Slice/sliceToolConfig.js
var t11 = has("mac") ? "Meta" : "Control";
var r8 = "Shift";
var s7 = 2;
var a8 = 1.15;
var c8 = 1.15;
var m3 = 2500;
var h6 = 0.02;
var e8 = Math.cos(M(45));
var i9 = Math.cos(M(5));
var f5 = 0.95;
var p2 = 0.3;
var M2 = 2;
var j = 1;
var l9 = 3;
var n9 = 11;
var x3 = 22.5;
var C2 = 40;
var S = 48;
var U4 = 2.25;
var b2 = 4;
var d5 = 1;
var g5 = 0.3;
var k = 6;
var q2 = 4;
var u5 = 1600;
var v3 = 0.4;

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/SlicePlaneMaterialTechnique.js
var h7 = class extends n5 {
  constructor() {
    super(...arguments), this.backgroundColor = r4(1, 0, 0, 0.5), this.gridColor = r4(0, 1, 0, 0.5), this.gridWidth = 4;
  }
};
var u6 = class _u extends e4 {
  initializeProgram(e9) {
    return new i5(e9.rctx, _u.shader.get().build(this.configuration), E);
  }
  initializePipeline() {
    return W2({ blending: l6(R2.ONE, R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE_MINUS_SRC_ALPHA), depthTest: { func: I.LESS }, colorWrite: _2 });
  }
};
u6.shader = new t6(g4, () => import("./SlicePlaneMaterial.glsl-57SI7U34.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/SlicePlaneMaterial.js
var l10 = class extends e5 {
  constructor(r9) {
    super(r9, new m4()), this._configuration = new t7();
  }
  createBufferWriter() {
    return new r5(c5);
  }
  requiresSlot(e9, t12) {
    return t12 === h3.Color && e9 === E2.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL;
  }
  createGLMaterial(r9) {
    return new f6(r9);
  }
  getConfiguration() {
    return this._configuration;
  }
};
var f6 = class extends t5 {
  constructor(r9) {
    super(r9), this.ensureTechnique(u6, null);
  }
  beginSlot() {
    return this.technique;
  }
};
var m4 = class extends h7 {
  constructor() {
    super(...arguments), this.renderOccluded = o4.Occlude;
  }
};

// node_modules/@arcgis/core/views/3d/interactive/visualElements/SlicePlaneVisualElement.js
var s8 = class extends a4 {
  constructor(r9) {
    super(r9), this._material = null, this._renderOccluded = o4.OccludeAndTransparent, this._gridWidth = 1, this._gridColor = r4(1, 0, 0, 1), this._backgroundColor = r4(1, 0, 0, 1), this.applyProps(r9);
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(r9) {
    r9 !== this._renderOccluded && (this._renderOccluded = r9, this._updateMaterial());
  }
  get gridWidth() {
    return this._gridWidth;
  }
  set gridWidth(r9) {
    this._gridWidth !== r9 && (this._gridWidth = r9, this._updateMaterial());
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(e9) {
    a3(this._gridColor, e9), this._updateMaterial();
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(e9) {
    a3(this._backgroundColor, e9), this._updateMaterial();
  }
  createExternalResources() {
    this._material = new l10(this._materialParameters);
  }
  destroyExternalResources() {
    this._material = null;
  }
  forEachExternalMaterial(r9) {
    null != this._material && r9(this._material);
  }
  createGeometries(r9) {
    if (null != this._material) {
      const e9 = ht(this._material);
      r9.addGeometry(e9);
    }
  }
  get _materialParameters() {
    return { backgroundColor: this._backgroundColor, gridWidth: this._gridWidth, gridColor: this._gridColor, renderOccluded: this._renderOccluded };
  }
  _updateMaterial() {
    null != this._material && this._material.setParameters(this._materialParameters);
  }
};

// node_modules/@arcgis/core/views/3d/analysis/Slice/sliceToolUtils.js
function vt(t12, e9, n10, o5, i10, r9, s10, a9) {
  return Nt(e9, s10.worldUpAtPosition(t12, c4.get()), i10, r9, a9.basis1, a9.basis2), g(a9.basis1, a9.basis1, n10), g(a9.basis2, a9.basis2, o5), r2(a9.origin, t12), P2(a9.basis2, a9.basis1, a9.origin, a9.plane), a9;
}
function Nt(t12, e9, n10, o5, i10, r9) {
  const s10 = P(t12, e9), a9 = c4.get(), c10 = c4.get();
  switch (o5 === ge.HORIZONTAL_OR_VERTICAL ? Math.abs(s10) > e8 ? ge.HORIZONTAL : ge.VERTICAL : o5) {
    case ge.VERTICAL: {
      const o6 = Math.abs(s10) <= i9 ? t12 : n10.viewUp;
      _(a9, o6, e9), r2(c10, e9);
      break;
    }
    case ge.HORIZONTAL:
      _(a9, n10.viewUp, e9), _(c10, e9, a9);
      break;
    case ge.TILTED: {
      const o6 = Math.abs(s10) <= i9 ? e9 : n10.viewUp;
      _(a9, o6, t12), _(c10, t12, a9);
      break;
    }
  }
  const l11 = _(c4.get(), a9, c10);
  P(l11, n10.viewForward) > 0 && g(c10, c10, -1), z(i10, a9), z(r9, c10);
}
function Vt(t12, e9, n10) {
  const o5 = e9.worldUpAtPosition(t12.origin, c4.get()), i10 = t12.basis1, r9 = ae(t12, o5), s10 = Math.round(r9 / he) * he;
  return ms(t12, s10 - r9, i10, n10);
}
function yt(t12, e9, n10, o5, i10, r9) {
  const s10 = r2(c4.get(), i10.origin);
  u(s10, s10, g(c4.get(), i10.basis1, t12.direction[0] < 0 ? 1 : -1)), u(s10, s10, g(c4.get(), i10.basis2, t12.direction[1] < 0 ? 1 : -1));
  const a9 = s2(i10.basis1), c10 = s2(i10.basis2), l11 = e2(c4.get(), n10, s10), u7 = e2(c4.get(), e9, s10);
  let d6 = 0, m6 = 0;
  if ($t(t12)) {
    const e10 = zt(i10), n11 = zt(r9);
    d6 = a9 - 0.5 * t12.direction[0] * P(i10.basis1, u7) / a9, m6 = c10 - 0.5 * t12.direction[1] * P(i10.basis2, u7) / c10;
    const o6 = n11 / e10;
    d6 *= o6, m6 *= o6;
  }
  const p3 = d6 + 0.5 * t12.direction[0] * P(i10.basis1, l11) / a9, g7 = m6 + 0.5 * t12.direction[1] * P(i10.basis2, l11) / c10, f8 = g(c4.get(), i10.basis1, p3 / a9), w2 = g(c4.get(), i10.basis2, g7 / c10);
  (p3 <= 0 || Wt(r9.origin, f8, o5) <= u5) && r2(f8, r9.basis1), (g7 <= 0 || Wt(r9.origin, w2, o5) <= u5) && r2(w2, r9.basis2);
  const O2 = r2(c4.get(), s10);
  return u(O2, O2, g(c4.get(), f8, t12.direction[0] < 0 ? -1 : 1)), u(O2, O2, g(c4.get(), w2, t12.direction[1] < 0 ? -1 : 1)), H(O2, f8, w2, r9);
}
function St(t12, e9) {
  return v3 * Math.min(e9.width, e9.height) * e9.computeRenderPixelSizeAt(t12);
}
function Gt(t12, e9, n10, o5) {
  const i10 = _(c4.get(), e9, n10);
  return _(i10, i10, e9), T(t12, i10, o5);
}
function kt(t12, e9) {
  return N(t12.basis1, t12.basis2, t12.origin, e9);
}
function Ht(t12, e9, n10, o5) {
  const i10 = e9.worldUpAtPosition(t12.origin, c4.get()), r9 = c4.get();
  switch (n10) {
    case pe.HEADING:
      r2(r9, i10);
      break;
    case pe.TILT:
      r2(r9, t12.basis1);
  }
  return T(t12.origin, r9, o5);
}
function Bt(t12, e9, n10, o5) {
  const i10 = Zt(n10, Yt.NEGATIVE_X), a9 = f3.get();
  x2(a9, e9, i10.edge * Math.PI / 2);
  const c10 = z(c4.get(), i10.basis);
  let l11 = g(c4.get(), c10, i10.direction * o5.computeScreenPixelSizeAt(i10.position) * C2);
  u(l11, l11, i10.position);
  const u7 = o5.projectToRenderScreen(l11, p(c4.get())), d6 = xt(o5, u7);
  s6(o5, u7, be), z(be.direction, be.direction);
  const m6 = c4.get();
  !d6 && ss(n10, be, m6) && (l11 = m6), a9[12] = 0, a9[13] = 0, a9[14] = 0, t12.modelTransform = a9, t12.renderLocation = t3(l11), d6 ? t12.state |= fe : t12.state &= ~fe;
}
function xt(t12, e9) {
  const [n10, o5, i10, r9] = t12.viewport, s10 = Math.min(i10, r9) / 16;
  let a9 = true;
  return e9[0] < n10 + s10 ? (e9[0] = n10 + s10, a9 = false) : e9[0] > n10 + i10 - s10 && (e9[0] = n10 + i10 - s10, a9 = false), e9[1] < o5 + s10 ? (e9[1] = o5 + s10, a9 = false) : e9[1] > o5 + r9 - s10 && (e9[1] = o5 + r9 - s10, a9 = false), a9;
}
function Ft(t12, e9, n10, o5) {
  const i10 = s2(o5.basis1), r9 = s2(o5.basis2), s10 = qt(o5), u7 = zt(o5), d6 = o2(c4.get(), 0, 0, 0);
  u(d6, g(c4.get(), o5.basis1, e9.direction[0]), g(c4.get(), o5.basis2, e9.direction[1])), u(d6, o5.origin, d6);
  let m6 = 0, p3 = 1;
  if ($t(e9))
    1 === e9.direction[0] && -1 === e9.direction[1] ? m6 = he : 1 === e9.direction[0] && 1 === e9.direction[1] ? m6 = Math.PI : -1 === e9.direction[0] && 1 === e9.direction[1] && (m6 = 3 * Math.PI / 2), p3 = u7;
  else {
    const t13 = 0 !== e9.direction[0] ? 1 : 2;
    m6 = 1 === t13 ? he : 0, p3 = (1 === t13 ? r9 : i10) - s10;
  }
  const g7 = R(f3.get(), m6);
  f2(g7, g7, o2(c4.get(), p3, p3, p3)), c2(g7, n10, g7), g7[12] = 0, g7[13] = 0, g7[14] = 0, t12.modelTransform = g7, t12.renderLocation = d6;
}
function Xt(t12, e9, n10, o5) {
  const i10 = o5.worldUpAtPosition(n10.origin, c4.get()), r9 = Zt(n10, Yt.POSITIVE_X), s10 = R(f3.get(), r9.edge * Math.PI / 2);
  l4(s10, s10, -ae(n10, i10)), c2(s10, e9, s10), s10[12] = 0, s10[13] = 0, s10[14] = 0, t12.modelTransform = s10, t12.renderLocation = r9.position;
}
function Dt(t12, e9, n10) {
  const o5 = Zt(n10, Yt.POSITIVE_Y), i10 = R(f3.get(), o5.edge * Math.PI / 2);
  l4(i10, i10, he), c2(i10, e9, i10), i10[12] = 0, i10[13] = 0, i10[14] = 0, t12.modelTransform = i10, t12.renderLocation = o5.position;
}
var Yt;
function Zt(t12, e9) {
  switch (e9) {
    case Yt.POSITIVE_X:
      return { basis: t12.basis1, direction: 1, position: u(c4.get(), t12.origin, t12.basis1), edge: e9 };
    case Yt.POSITIVE_Y:
      return { basis: t12.basis2, direction: 1, position: u(c4.get(), t12.origin, t12.basis2), edge: e9 };
    case Yt.NEGATIVE_X:
      return { basis: t12.basis1, direction: -1, position: e2(c4.get(), t12.origin, t12.basis1), edge: e9 };
    case Yt.NEGATIVE_Y:
      return { basis: t12.basis2, direction: -1, position: e2(c4.get(), t12.origin, t12.basis2), edge: e9 };
  }
}
function Wt(t12, e9, n10) {
  const o5 = n10.projectToRenderScreen(u(c4.get(), t12, e9), p(c4.get())), i10 = n10.projectToRenderScreen(e2(c4.get(), t12, e9), p(c4.get()));
  return v(e2(o5, o5, i10));
}
function qt(t12) {
  const e9 = s2(t12.basis1), n10 = s2(t12.basis2);
  return g5 * Math.min(e9, n10);
}
function zt(t12) {
  return qt(t12);
}
function $t(t12) {
  return 0 !== t12.direction[0] && 0 !== t12.direction[1];
}
function Jt(e9, n10) {
  const o5 = n10.offsetMode === Oe.CENTER_ON_CALLOUT ? C2 : 0, i10 = [r(o5, 0, -S / 2), r(o5, 0, S / 2)], r9 = ie(i10, true), s10 = (t12, e10) => ne(i10, t12, e10, n10), a9 = s10(0, false), c10 = s10(U4, true), l11 = new X({ color: h.toUnitRGBA(n10.calloutColor), renderOccluded: o4.OccludeAndTransparent }), u7 = pt(l11, [[o5, 0, 0], [o5 - C2, 0, 0]]), d6 = pt(l11, [[o5, 0, 0], [o5 - C2, 0, 0]]);
  return new $({ view: e9, renderObjects: [...a9.normal.map((t12) => new e6(t12, t8.Unfocused | me)), ...c10.normal.map((t12) => new e6(t12, t8.Unfocused | me)), new e6(u7, t8.Unfocused | me | fe), ...a9.focused.map((t12) => new e6(t12, t8.Focused | me)), ...c10.focused.map((t12) => new e6(t12, t8.Focused | me)), new e6(d6, t8.Focused | me | fe)], autoScaleRenderObjects: false, collisionType: { type: "line", paths: [r9] }, collisionPriority: 1, radius: n9, state: me });
}
function Kt(e9, n10) {
  const o5 = R4(e9, { calloutColor: h.toUnitRGBA(a7.callouts.color), customStateMask: me, texture: n10 });
  return o5.state = me, o5;
}
function Qt(e9) {
  const n10 = [[-1, -1, 0], [1, -1, 0], [1, 1, 0], [-1, 1, 0], [-1, -1, 0]];
  return new u4({ view: e9, attached: false, color: h.toUnitRGBA(a7.plane.outlineColor), width: j, renderOccluded: o4.OccludeAndTransparent, geometry: [n10] });
}
function te(e9) {
  return new s8({ view: e9, attached: false, backgroundColor: h.toUnitRGBA(a7.plane.color), gridColor: h.toUnitRGBA(a7.plane.gridColor), gridWidth: 4, renderOccluded: o4.OccludeAndTransparent });
}
function ee(e9, n10, o5) {
  const i10 = $t(n10), r9 = i10 ? [r(1, 0, 0), r(0, 0, 0), r(0, 1, 0)] : [r(1, 0, 0), r(-1, 0, 0)], s10 = h.toUnitRGBA(o5.color), a9 = (t12) => new B({ color: s10, width: t12, renderOccluded: o4.OccludeAndTransparent }), c10 = () => new X({ color: s10, renderOccluded: o4.OccludeAndTransparent }), l11 = i10 ? b2 : d5, u7 = l11 * s7, d6 = d5, m6 = (t12) => t12 > 1 ? a9(t12) : c10(), p3 = [new e6(pt(m6(l11), r9), t8.Unfocused | Te), new e6(pt(m6(u7), r9), t8.Focused | Te), new e6(pt(m6(d6), r9), we)], g7 = new $({ view: e9, renderObjects: p3, collisionType: { type: "line", paths: [r9] }, radius: i10 ? k : q2, ...U2 });
  return g7.state = Te, g7;
}
function ne(e9, n10, o5, i10) {
  const r9 = h.blendColors(i10.color, i10.outlineColor, 0.4), s10 = h.blendColors(i10.color, i10.outlineColor, 0.14), a9 = new f4({ color: h.toUnitRGBA(i10.color), cullFace: n4.Back, renderOccluded: o4.Opaque }), u7 = new f4({ color: h.toUnitRGBA(r9), cullFace: n4.Back, renderOccluded: o4.Opaque }), h9 = new f4({ color: h.toUnitRGBA(s10), cullFace: n4.Back, renderOccluded: o4.Opaque }), T2 = new f4({ color: h.toUnitRGBA(i10.outlineColor), transparent: true, writeDepth: false, cullFace: n4.Front, renderOccluded: o4.Transparent }), w2 = (t12) => {
    const i11 = e9.slice(0), r10 = e2(c4.get(), i11[0], i11[1]);
    z(r10, r10);
    const s11 = e2(c4.get(), i11[i11.length - 1], i11[i11.length - 2]);
    if (z(s11, s11), n10 > 0) {
      const t13 = g(n(), s11, -n10);
      i11[i11.length - 1] = u(t13, t13, i11[i11.length - 1]);
      const e10 = g(n(), r10, -n10);
      i11[0] = u(e10, e10, i11[0]);
    }
    const w3 = t12 ? c8 : 1, R5 = x3 * w3, j2 = n9 * w3, C3 = r3(f3.get());
    if (n10 > 0) {
      const t13 = R5 / 4, e10 = o2(c4.get(), 0, t13, 0), o6 = 1 + n10 / t13;
      i2(C3, C3, e10), f2(C3, C3, o2(c4.get(), o6, o6, o6)), i2(C3, C3, g(e10, e10, -1 / o6));
    }
    const L2 = r3(e3()), M4 = r(0, 1, 0), P4 = A2(e3(), Q(o3.get(), M4, s11));
    P4[12] = i11[i11.length - 1][0], P4[13] = i11[i11.length - 1][1], P4[14] = i11[i11.length - 1][2], c2(P4, P4, C3);
    const v4 = oe(l9 * (t12 ? a8 : 1) + n10, i11, o5 ? T2 : h9);
    v4.transformation = L2;
    const N2 = [v4], V2 = lt(o5 ? T2 : a9, R5, j2, 24, false, false, true);
    V2.transformation = P4, N2.push(V2);
    const y3 = lt(o5 ? T2 : u7, R5, j2, 24, false, true, false);
    y3.transformation = P4, N2.push(y3);
    const S3 = A2(e3(), Q(o3.get(), M4, r10));
    return S3[12] = i11[0][0], S3[13] = i11[0][1], S3[14] = i11[0][2], c2(S3, S3, C3), N2.push(V2.instantiate({ transformation: S3 })), N2.push(y3.instantiate({ transformation: S3 })), N2;
  };
  return { normal: w2(false), focused: w2(true) };
}
function oe(t12, e9, n10) {
  const o5 = [], i10 = 12;
  for (let r9 = 0; r9 < i10; r9++) {
    const e10 = r9 / i10 * 2 * Math.PI;
    o5.push([Math.cos(e10) * t12, Math.sin(e10) * t12]);
  }
  return at(n10, o5, e9, [], [], false);
}
function ie(t12, e9) {
  const n10 = e2(n(), t12[t12.length - 1], t12[t12.length - 2]);
  if (z(n10, n10), g(n10, n10, x3), u(n10, n10, t12[t12.length - 1]), e9) {
    const e10 = e2(n(), t12[0], t12[1]);
    return z(e10, e10), g(e10, e10, x3), u(e10, e10, t12[0]), [e10, ...t12, n10];
  }
  return [...t12, n10];
}
function re(t12, n10, i10, r9 = new h5()) {
  if (null == t12)
    return null;
  const { renderCoordsHelper: s10 } = n10, a9 = s10.fromRenderCoords(t12.origin, n10.spatialReference);
  if (null == a9)
    return null;
  const c10 = En(a9, i10);
  if (null == c10)
    return null;
  r9.position = c10;
  const l11 = 2 * s2(t12.basis1), u7 = 2 * s2(t12.basis2), d6 = U3.renderUnitScaleFactor(n10.spatialReference, i10);
  r9.width = l11 * d6, r9.height = u7 * d6;
  const m6 = s10.worldUpAtPosition(t12.origin, c4.get());
  return r9.tilt = m2(ae(t12, m6)), r9.heading = s10.headingAtPosition(t12.origin, t12.basis1) - 90, r9;
}
function ae(t12, e9) {
  return i4(e9, t12.basis2, t12.basis1) + he;
}
function ce(t12, e9, o5, r9, s10, a9, c10 = W3()) {
  return a9.toRenderCoords(t12, c10.origin) ? (a9.worldBasisAtPosition(c10.origin, n3.X, c10.basis1), a9.worldBasisAtPosition(c10.origin, n3.Y, c10.basis2), P2(c10.basis2, c10.basis1, c10.origin, c10.plane), ms(c10, -M(e9), ds(c10), c10), ms(c10, M(o5), c10.basis1, c10), g(c10.basis1, c10.basis1, r9 / 2), g(c10.basis2, c10.basis2, s10 / 2), J(c10), c10) : (s.getLogger("esri.views.3d.analysis.Slice.sliceToolUtils").error(`Failed to project slice plane position, projection from ${t12.spatialReference.wkid} is not supported`), null);
}
function le(t12, e9) {
  if (null == t12 || null == t12.position)
    return null;
  const n10 = r6(t12.position, e9.spatialReference, e9.elevationProvider);
  if (null == n10)
    return null;
  const o5 = U3.renderUnitScaleFactor(t12.position.spatialReference, e9.spatialReference), i10 = t12.width * o5, r9 = t12.height * o5;
  return { position: n10, heading: t12.heading, tilt: t12.tilt, renderWidth: i10, renderHeight: r9 };
}
function de(t12, e9, n10, o5 = W3()) {
  if (null == t12)
    return null;
  const i10 = ce(t12.position, t12.heading, t12.tilt, t12.renderWidth, t12.renderHeight, e9.renderCoordsHelper, o5);
  return n10.tiltEnabled || null == i10 || Vt(i10, e9.renderCoordsHelper, i10), i10;
}
!function(t12) {
  t12[t12.POSITIVE_X = 0] = "POSITIVE_X", t12[t12.POSITIVE_Y = 1] = "POSITIVE_Y", t12[t12.NEGATIVE_X = 2] = "NEGATIVE_X", t12[t12.NEGATIVE_Y = 3] = "NEGATIVE_Y";
}(Yt || (Yt = {}));
var me = u2.Custom1;
var pe;
var ge;
!function(t12) {
  t12[t12.HEADING = 1] = "HEADING", t12[t12.TILT = 2] = "TILT";
}(pe || (pe = {})), function(t12) {
  t12[t12.HORIZONTAL_OR_VERTICAL = 0] = "HORIZONTAL_OR_VERTICAL", t12[t12.HORIZONTAL = 1] = "HORIZONTAL", t12[t12.VERTICAL = 2] = "VERTICAL", t12[t12.TILTED = 3] = "TILTED";
}(ge || (ge = {}));
var fe = u2.Custom2;
var be = d3();
var he = Math.PI / 2;
var Te = u2.Custom1;
var we = u2.Custom2;
var Oe;
function Ae(t12) {
  return null != ("building-scene-3d" === t12.type ? t12 : null);
}
!function(t12) {
  t12[t12.CENTER_ON_CALLOUT = 0] = "CENTER_ON_CALLOUT", t12[t12.CENTER_ON_ARROW = 1] = "CENTER_ON_ARROW";
}(Oe || (Oe = {}));

// node_modules/@arcgis/core/views/3d/terrain/isTerrainSurfaceLayer.js
function s9(s10) {
  switch (s10.type) {
    case "building-scene":
    case "csv":
    case "dimension":
    case "feature":
    case "geo-rss":
    case "geojson":
    case "graphics":
    case "group":
    case "integrated-mesh":
    case "kml":
    case "knowledge-graph":
    case "link-chart":
    case "knowledge-graph-sublayer":
    case "line-of-sight":
    case "map-notes":
    case "ogc-feature":
    case "oriented-imagery":
    case "point-cloud":
    case "route":
    case "scene":
    case "stream":
    case "voxel":
    case "subtype-group":
    case "unknown":
    case "unsupported":
    case "wfs":
    case null:
      return false;
    case "base-dynamic":
    case "base-elevation":
    case "base-tile":
    case "bing-maps":
    case "elevation":
    case "imagery":
    case "imagery-tile":
    case "map-image":
    case "media":
    case "open-street-map":
    case "tile":
    case "vector-tile":
    case "video":
    case "wcs":
    case "web-tile":
    case "wms":
    case "wmts":
      return true;
    default:
      return n2(s10.type), false;
  }
}

// node_modules/@arcgis/core/views/3d/analysis/Slice/SliceController.js
var f7 = "esri.views.3d.analysis.Slice.SliceController";
var m5 = s.getLogger(f7);
var _3 = class extends m {
  constructor(e9) {
    super(e9), this._handles = new t(), this._internalChange = false, this._currentSlicePlane = null;
  }
  initialize() {
    this._handles.add(this.analysis.excludedLayers.on("before-add", (e9) => {
      const i10 = e9.item;
      null != i10 && (i10 instanceof b || i10 instanceof C) ? i10 instanceof b && s9(i10) ? (m5.error("excludedLayers", `Layer '${i10.title}, id:${i10.id}' of type '${i10.type}' can not be individually excluded from slicing. Use 'excludeGroundSurface' instead.`), e9.preventDefault()) : this.analysis.excludedLayers.includes(i10) && e9.preventDefault() : (m5.error("excludedLayers", "Invalid layer type, layer must derive from Layer or BuildingComponentSublayer"), e9.preventDefault());
    })), b3(this.view, this), this._handles.add([l3(() => this.analysisViewData.plane, () => {
      this._internalChange || this._updateSlicePlaneFromBoundedPlane(), this._updateLayerViews();
    }, { sync: true }), l3(() => this.analysis.excludeGroundSurface, () => this._updateLayerViews(), { sync: true }), this.analysis.excludedLayers.on("change", () => this._updateLayerViews()), l3(() => [this.analysisViewData.active, this.analysisViewData.visible], () => {
      this._updateActiveController(), this._updateViewSlicePlane();
    }, { sync: true }), l3(() => this._allLayerAndSubLayerViews, () => this._updateLayerViews())]), this._handles.add([l3(() => this.analysis.shape, () => {
      this._internalChange || (this._updateBoundedPlaneFromSlicePlane(), this._updateViewSlicePlane());
    }, { sync: true })], "analysis"), this._updateActiveController(), this._updateBoundedPlaneFromSlicePlane(), this._updateViewSlicePlane();
  }
  destroy() {
    this.analysisViewData.active && (this.analysisViewData.active = false, this.view.slicePlane = null), L(this.view, this), this._handles.destroy(), this.set("view", null);
  }
  get _allLayerAndSubLayerViews() {
    const e9 = this.view.allLayerViews.items;
    return e9.concat(e9.filter(Ae).flatMap(({ sublayerViews: e10 }) => e10.items));
  }
  _updateBoundedPlaneFromSlicePlane() {
    const e9 = this.analysis.shape, i10 = this._currentSlicePlane;
    if (null == i10 && null == e9 || null != i10 && null != e9 && e9.equals(i10))
      return;
    let a9 = null, t12 = null;
    if (null != e9 && null != e9.position) {
      const i11 = e9.position.spatialReference, l11 = le(e9, this.view);
      null == l11 && t10(this.analysis, i11, m5), a9 = de(l11, this.view, { tiltEnabled: this.analysis.tiltEnabled }, W3()), null != a9 && (t12 = { heading: e9.heading, tilt: e9.tilt, position: e9.position, width: e9.width, height: e9.height });
    }
    this._currentSlicePlane = t12, this._internalChange = true, this.analysisViewData.plane = a9, this._internalChange = false;
  }
  _updateSlicePlaneFromBoundedPlane() {
    const e9 = this.analysisViewData.plane, a9 = re(e9, this.view, this.view.spatialReference, new h5());
    let t12 = null;
    null != a9 && (t12 = { heading: a9.heading, tilt: a9.tilt, position: a9.position, width: a9.width, height: a9.height }), this._currentSlicePlane = t12, this._internalChange = true, this.analysis.shape = a9, this._internalChange = false, this._updateViewSlicePlane();
  }
  _updateActiveController() {
    if (g6)
      return;
    const e9 = P3(this.view);
    if (!e9)
      return;
    if (this.analysisViewData.active)
      null != e9.activeController && e9.activeController !== this ? (g6 = true, e9.activeController.analysisViewData.active = false, g6 = false) : null != e9.activeController && e9.activeController, this._updateLayerViews(), e9.activeController = this;
    else {
      if (null != e9.activeController && e9.activeController !== this)
        return;
      null != e9.activeController && e9.activeController === this && (e9.activeController = null, this._updateLayerViews());
    }
  }
  _updateViewSlicePlane() {
    S2(this.view);
  }
  _updateLayerViews() {
    const e9 = null != this.analysisViewData.plane && this.analysisViewData.visible && this.analysisViewData.active, i10 = [], a9 = (e10) => {
      "layers" in e10 ? e10.layers.forEach(a9) : i10.push(e10);
    };
    this.analysis.excludedLayers.forEach(a9), this.view.allLayerViews.forEach((a10) => {
      a10.destroyed || ("slicePlaneEnabled" in a10 && (a10.slicePlaneEnabled = e9 && !i10.includes(a10.layer)), "sublayerViews" in a10 && a10.sublayerViews.forEach((a11) => {
        a11.slicePlaneEnabled = e9 && !i10.includes(a11.sublayer);
      }));
    }), null != this.view.basemapTerrain && (this.view.basemapTerrain.slicePlaneEnabled = e9 && !this.analysis.excludeGroundSurface);
  }
};
e([y()], _3.prototype, "view", void 0), e([y()], _3.prototype, "analysis", void 0), e([y()], _3.prototype, "analysisViewData", void 0), e([y()], _3.prototype, "_allLayerAndSubLayerViews", null), _3 = e([a2(f7)], _3);
var V = /* @__PURE__ */ new Map();
var g6 = false;
function S2(e9) {
  const i10 = P3(e9), a9 = i10 == null ? void 0 : i10.activeController;
  null != a9 && null != a9.analysisViewData.plane && a9.analysisViewData.visible ? e9.slicePlane = a9.analysisViewData.plane : e9.slicePlane = null;
}
function b3(e9, i10) {
  var _a;
  V.has(e9) || V.set(e9, { all: [], activeController: null }), (_a = V.get(e9)) == null ? void 0 : _a.all.push(i10);
}
function P3(e9) {
  return V.get(e9);
}
function L(e9, i10) {
  if (!V.has(e9))
    throw new Error("view expected in global slice register");
  const a9 = V.get(e9), t12 = (a9 == null ? void 0 : a9.all.lastIndexOf(i10)) ?? -1;
  if (!a9 || -1 === t12)
    throw new Error("controller expected in global slice register");
  a9.all.splice(t12, 1), 0 === a9.all.length && V.delete(e9);
}

// node_modules/@arcgis/core/views/3d/analysis/Slice/SliceTool.js
var kt2;
var Et = kt2 = class extends a5 {
  constructor(t12) {
    super(t12), this._clock = t2, this._previewPlaneOpacity = 1, this.removeIncompleteOnCancel = false, this.layersMode = "none", this.shiftManipulator = null, this.rotateHeadingManipulator = null, this.rotateTiltManipulator = null, this.resizeManipulators = null, this._handles = new t(), this._viewHandles = new t(), this._frameTask = null, this._pointerMoveTimerMs = m3, this._prevPointerMoveTimeout = null, this._previewPlaneGridVisualElement = null, this._previewPlaneOutlineVisualElement = null, this._startPlane = W3(), this._previewPlane = null, this._activeKeyModifiers = {}, this._lastCursorPosition = c3(), this._resizeHandles = [{ direction: [1, 0] }, { direction: [1, 1] }, { direction: [0, 1] }, { direction: [-1, 1] }, { direction: [-1, 0] }, { direction: [-1, -1] }, { direction: [0, -1] }, { direction: [1, -1] }], this._intersector = A3(t12.view.state.viewingMode), this._intersector.options.store = t9.MIN;
  }
  initialize() {
    var _a;
    if (null == this.analysis)
      throw new Error("SliceTool requires valid analysis, but null was provided.");
    const t12 = !((_a = this.view._stage) == null ? void 0 : _a.renderView.renderingContext.driverTest.svgPremultipliesAlpha.result), e9 = { accentColor: a7.rotateManipulators.color, contrastColor: a7.rotateManipulators.contrastColor, preMultiplyAlpha: t12 };
    this._rotateHeadingImage = n7(this.view.toolViewManager.textures, e9), this._rotateTiltImage = l7(this.view.toolViewManager.textures, e9);
    const i10 = (t13) => {
      this._updateManipulatorsInteractive(t13), t13.grabbing || (null != this.analysisViewData.plane && Z(this.analysisViewData.plane, this._startPlane), this.inputState = null);
    };
    this.shiftManipulator = Jt(this.view, { offsetMode: Oe.CENTER_ON_ARROW, calloutColor: a7.callouts.color, color: a7.shiftManipulator.color, outlineColor: a7.shiftManipulator.outlineColor }), this.manipulators.add(this.shiftManipulator), this.shiftManipulator.events.on("grab-changed", (t13) => {
      this._onShiftGrab(t13), i10(this.shiftManipulator);
    }), this._handles.add(this._createShiftDragPipeline(this.shiftManipulator)), this.rotateHeadingManipulator = Kt(this.view, this._rotateHeadingImage.texture), this.manipulators.add(this.rotateHeadingManipulator), this.rotateHeadingManipulator.events.on("grab-changed", (t13) => {
      this._onRotateHeadingGrab(t13), i10(this.rotateHeadingManipulator);
    }), this._handles.add(this._createRotateHeadingDragPipeline(this.rotateHeadingManipulator)), this.rotateTiltManipulator = Kt(this.view, this._rotateTiltImage.texture), this.manipulators.add(this.rotateTiltManipulator), this.rotateTiltManipulator.events.on("grab-changed", (t13) => {
      this._onRotateTiltGrab(t13), i10(this.rotateTiltManipulator);
    }), this._handles.add(this._createRotateTiltDragPipeline(this.rotateTiltManipulator)), this.resizeManipulators = this._resizeHandles.map((t13, e10) => {
      const a10 = ee(this.view, t13, { color: a7.resizeManipulators.color });
      return a10.events.on("grab-changed", (t14) => {
        this._onResizeGrab(t14, e10), i10(a10);
      }), this._handles.add(this._createResizeDragPipeline(a10)), a10;
    }), this.manipulators.addMany(this.resizeManipulators), this._previewPlaneGridVisualElement = te(this.view), this._previewPlaneOutlineVisualElement = Qt(this.view), this._previewPlaneOutlineVisualElement.width = M2, this._handles.add(l3(() => [this.analysisViewData.plane, this.analysis.tiltEnabled], () => this._updateManipulators(), U));
    const a9 = l3(() => this.state, (t13) => {
      "sliced" === t13 && this.finishToolCreation();
    }, w);
    this._handles.add([a9, l3(() => this.view.state.camera, () => this._onCameraChange())]);
  }
  destroy() {
    this._rotateHeadingImage = f(this._rotateHeadingImage), this._rotateTiltImage = f(this._rotateTiltImage), this._handles = l(this._handles), this._viewHandles = l(this._viewHandles), this._removeFrameTask(), this._clearPointerMoveTimeout(), this._previewPlaneOutlineVisualElement = l(this._previewPlaneOutlineVisualElement), this._previewPlaneGridVisualElement = l(this._previewPlaneGridVisualElement);
  }
  get state() {
    const t12 = !!this.analysisViewData.plane, e9 = !!this.inputState;
    return t12 ? t12 && e9 ? "slicing" : t12 && !e9 ? "sliced" : "ready" : "ready";
  }
  get cursor() {
    return this._isPlacingSlicePlane || "exclude" === this.layersMode ? "crosshair" : null != this._creatingPointerId ? "grabbing" : null;
  }
  set analysis(t12) {
    if (null == t12)
      throw new Error("SliceTool requires valid analysis, but null was provided.");
    this._handles.remove("analysis"), this._set("analysis", t12);
  }
  get inputState() {
    return this._get("inputState");
  }
  set inputState(t12) {
    this._set("inputState", t12), this.analysisViewData.showGrid = null != t12 && "resize" === t12.type, this._updateMaterials();
  }
  get _isPlacingSlicePlane() {
    return !this.inputState && !this.analysisViewData.plane && this.active;
  }
  get _creatingPointerId() {
    return null != this.inputState && "shift" === this.inputState.type ? this.inputState.creatingPointerId : null;
  }
  enterExcludeLayerMode() {
    null != this.analysisViewData.plane && (this._set("layersMode", "exclude"), this.active || (this.view.activeTool = this));
  }
  exitExcludeLayerMode() {
    null != this.analysisViewData.plane && (this._set("layersMode", "none"), this.active && (this.view.activeTool = null));
  }
  onDeactivate() {
    this._set("layersMode", "none"), this._updatePreviewPlane(null);
  }
  onShow() {
    this._updateVisibility(true);
  }
  onHide() {
    this._updateVisibility(false);
  }
  _updateVisibility(t12) {
    this._updateManipulators(), t12 || this._clearPointerMoveTimeout();
  }
  onInputEvent(t12) {
    switch (t12.type) {
      case "pointer-drag":
        if (!Ht2(t12))
          return;
        this._isPlacingSlicePlane ? this._onClickPlacePlane(t12) && t12.stopPropagation() : this._onPointerDrag(t12) && t12.stopPropagation();
        break;
      case "pointer-move":
        this._onPointerMove(t12);
        break;
      case "pointer-up":
        this._onPointerUp(t12) && t12.stopPropagation();
        break;
      case "immediate-click":
        if (!Ht2(t12))
          return;
        this._onClickPlacePlane(t12) && t12.stopPropagation();
        break;
      case "click":
        if (!Ht2(t12))
          return;
        this._onClickExcludeLayer(t12) && t12.stopPropagation();
        break;
      case "drag":
        this.inputState && t12.stopPropagation();
        break;
      case "key-down":
        this._onKeyDown(t12) && t12.stopPropagation();
        break;
      case "key-up":
        this._onKeyUp(t12) && t12.stopPropagation();
    }
  }
  onEditableChange() {
    this.analysisViewData.editable = this.internallyEditable;
  }
  _onPointerDrag(t12) {
    const e9 = this.inputState;
    if (t12.pointerId === this._creatingPointerId && null != e9 && "shift" === e9.type) {
      const i10 = n6(t12);
      return this.shiftManipulator.events.emit("drag", { action: e9.hasBeenDragged ? "update" : "start", pointerType: t12.pointerType, start: i10, screenPoint: i10 }), e9.hasBeenDragged = true, true;
    }
    return false;
  }
  _onPointerMove(t12) {
    this._lastCursorPosition.x = t12.x, this._lastCursorPosition.y = t12.y, this._resetPointerMoveTimeout(), "touch" !== t12.pointerType && this._updatePreviewPlane(n6(t12), this._activeKeyModifiers);
  }
  _onCameraChange() {
    this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), this._updateManipulators();
  }
  _onPointerUp(t12) {
    if (t12.pointerId === this._creatingPointerId && null != this.analysisViewData.plane) {
      const e9 = n6(t12);
      return this.shiftManipulator.events.emit("drag", { action: "end", start: e9, screenPoint: e9 }), Z(this.analysisViewData.plane, this._startPlane), this.inputState = null, true;
    }
    return false;
  }
  _onClickPlacePlane(t12) {
    if ("exclude" === this.layersMode)
      return false;
    if (this._isPlacingSlicePlane) {
      const e9 = n6(t12), a9 = W3();
      if (this._pickPlane(e9, false, this._activeKeyModifiers, a9)) {
        if ("pointer-drag" === t12.type) {
          const i10 = this._calculatePickRay(e9);
          this.inputState = St2(i10, t12.pointerId, a9.origin, a9);
        }
        return Z(a9, this._startPlane), this.analysis.shape = re(a9, this.view, this.view.spatialReference, new h5()), true;
      }
    }
    return false;
  }
  _onClickExcludeLayer(t12) {
    return !("exclude" !== this.layersMode || !this.created) && (this.view.hitTest(n6(t12)).then((t13) => {
      if (t13.results.length) {
        const e9 = t13.results[0], i10 = "graphic" === (e9 == null ? void 0 : e9.type) && e9.graphic;
        if (i10) {
          const t14 = i10.sourceLayer || i10.layer;
          t14 && this.analysis.excludedLayers.push(t14);
        }
      } else
        t13.ground.layer ? this.analysis.excludedLayers.push(t13.ground.layer) : this.analysis.excludeGroundSurface = true;
    }), this._set("layersMode", "none"), this.active && (this.view.activeTool = null), true);
  }
  _onKeyDown(t12) {
    return (t12.key === r8 || t12.key === t11) && (this._activeKeyModifiers[t12.key] = true, null != this._previewPlane && this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), true);
  }
  _onKeyUp(t12) {
    return !(t12.key !== r8 && t12.key !== t11 || !this._activeKeyModifiers[t12.key]) && (delete this._activeKeyModifiers[t12.key], null != this._previewPlane && this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), true);
  }
  _onShiftGrab(t12) {
    if ("start" !== t12.action || null == this.analysisViewData.plane || !t12.screenPoint)
      return;
    const e9 = this._calculatePickRay(t12.screenPoint);
    Z(this.analysisViewData.plane, this._startPlane), this.inputState = St2(e9, null, this.shiftManipulator.renderLocation, this.analysisViewData.plane);
  }
  _createShiftDragPipeline(t12) {
    return d4(t12, (t13, e9, i10) => {
      const a9 = this.inputState;
      if (null == a9 || "shift" !== a9.type)
        return;
      const s10 = null != this.analysisViewData.plane ? Z(this.analysisViewData.plane, W3()) : null;
      e9.next(H2(this.view, a9.shiftPlane)).next(this._shiftDragAdjustSensitivity(a9)).next(this._shiftDragUpdatePlane(a9)), i10.next(() => {
        null != s10 && this._updateBoundedPlane(s10);
      });
    });
  }
  _shiftDragAdjustSensitivity(t12) {
    return (e9) => {
      if (null == this.analysisViewData.plane)
        return null;
      const i10 = 1e-3, a9 = Math.min((1 - Math.abs(P(ds(this.analysisViewData.plane), e9.ray.direction) / s2(e9.ray.direction))) / i10, 1), s10 = -R3(this._startPlane.plane, e9.renderEnd), n10 = -R3(this._startPlane.plane, t12.startPoint);
      return t12.depth = t12.depth * (1 - a9) + s10 * a9 - n10, e9;
    };
  }
  _shiftDragUpdatePlane(t12) {
    return () => {
      if (null == this.analysisViewData.plane)
        return;
      const e9 = r2(c4.get(), this._startPlane.origin), i10 = r2(c4.get(), ds(this._startPlane));
      g(i10, i10, -t12.depth), u(i10, i10, e9);
      const a9 = H(i10, this.analysisViewData.plane.basis1, this.analysisViewData.plane.basis2, W3());
      this._updateBoundedPlane(a9);
    };
  }
  _onRotateHeadingGrab(t12) {
    if ("start" !== t12.action || null == this.analysisViewData.plane || !t12.screenPoint)
      return;
    const e9 = Ht(this.analysisViewData.plane, this.view.renderCoordsHelper, pe.HEADING, h2()), i10 = this._calculatePickRay(t12.screenPoint), a9 = n();
    q(e9, i10, a9) && (Z(this.analysisViewData.plane, this._startPlane), this.inputState = { type: "rotate", rotatePlane: e9, startPoint: a9 });
  }
  _createRotateHeadingDragPipeline(t12) {
    return d4(t12, (t13, e9, i10) => {
      const a9 = this.inputState;
      if (null == a9 || "rotate" !== a9.type)
        return;
      const s10 = null != this.analysisViewData.plane ? Z(this.analysisViewData.plane, W3()) : null;
      e9.next(H2(this.view, a9.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(a9)).next(this._rotateDragUpdatePlaneFromRotate()), i10.next(() => {
        null != s10 && this._updateBoundedPlane(s10);
      });
    });
  }
  _onRotateTiltGrab(t12) {
    if ("start" !== t12.action || null == this.analysisViewData.plane || !t12.screenPoint)
      return;
    const e9 = Ht(this.analysisViewData.plane, this.view.renderCoordsHelper, pe.TILT, h2()), i10 = this._calculatePickRay(t12.screenPoint), a9 = n();
    q(e9, i10, a9) && (Z(this.analysisViewData.plane, this._startPlane), this.inputState = { type: "rotate", rotatePlane: e9, startPoint: a9 });
  }
  _createRotateTiltDragPipeline(t12) {
    return d4(t12, (t13, e9, i10) => {
      const a9 = this.inputState;
      if (null == a9 || "rotate" !== a9.type)
        return;
      const s10 = null != this.analysisViewData.plane ? Z(this.analysisViewData.plane, W3()) : null;
      e9.next(H2(this.view, a9.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(a9)).next(this._rotateDragUpdatePlaneFromRotate()), i10.next(() => {
        null != s10 && this._updateBoundedPlane(s10);
      });
    });
  }
  _rotateDragRenderPlaneToRotate(t12) {
    return (e9) => {
      if (null == this.analysisViewData.plane)
        return null;
      const i10 = W(t12.rotatePlane), a9 = D(t12.startPoint, e9.renderEnd, this.analysisViewData.plane.origin, i10);
      return { ...e9, rotateAxis: i10, rotateAngle: a9 };
    };
  }
  _rotateDragUpdatePlaneFromRotate() {
    return (t12) => {
      if (null == this.analysisViewData.plane)
        return;
      const e9 = g2(f3.get(), t12.rotateAngle, t12.rotateAxis);
      if (null == e9)
        return;
      const i10 = O(c4.get(), this._startPlane.basis1, e9), a9 = O(c4.get(), this._startPlane.basis2, e9), s10 = H(this.analysisViewData.plane.origin, i10, a9, W3());
      this._updateBoundedPlane(s10);
    };
  }
  _onResizeGrab(t12, e9) {
    if ("start" !== t12.action || null == this.analysisViewData.plane || !t12.screenPoint)
      return;
    const i10 = this._calculatePickRay(t12.screenPoint), a9 = c4.get();
    q(this.analysisViewData.plane.plane, i10, a9) && (Z(this.analysisViewData.plane, this._startPlane), this.inputState = { type: "resize", activeHandleIdx: e9, startPoint: t3(a9) });
  }
  _createResizeDragPipeline(t12) {
    return d4(t12, (t13, e9, i10) => {
      const a9 = this.inputState;
      if (null == a9 || "resize" !== a9.type || null == this.analysisViewData.plane)
        return;
      const s10 = Z(this.analysisViewData.plane, W3());
      e9.next(H2(this.view, this.analysisViewData.plane.plane)).next(this._resizeDragUpdatePlane(a9)), i10.next(() => {
        this._updateBoundedPlane(s10);
      });
    });
  }
  _resizeDragUpdatePlane(t12) {
    return (e9) => {
      if (null == this.analysisViewData.plane)
        return;
      const i10 = this._resizeHandles[t12.activeHandleIdx], a9 = yt(i10, t12.startPoint, e9.renderEnd, this.view.state.camera, this._startPlane, Z(this.analysisViewData.plane));
      this._updateBoundedPlane(a9);
    };
  }
  _updateBoundedPlane(t12) {
    const e9 = this.analysisViewData;
    if (null == e9)
      throw new Error("valid internal object expected");
    e9.plane = t12;
  }
  _updatePreviewPlane(t12, e9 = {}) {
    let i10 = this._previewPlane;
    if (this._previewPlane = null, null == t12)
      return this._removeFrameTask(), void this._updateManipulators();
    if (!this.analysisViewData.plane && this.active) {
      const a9 = null != i10 ? i10 : W3();
      if (i10 = null != i10 ? Z(i10, xt2) : null, this._pickPlane(t12, true, e9, a9)) {
        const t13 = f5;
        let e10 = false;
        null != i10 && (e10 = P(i10.plane, a9.plane) < t13 || P(z(c4.get(), i10.basis1), z(c4.get(), a9.basis1)) < t13), e10 && (this._previewPlaneOpacity = 0), this._previewPlane = a9;
      }
    }
    null != this._previewPlane && null == this._frameTask && 0 === this._previewPlaneOpacity ? this._frameTask = A({ update: ({ deltaTime: t13 }) => {
      this._previewPlaneOpacity = Math.min(this._previewPlaneOpacity + t13 / (1e3 * p2), 1), this._updateManipulators(), 1 === this._previewPlaneOpacity && this._removeFrameTask();
    } }) : null == this._previewPlane && null != this._frameTask ? this._removeFrameTask() : null != this._previewPlane && this._updateManipulators();
  }
  _removeFrameTask() {
    this._frameTask = o(this._frameTask);
  }
  _calculatePickRay(t12) {
    const e9 = d3(), i10 = d2(t12, Rt);
    return i7(this.view.state.camera, i10, e9), z(e9.direction, e9.direction), e9;
  }
  _pickMinResult(t12) {
    const e9 = d2(t12, t4.get());
    return this.view.sceneIntersectionHelper.intersectToolIntersectorScreen(e9, this._intersector), this._intersector.results.min;
  }
  _pickPlane(t12, e9, i10, a9) {
    const s10 = this._pickMinResult(t12), n10 = c4.get();
    if (!s10.getIntersectionPoint(n10))
      return false;
    const r9 = s10.getTransformedNormal(c4.get()), l11 = this.view.state.camera;
    P(r9, l11.viewForward) > 0 && g(r9, r9, -1);
    const o5 = St(n10, l11), h9 = (e9 ? 1 : -1) * o5 * h6, p3 = g(c4.get(), r9, h9);
    u(p3, p3, n10);
    const u7 = this.analysis.tiltEnabled ? ge.TILTED : ge.HORIZONTAL_OR_VERTICAL, c10 = i10[r8] ? ge.VERTICAL : i10[t11] ? ge.HORIZONTAL : u7;
    return vt(p3, r9, o5, o5, l11, c10, this.view.renderCoordsHelper, a9), true;
  }
  _clearPointerMoveTimeout() {
    this._prevPointerMoveTimeout = o(this._prevPointerMoveTimeout);
  }
  _resetPointerMoveTimeout() {
    this._clearPointerMoveTimeout(), this.shiftManipulator.state |= me, this.rotateHeadingManipulator.state |= me, this.rotateTiltManipulator.state |= me, this._prevPointerMoveTimeout = this._clock.setTimeout(() => {
      this.shiftManipulator.state &= ~me, this.rotateHeadingManipulator.state &= ~me, this.rotateTiltManipulator.state &= ~me;
    }, this._pointerMoveTimerMs);
  }
  _updateManipulators() {
    if (kt2.disableEngineLayers)
      return;
    let t12, e9 = false;
    if (null != this.analysisViewData.plane)
      t12 = this.analysisViewData.plane, e9 = false;
    else {
      if (null == this._previewPlane)
        return this.shiftManipulator.available = false, this.rotateHeadingManipulator.available = false, this.rotateTiltManipulator.available = false, this.resizeManipulators.forEach((t13) => t13.available = false), this._previewPlaneOutlineVisualElement.visible = false, void (this._previewPlaneGridVisualElement.visible = false);
      t12 = this._previewPlane, e9 = true;
    }
    const i10 = kt(t12, f3.get());
    e9 ? (this.shiftManipulator.available = false, this.rotateHeadingManipulator.available = false, this.rotateTiltManipulator.available = false, this.resizeManipulators.forEach((t13) => t13.available = false), this._previewPlaneOutlineVisualElement.attached = true, this._previewPlaneGridVisualElement.attached = true, this._previewPlaneOutlineVisualElement.visible = true, this._previewPlaneGridVisualElement.visible = true) : (this.shiftManipulator.available = true, this.rotateHeadingManipulator.available = true, this.rotateTiltManipulator.available = this.analysis.tiltEnabled, this.resizeManipulators.forEach((t13) => t13.available = true), Bt(this.shiftManipulator, i10, t12, this.view.state.camera), Xt(this.rotateHeadingManipulator, i10, t12, this.view.renderCoordsHelper), Dt(this.rotateTiltManipulator, i10, t12), this.resizeManipulators.forEach((e10, a10) => Ft(e10, this._resizeHandles[a10], i10, t12)), this._previewPlaneOutlineVisualElement.visible = false, this._previewPlaneGridVisualElement.visible = false);
    const a9 = o2(c4.get(), s2(t12.basis1), s2(t12.basis2), 1), s10 = d(f3.get(), a9), n10 = c2(s10, i10, s10);
    this._previewPlaneOutlineVisualElement.transform = n10, this._previewPlaneGridVisualElement.transform = n10, this._updateMaterials();
  }
  _updateMaterials() {
    const t12 = h.toUnitRGBA(a7.plane.outlineColor);
    t12[3] *= this._previewPlaneOpacity;
    const i10 = h.toUnitRGBA(a7.plane.color);
    i10[3] *= this._previewPlaneOpacity, this._previewPlaneOutlineVisualElement.color = t12, this._previewPlaneGridVisualElement.backgroundColor = i10, this._previewPlaneGridVisualElement.gridColor = l5;
  }
  _updateManipulatorsInteractive(t12) {
    if (!t12.grabbing)
      return this.shiftManipulator.interactive = true, this.rotateHeadingManipulator.interactive = true, this.rotateTiltManipulator.interactive = true, void this.resizeManipulators.forEach((t13) => {
        t13.interactive = true;
      });
    this.shiftManipulator.interactive = this.shiftManipulator === t12, this.rotateHeadingManipulator.interactive = this.rotateHeadingManipulator === t12, this.rotateTiltManipulator.interactive = this.rotateTiltManipulator === t12, this.resizeManipulators.forEach((e9) => {
      e9.interactive = e9 === t12;
    });
  }
  testData() {
    return { plane: this.analysisViewData.plane, setPointerMoveTimerMs: (t12) => {
      this._pointerMoveTimerMs = t12;
    } };
  }
};
function St2(t12, e9, i10, a9) {
  const s10 = Gt(i10, ds(a9), t12.direction, h2()), n10 = n();
  return q(s10, t12, n10) ? { type: "shift", creatingPointerId: e9, hasBeenDragged: false, shiftPlane: s10, depth: 0, startPoint: n10 } : null;
}
function Ht2(t12) {
  return "mouse" !== t12.pointerType || 0 === t12.button;
}
Et.disableEngineLayers = false, e([y()], Et.prototype, "_clock", void 0), e([y({ constructOnly: true })], Et.prototype, "view", void 0), e([y()], Et.prototype, "analysisViewData", void 0), e([y({ readOnly: true })], Et.prototype, "state", null), e([y({ readOnly: true })], Et.prototype, "cursor", null), e([y()], Et.prototype, "analysis", null), e([y()], Et.prototype, "removeIncompleteOnCancel", void 0), e([y({ readOnly: true })], Et.prototype, "layersMode", void 0), e([y({ value: null })], Et.prototype, "inputState", null), e([y()], Et.prototype, "_isPlacingSlicePlane", null), e([y()], Et.prototype, "_creatingPointerId", null), Et = kt2 = e([a2("esri.views.3d.analysis.Slice.SliceTool")], Et);
var xt2 = W3();
var Rt = i3();
var It = Et;

// node_modules/@arcgis/core/views/3d/analysis/Slice/SliceVisualization.js
var y2 = class extends m {
  constructor(i10) {
    super(i10), this._handles = new t(), this._gridVisualElement = null, this._outlineVisualElement = null, this.showGrid = false, this.preview = true;
  }
  initialize() {
    const i10 = this.analysisViewData;
    if (null == i10)
      throw new Error("expected internal object to be valid");
    this._gridVisualElement = te(this.view), this._outlineVisualElement = Qt(this.view), this._handles.add([l3(() => ({ visible: null != i10.plane && this.analysisViewData.visible, active: this.analysisViewData.active, preview: this.preview, showGrid: this.showGrid }), (i11) => this._updateMaterials(i11), w), l3(() => i10.plane, (i11) => this._updatePlane(i11), w)], "internal");
  }
  destroy() {
    this._handles.destroy(), this._gridVisualElement = l(this._gridVisualElement), this._outlineVisualElement = l(this._outlineVisualElement), this.set("view", null);
  }
  _updatePlane(i10) {
    if (null == i10)
      return;
    this._gridVisualElement.attached = true, this._outlineVisualElement.attached = true;
    const t12 = o2(c4.get(), s2(i10.basis1), s2(i10.basis2), 1), e9 = d(f3.get(), t12), s10 = kt(i10, f3.get()), o5 = c2(e9, s10, e9);
    this._outlineVisualElement.transform = o5, this._gridVisualElement.transform = o5;
  }
  _updateMaterials({ visible: i10, active: e9, preview: s10, showGrid: o5 }) {
    this._outlineVisualElement.color = h.toUnitRGBA(a7.plane.outlineColor), this._outlineVisualElement.width = s10 ? M2 : j, this._outlineVisualElement.stipplePattern = e9 ? null : h4(5), this._gridVisualElement.backgroundColor = h.toUnitRGBA(a7.plane.color), this._gridVisualElement.gridColor = o5 ? h.toUnitRGBA(a7.plane.gridColor) : l5, this._gridVisualElement.visible = i10, this._outlineVisualElement.visible = i10;
  }
};
e([y()], y2.prototype, "view", void 0), e([y()], y2.prototype, "analysis", void 0), e([y()], y2.prototype, "analysisViewData", void 0), e([y()], y2.prototype, "showGrid", void 0), e([y()], y2.prototype, "preview", void 0), y2 = e([a2("esri.views.3d.analysis.Slice.SliceVisualization")], y2);

// node_modules/@arcgis/core/views/3d/analysis/SliceAnalysisView3D.js
var h8 = class extends s5(m) {
  constructor(s10) {
    super(s10), this.type = "slice-view-3d", this.analysis = null, this.tool = null, this.analysisVisualization = null, this.analysisController = null, this.plane = null, this.active = true;
  }
  initialize() {
    this.analysisVisualization = new y2({ view: this.view, analysis: this.analysis, analysisViewData: this }), this.analysisController = new _3({ view: this.view, analysis: this.analysis, analysisViewData: this }), this.addHandles(a6(this, It));
  }
  destroy() {
    v2(this), this.analysisVisualization = l(this.analysisVisualization), this.analysisController = l(this.analysisController);
  }
  get showGrid() {
    var _a;
    return ((_a = this.analysisVisualization) == null ? void 0 : _a.showGrid) ?? false;
  }
  set showGrid(s10) {
    this.analysisVisualization && (this.analysisVisualization.showGrid = s10);
  }
  get editable() {
    return !this.analysisVisualization.preview;
  }
  set editable(s10) {
    this.analysisVisualization.preview = !s10;
  }
  get testData() {
    return { visualization: this.analysisVisualization, controller: this.analysisController, tool: this.tool };
  }
};
e([y({ readOnly: true })], h8.prototype, "type", void 0), e([y({ constructOnly: true, nonNullable: true })], h8.prototype, "analysis", void 0), e([y()], h8.prototype, "tool", void 0), e([y()], h8.prototype, "plane", void 0), e([y()], h8.prototype, "active", void 0), e([y()], h8.prototype, "showGrid", null), e([y()], h8.prototype, "editable", null), h8 = e([a2("esri.views.3d.analysis.SliceAnalysisView3D")], h8);
var c9 = h8;
export {
  c9 as default
};
//# sourceMappingURL=SliceAnalysisView3D-RFZ7XL52.js.map
