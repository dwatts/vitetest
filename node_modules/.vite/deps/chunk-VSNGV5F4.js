import {
  D as D2,
  D2 as D3,
  F,
  M,
  S as S5,
  a as a4,
  b,
  e as e8,
  ee as ee2,
  s as s4
} from "./chunk-2HZ6BJUS.js";
import {
  n as n8
} from "./chunk-UK4ZDRLR.js";
import {
  Fe,
  l as l5,
  m as m4
} from "./chunk-HBJAGP7O.js";
import {
  f
} from "./chunk-SS6BI3R6.js";
import {
  L,
  S as S4,
  e as e6,
  j,
  w as w2
} from "./chunk-QNL3GBGD.js";
import {
  c as c3,
  o as o3
} from "./chunk-IMCUA6JI.js";
import {
  H,
  c as c4,
  o as o6
} from "./chunk-BLRS5QI4.js";
import {
  o as o5
} from "./chunk-Y3PBROKK.js";
import {
  u as u3
} from "./chunk-PFDC65N2.js";
import {
  U as U2
} from "./chunk-CS6BZGQO.js";
import {
  A as A6,
  M as M2,
  i as i4,
  t as t7
} from "./chunk-V33FVMPT.js";
import {
  t as t6
} from "./chunk-644IM3NW.js";
import {
  C as C4
} from "./chunk-2EO2WRP7.js";
import {
  o as o4
} from "./chunk-PC4A4CQR.js";
import {
  y as y2
} from "./chunk-YEDW7SLL.js";
import {
  e as e7
} from "./chunk-N4JKQR77.js";
import {
  g as g2
} from "./chunk-NIZWDAMQ.js";
import {
  t as t5
} from "./chunk-SMDDCTGQ.js";
import {
  d as d2
} from "./chunk-VC3BY3DV.js";
import {
  h as h6
} from "./chunk-IWA3Q52A.js";
import {
  t as t3
} from "./chunk-UM64E5NS.js";
import {
  Z
} from "./chunk-2XKILFME.js";
import {
  r as r5
} from "./chunk-M7PTINEZ.js";
import {
  t as t2
} from "./chunk-BDWD2ZNU.js";
import {
  Be,
  J,
  Ke,
  Pe,
  Te,
  Ue,
  Y,
  ee,
  fe,
  h as h5,
  he,
  je,
  ke,
  n as n6,
  ne,
  te,
  we,
  xe
} from "./chunk-SLMR4CTS.js";
import {
  $,
  O as O3,
  P as P2,
  U
} from "./chunk-GZTS5346.js";
import {
  A as A5
} from "./chunk-EK3Y2IYO.js";
import {
  n as n7
} from "./chunk-BZL5MAFP.js";
import {
  E as E2
} from "./chunk-LEDSC236.js";
import {
  e as e5,
  r as r6
} from "./chunk-CW7LIPBH.js";
import {
  t as t4
} from "./chunk-TYOIANOD.js";
import {
  e as e4
} from "./chunk-VN2IXVGV.js";
import {
  E
} from "./chunk-WWUAHPIM.js";
import {
  a as a2
} from "./chunk-Z3GCSCQI.js";
import {
  p as p2,
  v as v2
} from "./chunk-EV77QZBT.js";
import {
  r as r4
} from "./chunk-YGUWDSEH.js";
import {
  r as r3
} from "./chunk-ZWFMUHG3.js";
import {
  I as I2
} from "./chunk-KRCNIFX2.js";
import {
  l as l4
} from "./chunk-RVS5HU2K.js";
import {
  a as a3
} from "./chunk-JB7FDW5N.js";
import {
  h as h7
} from "./chunk-XWGNMTES.js";
import {
  Cn,
  Hn,
  bn,
  fn,
  xn,
  yn
} from "./chunk-BNBT4QTW.js";
import {
  A as A4,
  I,
  c as c2
} from "./chunk-7EG7BYWF.js";
import {
  h2 as h4,
  k
} from "./chunk-JNDFAMXY.js";
import {
  C as C3,
  D,
  O as O2,
  P,
  S as S3,
  c,
  i as i2
} from "./chunk-AQ7R6V4L.js";
import {
  g as g3,
  i as i3
} from "./chunk-4BXK4H4L.js";
import {
  m as m3
} from "./chunk-DTYFMKYK.js";
import {
  h as h3
} from "./chunk-RRJGZKNX.js";
import {
  V
} from "./chunk-7EQSYZHW.js";
import {
  C as C2,
  i,
  m as m2,
  q
} from "./chunk-EKJ2DJIR.js";
import {
  p
} from "./chunk-TEHNQYQD.js";
import {
  O,
  S as S2,
  e as e3,
  g,
  o as o2,
  r,
  u as u2
} from "./chunk-TPJLFGOT.js";
import {
  n as n4
} from "./chunk-CQX57DED.js";
import {
  r2
} from "./chunk-3CQBBMMD.js";
import {
  A2 as A3,
  T2 as T
} from "./chunk-RTDN6KAT.js";
import {
  h as h2,
  l as l3
} from "./chunk-H7RDAEPY.js";
import {
  n as n5
} from "./chunk-7KH4CLS5.js";
import {
  A as A2,
  e2,
  m,
  t2 as t,
  v,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a,
  l as l2
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  n as n3
} from "./chunk-3R7FAT25.js";
import {
  C,
  d,
  s as s3,
  w
} from "./chunk-7I33FAWS.js";
import {
  l,
  n,
  o,
  u
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import {
  h
} from "./chunk-IYZKKFJM.js";
import {
  A,
  R,
  S,
  has,
  n2,
  z
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SGeometryUtil.js
function c5(t10, e10, r8) {
  const n12 = t3(24);
  return (f2) => {
    let c7 = f2.meta.featureExtents;
    if (null == c7) {
      c7 = new Float64Array(6 * f2.meta.featureIds.length), f2.meta.featureExtents = c7;
      for (let t11 = 0; t11 < c7.length; t11 += 6)
        c7[t11] = Number.POSITIVE_INFINITY;
    }
    const l7 = new Float64Array(c7.buffer, 6 * f2.index * Float64Array.BYTES_PER_ELEMENT, 6);
    return l7[0] === Number.POSITIVE_INFINITY && (i5(f2.index, r8, f2.meta.objectHandle, n12, 0), yn(n12, e10, 0, n12, t10, 0, 8) ? (O2(l7, C3), c(l7, n12, 0, 8)) : O2(l7, D)), l7;
  };
}
function i5(r8, o9, n12, a8, m5) {
  const s6 = o9.getComponentAabb(n12, r8, p3), u5 = o9.getObjectTransform(n12);
  for (let f2 = 0; f2 < 8; ++f2)
    I3[0] = 1 & f2 ? s6[0] : s6[3], I3[1] = 2 & f2 ? s6[1] : s6[4], I3[2] = 4 & f2 ? s6[2] : s6[5], S2(I3, I3, u5.rotationScale), u2(I3, I3, u5.position), a8[m5++] = I3[0], a8[m5++] = I3[1], a8[m5++] = I3[2];
  return a8;
}
var l6 = 24;
var p3 = i2();
var I3 = n4();

// node_modules/@arcgis/core/views/3d/layers/II3SMeshView3D.js
var E3;
var I4;
!function(E5) {
  E5[E5.VISIBLE_ONLY = 0] = "VISIBLE_ONLY", E5[E5.ALL = 1] = "ALL", E5[E5.QUERYABLE = 2] = "QUERYABLE";
}(E3 || (E3 = {})), function(E5) {
  E5[E5.EXIT = 0] = "EXIT", E5[E5.CONTINUE = 1] = "CONTINUE", E5[E5.SKIP = 2] = "SKIP";
}(I4 || (I4 = {}));

// node_modules/@arcgis/core/geometry/support/UByteArray.js
function e9(e10, n12 = false) {
  return e10 <= A ? n12 ? new Array(e10).fill(0) : new Array(e10) : new Uint8Array(e10);
}

// node_modules/@arcgis/core/views/3d/support/GraphicsMap.js
var r7 = class extends n5 {
  constructor() {
    super(...arguments), this._map = /* @__PURE__ */ new Map();
  }
  clear() {
    if (this._map.size > 0) {
      const e10 = this.toArray();
      this._map.clear(), this.emit("change", { added: [], removed: e10 });
    }
  }
  get length() {
    return this._map.size;
  }
  get(e10) {
    return this._map.get(e10);
  }
  addMany(e10) {
    if (0 === e10.length)
      return;
    const t10 = /* @__PURE__ */ new Set();
    for (let o9 = 0; o9 < e10.length; o9++) {
      const r9 = e10[o9], s6 = r9.objectId, n12 = this._map.get(s6);
      n12 ? (t10.add(s6), r9 !== n12 && (e10[o9] = n12), n12.refCount || (n12.refCount = 0), ++n12.refCount) : (r9.refCount = 1, this._map.set(s6, r9));
    }
    const r8 = t10.size > 0 ? e10.filter((e11) => !t10.has(e11.objectId)) : e10;
    r8.length > 0 && this.emit("change", { added: r8, removed: [] });
  }
  removeMany(e10) {
    const t10 = [];
    for (const r8 of e10) {
      const e11 = r8.objectId, o9 = this._map.get(e11);
      null != o9 && (!o9.refCount || --o9.refCount <= 0) && (this._map.delete(e11), t10.push(r8));
    }
    t10.length > 0 && this.emit("change", { added: [], removed: t10 });
  }
  removeManyByObjectId(e10) {
    const t10 = [];
    for (const r8 of e10) {
      const e11 = this._map.get(r8);
      null != e11 && (!e11.refCount || --e11.refCount <= 0) && (this._map.delete(r8), t10.push(e11));
    }
    t10.length > 0 && this.emit("change", { added: [], removed: t10 });
  }
  toArray() {
    return [...this._map.values()];
  }
  find(e10) {
    let r8;
    return n3(this._map, (t10) => !!e10(t10) && (r8 = t10, true)), r8;
  }
  forEach(e10) {
    this._map.forEach((t10) => e10(t10));
  }
};

// node_modules/@arcgis/core/views/3d/support/LimitGraphicsMap.js
var i6 = class extends n5 {
  constructor(e10) {
    super(), this._limit = e10, this._all = new r7(), this._active = new a5(this), this._pending = /* @__PURE__ */ new Map(), this._handle = this._all.on("change", (e11) => this._handleChanges(e11));
  }
  destroy() {
    this._handle.remove();
  }
  get length() {
    return this._active.length;
  }
  toArray() {
    return this._active.toArray();
  }
  find(e10) {
    return this._active.find(e10);
  }
  forEach(e10) {
    this._active.forEach(e10);
  }
  addMany(e10) {
    this._all.addMany(e10);
  }
  removeManyByObjectId(e10) {
    this._all.removeManyByObjectId(e10);
  }
  _handleChanges(e10) {
    let t10 = e10.removed;
    if (this._pending.size > 0) {
      t10 = new Array();
      for (const s7 of e10.removed)
        this._pending.delete(s7.objectId) || t10.push(s7);
    }
    let s6 = this._limit - this._active.length + t10.length;
    s6 < e10.added.length && (this._active.removeMany(t10), t10 = [], h8.reset(1 - this._limit / (this._active.length + e10.added.length)), this._active.forEach((e11) => {
      h8.sample() && (t10.push(e11), this._pending.set(e11.objectId, e11));
    }), s6 = this._limit - this._active.length + t10.length);
    let i12 = e10.added;
    if (s6 < e10.added.length) {
      i12 = new Array(), h8.reset(s6 / e10.added.length);
      for (const t11 of e10.added)
        h8.sample() ? i12.push(t11) : this._pending.set(t11.objectId, t11);
    }
    const n12 = s6 - i12.length;
    n12 > 0 && this._pending.size > 0 && (h8.reset(n12 / this._pending.size), this._pending.forEach((e11) => {
      h8.sample() && (i12.push(e11), this._pending.delete(e11.objectId));
    })), this._active.addAndRemove(i12, t10);
  }
};
var n9 = class {
  constructor() {
    this._percentage = 1, this._last = -1, this._index = 0;
  }
  reset(e10) {
    this._percentage = e10, this._last = -1;
  }
  sample() {
    const e10 = Math.floor(this._index * this._percentage);
    return ++this._index, e10 !== this._last && (this._last = e10, true);
  }
};
var h8 = new n9();
var a5 = class {
  constructor(e10) {
    this._parent = e10, this._map = /* @__PURE__ */ new Map();
  }
  get length() {
    return this._map.size;
  }
  forEach(e10) {
    this._map.forEach((t10) => e10(t10));
  }
  find(e10) {
    let s6;
    return n3(this._map, (t10) => !!e10(t10) && (s6 = t10, true)), s6;
  }
  toArray() {
    return [...this._map.values()];
  }
  addAndRemove(e10, t10) {
    for (const s6 of e10)
      this._map.set(s6.objectId, s6);
    for (const s6 of t10)
      this._map.delete(s6.objectId);
    (e10.length > 0 || t10.length > 0) && this._parent.emit("change", { added: e10, removed: t10 });
  }
  removeMany(e10) {
    for (const t10 of e10)
      this._map.delete(t10.objectId);
    e10.length > 0 && this._parent.emit("change", { added: [], removed: e10 });
  }
};

// node_modules/@arcgis/core/views/3d/layers/I3SMeshViewLabeler.js
var w3 = class {
  constructor(e10, t10) {
    this.meta = e10, this.index = t10;
  }
};
var D4 = class {
  constructor(e10, t10) {
    this.graphic = e10, this.geometry = t10, this.components = [], this.overridesDirty = false;
  }
};
var C5 = class extends m {
  get updating() {
    var _a;
    return ((_a = this._graphicsCore) == null ? void 0 : _a.updating) ?? false;
  }
  constructor(e10) {
    super(e10), this.loadedGraphics = new i6(5e4), this.slicePlaneEnabled = false, this._renderingInfo = { symbol: new h4() }, this._handles = new t(), this._featuresMap = /* @__PURE__ */ new Map();
  }
  initialize() {
    const e10 = this.view.basemapTerrain;
    this._graphicsCore = new Fe({ owner: this, layer: this.layer, preferredUpdatePolicy: C4.ASYNC, elevationFeatureExpressionEnabled: false, graphicSymbolSupported: false, getRenderingInfoWithoutRenderer: true, hasZ: true, hasM: false, componentFactories: { deconflictor: (e11) => this.view.deconflictor.addGraphicsOwner(e11), labeler: (e11, t10) => this.view.labeler.addGraphicsOwner(e11, t10, { emptySymbolLabelSupported: true, elevationInfoOverride: { mode: "absolute-height", offset: 0 }, disablePlacement: { logEntityDescription: "3D Object Scene Layer features" } }), scaleVisibility: (t10, r8) => new m4({ graphicsCoreOwner: this, layer: this.layer, queryGraphicUIDsInExtent: r8, graphicsCore: t10, basemapTerrain: e10, layerScaleEnabled: false }) } }), this._graphicsCore.initializePromise.then(() => this._graphicsCore.startCreateGraphics()).catch(() => {
    }), this._handles.add(l3(() => this.layer.labelingInfo, (e11, t10) => {
      a2(e11, t10) && this._graphicsCore.updateLabelingInfo();
    }));
  }
  destroy() {
    this._handles = l(this._handles), this._graphicsCore = l(this._graphicsCore), this.loadedGraphics = l(this.loadedGraphics), this.view = null;
  }
  addNodeMeta(e10, t10) {
    let r8 = 0;
    const s6 = e10.filteredIds, o9 = this.view.spatialReference, i12 = [];
    for (let a8 = 0; a8 < e10.featureIds.length; a8++) {
      const n12 = e10.featureIds[a8];
      let c7 = null == s6;
      if (s6 && r8 < s6.length && n12 === s6[r8] && (c7 = true, r8++), !this._enabledForFeatureInNode(e10, a8))
        continue;
      const h9 = this._featuresMap.get(n12);
      if (h9) {
        h9.components.push(new w3(e10, a8)), this._updateLabelPosition(n12);
        continue;
      }
      const l7 = t10(a8, e10), d4 = Z(0, 0, 0, o9), u5 = { objectId: n12, uid: e2(), attributes: l7, visible: c7, geometry: d4 }, m5 = new D4(u5, d4);
      m5.components.push(new w3(e10, a8)), this._featuresMap.set(n12, m5), this._updateLabelGeometry(n12), i12.push(u5);
    }
    this.loadedGraphics.addMany(i12);
  }
  updateLabelPositions(e10) {
    const t10 = this.view.renderCoordsHelper;
    this._forEachGraphic(e10, (r8, s6, o9) => {
      const i12 = this._graphicsCore.getGraphics3DGraphicById(s6.uid);
      null != i12 && this._updateLabelGeometry(e10.featureIds[r8]) && i12.alignWithAbsoluteElevation(o9.z ?? 0, t10, false);
    });
  }
  setNodeMetaAttributes(e10, t10) {
    const r8 = new Array();
    this._forEachGraphic(e10, (s6, i12) => {
      const a8 = t10(s6, e10);
      h(i12.attributes, a8) || (i12.attributes = a8, r8.push(i12.uid));
    }), this._graphicsCore.updateLabelingInfo(r8);
  }
  applyFilterChange(e10) {
    this._forEachFeature(e10, (t10, r8, s6) => {
      if (!this._enabledForFeatureInNode(e10, t10)) {
        const s7 = e10.featureIds[t10];
        switch (this._removeFeature(r8, e10, t10)) {
          case O4.REMOVED:
            this.loadedGraphics.removeManyByObjectId([s7]);
            break;
          case O4.MODIFIED:
            this._updateLabelPosition(s7);
        }
        return;
      }
      const o9 = r8.graphic, i12 = o9.visible;
      i12 !== s6 && (o9.visible = s6, F2.graphic = o9, F2.property = "visible", F2.oldValue = i12, F2.newValue = s6, this._graphicsCore.graphicUpdateHandler(F2));
    });
  }
  removeNodeMeta(e10) {
    const t10 = [];
    this._forEachGraphic(e10, (r8) => {
      const s6 = e10.featureIds[r8], o9 = this._featuresMap.get(s6);
      if (!o9)
        return;
      switch (this._removeFeature(o9, e10, r8)) {
        case O4.MODIFIED:
          this._updateLabelPosition(s6);
          break;
        case O4.REMOVED:
          t10.push(s6);
      }
    }), this.loadedGraphics.removeManyByObjectId(t10);
  }
  _removeFeature(e10, t10, s6) {
    const o9 = e10.components.length;
    return S(e10.components, (e11) => !(e11.meta === t10 && e11.index === s6)), 0 === e10.components.length ? (this._featuresMap.delete(t10.featureIds[s6]), O4.REMOVED) : o9 !== e10.components.length ? O4.MODIFIED : O4.UNMODIFIED;
  }
  getRenderingInfo() {
    return this._renderingInfo;
  }
  notifyGraphicGeometryChanged() {
  }
  notifyGraphicVisibilityChanged() {
  }
  _updateLabelPosition(e10) {
    const t10 = this._featuresMap.get(e10);
    t10 && this._updateLabelGeometry(e10) && (this.loadedGraphics.removeManyByObjectId([e10]), this.loadedGraphics.addMany([t10.graphic]));
  }
  _updateLabelGeometry(e10) {
    const t10 = this._featuresMap.get(e10);
    if (!t10)
      return false;
    const r8 = t10.geometry, s6 = this.view.spatialReference, o9 = this.view.renderCoordsHelper, a8 = r8.x, n12 = r8.y, p4 = r8.z ?? 0, c7 = t10.components.length, h9 = t3(c7 * l6);
    let l7 = 0;
    for (const { meta: i12, index: d4 } of t10.components)
      i5(d4, this.collection, i12.objectHandle, h9, l7), l7 += l6;
    return yn(h9, o9.spatialReference, 0, h9, s6, 0, h9.length / 3), O2(L2, C3), c(L2, h9), r8.x = (L2[0] + L2[3]) / 2, r8.y = (L2[1] + L2[4]) / 2, r8.z = L2[5], !p(r8.x, a8) || !p(r8.y, n12) || !p(r8.z, p4);
  }
  _forEachGraphic(e10, t10) {
    this._forEachFeature(e10, (r8, { graphic: s6, geometry: o9 }, i12) => {
      this._enabledForFeatureInNode(e10, r8) && t10(r8, s6, o9, i12);
    });
  }
  _forEachFeature(e10, t10) {
    let r8 = 0;
    for (let s6 = 0; s6 < e10.featureIds.length; s6++) {
      const o9 = this._featuresMap.get(e10.featureIds[s6]);
      let i12 = null == e10.filteredIds;
      e10.filteredIds && e10.filteredIds[r8] === e10.featureIds[s6] && (i12 = true, r8++), o9 && t10(s6, o9, i12);
    }
  }
  _enabledForFeatureInNode(e10, t10) {
    var _a;
    return e10.node.index < 0 || !((_a = this.overrides) == null ? void 0 : _a.featureHasGeometryChanges(e10.featureIds[t10]));
  }
  get updatePolicy() {
    return this._graphicsCore.effectiveUpdatePolicy;
  }
  get usedMemory() {
    return this._graphicsCore.usedMemory;
  }
  get unloadedMemoryEstimate() {
    return this._graphicsCore.unprocessedMemoryEstimate;
  }
  get test() {
    return { graphicsCore: this._graphicsCore };
  }
};
e([y()], C5.prototype, "view", void 0), e([y()], C5.prototype, "layer", void 0), e([y()], C5.prototype, "collection", void 0), e([y()], C5.prototype, "loadedGraphics", void 0), e([y()], C5.prototype, "overrides", void 0), e([y()], C5.prototype, "updating", null), e([y()], C5.prototype, "slicePlaneEnabled", void 0), e([y()], C5.prototype, "_graphicsCore", void 0), C5 = e([a("esri.views.3d.layers.I3SMeshViewLabeler")], C5);
var F2 = { graphic: null, property: null, oldValue: null, newValue: null };
var O4;
!function(e10) {
  e10[e10.UNMODIFIED = 0] = "UNMODIFIED", e10[e10.MODIFIED = 1] = "MODIFIED", e10[e10.REMOVED = 2] = "REMOVED";
}(O4 || (O4 = {}));
var L2 = i2();
var S6 = C5;

// node_modules/@arcgis/core/views/3d/layers/I3SMeshWorkerHandle.js
var i7 = class extends h6 {
  constructor(s6) {
    super("SceneLayerWorker", "process", { process: (s7) => [s7.geometryBuffer], project: (s7) => [s7.positions.buffer], transformNormals: (s7) => [s7.normals.buffer] }, s6, { hasInitialize: true });
  }
  setModifications(s6, e10, o9, t10) {
    const r8 = { context: s6, modifications: a6(e10, o9, t10), isGeodetic: t10.isGeographic };
    this.broadcast(r8, "setModifications");
  }
  setLegacySchema(s6, e10) {
    const o9 = JSON.stringify(e10);
    this.broadcast({ context: s6, jsonSchema: o9 }, "setLegacySchema");
  }
  destroyContext(s6) {
    return this.broadcast(s6, "destroyContext");
  }
  project(s6, e10) {
    return this.invokeMethod("project", s6, e10);
  }
  transformNormals(s6, e10) {
    return this.invokeMethod("transformNormals", s6, e10);
  }
};
var n10 = new l2({ deallocator: null });
var u4 = [0, 0, 0];
function a6(o9, t10, i12) {
  n10.clear();
  let a8 = 1 / 0, c7 = 1 / 0, f2 = -1 / 0, m5 = -1 / 0, l7 = false;
  for (const g5 of t10) {
    const o10 = "clip" === g5.type ? e6.Inside : "mask" === g5.type ? e6.Outside : e6.Replace, t11 = u(g5.geometry, "modification.geometry");
    let d5 = (s6) => s6;
    if (t11.spatialReference) {
      if (!Cn(t11.spatialReference, i12)) {
        s.getLogger("esri.views.3d.layers.I3SMeshWorkerHandle").warn("Can't project modification polygon into layer spatial reference, ignoring modification");
        continue;
      }
      d5 = (s6) => (Hn(s6, t11.spatialReference, u4, i12), u4);
    } else
      t11.hasZ || (u4[2] = 0, d5 = (s6) => (u4[0] = s6[0], u4[1] = s6[1], u4));
    l7 = l7 || o10 === e6.Outside, n10.push(o10), n10.push(t11.rings.length);
    for (const s6 of t11.rings) {
      n10.push(s6.length);
      for (const e10 of s6) {
        const s7 = d5(e10);
        n10.push(s7[0]), n10.push(s7[1]), n10.push(s7[2]), a8 = Math.min(a8, s7[0]), c7 = Math.min(c7, s7[1]), f2 = Math.max(f2, s7[0]), m5 = Math.max(m5, s7[1]);
      }
    }
  }
  if (null != o9)
    if (l7) {
      const s6 = 1e-4;
      n10.push(e6.Inside), n10.push(2), n10.push(4), n10.push(a8 - s6), n10.push(c7 - s6), n10.push(0), n10.push(f2 + s6), n10.push(c7 - s6), n10.push(0), n10.push(f2 + s6), n10.push(m5 + s6), n10.push(0), n10.push(a8 - s6), n10.push(m5 + s6), n10.push(0), n10.push(4), n10.push(o9[0]), n10.push(o9[1]), n10.push(0), n10.push(o9[2]), n10.push(o9[1]), n10.push(0), n10.push(o9[2]), n10.push(o9[3]), n10.push(0), n10.push(o9[0]), n10.push(o9[3]), n10.push(0);
    } else
      n10.push(e6.Outside), n10.push(1), n10.push(4), n10.push(o9[0]), n10.push(o9[1]), n10.push(0), n10.push(o9[2]), n10.push(o9[1]), n10.push(0), n10.push(o9[2]), n10.push(o9[3]), n10.push(0), n10.push(o9[0]), n10.push(o9[3]), n10.push(0);
  n10.push(e6.Finished);
  const d4 = new Float64Array(n10.length);
  for (let s6 = 0; s6 < n10.length; ++s6)
    d4[s6] = n10.at(s6);
  return d4;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/Highlights.js
var s5 = class {
  constructor() {
    this.ids = /* @__PURE__ */ new Set(), this.paused = false;
  }
};
var i8 = class {
  constructor({ collection: e10, forAllFeatures: t10, forAllFeaturesOfNode: s6 }) {
    this._highlights = [], this._collection = e10, this._forAllFeatures = t10, this._forAllFeaturesOfNode = s6;
  }
  destroy() {
    this._highlights.forEach((e10) => this._releaseSet(e10)), this._highlights = null;
  }
  acquireSet() {
    const t10 = new s5();
    this._highlights.push(t10);
    const i12 = { remove: () => {
      this._highlights && (this._releaseSet(t10), z(this._highlights, t10));
    }, pause: () => {
      this._releaseSet(t10), t10.paused = true;
    }, resume: () => {
      t10.paused = false, this._initializeSet(t10);
    } };
    return { set: t10, handle: i12 };
  }
  setFeatureIds(e10, t10) {
    t10.forEach((t11) => e10.ids.add(t11)), this._initializeSet(e10);
  }
  _initializeSet(e10) {
    this._forAllFeatures((s6, i12, h9) => (e10.ids.has(s6) && this._collection.addComponentHighlight(h9.objectHandle, i12), I4.CONTINUE));
  }
  _releaseSet(e10) {
    this._forAllFeatures((s6, i12, h9) => (e10.ids.has(s6) && this._collection.removeComponentHighlight(h9.objectHandle, i12), I4.CONTINUE));
  }
  objectCreated(e10) {
    this._highlights.forEach((s6) => {
      s6.paused || this._forAllFeaturesOfNode(e10, (i12, h9) => (s6.ids.has(i12) && this._collection.addComponentHighlight(e10.objectHandle, h9), I4.CONTINUE));
    });
  }
  objectDeleted(e10) {
    this._collection.clearHighlights(e10.objectHandle);
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SAsyncElevationUpdater.js
var i9 = class extends m {
  constructor(e10, t10, s6) {
    super({}), this._updateExtent = t10, this._updateNode = s6, this.running = false, this._extentSet = new l5(), this._nodeSet = /* @__PURE__ */ new Set(), this.addHandles(e10.registerTask(I2.ELEVATION_ALIGNMENT, this));
  }
  normalizeCtorArgs() {
    return {};
  }
  addExtent(e10) {
    this._extentSet.add(e10), this.running = true;
  }
  schedule(e10) {
    this._nodeSet.add(e10), this.running = true;
  }
  remove(e10) {
    this._nodeSet.delete(e10), this._updateRunning();
  }
  runTask(e10) {
    const t10 = this._extentSet;
    for (e10.run(() => t10.merge(e10)); !t10.empty && !e10.done; ) {
      const s7 = this._updateExtent(t10.pop());
      null != s7 && s7.forAll((e11) => this.schedule(e11)), e10.madeProgress();
    }
    if (e10.done)
      return;
    const s6 = this._nodeSet;
    for (const r8 of s6)
      if (s6.delete(r8), this._updateNode(r8), e10.madeProgress(), e10.done)
        break;
    this._updateRunning();
  }
  _updateRunning() {
    this.running = this._nodeSet.size > 0 || this._extentSet.size > 0;
  }
};
e([y()], i9.prototype, "running", void 0), i9 = e([a("esri.views.3d.layers.i3s.I3SAsyncElevationUpdater.ts")], i9);

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SCrossfadeHelper.js
var o7 = class {
  constructor() {
    this.lodCrossfadeSignedDuration = 0;
  }
};
var i10 = class {
  constructor(e10) {
    this._view = e10, this._preRenderFrameTaskHandle = null, this._currentFrameStartTime = null, this._numFadingNodes = 0;
  }
  destroy() {
    var _a;
    (_a = this._preRenderFrameTaskHandle) == null ? void 0 : _a.remove(), this._preRenderFrameTaskHandle = null, this._view = null;
  }
  get updating() {
    return this._numFadingNodes > 0;
  }
  stopNodeFading(s6) {
    null != s6.lodCrossfadeProgress && (this._numFadingNodes--, s6.lodCrossfadeProgress = null, 0 === this._numFadingNodes && (null != this._preRenderFrameTaskHandle && (this._preRenderFrameTaskHandle = o(this._preRenderFrameTaskHandle)), this._view.notifyLODUpdate(), this._view.notifyUpdate()));
  }
  _startNodeFading(e10, d4, o9) {
    0 === this._numFadingNodes && (this._preRenderFrameTaskHandle = A2({ preRender: (e11) => this._updateAllNodeFading(e11) }), this._view.notifyLODUpdate()), null == e10.lodCrossfadeProgress && (this._numFadingNodes++, this._view.notifyUpdate()), e10.lodCrossfadeSignedDuration = o9, e10.lodCrossfadeProgress = d4;
  }
  _updateAllNodeFading(e10) {
    const s6 = this._view.nodeCrossfadingEnabled;
    this._view.foreachCrossfadeNode((d4, o9) => {
      if (null != o9 && null != o9.lodCrossfadeProgress) {
        const i12 = o9.lodCrossfadeSignedDuration, t10 = i12 > 0 ? this._view.fullOpacity : 0, r8 = e10.deltaTime / i12, a8 = o9.lodCrossfadeProgress + Math.abs(r8), n12 = !s6 || a8 >= 1 || 0 === i12, l7 = t10 - (n12 ? 0 : i12 > 0 ? 1 : -1) * (1 - a8);
        n12 ? (this.stopNodeFading(o9), i12 < 0 && this._view.markNodeToRemove(d4)) : o9.lodCrossfadeProgress = a8, this._view.setNodeOpacityByIndex(d4, l7);
      }
    }), this._view.removeMarkedNodes();
  }
  stopAllNodeFading() {
    this._view.foreachCrossfadeNode((e10, s6) => {
      if (null != s6 && null != s6.lodCrossfadeProgress) {
        this.stopNodeFading(s6);
        const d4 = s6.lodCrossfadeSignedDuration;
        d4 < 0 && this._view.markNodeToRemove(e10);
        const o9 = d4 > 0 ? this._view.fullOpacity : 0;
        this._view.setNodeOpacityByIndex(e10, o9);
      }
    }), this._view.removeMarkedNodes();
  }
  fadeNode(e10, s6, o9, i12) {
    null == this._currentFrameStartTime && (this._currentFrameStartTime = Date.now());
    const r8 = this._view, a8 = r8.nodeCrossfadingEnabled, n12 = o9 === a4.FadeIn ? r8.fullOpacity : 0, l7 = a8 ? i12 ? o9 === a4.FadeIn ? r8.lodCrossfadeinDuration : r8.lodCrossfadeoutDuration : r8.lodCrossfadeUncoveredDuration : 0, h9 = this._view.getNodeOpacityByIndex(e10);
    if (a8 && h9 !== n12 && l7 > 0) {
      const e11 = 1 - Math.abs(n12 - h9);
      this._startNodeFading(s6, e11, t8(o9) * l7);
    } else
      this.stopNodeFading(s6), this._view.setNodeOpacityByIndex(e10, n12), o9 === a4.FadeOut && this._view.removeNode(e10);
  }
  isNodeFullyFadedIn(e10) {
    const s6 = this._view.getNodeCrossfadeMetaData(e10);
    return null == s6 || null == s6.lodCrossfadeProgress && this._view.getNodeOpacityByIndex(e10) === this._view.fullOpacity;
  }
};
function t8(e10) {
  return e10 === a4.FadeIn ? 1 : -1;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SElevationProvider.js
var v3 = C2();
var _ = e5();
var g4 = E2(0, 0, 0, 0);
var x = n4();
var y3 = n4();
var E4 = n4();
var j2 = class extends n5.EventedMixin(m) {
  get spatialReference() {
    var _a, _b;
    return (_b = (_a = this.view) == null ? void 0 : _a.elevationProvider) == null ? void 0 : _b.spatialReference;
  }
  constructor(e10) {
    super(e10), this._tmpEvent = { spatialReference: null, extent: v3, context: "scene" };
  }
  initialize() {
    this.view = this.layerView.view, this._renderCoordsHelper = this.view.renderCoordsHelper, this._intersector = A6(this.view.state.viewingMode), this._intersector.options.store = t7.MIN;
    const e10 = this.layerView.i3slayer.fullExtent;
    null == e10 ? s.getLogger(this).error("I3SElevationProvider expected fullExtent on I3SLayer.") : (this._zmin = e10.zmin, this._zmax = e10.zmax), this._tmpEvent.context = this.intersectionHandler.isGround ? "ground" : "scene";
  }
  getElevation(e10, t10, r8, i12) {
    if (x[0] = e10, x[1] = t10, x[2] = r8, !this._renderCoordsHelper.toRenderCoords(x, i12, x))
      return s.getLogger(this).error("could not project point to compute elevation"), null;
    const o9 = this.layerView.elevationOffset, n12 = this._zmin + o9, a8 = this._zmax + o9;
    return this._renderCoordsHelper.setAltitude(y3, a8, x), this._renderCoordsHelper.setAltitude(E4, n12, x), this._intersector.reset(y3, E4, null), this.intersectionHandler.intersect(this._intersector, null, y3, E4), this._intersector.results.min.getIntersectionPoint(x) ? this._renderCoordsHelper.getAltitude(x) : null;
  }
  getSphereElevationBounds(e10, t10) {
    return xn(e10, t10, g4, this._renderCoordsHelper.spatialReference), this.layerView.getElevationRange(g4);
  }
  layerChanged() {
    this.spatialReference && (this._tmpEvent.extent = this._computeLayerExtent(), this._tmpEvent.spatialReference = this.spatialReference, this.emit("elevation-change", this._tmpEvent));
  }
  objectChanged(e10) {
    this.spatialReference && (this._tmpEvent.extent = this._computeObjectExtent(e10), this._tmpEvent.spatialReference = this.spatialReference, this.emit("elevation-change", this._tmpEvent));
  }
  _computeObjectExtent(e10) {
    return C2(v3), this._expandExtent(e10, v3), v3;
  }
  _computeLayerExtent() {
    C2(v3);
    for (const e10 of this.layerView.getVisibleNodes())
      this._expandExtent(e10, v3);
    return v3;
  }
  _expandExtent(e10, t10) {
    const r8 = this.spatialReference;
    if (null == r8)
      return;
    const s6 = this.layerView.getNodeComponentObb(e10);
    if (null != s6) {
      A4(_, s6.quaternion), _[12] = s6.center[0], _[13] = s6.center[1], _[14] = s6.center[2];
      for (let e11 = 0; e11 < 8; ++e11)
        x[0] = 1 & e11 ? s6.halfSize[0] : -s6.halfSize[0], x[1] = 2 & e11 ? s6.halfSize[1] : -s6.halfSize[1], x[2] = 4 & e11 ? s6.halfSize[2] : -s6.halfSize[2], O(x, x, _), this._renderCoordsHelper.fromRenderCoords(x, x, r8), m2(t10, x, t10);
    }
  }
};
e([y({ constructOnly: true })], j2.prototype, "layerView", void 0), e([y({ constructOnly: true })], j2.prototype, "intersectionHandler", void 0), e([y()], j2.prototype, "view", void 0), e([y()], j2.prototype, "spatialReference", null), j2 = e([a("esri.views.3d.layers.i3s.I3SElevationProvider")], j2);
var w4 = j2;

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SIntersectionHandler.js
var d3 = class {
  constructor(e10) {
    this.type = i4.I3S, this._needVerticalOffset = false, this.layerUid = e10.layerUid, this.sublayerUid = e10.sublayerUid, this._collection = e10.collection, this._traverseNodeHierarchy = e10.traverseNodeHierarchy, this.slicePlaneEnabled = e10.slicePlaneEnabled, this.isGround = e10.isGround;
  }
  updateElevationAlignState(t10, r8) {
    this._needVerticalOffset = t10 && r8 === l4.Global;
  }
  intersect(e10, l7, d4, u5) {
    const f2 = e10.results, b2 = e10.options.store === t7.ALL, m5 = e10.ray.direction, h9 = e10.tolerance;
    let p4 = (e11) => e11, y4 = (e11) => e11;
    const g5 = y2(null != e10.verticalOffset ? e10.verticalOffset : this._needVerticalOffset ? 0 : null);
    null != e10.verticalOffset && null != g5 && (p4 = (e11) => g5.applyToMbs(e11), y4 = (e11) => g5.applyToObb(e11)), this._traverseNodeHierarchy((o9, c7) => {
      if (0 === o9.childrenLoaded)
        return false;
      const O5 = null != o9.serviceObbInRenderSR && Be(o9.serviceObbInRenderSR) ? o9.serviceObbInRenderSR : null;
      return !(null != O5 && !$(y4(O5), d4, m5, h9)) && (!c7 || null == O5 && Pe(o9.renderMbs) && !a7(p4(o9.renderMbs), d4, m5, h9) || null != o9.geometryObb && !$(y4(o9.geometryObb), d4, m5, h9) || this._collection.intersect(c7, d4, u5, h9, g5, (t10, r8, s6, c8) => {
        if (r8 >= 0) {
          if (null != l7 && !l7(d4, u5, r8))
            return;
          const a8 = (e11) => {
            const n12 = new o5(this.layerUid, this.sublayerUid, o9.index, t10, c8);
            e11.set(this.type, n12, r8, s6);
          };
          if (this.isGround && (null == f2.ground.dist || r8 < f2.ground.dist) && a8(f2.ground), e10.options.isFiltered)
            return;
          if ((null == f2.min.dist || r8 < f2.min.dist) && a8(f2.min), (null == f2.max.dist || r8 > f2.max.dist) && a8(f2.max), b2) {
            const t11 = M2(e10.ray);
            a8(t11), e10.results.all.push(t11);
          }
        }
      }), true);
    });
  }
};
function a7(e10, t10, r8, i12 = 0) {
  const s6 = e10[3] + i12, n12 = t10[0] - e10[0], l7 = t10[1] - e10[1], o9 = t10[2] - e10[2], c7 = r8[0], d4 = r8[1], a8 = r8[2], u5 = c7 * n12 + d4 * l7 + a8 * o9;
  return u5 * u5 - (c7 * c7 + d4 * d4 + a8 * a8) * (n12 * n12 + l7 * l7 + o9 * o9 - s6 * s6) >= 0;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/IDBCache.js
var o8 = 14;
var i11 = class {
  constructor(t10, s6, r8 = o8) {
    this._version = r8, this._db = null, this._quotaReductionPromise = null, this._gcCounter = 0, this._hit = 0, this._miss = 0, this._destroyed = false, this.gcFrequency = 50, this.maxByteSize = E.GIGABYTES, this.quotaReductionFactor = 0.2, this._dbName = t10, this._storeName = s6;
  }
  init() {
    return Promise.resolve().then(() => {
      const e10 = indexedDB.open(this._dbName, this._version);
      return e10.onupgradeneeded = (t10) => {
        const s6 = e10.result, r8 = e10.transaction, o9 = s6.objectStoreNames.contains(this._storeName) ? r8.objectStore(this._storeName) : s6.createObjectStore(this._storeName), i12 = s6.objectStoreNames.contains("last_access") ? r8.objectStore("last_access") : s6.createObjectStore("last_access");
        i12.indexNames.contains("date") || i12.createIndex("date", "date", { unique: false }), i12.indexNames.contains("byteSize") || i12.createIndex("byteSize", "byteSize", { unique: false }), t10.oldVersion < this._version && (o9.clear(), i12.clear());
      }, c6(e10);
    }).then((e10) => {
      this._destroyed ? e10.close() : this._db = e10;
    });
  }
  destroy() {
    this._db && (this._db.close(), this._db = null), this._destroyed = true;
  }
  get initialized() {
    return null != this._db;
  }
  getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
  put(e10, s6) {
    if (null == this._db)
      return Promise.reject(new s2("indexedb:not-initialized", "IndexedDB Cache is not initialized"));
    return (null != this._quotaReductionPromise ? this._quotaReductionPromise : Promise.resolve()).then(() => this._put(e10, s6)).catch((t10) => {
      if (t10 && "QuotaExceededError" === t10.name)
        return null == this._quotaReductionPromise && (this._quotaReductionPromise = this._getCacheSize().then((e11) => this._removeLeastRecentlyAccessed(s6.byteSize + Math.ceil(e11 * this.quotaReductionFactor))), this._quotaReductionPromise.then(() => this._quotaReductionPromise = null, () => this._quotaReductionPromise = null)), this._quotaReductionPromise.then(() => this._put(e10, s6));
      throw t10;
    }).then(() => {
      this._gcCounter--, this._gcCounter < 0 && null != this._db && (this._gcCounter = this.gcFrequency, this._getCacheSize().then((e11) => this._removeLeastRecentlyAccessed(e11 - this.maxByteSize)));
    });
  }
  get(e10, t10) {
    const o9 = this._db;
    if (null == o9)
      return Promise.resolve(void 0);
    let i12 = null;
    return Promise.resolve().then(() => {
      const r8 = o9.transaction(this._storeName, "readonly");
      i12 = w(t10, () => {
        r8.abort();
      });
      return c6(r8.objectStore(this._storeName).get(e10));
    }).then((t11) => {
      if (null == t11)
        ++this._miss;
      else if (this._db) {
        ++this._hit;
        this._db.transaction("last_access", "readwrite").objectStore("last_access").put({ date: Date.now(), byteSize: t11.byteSize }, e10);
      }
      return null != i12 && i12.remove(), t11;
    }).catch(() => {
      ++this._miss, s3(t10), null != i12 && i12.remove();
    });
  }
  remove(e10) {
    const t10 = this._db;
    return null == t10 ? Promise.resolve() : Promise.resolve().then(async () => {
      const s6 = t10.transaction([this._storeName, "last_access"], "readwrite"), r8 = s6.objectStore(this._storeName), o9 = s6.objectStore("last_access"), i12 = r8.delete(e10), a8 = o9.delete(e10);
      await Promise.all([c6(i12), c6(a8), n11(s6)]);
    });
  }
  _put(e10, t10) {
    const s6 = this._db;
    if (null == s6)
      return Promise.resolve();
    const r8 = s6.transaction([this._storeName, "last_access"], "readwrite"), o9 = r8.objectStore(this._storeName), i12 = r8.objectStore("last_access"), a8 = o9.put(t10, e10), l7 = i12.put({ date: Date.now(), byteSize: t10.byteSize }, e10);
    return Promise.all([c6(a8), c6(l7), n11(r8)]);
  }
  _removeLeastRecentlyAccessed(e10) {
    if (e10 <= 0 || !this._db)
      return Promise.resolve();
    const t10 = this._db.transaction([this._storeName, "last_access"], "readwrite"), s6 = t10.objectStore(this._storeName), r8 = t10.objectStore("last_access");
    let o9 = 0;
    const i12 = r8.index("date").openCursor(null, "next");
    return i12.onsuccess = () => {
      const t11 = i12.result;
      null != t11 && (null != t11.value.byteSize && (o9 += t11.value.byteSize), s6.delete(t11.primaryKey), r8.delete(t11.primaryKey), o9 < e10 && t11.continue());
    }, n11(t10);
  }
  _getCacheSize() {
    const e10 = this._db;
    if (null == e10)
      return Promise.resolve(0);
    const t10 = e10.transaction("last_access"), s6 = t10.objectStore("last_access");
    let r8 = 0;
    const o9 = s6.index("byteSize").openKeyCursor();
    return o9.onsuccess = () => {
      const e11 = o9.result;
      if (!e11)
        return;
      const t11 = e11.key;
      null != t11 && (r8 += t11), e11.continue();
    }, n11(t10).then(() => r8);
  }
};
function n11(e10) {
  return new Promise((t10, s6) => {
    e10.oncomplete = () => t10(), e10.onerror = () => s6(e10.error), e10.onabort = () => s6(e10.error);
  });
}
function c6(e10) {
  return new Promise((t10, s6) => {
    "done" === e10.readyState ? null != e10.error ? s6(e10.error) : t10(e10.result) : (e10.onsuccess = () => t10(e10.result), e10.onerror = () => s6(e10.error));
  });
}

// node_modules/@arcgis/core/views/3d/layers/i3s/IDBMockCache.js
var t9 = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map(), this._miss = 0, this._hit = 0, this.initialized = true;
  }
  init() {
    return Promise.resolve();
  }
  async get(t10, i12) {
    if (this._data.has(t10))
      return this._hit++, this._data.get(t10) ?? void 0;
    this._miss++;
  }
  destroy() {
  }
  put(t10, i12) {
    return this._data.set(t10, i12), Promise.resolve();
  }
  remove(t10) {
    return this._data.delete(t10), Promise.resolve();
  }
  getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
};

// node_modules/@arcgis/core/views/3d/layers/I3SMeshView3D.js
var bt = "esri.views.3d.layers.I3SMeshView3D";
var yt = s.getLogger(bt);
var vt = [1, 1, 1, 1];
var It = class extends o7 {
  constructor(e10, t10, i12, s6, r8, o9, a8, n12, l7) {
    super(), this.node = e10, this.featureIds = t10, this.objectHandle = i12, this.cachedRendererVersion = s6, this.attributeInfo = r8, this.material = o9, this.textures = a8, this.anchorIds = n12, this.anchors = l7, this.cachedElevationAnchors = null, this.cachedEdgeMaterials = new Array(), this.edgeMemoryUsage = 0;
  }
};
var Mt;
!function(e10) {
  e10[e10.CastShadows = 4] = "CastShadows", e10[e10.Pickable = 5] = "Pickable";
}(Mt || (Mt = {}));
var Ct = 23;
var Ot = 100 * E.MEGABYTES;
var xt = (t10) => {
  let o9 = class extends t10 {
    constructor(...e10) {
      super(e10), this._nodeId2Meta = /* @__PURE__ */ new Map(), this._nodeId2MetaReloading = /* @__PURE__ */ new Map(), this._i3sWasmLoaded = false, this._snappingSourcesTrackers = [], this._hasLoadedPBRTextures = false, this._asyncModuleLoading = 0, this._addTasks = /* @__PURE__ */ new Map(), this._currentRenderer = null, this._rendererVersion = 0, this._colorVariable = null, this._opacityVariable = null, this._rendererFields = null, this._symbologyFields = null, this._symbologyOverride = null, this._symbologyOverrideFields = null, this._symbolInfos = /* @__PURE__ */ new Map(), this._visibleGeometryChangedSchedulerHandle = null, this._idbCache = has("enable-feature:idb-mock-cache") ? new t9() : new i11("esri-scenelayer-cache", "geometries"), this._hasComponentData = false, this._hasVertexColors = false, this.updating = true, this.holeFilling = "auto", this._hasColors = false, this._hasTextures = false, this._hasData = false, this.slicePlaneEnabled = false, this._modifications = new Array(), this.ignoresMemoryFactor = false, this._layerUrl = "", this._cacheKeySuffix = null, this._elevationTask = null, this._filters = [], this._arcade = null, this._tmpAttributeOnlyGraphic = new h7(null, null, {}), this._crossfadeHelper = new i10(this);
    }
    get lodCrossfadeoutDuration() {
      return 0;
    }
    get lodCrossfadeinDuration() {
      return 0;
    }
    get lodCrossfadeUncoveredDuration() {
      return 0;
    }
    get layerUid() {
      return this.i3slayer && this.i3slayer.uid;
    }
    get sublayerUid() {
      return null;
    }
    get layerId() {
      return this.i3slayer && this.i3slayer.id;
    }
    get sublayerId() {
      return null;
    }
    get contentVisible() {
      var _a;
      return !this.suspended && ((_a = this._controller) == null ? void 0 : _a.rootNodeVisible);
    }
    get legendEnabled() {
      var _a;
      return this.contentVisible && true === ((_a = this.i3slayer) == null ? void 0 : _a.legendEnabled);
    }
    get updatingProgressValue() {
      var _a;
      return ((_a = this._controller) == null ? void 0 : _a.updatingProgress) ?? 0;
    }
    get hasTexturesOrVertexColors() {
      return this._hasData ? this._hasTextures || this._hasColors ? "yes" : "probably-not" : "unknown";
    }
    get rendererTextureUsage() {
      return xe(this._currentRenderer) ? this._usePBR || this._hasLoadedPBRTextures ? s4.AllTexturesPBR : s4.AllTextures : this._usePBR || this._hasLoadedPBRTextures ? s4.GeometryTexturesPBR : s4.GeometryTextures;
    }
    get elevationOffset() {
      const e10 = null != this.i3slayer ? this.i3slayer.elevationInfo : null;
      if (null != e10 && "absolute-height" === e10.mode) {
        const t11 = T(this.i3slayer.spatialReference), i12 = r3(e10.unit);
        return (e10.offset ?? 0) * i12 / t11;
      }
      return 0;
    }
    get elevationInfo() {
      const e10 = null != this.i3slayer ? this.i3slayer.elevationInfo : null;
      if (null == e10)
        return { mode: Bt.Absolute, offset: 0 };
      const t11 = T(this.i3slayer.spatialReference), i12 = r3(e10.unit), s6 = (e10.offset ?? 0) * i12 / t11;
      switch (e10.mode) {
        case "absolute-height":
          return { mode: Bt.Absolute, offset: s6 };
        case "relative-to-ground":
          return { mode: Bt.RelativeToGround, offset: s6 };
        case "on-the-ground":
          return { mode: Bt.OnTheGround, offset: 0 };
        default:
          return { mode: Bt.Absolute, offset: 0 };
      }
    }
    get supportedTextureEncodings() {
      return M(this.view._stage.renderView.capabilities);
    }
    get uncompressedTextureDownsamplingEnabled() {
      var _a;
      const e10 = (_a = this.view) == null ? void 0 : _a.qualitySettings.sceneService.uncompressedTextureDownsamplingEnabled, t11 = 0 == (this.supportedTextureEncodings & e8.DDS_S3TC);
      return e10 && t11;
    }
    get clientGeometry() {
      return this.i3sOverrides.geometryOverrides;
    }
    initialize() {
      this._preLoadBasis(), this.addResolvingPromise(this.i3slayer.indexInfo);
      const e10 = this.view.resourceController, t11 = e10.memoryController;
      this.i3sOverrides = new D3({ view: this.view, layer: this.i3slayer, memoryController: t11 }), this._worker = new i7(Wt(e10)), this.addResolvingPromise(this._worker.promise);
      const i12 = this.i3slayer.store;
      this._worker.setLegacySchema(this.uid, i12.defaultGeometrySchema), we(this.i3slayer), Te(this.i3slayer, this.view), this._layerUrl = this.i3slayer.parsedUrl.path, this._controller = new ee2({ layerView: this, worker: this._worker }), this._gpuMemoryEstimate = 0, this._texMemoryEstimate = 0, this._geoMemoryEstimate = 0, this._stage = this.view._stage, this._collection = this._stage.renderView.componentObjectCollection, this.resetHighlights();
      const s6 = i12.defaultGeometrySchema;
      if (this._isIntegratedMesh || !s6)
        this._hasComponentData = false;
      else {
        const e11 = s6.featureAttributes;
        this._hasComponentData = !!(e11 && e11.faceRange && e11.id);
      }
      this._hasVertexColors = null != ((s6 == null ? void 0 : s6.vertexAttributes.color) ?? null) && (null == this.i3slayer.cachedDrawingInfo || !this.i3slayer.cachedDrawingInfo.color), this._isIntegratedMesh || (this._edgeView = this._stage.renderer.ensureEdgeView());
      const r8 = this.view.resourceController.memoryController.newCache(`sl-${this.uid}`, (e11) => this._deleteComponentObject(e11));
      this._memCache = r8;
      const o10 = (e11) => null != this._controller.index && null != this._controller.index.rootNode ? this._controller.index.traverse(this._controller.index.rootNode, (t12) => {
        const i13 = t12.index, s7 = this._nodeId2Meta.get(i13) || this._nodeId2MetaReloading.get(i13);
        return e11(t12, null != s7 ? s7.objectHandle : null);
      }) : () => {
      };
      this._intersectionHandler = new d3({ layerUid: this.layerUid, sublayerUid: this.sublayerUid, collection: this._collection, slicePlaneEnabled: this.slicePlaneEnabled, isGround: this._isIntegratedMesh, traverseNodeHierarchy: o10 }), this.updatingHandles.add(() => this.layerUid, (e11) => this._intersectionHandler.layerUid = e11), this.updatingHandles.add(() => this.sublayerUid, (e11) => this._intersectionHandler.sublayerUid = e11), this._elevationProvider = new w4({ layerView: this, intersectionHandler: this._intersectionHandler }), this._hasLoadedPBRTextures = this._usePBR, this.updatingHandles.add(() => this.view.clippingArea, () => this._clippingAreaChanged(), h2), this.updatingHandles.add(() => this.fullOpacity, (e11) => this._opacityChange(e11)), this.updatingHandles.add(() => this.slicePlaneEnabled, (e11) => this._slicePlaneEnabledChange(e11)), this.updatingHandles.add(() => this.elevationOffset, (e11, t12) => {
        this._reloadAll(t12), this._controller.invalidateVisibilityObbs();
      }), this.updatingHandles.add(() => this.elevationInfo, (e11, t12) => this._elevationInfoChanged(e11, t12), h2), this.updatingHandles.add(() => this.contentVisible && this.elevationInfo.mode !== Bt.Absolute, (e11, t12) => {
        e11 ? this.handles.add(this.view.basemapTerrain.on("elevation-change", ({ extent: e12 }) => this._ensureElevationTask().addExtent(e12)), Kt) : t12 && this.handles.remove(Kt);
      }, h2), this.updatingHandles.add(() => this._usePBR, (e11) => this._updatePBR(e11));
      const a8 = () => {
        this._reloadAll(), this.clearMemCache();
      };
      this.updatingHandles.add(() => this.rendererTextureUsage, a8), this.updatingHandles.add(() => this.uncompressedTextureDownsamplingEnabled, a8), this.updatingHandles.add(() => this.contentVisible, (e11) => this._contentVisibleChanged(e11), h2), this.updatingHandles.add(() => this.i3slayer.labelsVisible, () => this._labelingChanged(), h2), this.updatingHandles.add(() => this.i3slayer.labelingInfo, () => this._labelingChanged(), h2), this.updatingHandles.add(() => this._modifications, () => this._modificationsChanged(), h2), this.handles.add([l3(() => t5.I3S_TREE_SHOW_TILES, (e11) => {
        if (e11 && !this._treeDebugger) {
          const e12 = this._controller.crsIndex;
          import("./I3STreeDebugger-A6VDXWTZ.js").then(({ I3STreeDebugger: t12 }) => {
            !this._treeDebugger && t5.I3S_TREE_SHOW_TILES && (this._treeDebugger = new t12({ lv: this, view: this.view, nodeSR: e12 }));
          });
        } else
          e11 || t5.I3S_TREE_SHOW_TILES || (this._treeDebugger = l(this._treeDebugger));
      }, h2), l3(() => t5.I3S_SHOW_MODIFICATIONS, () => this._showModifications(), h2)]), this._cacheKeySuffix = he(this.i3slayer.spatialReference, this.view.renderSpatialReference), this._idbCache.init().catch((e11) => yt.warn(`Failed to initialize IndexedDB cache: ${e11}`));
    }
    destroy() {
      this._clearAddTasks(), this._elevationTask = l(this._elevationTask), this.i3sOverrides = l(this.i3sOverrides), this._elevationProvider && (this._elevationProvider.layerChanged(), this.view.elevationProvider.unregister(this._elevationProvider), this._elevationProvider = null), this._intersectionHandler && (this._stage.view.sceneIntersectionHelper.removeIntersectionHandler(this._intersectionHandler), this._intersectionHandler = null);
      const e10 = this._worker;
      e10 && (e10.destroyContext(this.uid).then(() => e10.destroy()), this._worker = null), this._removeAllNodeDataFromStage(), this._memCache = l(this._memCache), this._collection = null, this._stage = null, this._edgeView = null, this._labeler = l(this._labeler), this._treeDebugger = l(this._treeDebugger), this._controller = l(this._controller), this._highlights.destroy(), this._nodeId2Meta.clear(), this._nodeId2MetaReloading.clear(), this._crossfadeHelper = l(this._crossfadeHelper), this.emit("visible-geometry-changed"), this._visibleGeometryChangedSchedulerHandle && (this._visibleGeometryChangedSchedulerHandle.remove(), this._visibleGeometryChangedSchedulerHandle = null);
    }
    _memEstimateTextureAdded(e10) {
      const t11 = e10.memoryEstimate;
      return this._gpuMemoryEstimate += t11, this._texMemoryEstimate += t11, t11;
    }
    _memEstimateTextureRemoved(e10) {
      if (null != e10) {
        const t11 = e10.memoryEstimate;
        this._gpuMemoryEstimate -= t11, this._texMemoryEstimate -= t11;
      }
    }
    _memEstimateGeometryAdded(e10) {
      const t11 = this._collection.getObjectGPUMemoryUsage(e10);
      return this._gpuMemoryEstimate += t11, this._geoMemoryEstimate += t11, t11;
    }
    _memEstimateGeometryRemoved(e10) {
      const t11 = this._collection.getObjectGPUMemoryUsage(e10);
      this._gpuMemoryEstimate -= t11, this._geoMemoryEstimate -= t11;
    }
    isNodeLoaded(e10) {
      return this._nodeId2Meta.has(e10);
    }
    isNodeReloading(e10) {
      return this._nodeId2MetaReloading.has(e10);
    }
    get usedMemory() {
      let e10 = null != this._labeler ? this._labeler.usedMemory : 0;
      return this._nodeId2Meta.forEach((t11) => e10 += null != t11 ? t11.node.memory : 0), this._nodeId2MetaReloading.forEach((t11) => e10 += null != t11 ? t11.node.memory : 0), e10;
    }
    get unloadedMemory() {
      return (null != this._controller ? this._controller.unloadedMemoryEstimate : 0) + (null != this._labeler ? this._labeler.unloadedMemoryEstimate : 0);
    }
    _labelingChanged() {
      if (!(H(this.i3slayer) && this._supportsLabeling))
        return void (null != this._labeler && (this._labeler.destroy(), this._labeler = null));
      if (null != this._labeler)
        return;
      const e10 = new S6({ view: this.view, layer: this.i3slayer, collection: this._collection, overrides: this.i3sOverrides });
      this._nodeId2Meta.forEach((t11) => null != t11 && this._addMetaToLabeler(e10, t11)), this._labeler = e10;
    }
    _loadAsyncModule(e10) {
      return ++this._asyncModuleLoading, e10.then((e11) => (--this._asyncModuleLoading, e11), (e11) => {
        throw --this._asyncModuleLoading, e11;
      });
    }
    _modificationsChanged() {
      if (!this._i3sWasmLoaded && this.hasModifications)
        return this._i3sWasmLoaded = j().then(() => {
          this._i3sWasmLoaded = true, this._modificationsChanged(), this.notifyUpdate();
        }), void this.notifyUpdate();
      if (true !== this._i3sWasmLoaded)
        return;
      const e10 = this.uid, t11 = this.i3slayer.spatialReference;
      this._worker.setModifications(e10, this._layerClippingArea, this._modifications, t11);
      const i12 = a6(this._layerClippingArea, this._modifications, t11);
      w2({ context: e10, modifications: i12, isGeodetic: t11.isGeographic }), this._controller.modificationsChanged();
      const s6 = this.hasModifications ? new l2() : null;
      this._nodeId2Meta.forEach((e11, t12) => {
        null == e11 ? (this._nodeId2Meta.delete(t12), this._controller.updateLoadStatus(t12, false)) : e11.node.hasModifications ? (this._nodeId2Meta.delete(t12), this._nodeId2MetaReloading.set(t12, e11)) : null != s6 && s6.push(e11.node);
      }), null != s6 && this._nodeId2MetaReloading.forEach((e11) => s6.push(e11.node)), null != s6 && s6.length > 0 && (this.updateNodeModificationStatus(s6), s6.forAll((e11) => {
        if (e11.imModificationImpact !== o3.Culled) {
          const t12 = this._nodeId2Meta.get(e11.index);
          this._controller.invalidateGeometryVisibility(e11.index), null != t12 ? (this._nodeId2Meta.delete(e11.index), this._nodeId2MetaReloading.set(e11.index, t12)) : this._nodeId2Meta.has(e11.index) && (this._nodeId2Meta.delete(e11.index), this._controller.updateLoadStatus(e11.index, false));
        }
      })), this.clearMemCache(), this._controller.restartNodeLoading(), this._showModifications();
    }
    _showModifications() {
      if (null != this._modificationGraphics && (this.view.graphics.removeMany(this._modificationGraphics), this._modificationGraphics = null), !t5.I3S_SHOW_MODIFICATIONS || 0 === this._modifications.length)
        return;
      const e10 = { clip: [227, 227, 79, 0.8], mask: [227, 139, 79, 0.8], replace: [139, 227, 79, 0.8] }, t11 = { type: "simple-fill", outline: { color: [255, 255, 255], width: 1 } };
      this._modificationGraphics = new Array();
      for (const s6 of this._modifications) {
        const r8 = s6.geometry;
        r8.spatialReference = this.i3slayer.spatialReference;
        const o10 = { ...t11, color: e10[s6.type] };
        this._modificationGraphics.push(new h7({ geometry: r8, symbol: o10 }));
      }
      this.view.graphics.addMany(this._modificationGraphics);
    }
    _addMetaToLabeler(e10, t11) {
      e10.addNodeMeta(t11, (e11, t12) => this._createAttributes(e11, t12));
    }
    _contentVisibleChanged(e10) {
      e10 ? (this.view.elevationProvider.register(this._elevationContext, this._elevationProvider), this._stage.view.sceneIntersectionHelper.addIntersectionHandler(this._intersectionHandler)) : (this._removeAllNodeDataFromStage(), this.view.elevationProvider && this.view.elevationProvider.unregister(this._elevationProvider), this._stage.view.sceneIntersectionHelper.removeIntersectionHandler(this._intersectionHandler));
    }
    getLoadedAttributes(e10) {
      const t11 = this._nodeId2Meta.get(e10);
      if (null != t11 && null != t11.attributeInfo)
        return t11.attributeInfo.loadedAttributes;
    }
    getAttributeData(e10) {
      const t11 = this._nodeId2Meta.get(e10);
      if (null != t11 && null != t11.attributeInfo)
        return t11.attributeInfo.attributeData;
    }
    setAttributeData(e10, t11) {
      const i12 = this._nodeId2Meta.get(e10);
      null != i12 && null != i12.attributeInfo && (i12.attributeInfo.attributeData = t11, this._attributeValuesChanged(i12));
    }
    async updateAttributes(e10, t11, i12) {
      const s6 = this._nodeId2Meta.get(e10);
      null != s6 && (await this.i3sOverrides.applyAttributeOverrides(s6.featureIds, t11, i12), s6.attributeInfo = t11, this._controller.reschedule(() => this._attributeValuesChanged(s6), i12).catch((e11) => {
        d(e11) || yt.warn("Error while updating attribute values. Layer might not display correctly.", e11);
      }));
    }
    _attributeValuesChanged(e10) {
      e10.cachedRendererVersion = this._getInvalidRendererVersion(), e10.filteredIds = null, null != this._labeler && this._labeler.setNodeMetaAttributes(e10, (e11, t11) => this._createAttributes(e11, t11)), this._updateEngineObject(e10);
    }
    clearMemCache() {
      null != this._memCache && this._memCache.clear();
    }
    getVisibleNodes() {
      const e10 = new Array();
      return this._nodeId2Meta.forEach((t11) => null != t11 && e10.push(t11.node)), e10;
    }
    getNodeComponentObb(e10) {
      const t11 = this._nodeId2Meta.get(e10.index) ?? this._nodeId2MetaReloading.get(e10.index);
      return null != t11 ? this._collection.getComponentObb(t11.objectHandle) : null;
    }
    getLoadedNodeIndices(e10) {
      this._nodeId2Meta.forEach((t11, i12) => e10.push(i12)), this._nodeId2MetaReloading.forEach((t11, i12) => e10.push(i12));
    }
    _preLoadBasis() {
      !has("disable-feature:i3s-basis") && 0 != (this.supportedTextureEncodings & e8.Basis) && n(this.i3slayer.textureSetDefinitions, (e10) => e10.some((e11) => e11.formats.some((e12) => "basis" === e12.format || "ktx2" === e12.format))) && g2();
    }
    _getVertexBufferLayout(e10, t11) {
      const i12 = { hasTexture: Ft(e10.params.material), hasNormals: t11.normal, hasRegions: t11.uvRegion };
      return r5(o6(this._getGeometryParameters(i12)));
    }
    _getObjectIdField() {
      return this.i3slayer.objectIdField || o4;
    }
    _getGlobalIdField() {
      var _a;
      return (_a = this.i3slayer.associatedLayer) == null ? void 0 : _a.globalIdField;
    }
    _findGraphicNodeAndIndex(e10) {
      const t11 = n8(this.i3slayer.fieldsIndex, e10.attributes, this._getObjectIdField());
      let i12 = null;
      return n3(this._nodeId2Meta, (e11) => {
        if (null == e11)
          return false;
        const s6 = e11.featureIds.indexOf(t11);
        return -1 !== s6 && (i12 = { node: e11.node, index: s6 }, true);
      }), i12;
    }
    _getGraphicIndices(e10, t11) {
      const i12 = this._nodeId2Meta.get(e10.index);
      if (null == i12)
        return [];
      const s6 = [], r8 = this._getObjectIdField(), o10 = this.i3slayer.fieldsIndex;
      for (const a8 of t11) {
        const e11 = n8(o10, a8.attributes, r8), t12 = i12.featureIds.indexOf(e11);
        -1 !== t12 && s6.push(t12);
      }
      return s6;
    }
    whenGraphicBounds(e10) {
      const t11 = this._findGraphicNodeAndIndex(e10);
      if (!t11)
        return Promise.reject();
      const i12 = this._getAABB(t11.node.index, t11.index);
      return null == i12 ? Promise.reject() : Promise.resolve({ boundingBox: i12, screenSpaceObjects: [] });
    }
    getAABBFromIntersectorTarget(e10) {
      return null == e10.nodeIndex || null == e10.componentIndex ? null : this._getAABB(e10.nodeIndex, e10.componentIndex);
    }
    _getAABB(e10, t11) {
      const i12 = this._nodeId2Meta.get(e10);
      if (null == i12 || null == i12.featureIds || t11 >= i12.featureIds.length)
        return null;
      const s6 = i12.objectHandle, r8 = i5(t11, this._collection, s6, t3(24), 0), o10 = this.view.renderSpatialReference, a8 = this.view.spatialReference;
      if (!yn(r8, o10, 0, r8, a8, 0, 8))
        return null;
      const n12 = P();
      return c(n12, r8, 0, 8), n12;
    }
    whenGraphicAttributes(e10, t11) {
      return ne(this.i3slayer, e10, this._getObjectIdField(), t11, () => [...this._nodeId2Meta.values()].filter(R));
    }
    getGraphicFromIntersectorTarget(e10) {
      if (null == e10.nodeIndex || null == e10.componentIndex)
        return null;
      const t11 = this._nodeId2Meta.get(e10.nodeIndex);
      return null == t11 || null == t11.featureIds || e10.componentIndex >= t11.featureIds.length ? null : this._createGraphic(e10.componentIndex, t11);
    }
    _getCacheKey(e10) {
      return `${this._layerUrl}/v${Ct}/${e10}${this._cacheKeySuffix}`;
    }
    _getMemCacheKey(e10, t11 = this.elevationOffset) {
      return e10 + "#" + t11;
    }
    get _idbCacheEnabled() {
      return !this._controller.disableIDBCache && !this.hasModifications && 0 === this.elevationOffset && null != this._cacheKeySuffix;
    }
    loadCachedGPUData(e10) {
      return null != this._memCache ? this._memCache.pop(this._getMemCacheKey(e10)) : null;
    }
    deleteCachedGPUData(e10) {
      null != e10 && this._deleteComponentObject(e10);
    }
    _cacheGPUData(e10, t11 = this.elevationOffset) {
      if (null == this._memCache)
        return void this._deleteComponentObject(e10);
      const i12 = this._controller.indexDepth - e10.node.level;
      this._memCache.put(this._getMemCacheKey(e10.node.index, t11), e10, e10.node.memory, i12);
    }
    loadMissingTextures(e10, t11, i12, s6) {
      const r8 = (e10 == null ? void 0 : e10.filter((e11, i13) => {
        if (0 == (e11.usage & this.rendererTextureUsage))
          return false;
        if (null == t11)
          return true;
        const s7 = D2(e11.encodings, this.supportedTextureEncodings), r9 = t11[i13];
        return !!(null == r9 || null == r9.data || s7 && r9.encoding !== s7.encoding);
      })) ?? [];
      return 0 === r8.length ? Promise.resolve(false) : i12(r8, s6).then((i13) => {
        let s7 = 0;
        for (let r9 = 0; r9 < e10.length; r9++)
          s7 < i13.length && i13[s7].id === e10[r9].id && (t11[r9] = i13[s7], s7++);
        return true;
      });
    }
    loadCachedNodeData(e10, t11, i12) {
      return this._idbCacheEnabled ? this._idbCache.get(this._getCacheKey(e10.id), t11).then((s6) => null == s6 ? null : s6.nodeVersion !== e10.version ? (this._idbCache.remove(this._getCacheKey(e10.id)), null) : (this.elevationInfo.mode === Bt.Absolute && (e10.geometryObb = s6.geometryObb), this.loadMissingTextures(s6.requiredTextures, s6.textureData, i12, t11).then((i13) => (i13 && this._idbCache.initialized && null != s6.textureData && (s6.byteSize = Ht(s6.transformedGeometry, s6.textureData), s6.textureData.every(Pt) && Ut(e10, s6) && this._idbCache.put(this._getCacheKey(e10.id), s6).catch((t12) => yt.warn(`Failed to update node with textures in IndexedDB cache: ${e10.id}: ${t12}`))), s3(t11), s6)))) : Promise.resolve(null);
    }
    addNode(e10, t11, i12) {
      return Vt(t11) ? null == t11.geometryBuffer ? (this._addNodeMeta(e10.index, null), Promise.resolve()) : this._addData(e10, t11.attributeDataInfo, () => this._transformNode(e10, t11, i12).then((s6) => this._safeReschedule(() => {
        if (null == s6)
          return e10.hasModifications = false, this._addCachedNodeData(e10, null, i12);
        e10.hasModifications = s6.transformedGeometry.hasModifications;
        const { obb: r8, componentOffsets: o10, featureIds: a8, anchorIds: n12, anchors: l7, transformedGeometry: d4 } = s6, h9 = this._controller.crsIndex, c7 = this.view.renderSpatialReference, u5 = n6(e10.mbs, this.elevationOffset, h9, c7), _2 = O3([r8.center.x, r8.center.y, r8.center.z], [r8.extents.x, r8.extents.y, r8.extents.z], t4(r8.orientation.x, r8.orientation.y, r8.orientation.z, r8.orientation.w));
        O(_2.center, _2.center, u5), this.elevationInfo.mode === Bt.Absolute && (e10.geometryObb = _2), t11.geometryData.componentOffsets = o10, a8 && (t11.geometryData.featureIds = Array.from(a8)), t11.geometryData.anchorIds = n12, t11.geometryData.anchors = l7;
        const m5 = { nodeVersion: e10.version, geometryData: t11.geometryData, requiredTextures: t11.requiredTextures, textureData: t11.textureData, transformedGeometry: d4, globalTrafo: u5, geometryObb: _2, byteSize: Ht(d4, t11.textureData) };
        if (this._idbCacheEnabled && this._idbCache.initialized && Ut(e10, m5)) {
          const t12 = null != m5.textureData ? m5.textureData.map((e11) => Pt(e11) ? e11 : null) : null;
          this._idbCache.put(this._getCacheKey(e10.id), { ...m5, textureData: t12 }).catch((t13) => yt.warn(`Failed to store node in IndexedDB cache: ${e10.id}: ${t13}`));
        }
        return this._addCachedNodeData(e10, m5, i12);
      }, i12))) : Promise.reject();
    }
    getElevationRange(e10) {
      let t11 = 1 / 0, i12 = -1 / 0;
      const s6 = A3(this.view.renderCoordsHelper.spatialReference);
      return this._nodeId2Meta.forEach((r8) => {
        if (null != r8 && null != r8.node.geometryObb) {
          const o10 = r8.node.geometryObb;
          if (U(o10, e10)) {
            const e11 = this._collection.getObjectTransform(r8.objectHandle), o11 = this.view.renderCoordsHelper.getAltitude(e11.position);
            for (let a8 = 0; a8 < r8.featureIds.length; a8++) {
              const e12 = this._collection.getComponentAabb(r8.objectHandle, a8, zt);
              if ("local" === this.view.viewingMode)
                t11 = Math.min(t11, o11 + e12[2]), i12 = Math.max(i12, o11 + e12[5]);
              else {
                t11 = Math.min(t11, o11 + e12[2]);
                const r9 = Math.max(Math.abs(e12[3]), Math.abs(e12[0])), a9 = Math.max(Math.abs(e12[4]), Math.abs(e12[1])), n12 = o11 + e12[5] + s6.radius;
                i12 = Math.max(i12, Math.sqrt(r9 * r9 + a9 * a9 + n12 * n12) - s6.radius);
              }
            }
          }
        }
      }), { min: t11, max: i12 };
    }
    computeVisibilityObb(e10) {
      return Ke(e10, this.view.renderSpatialReference, this._controller.crsIndex, this.i3slayer.spatialReference, this.elevationOffset, this._modifications);
    }
    _transformNode(e10, t11, i12) {
      const s6 = t11.geometryData.geometries ?? [], r8 = new Array(s6.length);
      for (let g5 = 0; g5 < s6.length; ++g5)
        r8[g5] = this._getVertexBufferLayout(s6[g5], t11.geometryDescriptor);
      const o10 = e10.mbs, a8 = this.elevationOffset, n12 = this._controller.crsIndex, l7 = this._controller.crsVertex, d4 = this.view.renderSpatialReference, h9 = h5(o10, a8, n12), c7 = n6(o10, a8, n12, d4), u5 = fn(n12, l7), _2 = fn(l7, d4);
      if (null == u5 || null == _2)
        return Promise.resolve(null);
      const m5 = { context: this.uid, geometryBuffer: t11.geometryBuffer, geometryData: t11.geometryData, geometryDescriptor: t11.geometryDescriptor, layouts: r8, localOrigin: h9, globalTrafo: c7, mbs: o10, obb: e10.serviceObb, elevationOffset: a8, needNormals: !this._isIntegratedMesh && this._controller.isMeshPyramid, normalReferenceFrame: this.i3slayer.normalReferenceFrame || "none", indexToVertexProjector: u5, vertexToRenderProjector: _2 };
      return this._worker.invoke(m5, i12);
    }
    get _supportsNodeCrossFading() {
      var _a, _b;
      return !((_b = (_a = this.view) == null ? void 0 : _a._stage) == null ? void 0 : _b.renderer.shadowsEnabled);
    }
    get nodeCrossfadingEnabled() {
      return this._supportsNodeCrossFading && (this.lodCrossfadeinDuration > 0 || this.lodCrossfadeoutDuration > 0 || this.lodCrossfadeUncoveredDuration > 0);
    }
    get nodeFadeoutEnabled() {
      return this._supportsNodeCrossFading && this.lodCrossfadeoutDuration > 0;
    }
    _setNewNodeOpacity(e10) {
      const t11 = this.nodeCrossfadingEnabled ? 0 : this.fullOpacity;
      this._setNodeOpacity(e10, t11);
    }
    addCachedGPUData(e10, t11, i12) {
      if (this.elevationInfo.mode === Bt.Absolute && (e10.geometryObb = P2(this._collection.getComponentObb(t11.objectHandle))), !this._controller.isGeometryVisible(e10))
        return void this._cacheGPUData(t11);
      null != this._labeler && this._addMetaToLabeler(this._labeler, t11);
      const s6 = e10.index;
      this._addNodeMeta(s6, t11), this.updateNodeState(s6, i12), this._collection.setObjectVisibility(t11.objectHandle, c4.Visible), this._updateMaterial(t11), this._setNewNodeOpacity(t11), this.elevationInfo.mode !== Bt.Absolute && this._ensureElevationTask().schedule(s6), this._updateEngineObject(t11), this._highlights.objectCreated(t11), null != this._treeDebugger && this._treeDebugger.update();
    }
    addCachedNodeData(e10, t11, i12, s6) {
      return this._addData(e10, i12, () => this._addCachedNodeData(e10, t11, s6));
    }
    async deleteCachedNodeData(e10) {
      if (this._idbCacheEnabled)
        return this._idbCache.remove(this._getCacheKey(e10));
    }
    async _addCachedNodeData(e10, t11, i12) {
      var _a;
      if (!this.contentVisible || !this._controller.isGeometryVisible(e10))
        return void this._removeNodeStageData(e10.index, this.elevationOffset, this._nodeId2MetaReloading);
      if (null == t11)
        return void this._addNodeMeta(e10.index, null);
      const s6 = this._addTasks.get(e10.index), { geometryData: r8, transformedGeometry: o10, globalTrafo: a8 } = t11;
      await this.i3sOverrides.applyAttributeOverrides(r8.featureIds, s6.attributeInfo, i12);
      const n12 = null != t11.textureData ? t11.textureData.filter((e11) => null != e11 && 0 != (e11.usage & this.rendererTextureUsage)) : [];
      !has("disable-feature:i3s-basis") && n12.some((e11) => null != e11 && (e11.encoding === e8.Basis || e11.encoding === e8.KTX2)) && await g2(), e10.memory = 0;
      const { componentOffsets: l7, geometries: d4, featureIds: h9, anchorIds: c7, anchors: u5 } = r8, _2 = this._collection, m5 = d4[0], { layout: g5, indices: p4, interleavedVertexData: f2, positionData: b2, hasColors: y4 } = o10, v4 = this._materialParameters(m5, g5), I5 = l7 || new Uint32Array([0, p4 ? p4.length : f2.byteLength / g5[0].stride]), w5 = { vertices: { data: f2, count: f2.byteLength / g5[0].stride, layoutParameters: v4.geometryParams }, positionData: { positions: e7(b2.data), indices: t2(b2.indices) }, indices: p4, componentOffsets: I5 }, S7 = m5.transformation ? r6(m5.transformation) : e5();
      c2(S7, a8, S7);
      const A7 = I(n4(), S7), T2 = a3(e4(), S7), D5 = this.view.renderSpatialReference, R2 = this.view.basemapTerrain.spatialReference, N = n4(), F3 = [1, 1, 1];
      bn(A7, D5, F3, R2) || yt.errorOnce("Unsupported coordinate system for IM overlay"), Hn(A7, D5, N, R2);
      const P3 = _2.createObject({ toMapSpace: r4(N[0], N[1], F3[0], F3[1]), geometry: w5, obb: t11.geometryObb, transform: { position: A7, rotationScale: T2 } }), U3 = v4.geometryParams.textureCoordinates === d2.Atlas, { textures: G, texturePromise: L3 } = this._initMaterialAndTextures(P3, v4.material, n12, U3);
      e10.memory += this._memEstimateGeometryAdded(P3), e10.memory += G.reduce((e11, t12) => e11 + (null != t12 ? this._memEstimateTextureAdded(t12) : 0), 0);
      const q2 = !!v4.material.hasParametersFromSource, z2 = "blend" !== v4.material.alphaMode && v4.material.metallicRoughness.baseColorFactor[3] >= 1, K = new It(e10, h9, P3, this._getInvalidRendererVersion(), s6.attributeInfo, { hasParametersFromSource: q2, isOpaque: z2 }, G, c7, u5);
      s6.meta = K, !this._hasTextures && ((_a = t11.requiredTextures) == null ? void 0 : _a.some(({ usage: e11 }) => 0 != (e11 & s4.ColorTextures))) && (this._hasTextures = true), this._hasData = true, this._hasColors = this._hasColors || y4, this._hasTextures = this._hasTextures || !!e10.resources.texture, this.notifyChange("hasTexturesOrVertexColors");
      const W = this.slicePlaneEnabled;
      return Promise.all([this._addOrUpdateEdgeRendering(K), L3]).then(([t12, s7]) => (null != t12 && t12.updateObjectVisibility(K.objectHandle, false).catch((e11) => Et(e11, this.i3slayer.title)), this._safeReschedule(() => {
        const i13 = this._addTasks.get(e10.index);
        if (!i13)
          return;
        if (this._addNodeMeta(e10.index, K), i13.meta = null, !this.contentVisible)
          return void this._removeNodeStageData(e10.index, this.elevationOffset);
        _2.setObjectVisibility(P3, c4.Visible), null != t12 && t12.updateObjectVisibility(K.objectHandle, true).catch((e11) => Et(e11, this.i3slayer.title)), K.attributeInfo = i13.attributeInfo;
        const s8 = K.cachedRendererVersion !== this._rendererVersion, r9 = W !== this.slicePlaneEnabled;
        this._updateElevationOffsets(K);
        const o11 = K.elevationOffsets;
        this._updateComponentData(K);
        const a9 = this._applyFiltersToNode(K);
        (s8 || null != t12 && (r9 || a9 || o11)) && this._addOrUpdateEdgeRendering(K), null != this._labeler && this._addMetaToLabeler(this._labeler, K), this._visibleGeometryChanged(K, jt.ADD), this._highlights.objectCreated(K), this._updateMaterial(K), this._setNewNodeOpacity(K), null != this._treeDebugger && this._treeDebugger.update();
      }, i12))).catch((e11) => {
        throw null != s6.meta && (this._cacheGPUData(s6.meta), s6.meta = null), e11;
      });
    }
    _addNodeMeta(e10, t11) {
      if (this._removeNodeStageData(e10, this.elevationOffset, this._nodeId2MetaReloading), this._nodeId2Meta.has(e10)) {
        yt.error("Removing duplicated node");
        const t12 = this._nodeId2Meta.get(e10);
        null != t12 && this._deleteComponentObject(t12);
      } else
        this._controller.updateLoadStatus(e10, true);
      null != t11 && (t11.lodCrossfadeProgress = null, this.nodeCrossfadingEnabled && kt(t11.cachedEdgeMaterials, 0)), this._nodeId2Meta.set(e10, t11);
    }
    _updateElevationOffsets(e10) {
      const t11 = this.view.renderSpatialReference, i12 = this._controller.crsIndex, s6 = this.elevationInfo, r8 = this.view.basemapTerrain, o10 = r8.spatialReference, a8 = s6.mode;
      if (null == t11 || null == o10 || a8 === Bt.Absolute)
        return void (e10.elevationOffsets = null);
      const n12 = this._collection.getObjectTransform(e10.objectHandle);
      e10.elevationOffsets = e10.elevationOffsets ?? [];
      const l7 = qt, d4 = zt, h9 = a8 === Bt.OnTheGround, c7 = this.view.renderCoordsHelper, u5 = e10.featureIds.length, _2 = (() => {
        var _a;
        if (e10.cachedElevationAnchors)
          return e10.cachedElevationAnchors;
        const s7 = t3(3 * u5);
        e10.cachedElevationAnchors = s7;
        for (let r9 = 0; r9 < u5; r9++) {
          const a9 = 3 * r9, h10 = ((_a = e10.anchorIds) == null ? void 0 : _a.indexOf(r9)) ?? -1;
          e10.anchors && h10 >= 0 ? (o2(l7, e10.anchors[3 * h10], e10.anchors[3 * h10 + 1], e10.anchors[3 * h10 + 2]), u2(l7, l7, e10.node.mbs), Hn(l7, i12, l7, o10), s7[a9] = l7[0], s7[a9 + 1] = l7[1], s7[a9 + 2] = c7.getAltitude(l7)) : (this._collection.getComponentAabb(e10.objectHandle, r9, d4, true), o2(l7, (d4[0] + d4[3]) / 2, (d4[1] + d4[4]) / 2, d4[2]), S2(l7, l7, n12.rotationScale), u2(l7, l7, n12.position), s7[a9 + 2] = c7.getAltitude(l7), Hn(l7, t11, l7, o10), s7[a9] = l7[0], s7[a9 + 1] = l7[1]);
        }
        return s7;
      })(), m5 = s6.offset, g5 = e10.elevationOffsets, p4 = (e11, t12) => {
        const i13 = h9 ? _2[3 * e11 + 2] : 0;
        g5[e11] = m5 + (null != t12 ? t12 - i13 : 0);
      };
      r8.getElevations(_2, u5, p4);
    }
    _ensureElevationTask() {
      return null != this._elevationTask || (this._elevationTask = new i9(this.view.resourceController.scheduler, (e10) => {
        const t11 = this._controller.updateElevationChanged(e10, this.view.basemapTerrain.spatialReference);
        return null != t11 ? t11.filterInPlace((e11) => null != this._nodeId2Meta.get(e11)) : null;
      }, (e10) => {
        const t11 = this._nodeId2Meta.get(e10);
        this._nodeElevationAlignmentChanged(t11);
      })), this._elevationTask;
    }
    _elevationInfoChanged(e10, t11) {
      const i12 = e10.mode !== Bt.Absolute, s6 = !!t11 && t11 !== e10 && t11.mode !== Bt.Absolute;
      this._intersectionHandler.updateElevationAlignState(i12, this.view.state.viewingMode), i12 && !s6 && this._controller.removeAllGeometryObbs(), this._nodeId2Meta.forEach((e11) => this._nodeElevationAlignmentChanged(e11));
    }
    _nodeElevationAlignmentChanged(e10) {
      null != e10 && (this._updateElevationOffsets(e10), this._updateComponentData(e10), this._updateEdgeRendering(e10), null != this._labeler && this._labeler.updateLabelPositions(e10), this._updateSnappingSources(e10, jt.UPDATE));
    }
    _safeReschedule(e10, t11) {
      return s3(t11), this._controller.reschedule(e10, t11);
    }
    _materialParameters(e10, t11) {
      const i12 = null != e10.params.material ? e10.params.material : b(), s6 = t11.some((e11) => "uvRegion" === e11.name), r8 = t11.some((e11) => "normalCompressed" === e11.name), o10 = Ft(i12);
      return { geometryParams: this._getGeometryParameters({ hasTexture: o10, hasNormals: r8, hasRegions: s6 }), material: i12 };
    }
    _initMaterialAndTextures(e10, t11, i12, s6) {
      const r8 = this._stage.renderView, o10 = i12.map((e11) => F(e11, t11, s6, r8));
      this._stage.addMany(o10);
      let a8 = null;
      return this._collection.updateMaterial(e10, (e11) => {
        a8 = S5(e11, t11, o10, i12, this.view._stage.renderView.textureRepository, { rendererTextureUsage: this.rendererTextureUsage, usePBR: this._usePBR, isIntegratedMesh: this._isIntegratedMesh, slicePlaneEnabled: this.slicePlaneEnabled, viewSpatialReference: this.view.spatialReference }), this._updateMaterialOverlay(e11);
      }), { textures: o10, texturePromise: a8 };
    }
    _getGeometryParameters(e10) {
      return { textureCoordinates: e10.hasTexture ? e10.hasRegions ? d2.Atlas : d2.Default : d2.None, colors: this._hasVertexColors, normals: e10.hasNormals && !this._isIntegratedMesh };
    }
    _addData(e10, t11, i12) {
      let s6 = this._addTasks.get(e10.index);
      return s6 ? s6.attributeInfo = t11 : (s6 = { ...C(), attributeInfo: t11, meta: null }, this._addTasks.set(e10.index, s6), i12().then(s6.resolve, s6.reject).then(() => this._addTasks.delete(e10.index)).catch((t12) => {
        throw this._addTasks.delete(e10.index), t12;
      })), s6.promise;
    }
    _clearAddTasks() {
      this._addTasks.forEach((e10) => {
        null != e10.meta && (this._cacheGPUData(e10.meta), e10.meta = null);
      }), this._addTasks.clear();
    }
    _clippingAreaChanged() {
      const e10 = this.view.renderSpatialReference, t11 = this.i3slayer.spatialReference, i12 = i();
      this._renderClippingArea = u3(this.view.clippingArea, i12, e10) ? i12 : null;
      const s6 = i();
      this._layerClippingArea = u3(this.view.clippingArea, s6, t11) ? s6 : null, this._filterChange(), this._controller && this._controller.updateClippingArea(this.view.clippingArea), this._isIntegratedMesh && this._modificationsChanged();
    }
    get hasGeometryFilter() {
      return false;
    }
    _geometryFilterChange() {
      const e10 = this.hasGeometryFilter;
      this._controller.geometryFilterChanged(e10), this._applyFilters(e10);
    }
    _filterChange() {
      this._applyFilters(this.hasGeometryFilter);
    }
    _applyFilters(e10) {
      this._filters = this.getFilters(), e10 ? this._controller && this._controller.requestUpdate() : this._nodeId2Meta.forEach((e11) => {
        null != e11 && this._applyFiltersToNode(e11) && (this._addOrUpdateEdgeRendering(e11), this._visibleGeometryChanged(e11, jt.UPDATE));
      });
    }
    getFilters() {
      const e10 = [], t11 = this._renderClippingArea;
      return null != t11 && e10.push((e11, i12) => this._boundingRectFilter(e11, i12, t11)), e10;
    }
    addSqlFilter(e10, t11, i12) {
      if (null != t11) {
        const s6 = t11.fieldNames;
        e10.push((e11, r8) => this._sqlFilter(e11, r8, t11, s6, i12));
      }
    }
    _sqlFilter(e10, t11, i12, s6, r8) {
      const o10 = {}, a8 = this._createLayerGraphic(o10), n12 = this.i3slayer.objectIdField, l7 = t11.featureIds, d4 = null != t11.attributeInfo && t11.attributeInfo.attributeData;
      s6.every((e11) => e11 === n12 || d4 && null != d4[e11]) && J(e10, l7, (e11) => {
        o10[n12] = l7[e11];
        for (const i13 of s6)
          i13 !== n12 && (o10[i13] = d4 ? fe(d4[i13], e11) : null);
        try {
          return i12.testFeature(a8);
        } catch (t12) {
          return r8(t12), false;
        }
      });
    }
    _boundingRectNodeTest(e10, t11) {
      return xn(e10.node.mbs, this._controller.crsIndex, Nt, this.view.renderSpatialReference), te(t11, Nt);
    }
    _boundingRectFeatureTest(e10, t11, i12) {
      return this._collection.getComponentAabb(e10.objectHandle, t11, wt), S3(wt, St), q(i12, St);
    }
    _boundingRectFilter(e10, t11, i12) {
      const s6 = this._collection, r8 = this._boundingRectNodeTest(t11, i12);
      if (r8 === ee.INSIDE)
        return;
      if (r8 === ee.OUTSIDE)
        return void (e10.length = 0);
      const o10 = s6.getComponentCount(t11.objectHandle);
      if (o10.invisible + o10.visible !== t11.featureIds.length)
        return;
      const a8 = this._transformClippingArea(At, i12, t11.objectHandle);
      J(e10, t11.featureIds, (e11) => this._boundingRectFeatureTest(t11, e11, a8));
    }
    _transformClippingArea(e10, t11, i12) {
      const s6 = this._collection.getObjectTransform(i12), r8 = s6.position, o10 = s6.rotationScale;
      return e10[0] = (t11[0] - r8[0]) / o10[0], e10[1] = (t11[1] - r8[1]) / o10[4], e10[2] = (t11[2] - r8[0]) / o10[0], e10[3] = (t11[3] - r8[1]) / o10[4], e10;
    }
    _addOrUpdateEdgeRendering(e10, t11 = true) {
      const i12 = this._edgeView;
      if (null == i12)
        return Promise.resolve(null);
      const s6 = e10.objectHandle, r8 = i12.hasObject(s6), { hasEdges: o10, perFeatureEdgeMaterials: a8 } = this._getFilteredEdgeMaterials(e10), n12 = { hasSlicePlane: this.slicePlaneEnabled };
      if (o10 && r8) {
        if (this.nodeCrossfadingEnabled) {
          kt(a8, this.getNodeOpacity(e10));
        }
        return i12.updateAllComponentMaterials(s6, a8, n12, t11).catch((e11) => Et(e11, this.i3slayer.title)), i12.updateObjectVisibility(s6, true).catch((e11) => Et(e11, this.i3slayer.title)), i12.updateAllVerticalOffsets(s6, e10.elevationOffsets).catch((e11) => Et(e11, this.i3slayer.title)), Promise.resolve(i12);
      }
      return o10 && !r8 ? this._collection.addEdges(s6, i12, a8, n12).then((t12) => (e10.edgeMemoryUsage = t12, e10.node.memory += t12, i12.updateAllVerticalOffsets(s6, e10.elevationOffsets).catch((e11) => Et(e11, this.i3slayer.title)), i12)) : (!o10 && r8 && (e10.node.memory -= e10.edgeMemoryUsage, e10.edgeMemoryUsage = 0, i12.removeObject(s6)), Promise.resolve(null));
    }
    _applyFiltersToNode(e10) {
      return !!this._applyFiltersToNodeComponents(e10) && (null != this._labeler && this._labeler.applyFilterChange(e10), true);
    }
    _applyFiltersToNodeComponents(e10) {
      const t11 = this._collection, i12 = 0 === t11.getComponentCount(e10.objectHandle).invisible;
      if (t11.setAllComponentVisibilities(e10.objectHandle, "all"), 0 === this._filters.length)
        return e10.filteredIds = null, !i12;
      if (this._updateCachedFilteredIds(e10), e10.filteredIds === e10.featureIds)
        return !i12;
      const s6 = this._computeFilteredComponentIndices(e10);
      return t11.setAllComponentVisibilities(e10.objectHandle, s6), true;
    }
    _updateCachedFilteredIds(e10) {
      null != e10.filteredIds && e10.appliedFilters === this._filters || (e10.filteredIds = this._computeFilteredIds(e10), e10.appliedFilters = this._filters);
    }
    _computeFilteredIds(e10) {
      const t11 = e10.featureIds.slice();
      for (const i12 of this._filters)
        if (i12(t11, e10), 0 === t11.length)
          break;
      return t11.length === e10.featureIds.length ? e10.featureIds : t11;
    }
    _computeFilteredComponentIndices(e10) {
      const t11 = new Array(), i12 = e10.filteredIds;
      return null != i12 && e10.featureIds.forEach((e11, s6) => {
        i12[t11.length] === e11 && t11.push(s6);
      }), t11;
    }
    _removeAllNodeDataFromStage(e10 = this.elevationOffset) {
      this._nodeId2Meta.forEach((t11, i12) => this._removeNodeStageData(i12, e10)), this._nodeId2MetaReloading.forEach((t11, i12) => this._removeNodeStageData(i12, e10, this._nodeId2MetaReloading)), this._elevationTask = l(this._elevationTask);
    }
    removeNode(e10) {
      const t11 = this.elevationOffset;
      this._removeNodeStageData(e10, t11), this._removeNodeStageData(e10, t11, this._nodeId2MetaReloading), null != this._elevationTask && this._elevationTask.remove(e10);
    }
    _removeNodeStageData(e10, t11, i12 = this._nodeId2Meta) {
      i12.has(e10) && this._controller.updateLoadStatus(e10, false);
      const s6 = i12.get(e10);
      null != s6 ? (this._collection.setObjectVisibility(s6.objectHandle, c4.Hidden), null != this._edgeView && this._edgeView.hasObject(s6.objectHandle) && this._edgeView.updateObjectVisibility(s6.objectHandle, false).catch((e11) => Et(e11, this.i3slayer.title)), this._visibleGeometryChanged(s6, jt.REMOVE), null != this._labeler && this._labeler.removeNodeMeta(s6), i12.delete(e10), this._highlights.objectDeleted(s6), i12 === this._nodeId2Meta ? (this._cacheGPUData(s6, t11), this.nodeCrossfadingEnabled && this._crossfadeHelper.stopNodeFading(s6)) : this._deleteComponentObject(s6), null != this._treeDebugger && this._treeDebugger.update()) : i12.delete(e10);
    }
    _deleteComponentObject(e10) {
      if (null != this._edgeView && this._edgeView.removeObject(e10.objectHandle), this._memEstimateGeometryRemoved(e10.objectHandle), this._collection.destroyObject(e10.objectHandle), e10.textures)
        for (const t11 of e10.textures)
          this._memEstimateTextureRemoved(t11), this._stage.remove(t11);
    }
    updateNodeState(e10, t11) {
      const i12 = this._nodeId2Meta.get(e10);
      null != i12 && this._collection.updateMaterial(i12.objectHandle, (e11) => e11.polygonOffsetEnabled = t11 === c3.Hole);
    }
    updateNodeIndex(e10, t11) {
      if (this._nodeId2Meta.has(e10)) {
        const i13 = this._nodeId2Meta.get(e10);
        this._nodeId2Meta.delete(e10), this._nodeId2Meta.set(t11, i13);
      }
      const i12 = this._nodeId2MetaReloading.get(e10);
      i12 && (this._nodeId2MetaReloading.delete(e10), this._nodeId2MetaReloading.set(t11, i12));
    }
    _invalidateAllSymbols() {
      this._rendererVersion = ke(this._rendererVersion, 1), this._controller && this._controller.requestUpdate();
    }
    _getInvalidRendererVersion() {
      return ke(this._rendererVersion, -1);
    }
    async _rendererChange(e10) {
      if (this._currentRenderer = e10, this.notifyChange("rendererTextureUsage"), this._rendererVersion = ke(this._rendererVersion, 1), this._rendererFields = null, this._colorVariable = null, this._opacityVariable = null, this._invalidateAllSymbols(), e10 && (this._rendererFields = await e10.getRequiredFields(this.i3slayer.fieldsIndex)), this._updateSymbologyFields(), !this._arcade && e10 && "arcadeRequired" in e10 && e10.arcadeRequired && (this._arcade = await i3()), e10 && "visualVariables" in e10 && e10.visualVariables)
        for (const t11 of e10.visualVariables)
          "color" === t11.type ? this._colorVariable = t11 : "opacity" === t11.type ? this._opacityVariable = t11 : yt.warn(`Unsupported visual variable type for 3D Object Scene Services: ${t11.type}`);
      if (e10)
        for (const t11 of e10.getSymbols())
          "mesh-3d" !== t11.type && yt.error(`Symbols of type '${t11.type}' are not supported for 3D Object Scene Services.`);
      this._controller && this._controller.requestUpdate();
    }
    _getCachedEdgeMaterials(e10) {
      return this._hasComponentData && e10.cachedRendererVersion !== this._rendererVersion && this._updateCachedRendererData(e10), e10.cachedEdgeMaterials;
    }
    _getComponentParameters(e10) {
      this._hasComponentData && e10.cachedRendererVersion !== this._rendererVersion && this._updateCachedRendererData(e10);
      const t11 = e10.cachedSymbology;
      return (i12, s6) => {
        var _a;
        const r8 = 5 * i12;
        if (r2(s6.externalColor, t11[r8] / 255, t11[r8 + 1] / 255, t11[r8 + 2] / 255, t11[r8 + 3] / 255), null != this._stage.renderView.objectAndLayerIdRenderHelper) {
          const t12 = e10.featureIds[i12], r9 = m3(this.view.map, this.layerUid);
          this._stage.renderView.objectAndLayerIdRenderHelper.setUidToObjectAndLayerId(t12, t12, this.layerId, this.layerUid + "_" + this.sublayerId, this.layerPopupEnabledAndHasTemplate && !r9, e10.node.resources.attributes, i12, this.sublayerId), s6.objectAndLayerIdColor = this._stage.renderView.getObjectAndLayerIdColor({ graphicUid: t12, layerUid: this.layerUid + "_" + this.sublayerId });
        }
        s6.externalColorMixMode = t11[r8 + 4] & (1 << Mt.CastShadows) - 1, s6.castShadows = 0 != (t11[r8 + 4] & 1 << Mt.CastShadows), s6.pickable = 0 != (t11[r8 + 4] & 1 << Mt.Pickable), s6.elevationOffset = ((_a = e10.elevationOffsets) == null ? void 0 : _a[i12]) ?? 0;
      };
    }
    _getSymbolInfo(e10, t11) {
      const i12 = e10 && e10.getSymbol(t11, { arcade: this._arcade });
      if (!(i12 instanceof k))
        return null;
      const s6 = i12.id;
      if (this._symbolInfos.has(s6))
        return this._symbolInfos.get(s6);
      const r8 = Ue(i12);
      return this._symbolInfos.set(s6, r8), r8;
    }
    _setSymbologyOverride(e10, t11) {
      this._symbologyOverride !== e10 && (this._symbologyOverride = e10, this._symbologyOverrideFields = t11, this._invalidateAllSymbols(), this._updateSymbologyFields());
    }
    _updateSymbologyFields() {
      this._symbologyFields = null != this._symbologyOverrideFields && this._symbologyOverrideFields.length > 0 ? null != this._rendererFields && this._rendererFields.length > 0 ? g3(this.i3slayer.fieldsIndex, [...this._rendererFields, ...this._symbologyOverrideFields]) : this._symbologyOverrideFields : this._rendererFields;
    }
    _updateCachedRendererData(e10) {
      var _a;
      if (e10.cachedRendererVersion = this._rendererVersion, !this._hasComponentData)
        return;
      const t11 = this._tmpAttributeOnlyGraphic, i12 = {};
      t11.attributes = i12;
      const s6 = this._currentRenderer, r8 = (_a = e10.attributeInfo) == null ? void 0 : _a.attributeData, o10 = null != e10.featureIds ? this.i3slayer.objectIdField : null, a8 = null != r8 && null != this._symbologyFields && this._symbologyFields.length > 0;
      let n12 = null, l7 = null;
      if (a8 && null != this._symbologyFields) {
        n12 = [], l7 = [];
        for (const e11 of this._symbologyFields) {
          const t12 = r8[e11];
          t12 && (n12.push(e11), l7.push(t12));
        }
      }
      e10.cachedSymbology || (e10.cachedSymbology = e9(5 * e10.featureIds.length));
      const d4 = { color: Dt, castShadows: true, pickable: true, colorMixMode: n7.Multiply, edgeMaterial: null }, h9 = this.fullOpacity, c7 = this.nodeCrossfadingEnabled ? this.getNodeOpacity(e10) : h9;
      let u5 = null, _2 = A5.OPAQUE, m5 = je, g5 = 0;
      for (let p4 = 0; p4 < e10.featureIds.length; p4++) {
        if (null != o10 && (i12[o10] = e10.featureIds[p4]), a8 && n12)
          for (let e11 = 0; e11 < n12.length; e11++)
            i12[n12[e11]] = fe(l7[e11], p4);
        const r9 = s6 ? this._getSymbolInfo(s6, t11) : null;
        let h10 = null, f2 = null;
        if (s6 && "visualVariables" in s6) {
          if (this._colorVariable) {
            const e11 = p2(this._colorVariable, t11, { color: Rt, arcade: this._arcade });
            e11 && (h10 = Dt, h10[0] = e11.r / 255, h10[1] = e11.g / 255, h10[2] = e11.b / 255, this._opacityVariable || null === e11.a || (f2 = e11.a));
          }
          this._opacityVariable && (f2 = v2(this._opacityVariable, t11, { arcade: this._arcade }));
        }
        if (r9 && r9.material) {
          const e11 = r9.material;
          h10 = null == h10 || null == f2 ? U2(h10, f2, e11.color, e11.alpha, vt, Dt) : U2(h10, f2, null, null, vt, Dt);
        }
        if (null == h10 && (h10 = Dt, h10[0] = 1, h10[1] = 1, h10[2] = 1, h10[3] = 1), d4.pickable = true, d4.castShadows = !r9 || r9.castShadows, d4.colorMixMode = r9 && r9.material ? r9.material.colorMixMode : n7.Multiply, d4.edgeMaterial = r9 ? r9.edgeMaterial : null, null != this._symbologyOverride && (d4.color = h10, this._symbologyOverride(t11, d4), h10 = d4.color), null != d4.edgeMaterial) {
          const t12 = h10[3] <= 0 ? A5.INVISIBLE : h10[3] >= 1 && (e10.material.isOpaque || d4.colorMixMode === n7.Replace) ? A5.OPAQUE : A5.TRANSPARENT;
          d4.edgeMaterial === u5 && t12 === _2 || (m5 = { ...d4.edgeMaterial, opacity: c7, objectTransparency: t12 }, u5 = d4.edgeMaterial, _2 = t12), e10.cachedEdgeMaterials[p4] = m5;
        } else
          e10.cachedEdgeMaterials[p4] = je;
        e10.cachedSymbology[g5++] = Math.round(255 * h10[0]), e10.cachedSymbology[g5++] = Math.round(255 * h10[1]), e10.cachedSymbology[g5++] = Math.round(255 * h10[2]), e10.cachedSymbology[g5++] = Math.round(255 * h10[3]), e10.cachedSymbology[g5++] = d4.colorMixMode | +d4.castShadows << Mt.CastShadows | +d4.pickable << Mt.Pickable;
      }
    }
    _getFilteredEdgeMaterials(e10) {
      const t11 = this._getCachedEdgeMaterials(e10);
      this.nodeCrossfadingEnabled || kt(t11, this.fullOpacity);
      const i12 = e10.filteredIds;
      if (null == i12) {
        return { hasEdges: t11.some((e11) => e11 !== je), perFeatureEdgeMaterials: t11 };
      }
      let s6 = 0, r8 = false;
      const o10 = t11.map((t12, o11) => e10.featureIds[o11] !== i12[s6] ? je : (r8 = r8 || t12 !== je, s6++, t12));
      return { hasEdges: r8, perFeatureEdgeMaterials: o10 };
    }
    _updateComponentData(e10) {
      if (!this._hasComponentData)
        return;
      const t11 = e10.objectHandle, i12 = this._getComponentParameters(e10);
      this._collection.setComponentData(t11, i12), this._stage.renderView.requestRender();
    }
    _reloadAll(e10 = this.elevationOffset) {
      this._removeAllNodeDataFromStage(e10), null != this._controller && this._controller.restartNodeLoading();
    }
    _opacityChange(e10) {
      this.nodeCrossfadingEnabled && this._crossfadeHelper.stopAllNodeFading(), this._nodeId2Meta.forEach((t11) => {
        null != t11 && (this._collection.updateMaterial(t11.objectHandle, (t12) => t12.objectOpacity = e10), kt(t11.cachedEdgeMaterials, e10), this._updateEdgeRendering(t11));
      });
    }
    _updateMaterial(e10) {
      this._collection.updateMaterial(e10.objectHandle, (e11) => {
        e11.commonMaterialParameters.hasSlicePlane = this.slicePlaneEnabled, e11.usePBR = this._usePBR, this._updateMaterialOverlay(e11);
      });
    }
    _updateMaterialOverlay(e10) {
    }
    _updateEngineObject(e10) {
      this._updateComponentData(e10), this._applyFiltersToNode(e10), this._addOrUpdateEdgeRendering(e10), this._visibleGeometryChanged(e10, jt.UPDATE);
    }
    _slicePlaneEnabledChange(e10) {
      this._intersectionHandler && (this._intersectionHandler.slicePlaneEnabled = e10), null != this._labeler && (this._labeler.slicePlaneEnabled = e10), this._nodeId2Meta.forEach((t11) => {
        null != t11 && (this._collection.updateMaterial(t11.objectHandle, (t12) => t12.commonMaterialParameters.hasSlicePlane = e10), this._updateEdgeRendering(t11, false));
      });
    }
    _updatePBR(e10) {
      this._nodeId2Meta.forEach((t11) => {
        null != t11 && this._collection.updateMaterial(t11.objectHandle, (t12) => t12.usePBR = e10);
      }), this._hasLoadedPBRTextures = true;
    }
    get _usePBR() {
      return !this._isIntegratedMesh && this.view.qualitySettings.physicallyBasedRenderingEnabled;
    }
    _updateEdgeRendering(e10, t11 = true) {
      null != this._edgeView && this._edgeView.hasObject(e10.objectHandle) && this._addOrUpdateEdgeRendering(e10, t11);
    }
    _forAllNodes(e10) {
      this._nodeId2Meta.forEach(e10);
    }
    _ignoreClientNodeOverriddenFeatures(e10) {
      return this.i3sOverrides.hasGeometryChanges ? e10 : (t11, i12, s6) => s6.node.index >= 0 && this.i3sOverrides.featureHasGeometryChanges(t11) ? I4.CONTINUE : e10(t11, i12, s6);
    }
    _forAllFeatures(e10, t11, i12) {
      n3(this._nodeId2Meta, (s6) => {
        if (null == s6)
          return false;
        if (null != t11) {
          switch (t11(s6)) {
            case I4.EXIT:
              return true;
            case I4.SKIP:
              return false;
          }
        }
        let r8 = I4.CONTINUE;
        switch (i12) {
          case E3.ALL:
            r8 = this._forAllFeaturesOfNode(s6, e10);
            break;
          case E3.VISIBLE_ONLY:
            r8 = this._forAllVisibleFeaturesOfNode(s6, e10);
            break;
          case E3.QUERYABLE:
            r8 = this._forAllQueryableFeaturesOfNode(s6, e10);
        }
        return r8 === I4.EXIT;
      });
    }
    _forAllFeaturesOfNode(e10, t11) {
      let i12 = I4.CONTINUE;
      const s6 = e10.featureIds;
      for (let r8 = 0; r8 < s6.length; r8++)
        if (i12 = t11(s6[r8], r8, e10), i12 === I4.EXIT)
          return i12;
      return i12;
    }
    _forAllVisibleFeaturesOfNode(e10, t11) {
      let i12 = I4.CONTINUE;
      const s6 = e10.featureIds;
      return this._collection.forEachVisibleComponent(e10.objectHandle, (r8) => (i12 = t11(s6[r8], r8, e10), i12 === I4.CONTINUE)), i12;
    }
    _forAllQueryableFeaturesOfNode(e10, t11) {
      const i12 = this._ignoreClientNodeOverriddenFeatures(t11);
      if (null == this._renderClippingArea)
        return this._forAllFeaturesOfNode(e10, i12);
      const s6 = this._boundingRectNodeTest(e10, this._renderClippingArea);
      if (s6 === ee.OUTSIDE)
        return I4.CONTINUE;
      if (s6 === ee.INSIDE)
        return this._forAllFeaturesOfNode(e10, i12);
      const r8 = I4.CONTINUE, o10 = e10.featureIds, a8 = e10.objectHandle, n12 = Y(this._renderClippingArea, this._collection.getObjectTransform(a8));
      for (let l7 = 0; l7 < o10.length; l7++) {
        if (!this._boundingRectFeatureTest(e10, l7, n12))
          continue;
        const t12 = i12(o10[l7], l7, e10);
        if (t12 === I4.EXIT)
          return t12;
      }
      return r8;
    }
    _createAttributes(e10, t11) {
      var _a;
      const i12 = {};
      null != t11.featureIds && (i12[this._getObjectIdField()] = t11.featureIds[e10]);
      const s6 = (_a = t11.attributeInfo) == null ? void 0 : _a.attributeData;
      if (null != s6)
        for (const r8 of Object.keys(s6))
          i12[r8] = fe(s6[r8], e10);
      return i12;
    }
    _createGraphic(e10, t11) {
      return this._createLayerGraphic(this._createAttributes(e10, t11));
    }
    highlight(e10) {
      const t11 = this._highlights;
      if ("number" == typeof e10 || e10 instanceof h7 ? e10 = [e10] : e10 instanceof V && (e10 = e10.toArray()), Array.isArray(e10) && e10.length > 0) {
        if (e10[0] instanceof h7) {
          const i12 = e10, s6 = this.i3slayer.fieldsIndex, r8 = this._getObjectIdField(), o10 = i12.map((e11) => n8(s6, e11.attributes, r8)), { set: a8, handle: n12 } = t11.acquireSet();
          return t11.setFeatureIds(a8, o10), n12;
        }
        if ("number" == typeof e10[0]) {
          const i12 = e10, { set: s6, handle: r8 } = t11.acquireSet();
          return t11.setFeatureIds(s6, i12), r8;
        }
      }
      return Lt;
    }
    resetHighlights() {
      l(this._highlights), this._highlights = new i8({ collection: this._collection, forAllFeatures: (e10) => this._forAllFeatures(e10, null, E3.ALL), forAllFeaturesOfNode: (e10, t11) => this._forAllFeaturesOfNode(e10, t11) });
    }
    _visibleGeometryChanged(e10, t11) {
      this._elevationProvider && (this._elevationProvider.objectChanged(e10.node), null == this._visibleGeometryChangedSchedulerHandle && (this._visibleGeometryChangedSchedulerHandle = v(() => {
        this.emit("visible-geometry-changed"), this._visibleGeometryChangedSchedulerHandle = null;
      })), this._updateSnappingSources(e10, t11));
    }
    get performanceInfo() {
      const e10 = { displayedNumberOfFeatures: 0, maximumNumberOfFeatures: 0, totalNumberOfFeatures: 0, core: null, index: 0, nodes: this._nodeId2Meta.size, "Total GPU Memory Estimate": (this._gpuMemoryEstimate / 1048576).toFixed(1) + "MB", "Geometry Memory Estimate": (this._geoMemoryEstimate / 1048576).toFixed(1) + "MB", "Texture Memory Estimate": (this._texMemoryEstimate / 1048576).toFixed(1) + "MB", "Unloaded Memory Estimate": (this.unloadedMemory / 1048576).toFixed(1) + "MB" };
      return null != this._memCache && (e10.MemCache = Math.round(100 * this._memCache.hitRate) + "% hit"), this._controller && (this._idbCacheEnabled && (e10.IDBCache = Math.round(100 * this._idbCache.getHitRate()) + "% hit"), this._controller.updateStats(e10)), e10;
    }
    get test() {
      const e10 = this;
      return { controller: this._controller, labeler: this._labeler, get visibleObjectIds() {
        const t11 = [];
        return e10._forAllFeatures((e11) => (t11.push(e11), I4.CONTINUE), null, E3.VISIBLE_ONLY), t11.sort((e11, t12) => e11 - t12), t11;
      }, get numNodes() {
        return e10._nodeId2Meta.size;
      }, get loadedNodes() {
        return Array.from(e10._nodeId2Meta.keys()).sort((e11, t11) => e11 - t11);
      } };
    }
    getNodeOpacityByIndex(e10) {
      const t11 = this._nodeId2Meta.get(e10);
      return this.getNodeOpacity(t11);
    }
    getNodeOpacity(e10) {
      return null != e10 ? this._collection.getMaterial(e10.objectHandle).objectOpacity : 0;
    }
    isNodeFullyFadedIn(e10) {
      return this._crossfadeHelper.isNodeFullyFadedIn(e10);
    }
    getNodeCrossfadeMetaData(e10) {
      return this._nodeId2Meta.get(e10);
    }
    markNodeToRemove(e10) {
      this._controller && this._controller.markNodeToRemove(e10);
    }
    removeMarkedNodes() {
      this._controller && this._controller.removeMarkedNodes();
    }
    foreachCrossfadeNode(e10) {
      this._nodeId2Meta.forEach((t11, i12) => e10(i12, t11));
    }
    fadeNode(e10, t11, i12) {
      if (!this.nodeCrossfadingEnabled)
        return;
      const s6 = this._nodeId2Meta.get(e10);
      null != s6 && this._crossfadeHelper.fadeNode(e10, s6, t11, i12);
    }
    setNodeOpacityByIndex(e10, t11) {
      const i12 = this._nodeId2Meta.get(e10);
      null != i12 && this._setNodeOpacity(i12, t11);
    }
    _setNodeOpacity(e10, t11) {
      this._collection.updateMaterial(e10.objectHandle, (e11) => e11.objectOpacity = t11), this._setNodeEdgeOpacity(e10, t11);
    }
    _setNodeEdgeOpacity(e10, t11) {
      if (null == this._edgeView || !e10.cachedEdgeMaterials)
        return;
      kt(e10.cachedEdgeMaterials, t11);
      const i12 = e10.objectHandle;
      this._edgeView.hasObject(i12) && this._edgeView.updateAllComponentOpacities(i12, t11).catch((e11) => Et(e11, this.i3slayer.title));
    }
    get hasModifications() {
      return this._isIntegratedMesh && null != this._layerClippingArea || this._modifications && this._modifications.length > 0;
    }
    updateNodeModificationStatus(e10) {
      const t11 = e10.length;
      if (!this.hasModifications || t11 <= 0 || true !== this._i3sWasmLoaded)
        return;
      const i12 = this.uid, s6 = Gt(e10);
      if (null != s6) {
        const t12 = { context: i12, buffer: s6.buffer };
        S4(t12);
        const r8 = new Float64Array(s6.buffer);
        e10.forAll((e11, t13) => {
          const i13 = r8[t13], s7 = L(i13);
          e11.imModificationImpact = s7, s7 !== o3.Unmodified && this._controller.invalidateGeometryVisibility(e11.index);
        });
      }
    }
    notifyUpdate() {
      this.notifyChange("updating");
    }
    notifyLODUpdate() {
      this._controller.notifyLODUpdate();
    }
    isUpdating() {
      var _a;
      return !(!this._controller || !this._controller.updating) || !!this._visibleGeometryChangedSchedulerHandle || null != this._labeler && this._labeler.updating || ((_a = this._crossfadeHelper) == null ? void 0 : _a.updating) || this._i3sWasmLoaded instanceof Promise || this._asyncModuleLoading > 0 || null != this._elevationTask && this._elevationTask.running;
    }
    trackSnappingSources(e10) {
      const t11 = { events: e10, fetchEdgeLocations: async (e11, t12, i12) => {
        const s6 = this._nodeId2Meta.get(e11);
        if (null == s6)
          throw new Error("invalid-node");
        const { origin: r8, buffer: o10 } = await this._collection.extractEdgeInformation(s6.objectHandle, t12, i12);
        return this._snappingLocationsApplyElevation(s6, o10, r8), { type: "components", objectIds: s6.featureIds, locations: o10, origin: r8 };
      }, remove: () => {
        z(this._snappingSourcesTrackers, t11);
      } };
      return this._snappingSourcesTrackers.push(t11), this._nodeId2Meta.forEach((t12, i12) => {
        if (null == t12)
          return;
        const s6 = this._controller.getRenderMbs(t12.node);
        null != s6 && e10.add(i12, s6);
      }), t11;
    }
    _snappingLocationsApplyElevation(e10, t11, i12) {
      if (!e10.elevationOffsets || this.elevationInfo.mode === Bt.Absolute)
        return;
      const s6 = t11.position0, r8 = t11.position1, o10 = t11.componentIndex, a8 = n4(), n12 = n4(), l7 = (e11, t12) => {
        u2(e11, e11, i12), this.view.renderCoordsHelper.worldUpAtPosition(e11, n12), u2(e11, e11, g(n12, n12, t12)), e3(e11, e11, i12);
      };
      for (let d4 = 0; d4 < s6.count; d4++) {
        const t12 = e10.elevationOffsets[o10.get(d4)];
        s6.getVec(d4, a8), l7(a8, t12), s6.setVec(d4, a8), r8.getVec(d4, a8), l7(a8, t12), r8.setVec(d4, a8);
      }
    }
    _updateSnappingSources(e10, t11) {
      const { index: i12 } = e10.node, s6 = this._controller.getRenderMbs(e10.node);
      if (null != s6)
        for (const r8 of this._snappingSourcesTrackers)
          t11 !== jt.REMOVE && t11 !== jt.UPDATE || r8.events.remove(i12), t11 !== jt.ADD && t11 !== jt.UPDATE || r8.events.add(i12, s6);
    }
  };
  return e([y()], o9.prototype, "_hasLoadedPBRTextures", void 0), e([y()], o9.prototype, "_asyncModuleLoading", void 0), e([y()], o9.prototype, "_visibleGeometryChangedSchedulerHandle", void 0), e([y()], o9.prototype, "view", void 0), e([y()], o9.prototype, "i3slayer", void 0), e([y()], o9.prototype, "_controller", void 0), e([y()], o9.prototype, "_labeler", void 0), e([y()], o9.prototype, "updating", void 0), e([y()], o9.prototype, "suspended", void 0), e([y()], o9.prototype, "contentVisible", null), e([y({ readOnly: true })], o9.prototype, "legendEnabled", null), e([y()], o9.prototype, "holeFilling", void 0), e([y(t6)], o9.prototype, "updatingProgress", void 0), e([y()], o9.prototype, "updatingProgressValue", null), e([y()], o9.prototype, "hasTexturesOrVertexColors", null), e([y()], o9.prototype, "rendererTextureUsage", null), e([y()], o9.prototype, "elevationOffset", null), e([y()], o9.prototype, "elevationInfo", null), e([y({ type: Boolean })], o9.prototype, "slicePlaneEnabled", void 0), e([y()], o9.prototype, "supportedTextureEncodings", null), e([y()], o9.prototype, "uncompressedTextureDownsamplingEnabled", null), e([y({ type: [f] })], o9.prototype, "_modifications", void 0), e([y({ readOnly: true })], o9.prototype, "clientGeometry", null), e([y()], o9.prototype, "_elevationTask", void 0), e([y({ readOnly: true })], o9.prototype, "_usePBR", null), o9 = e([a(bt)], o9), o9;
};
function Et(e10, t10) {
  d(e10) || yt.warn("Error while processing edges. Edges on this layer might not display correctly", t10, e10);
}
var jt;
!function(e10) {
  e10[e10.ADD = 0] = "ADD", e10[e10.REMOVE = 1] = "REMOVE", e10[e10.UPDATE = 2] = "UPDATE";
}(jt || (jt = {}));
var wt = i2();
var St = i();
var At = i();
var Tt = O3();
var Dt = [0, 0, 0, 0];
var Rt = new h3([0, 0, 0, 0]);
var Nt = E2(0, 0, 0, 0);
function Ft(e10) {
  if (null == e10)
    return false;
  const t10 = e10.metallicRoughness;
  return t10 && t10.baseColorTextureId >= 0 || t10 && t10.metallicRoughnessTextureId >= 0 || e10.normalTextureId >= 0 || e10.emissiveTextureId >= 0 || e10.occlusionTextureId >= 0;
}
function Vt(e10) {
  return "geometryData" in e10;
}
function Pt(e10) {
  return null != e10 && n2(e10.data);
}
function Ht(e10, t10) {
  let i12 = 1024 + e10.interleavedVertexData.byteLength + (e10.indices ? e10.indices.byteLength : 0) + e10.positionData.data.byteLength + e10.positionData.indices.byteLength;
  if (null != t10)
    for (const s6 of t10)
      null != s6 && n2(s6.data) && (i12 += s6.data.byteLength);
  return i12;
}
function Ut(e10, t10) {
  return t10.byteSize > Ot ? (yt.warn(`Node is too big to store in IndexedDB cache: ${e10.id} (${t10.byteSize} bytes)`), false) : t10.byteSize > 0;
}
function Gt(e10) {
  if (0 === e10.length)
    return null;
  const t10 = 10 * e10.length, i12 = new Float64Array(t10);
  return e10.forAll((e11, t11) => {
    let s6 = e11.serviceObb;
    null == s6 && (s6 = Tt, r(s6.center, e11.mbs), s6.halfSize[0] = s6.halfSize[1] = s6.halfSize[2] = e11.mbs[3]);
    const r8 = 10 * t11;
    i12[r8] = s6.center[0], i12[r8 + 1] = s6.center[1], i12[r8 + 2] = s6.center[2], i12[r8 + 3] = s6.halfSize[0], i12[r8 + 4] = s6.halfSize[1], i12[r8 + 5] = s6.halfSize[2], i12[r8 + 6] = s6.quaternion[0], i12[r8 + 7] = s6.quaternion[1], i12[r8 + 8] = s6.quaternion[2], i12[r8 + 9] = s6.quaternion[3];
  }), i12;
}
var Lt = { remove() {
}, pause() {
}, resume() {
} };
function kt(e10, t10) {
  e10.forEach((e11) => e11.opacity = t10);
}
var Bt;
!function(e10) {
  e10[e10.Absolute = 0] = "Absolute", e10[e10.RelativeToGround = 1] = "RelativeToGround", e10[e10.OnTheGround = 2] = "OnTheGround";
}(Bt || (Bt = {}));
var qt = n4();
var zt = i2();
var Kt = "elevation-change";
function Wt(e10) {
  return (t10) => {
    if (e10.immediate)
      return e10.immediate.schedule(t10);
    throw console.error("Error no immediate schudler"), new Error("cant find immediate scheduler");
  };
}

export {
  c5 as c,
  E3 as E,
  I4 as I,
  xt
};
//# sourceMappingURL=chunk-VSNGV5F4.js.map
