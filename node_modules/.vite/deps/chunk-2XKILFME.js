import {
  t
} from "./chunk-G4LSNP77.js";
import {
  U,
  k,
  q,
  v
} from "./chunk-BA6PBZHC.js";
import {
  y
} from "./chunk-GSS6WNQU.js";
import {
  P,
  x
} from "./chunk-AQ7R6V4L.js";
import {
  o
} from "./chunk-HIPTG7BJ.js";
import {
  C,
  h
} from "./chunk-EKJ2DJIR.js";
import {
  f
} from "./chunk-ZEEBL7ZN.js";
import {
  S2 as S
} from "./chunk-RTDN6KAT.js";
import {
  e2 as e
} from "./chunk-V76KGJFU.js";
import {
  m
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/layers/graphics/dehydratedFeatureComparison.js
function n(e2, n2) {
  if (e2 === n2)
    return true;
  if (null == e2 || null == n2)
    return false;
  if (e2.length !== n2.length)
    return false;
  for (let t3 = 0; t3 < e2.length; t3++) {
    const r2 = e2[t3], a2 = n2[t3];
    if (r2.length !== a2.length)
      return false;
    for (let e3 = 0; e3 < r2.length; e3++)
      if (r2[e3] !== a2[e3])
        return false;
  }
  return true;
}
function t2(e2, t3) {
  if (e2 === t3)
    return true;
  if (null == e2 || null == t3)
    return false;
  if (e2.length !== t3.length)
    return false;
  for (let r2 = 0; r2 < e2.length; r2++)
    if (!n(e2[r2], t3[r2]))
      return false;
  return true;
}
function r(n2, t3) {
  return n2 === t3 || null != n2 && null != t3 && S(n2.spatialReference, t3.spatialReference) && n2.x === t3.x && n2.y === t3.y && n2.z === t3.z && n2.m === t3.m;
}
function a(n2, r2) {
  return n2.hasZ === r2.hasZ && n2.hasM === r2.hasM && (!!S(n2.spatialReference, r2.spatialReference) && t2(n2.paths, r2.paths));
}
function u(n2, r2) {
  return n2.hasZ === r2.hasZ && n2.hasM === r2.hasM && (!!S(n2.spatialReference, r2.spatialReference) && t2(n2.rings, r2.rings));
}
function i(t3, r2) {
  return t3.hasZ === r2.hasZ && t3.hasM === r2.hasM && (!!S(t3.spatialReference, r2.spatialReference) && n(t3.points, r2.points));
}
function s(n2, t3) {
  return n2.hasZ === t3.hasZ && n2.hasM === t3.hasM && (!!S(n2.spatialReference, t3.spatialReference) && (n2.xmin === t3.xmin && n2.ymin === t3.ymin && n2.zmin === t3.zmin && n2.xmax === t3.xmax && n2.ymax === t3.ymax && n2.zmax === t3.zmax));
}
function l(e2, n2) {
  if (e2 === n2)
    return true;
  if (null == e2 || null == n2)
    return false;
  if (e2.type !== n2.type)
    return false;
  switch (e2.type) {
    case "point":
      return r(e2, n2);
    case "extent":
      return s(e2, n2);
    case "polyline":
      return a(e2, n2);
    case "polygon":
      return u(e2, n2);
    case "multipoint":
      return i(e2, n2);
    case "mesh":
      return false;
    default:
      return;
  }
}
function f2(e2, n2) {
  if (e2 === n2)
    return true;
  if (!e2 || !n2)
    return false;
  const t3 = Object.keys(e2), r2 = Object.keys(n2);
  if (t3.length !== r2.length)
    return false;
  for (const a2 of t3)
    if (e2[a2] !== n2[a2])
      return false;
  return true;
}
function c(e2, n2) {
  return e2 === n2 || null != e2 && null != n2 && e2.objectId === n2.objectId && (!!l(e2.geometry, n2.geometry) && !!f2(e2.attributes, n2.attributes));
}

// node_modules/@arcgis/core/layers/graphics/dehydratedFeatures.js
var y2 = class {
  constructor(e2, t3, s2) {
    this.uid = e2, this.geometry = t3, this.attributes = s2, this.visible = true, this.objectId = null, this.centroid = null;
  }
};
function f3(e2) {
  return null != e2.geometry;
}
var g = class {
  constructor() {
    this.exceededTransferLimit = false, this.features = [], this.fields = [], this.hasM = false, this.hasZ = false, this.geometryType = null, this.objectIdFieldName = null, this.globalIdFieldName = null, this.geometryProperties = null, this.geohashFieldName = null, this.spatialReference = null, this.transform = null;
  }
};
function d(e2) {
  var _a;
  const t3 = o.fromJSON(e2.geometryType), s2 = f.fromJSON(e2.spatialReference), n2 = e2.transform, a2 = e2.features.map((r2) => {
    const a3 = b(r2, t3, s2, e2.objectIdFieldName), i2 = a3.geometry;
    if (null != i2 && n2)
      switch (i2.type) {
        case "point":
          a3.geometry = k(n2, i2, i2, i2.hasZ, i2.hasM);
          break;
        case "multipoint":
          a3.geometry = U(n2, i2, i2, !!i2.hasZ, !!i2.hasM);
          break;
        case "polygon":
          a3.geometry = q(n2, i2, i2, !!i2.hasZ, !!i2.hasM);
          break;
        case "polyline":
          a3.geometry = v(n2, i2, i2, !!i2.hasZ, !!i2.hasM);
          break;
        case "extent":
        case "mesh":
          a3.geometry = i2;
      }
    return a3;
  });
  return { geometryType: t3, features: a2, spatialReference: s2, fields: ((_a = e2.fields) == null ? void 0 : _a.map((e3) => y.fromJSON(e3))) ?? [], objectIdFieldName: e2.objectIdFieldName, globalIdFieldName: e2.globalIdFieldName, geohashFieldName: e2.geohashFieldName, geometryProperties: e2.geometryProperties, hasZ: e2.hasZ, hasM: e2.hasM, exceededTransferLimit: e2.exceededTransferLimit, transform: null };
}
function b(e2, t3, r2, n2) {
  return { uid: e(), objectId: n2 && e2.attributes ? e2.attributes[n2] : null, attributes: e2.attributes, geometry: x2(e2.geometry, t3, r2), visible: true };
}
function x2(e2, t3, s2) {
  if (null == e2)
    return null;
  switch (t3) {
    case "point": {
      const t4 = e2;
      return { x: t4.x, y: t4.y, z: t4.z, m: t4.m, hasZ: null != t4.z, hasM: null != t4.m, type: "point", spatialReference: s2 };
    }
    case "polyline": {
      const t4 = e2;
      return { paths: t4.paths, hasZ: !!t4.hasZ, hasM: !!t4.hasM, type: "polyline", spatialReference: s2 };
    }
    case "polygon": {
      const t4 = e2;
      return { rings: t4.rings, hasZ: !!t4.hasZ, hasM: !!t4.hasM, type: "polygon", spatialReference: s2 };
    }
    case "multipoint": {
      const t4 = e2;
      return { points: t4.points, hasZ: !!t4.hasZ, hasM: !!t4.hasM, type: "multipoint", spatialReference: s2 };
    }
  }
}
function Z(e2, t3, s2, r2) {
  return { x: e2, y: t3, z: s2, hasZ: null != s2, hasM: false, spatialReference: r2, type: "point" };
}
function j(e2) {
  if (null == e2)
    return 0;
  let s2 = 32;
  switch (e2.type) {
    case "point":
      s2 += 42;
      break;
    case "polyline":
    case "polygon": {
      let t3 = 0;
      const r2 = 2 + (e2.hasZ ? 1 : 0) + (e2.hasM ? 1 : 0), n2 = "polyline" === e2.type ? e2.paths : e2.rings;
      for (const e3 of n2)
        t3 += e3.length;
      s2 += 8 * t3 * r2 + 64, s2 += 128 * t3, s2 += 34, s2 += 32 * (n2.length + 1);
      break;
    }
    case "multipoint": {
      const t3 = 2 + (e2.hasZ ? 1 : 0) + (e2.hasM ? 1 : 0), r2 = e2.points.length;
      s2 += 8 * r2 * t3 + 64, s2 += 128 * r2, s2 += 34, s2 += 32;
      break;
    }
    case "extent":
      s2 += 98, e2.hasM && (s2 += 32), e2.hasZ && (s2 += 32);
      break;
    case "mesh":
      s2 += m(e2.vertexAttributes.position), s2 += m(e2.vertexAttributes.normal), s2 += m(e2.vertexAttributes.uv), s2 += m(e2.vertexAttributes.tangent);
  }
  return s2;
}
function M(t3) {
  let s2 = 32;
  return s2 += t(t3.attributes), s2 += 3, s2 += 8 + j(t3.geometry), s2;
}
function k2(e2) {
  if (null == e2)
    return 0;
  switch (e2.type) {
    case "point":
      return 1;
    case "polyline": {
      let t3 = 0;
      for (const s2 of e2.paths)
        t3 += s2.length;
      return t3;
    }
    case "polygon": {
      let t3 = 0;
      for (const s2 of e2.rings)
        t3 += s2.length;
      return t3;
    }
    case "multipoint":
      return e2.points.length;
    case "extent":
      return 2;
    case "mesh": {
      const t3 = e2.vertexAttributes && e2.vertexAttributes.position;
      return t3 ? t3.length / 3 : 0;
    }
    default:
      return;
  }
}
function N(e2) {
  if (null == e2)
    return false;
  switch (e2.type) {
    case "extent":
    case "point":
      return true;
    case "polyline":
      for (const t3 of e2.paths)
        if (t3.length > 0)
          return true;
      return false;
    case "polygon":
      for (const t3 of e2.rings)
        if (t3.length > 0)
          return true;
      return false;
    case "multipoint":
      return e2.points.length > 0;
    case "mesh":
      return !e2.loaded || e2.vertexAttributes.position.length > 0;
  }
}
function z(e2, t3) {
  switch (P(t3), "mesh" === e2.type && (e2 = e2.extent), e2.type) {
    case "point":
      t3[0] = t3[3] = e2.x, t3[1] = t3[4] = e2.y, e2.hasZ && (t3[2] = t3[5] = e2.z);
      break;
    case "polyline":
      for (let s2 = 0; s2 < e2.paths.length; s2++)
        x(t3, e2.paths[s2], !!e2.hasZ);
      break;
    case "polygon":
      for (let s2 = 0; s2 < e2.rings.length; s2++)
        x(t3, e2.rings[s2], !!e2.hasZ);
      break;
    case "multipoint":
      x(t3, e2.points, !!e2.hasZ);
      break;
    case "extent":
      t3[0] = e2.xmin, t3[1] = e2.ymin, t3[3] = e2.xmax, t3[4] = e2.ymax, null != e2.zmin && (t3[2] = e2.zmin), null != e2.zmax && (t3[5] = e2.zmax);
  }
}
function F(e2, t3) {
  switch (C(t3), "mesh" === e2.type && (e2 = e2.extent), e2.type) {
    case "point":
      t3[0] = t3[2] = e2.x, t3[1] = t3[3] = e2.y;
      break;
    case "polyline":
      for (let s2 = 0; s2 < e2.paths.length; s2++)
        h(t3, e2.paths[s2]);
      break;
    case "polygon":
      for (let s2 = 0; s2 < e2.rings.length; s2++)
        h(t3, e2.rings[s2]);
      break;
    case "multipoint":
      h(t3, e2.points);
      break;
    case "extent":
      t3[0] = e2.xmin, t3[1] = e2.ymin, t3[2] = e2.xmax, t3[3] = e2.ymax;
  }
}
function I(e2, t3) {
  return null != e2.objectId ? e2.objectId : e2.attributes && t3 ? e2.attributes[t3] : null;
}

export {
  r,
  c,
  y2 as y,
  f3 as f,
  g,
  d,
  Z,
  M,
  k2 as k,
  N,
  z,
  F,
  I
};
//# sourceMappingURL=chunk-2XKILFME.js.map
