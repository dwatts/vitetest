import {
  r as r4
} from "./chunk-VDSNHCMM.js";
import {
  t as t4
} from "./chunk-Z2RTGLQI.js";
import {
  e as e2,
  r as r3
} from "./chunk-SMDDCTGQ.js";
import {
  t as t3
} from "./chunk-JP7O2ZWE.js";
import {
  v
} from "./chunk-4SIKLJSS.js";
import {
  s as s3
} from "./chunk-SGBMUZSF.js";
import {
  t as t2,
  y as y2
} from "./chunk-BDWD2ZNU.js";
import {
  c as c2,
  i,
  q,
  u as u2,
  x,
  y
} from "./chunk-FIBWCATC.js";
import {
  s as s4
} from "./chunk-LEDSC236.js";
import {
  o as o2,
  r as r2
} from "./chunk-CW7LIPBH.js";
import {
  O as O2
} from "./chunk-BN6X2OXK.js";
import {
  G,
  H
} from "./chunk-7EG7BYWF.js";
import {
  A as A2,
  O,
  U,
  _,
  e,
  g,
  o,
  p,
  s as s2,
  u
} from "./chunk-TPJLFGOT.js";
import {
  n,
  r,
  t
} from "./chunk-CQX57DED.js";
import {
  l
} from "./chunk-HB2SQRT2.js";
import {
  A,
  c2 as c,
  s2 as s
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/AttributeArray.js
function o3(o6) {
  if (o6.length < A)
    return Array.from(o6);
  if (s(o6))
    return Float64Array.from(o6);
  if (!("BYTES_PER_ELEMENT" in o6))
    return Array.from(o6);
  switch (o6.BYTES_PER_ELEMENT) {
    case 1:
      return Uint8Array.from(o6);
    case 2:
      return c(o6) ? Uint16Array.from(o6) : Int16Array.from(o6);
    case 4:
      return Float32Array.from(o6);
    default:
      return Float64Array.from(o6);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/BoundingInfo.js
var o4 = class _o {
  constructor(i3, s6, o6, c5) {
    this.primitiveIndices = i3, this._numIndexPerPrimitive = s6, this.indices = o6, this.position = c5, this._children = void 0, s3(i3.length >= 1), s3(o6.length % this._numIndexPerPrimitive == 0), s3(o6.length >= i3.length * this._numIndexPerPrimitive), s3(3 === c5.size || 4 === c5.size);
    const { data: d2, size: l4 } = c5, m2 = i3.length;
    let u5 = l4 * o6[this._numIndexPerPrimitive * i3[0]];
    a.clear(), a.push(u5);
    const f2 = r(d2[u5], d2[u5 + 1], d2[u5 + 2]), x3 = t(f2);
    for (let t5 = 0; t5 < m2; ++t5) {
      const s7 = this._numIndexPerPrimitive * i3[t5];
      for (let i4 = 0; i4 < this._numIndexPerPrimitive; ++i4) {
        u5 = l4 * o6[s7 + i4], a.push(u5);
        let t6 = d2[u5];
        f2[0] = Math.min(t6, f2[0]), x3[0] = Math.max(t6, x3[0]), t6 = d2[u5 + 1], f2[1] = Math.min(t6, f2[1]), x3[1] = Math.max(t6, x3[1]), t6 = d2[u5 + 2], f2[2] = Math.min(t6, f2[2]), x3[2] = Math.max(t6, x3[2]);
      }
    }
    this.bbMin = f2, this.bbMax = x3;
    const P2 = A2(n(), this.bbMin, this.bbMax, 0.5);
    this.radius = 0.5 * Math.max(Math.max(x3[0] - f2[0], x3[1] - f2[1]), x3[2] - f2[2]);
    let v3 = this.radius * this.radius;
    for (let t5 = 0; t5 < a.length; ++t5) {
      u5 = a.at(t5);
      const i4 = d2[u5] - P2[0], s7 = d2[u5 + 1] - P2[1], e3 = d2[u5 + 2] - P2[2], n3 = i4 * i4 + s7 * s7 + e3 * e3;
      if (n3 <= v3)
        continue;
      const r8 = Math.sqrt(n3), h2 = 0.5 * (r8 - this.radius);
      this.radius = this.radius + h2, v3 = this.radius * this.radius;
      const o7 = h2 / r8;
      P2[0] += i4 * o7, P2[1] += s7 * o7, P2[2] += e3 * o7;
    }
    this.center = P2, a.clear();
  }
  getChildren() {
    if (this._children || p(this.bbMin, this.bbMax) <= 1)
      return this._children;
    const i3 = A2(n(), this.bbMin, this.bbMax, 0.5), e3 = this.primitiveIndices.length, n3 = new Uint8Array(e3), h2 = new Array(8);
    for (let t5 = 0; t5 < 8; ++t5)
      h2[t5] = 0;
    const { data: a4, size: c5 } = this.position;
    for (let t5 = 0; t5 < e3; ++t5) {
      let s6 = 0;
      const e4 = this._numIndexPerPrimitive * this.primitiveIndices[t5];
      let r8 = c5 * this.indices[e4], o6 = a4[r8], d3 = a4[r8 + 1], l5 = a4[r8 + 2];
      for (let i4 = 1; i4 < this._numIndexPerPrimitive; ++i4) {
        r8 = c5 * this.indices[e4 + i4];
        const t6 = a4[r8], s7 = a4[r8 + 1], n4 = a4[r8 + 2];
        t6 < o6 && (o6 = t6), s7 < d3 && (d3 = s7), n4 < l5 && (l5 = n4);
      }
      o6 < i3[0] && (s6 |= 1), d3 < i3[1] && (s6 |= 2), l5 < i3[2] && (s6 |= 4), n3[t5] = s6, ++h2[s6];
    }
    let d2 = 0;
    for (let t5 = 0; t5 < 8; ++t5)
      h2[t5] > 0 && ++d2;
    if (d2 < 2)
      return;
    const l4 = new Array(8);
    for (let t5 = 0; t5 < 8; ++t5)
      l4[t5] = h2[t5] > 0 ? new Uint32Array(h2[t5]) : void 0;
    for (let t5 = 0; t5 < 8; ++t5)
      h2[t5] = 0;
    for (let t5 = 0; t5 < e3; ++t5) {
      const i4 = n3[t5];
      l4[i4][h2[i4]++] = this.primitiveIndices[t5];
    }
    this._children = new Array();
    for (let t5 = 0; t5 < 8; ++t5)
      void 0 !== l4[t5] && this._children.push(new _o(l4[t5], this._numIndexPerPrimitive, this.indices, this.position));
    return this._children;
  }
  static prune() {
    a.prune();
  }
};
var a = new l({ deallocator: null });

// node_modules/@arcgis/core/geometry/support/triangle.js
function j(t5) {
  return t5 ? { p0: t(t5.p0), p1: t(t5.p1), p2: t(t5.p2) } : { p0: n(), p1: n(), p2: n() };
}
function S(t5, n3, e3) {
  const r8 = n3[0] - t5[0], o6 = n3[1] - t5[1], p4 = e3[0] - t5[0], c5 = e3[1] - t5[1];
  return 0.5 * Math.abs(r8 * c5 - o6 * p4);
}
function w(t5, n3, o6) {
  return e(O3, n3, t5), e(V, o6, t5), s2(_(O3, O3, V)) / 2;
}
var M2 = new s4(v);
var x2 = new s4(() => j());
var O3 = n();
var V = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/geometryDataUtils.js
function c4(r8, o6, c5) {
  if (!r8 || !o6)
    return false;
  const { size: a4, data: f2 } = r8;
  o(c5, 0, 0, 0), o(g2, 0, 0, 0);
  let m2 = 0, h2 = 0;
  for (let p4 = 0; p4 < o6.length - 2; p4 += 3) {
    const r9 = o6[p4] * a4, j2 = o6[p4 + 1] * a4, d2 = o6[p4 + 2] * a4;
    o(i2, f2[r9], f2[r9 + 1], f2[r9 + 2]), o(u3, f2[j2], f2[j2 + 1], f2[j2 + 2]), o(l2, f2[d2], f2[d2 + 1], f2[d2 + 2]);
    const z = w(i2, u3, l2);
    z ? (u(i2, i2, u3), u(i2, i2, l2), g(i2, i2, 1 / 3 * z), u(c5, c5, i2), m2 += z) : (u(g2, g2, i2), u(g2, g2, u3), u(g2, g2, l2), h2 += 3);
  }
  return (0 !== h2 || 0 !== m2) && (0 !== m2 ? (g(c5, c5, 1 / m2), true) : 0 !== h2 && (g(c5, g2, 1 / h2), true));
}
function a2(n3, r8, o6) {
  if (!n3 || !r8)
    return false;
  const { size: s6, data: c5 } = n3;
  o(o6, 0, 0, 0);
  let a4 = -1, f2 = 0;
  for (let t5 = 0; t5 < r8.length; t5++) {
    const n4 = r8[t5] * s6;
    a4 !== n4 && (o6[0] += c5[n4], o6[1] += c5[n4 + 1], o6[2] += c5[n4 + 2], f2++), a4 = n4;
  }
  return f2 > 1 && g(o6, o6, 1 / f2), f2 > 0;
}
function f(o6, s6, c5, a4) {
  if (!o6)
    return false;
  o(a4, 0, 0, 0), o(g2, 0, 0, 0);
  let f2 = 0, l4 = 0;
  const { size: m2, data: h2 } = o6, p4 = s6 ? s6.length - 1 : h2.length / m2 - 1, j2 = p4 + (c5 ? 2 : 0);
  for (let t5 = 0; t5 < j2; t5 += 2) {
    const o7 = t5 < p4 ? t5 : p4, c6 = t5 < p4 ? t5 + 1 : 0, j3 = (s6 ? s6[o7] : o7) * m2, d2 = (s6 ? s6[c6] : c6) * m2;
    i2[0] = h2[j3], i2[1] = h2[j3 + 1], i2[2] = h2[j3 + 2], u3[0] = h2[d2], u3[1] = h2[d2 + 1], u3[2] = h2[d2 + 2], g(i2, u(i2, i2, u3), 0.5);
    const z = U(i2, u3);
    z > 0 ? (u(a4, a4, g(i2, i2, z)), f2 += z) : 0 === f2 && (u(g2, g2, i2), l4++);
  }
  return 0 !== f2 ? (g(a4, a4, 1 / f2), true) : 0 !== l4 && (g(a4, g2, 1 / l4), true);
}
var i2 = n();
var u3 = n();
var l2 = n();
var g2 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/utils.js
function n2(t5, e3) {
  return null == t5 && (t5 = []), t5.push(e3), t5;
}
function r6(t5, e3) {
  if (null == t5)
    return null;
  const n3 = t5.filter((t6) => t6 !== e3);
  return 0 === n3.length ? null : n3;
}
function s5(t5, n3, r8, s6, u5) {
  l3[0] = t5.get(n3, 0), l3[1] = t5.get(n3, 1), l3[2] = t5.get(n3, 2), t4(l3, o5, 3), r8.set(u5, 0, o5[0]), s6.set(u5, 0, o5[1]), r8.set(u5, 1, o5[2]), s6.set(u5, 1, o5[3]), r8.set(u5, 2, o5[4]), s6.set(u5, 2, o5[5]);
}
var l3 = n();
var o5 = new Float32Array(6);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Geometry.js
var b = class _b extends r3 {
  constructor(t5, e3, i3 = [], r8 = null, o6 = e2.Mesh, h2 = null, a4 = -1) {
    super(), this.material = t5, this.mapPositions = r8, this.type = o6, this.objectAndLayerIdColor = h2, this.edgeIndicesLength = a4, this.visible = true, this._vertexAttributes = /* @__PURE__ */ new Map(), this._indices = /* @__PURE__ */ new Map(), this._boundingInfo = null;
    for (const [s6, n3] of e3)
      n3 && this._vertexAttributes.set(s6, { ...n3 });
    if (null == i3 || 0 === i3.length) {
      const t6 = p2(this._vertexAttributes), e4 = y2(t6);
      this.edgeIndicesLength = this.edgeIndicesLength < 0 ? t6 : this.edgeIndicesLength;
      for (const i4 of this._vertexAttributes.keys())
        this._indices.set(i4, e4);
    } else
      for (const [s6, u5] of i3)
        u5 && (this._indices.set(s6, t2(u5)), s6 === O2.POSITION && (this.edgeIndicesLength = this.edgeIndicesLength < 0 ? this._indices.get(s6).length : this.edgeIndicesLength));
  }
  instantiate(t5 = {}) {
    const e3 = new _b(t5.material || this.material, [], void 0, this.mapPositions, this.type, this.objectAndLayerIdColor, this.edgeIndicesLength);
    return this._vertexAttributes.forEach((t6, i3) => {
      t6.exclusive = false, e3._vertexAttributes.set(i3, t6);
    }), this._indices.forEach((t6, i3) => e3._indices.set(i3, t6)), e3._boundingInfo = this._boundingInfo, e3.transformation = t5.transformation || this.transformation, e3;
  }
  get vertexAttributes() {
    return this._vertexAttributes;
  }
  getMutableAttribute(t5) {
    let e3 = this._vertexAttributes.get(t5);
    return e3 && !e3.exclusive && (e3 = { ...e3, exclusive: true, data: o3(e3.data) }, this._vertexAttributes.set(t5, e3)), e3;
  }
  setAttributeData(t5, e3) {
    const i3 = this._vertexAttributes.get(t5);
    i3 && this._vertexAttributes.set(t5, { ...i3, exclusive: true, data: e3 });
  }
  get indices() {
    return this._indices;
  }
  get indexCount() {
    const t5 = this._indices.values().next().value;
    return t5 ? t5.length : 0;
  }
  get faceCount() {
    return this.indexCount / 3;
  }
  get boundingInfo() {
    return null == this._boundingInfo && (this._boundingInfo = this._calculateBoundingInfo()), this._boundingInfo;
  }
  computeAttachmentOrigin(t5) {
    return !!(this.type === e2.Mesh ? this._computeAttachmentOriginTriangles(t5) : this.type === e2.Line ? this._computeAttachmentOriginLines(t5) : this._computeAttachmentOriginPoints(t5)) && (null != this._transformation && O(t5, t5, this._transformation), true);
  }
  _computeAttachmentOriginTriangles(t5) {
    const e3 = this.indices.get(O2.POSITION), i3 = this.vertexAttributes.get(O2.POSITION);
    return c4(i3, e3, t5);
  }
  _computeAttachmentOriginLines(t5) {
    const e3 = this.vertexAttributes.get(O2.POSITION), i3 = this.indices.get(O2.POSITION);
    return f(e3, i3, i3 && v2(this.material.parameters, e3, i3), t5);
  }
  _computeAttachmentOriginPoints(t5) {
    const e3 = this.indices.get(O2.POSITION), i3 = this.vertexAttributes.get(O2.POSITION);
    return a2(i3, e3, t5);
  }
  invalidateBoundingInfo() {
    this._boundingInfo = null;
  }
  _calculateBoundingInfo() {
    const t5 = this.indices.get(O2.POSITION), e3 = this.vertexAttributes.get(O2.POSITION);
    if (!t5 || 0 === t5.length || !e3)
      return null;
    const i3 = this.type === e2.Mesh ? 3 : 1;
    s3(t5.length % i3 == 0, "Indexing error: " + t5.length + " not divisible by " + i3);
    const n3 = y2(t5.length / i3);
    return new o4(n3, i3, t5, e3);
  }
  get transformation() {
    return this._transformation ?? o2;
  }
  set transformation(i3) {
    this._transformation = i3 && i3 !== o2 ? r2(i3) : null;
  }
  get shaderTransformation() {
    return null != this._shaderTransformer ? this._shaderTransformer(this.transformation) : this.transformation;
  }
  get shaderTransformer() {
    return this._shaderTransformer;
  }
  set shaderTransformer(t5) {
    this._shaderTransformer = t5;
  }
  get hasVolatileTransformation() {
    return null != this._shaderTransformer;
  }
  addHighlight() {
    const t5 = new r4(t3.Highlight);
    return this.highlights = n2(this.highlights, t5), t5;
  }
  removeHighlight(t5) {
    this.highlights = r6(this.highlights, t5);
  }
};
function p2(t5) {
  const e3 = t5.values().next().value;
  return null == e3 ? 0 : e3.data.length / e3.size;
}
function v2(t5, e3, i3) {
  return !(!("isClosed" in t5) || !t5.isClosed) && (i3 ? i3.length > 2 : e3.data.length > 6);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/bufferWriterUtils.js
function d(e3, t5, f2, o6, r8 = 1) {
  const s6 = f2.typedBuffer, n3 = f2.typedBufferStride, i3 = e3.length;
  if (o6 *= n3, 1 === r8)
    for (let c5 = 0; c5 < i3; ++c5)
      s6[o6] = t5[e3[c5]], o6 += n3;
  else
    for (let c5 = 0; c5 < i3; ++c5) {
      const f3 = t5[e3[c5]];
      for (let e4 = 0; e4 < r8; e4++)
        s6[o6] = f3, o6 += n3;
    }
}
function u4(e3, t5, f2, o6) {
  const r8 = f2.typedBuffer, s6 = f2.typedBufferStride, n3 = e3.length;
  o6 *= s6;
  for (let i3 = 0; i3 < n3; ++i3) {
    const f3 = 2 * e3[i3];
    r8[o6] = t5[f3], r8[o6 + 1] = t5[f3 + 1], o6 += s6;
  }
}
function a3(e3, t5, f2, o6, r8) {
  const s6 = f2.typedBuffer, n3 = f2.typedBufferStride, i3 = e3.length;
  if (o6 *= n3, null == r8 || 1 === r8)
    for (let c5 = 0; c5 < i3; ++c5) {
      const f3 = 3 * e3[c5];
      s6[o6] = t5[f3], s6[o6 + 1] = t5[f3 + 1], s6[o6 + 2] = t5[f3 + 2], o6 += n3;
    }
  else
    for (let c5 = 0; c5 < i3; ++c5) {
      const f3 = 3 * e3[c5];
      for (let e4 = 0; e4 < r8; ++e4)
        s6[o6] = t5[f3], s6[o6 + 1] = t5[f3 + 1], s6[o6 + 2] = t5[f3 + 2], o6 += n3;
    }
}
function p3(e3, t5, f2, o6, r8 = 1) {
  const s6 = f2.typedBuffer, n3 = f2.typedBufferStride, i3 = e3.length;
  if (o6 *= n3, 1 === r8)
    for (let c5 = 0; c5 < i3; ++c5) {
      const f3 = 4 * e3[c5];
      s6[o6] = t5[f3], s6[o6 + 1] = t5[f3 + 1], s6[o6 + 2] = t5[f3 + 2], s6[o6 + 3] = t5[f3 + 3], o6 += n3;
    }
  else
    for (let c5 = 0; c5 < i3; ++c5) {
      const f3 = 4 * e3[c5];
      for (let e4 = 0; e4 < r8; ++e4)
        s6[o6] = t5[f3], s6[o6 + 1] = t5[f3 + 1], s6[o6 + 2] = t5[f3 + 2], s6[o6 + 3] = t5[f3 + 3], o6 += n3;
    }
}
function y3(e3, t5, f2) {
  const o6 = e3.typedBuffer, r8 = e3.typedBufferStride;
  t5 *= r8;
  for (let s6 = 0; s6 < f2; ++s6)
    o6[t5] = 0, o6[t5 + 1] = 0, o6[t5 + 2] = 0, o6[t5 + 3] = 0, t5 += r8;
}
function b2(t5, f2, o6, r8, s6, n3 = 1) {
  if (!o6)
    return void a3(t5, f2, r8, s6, n3);
  const i3 = r8.typedBuffer, c5 = r8.typedBufferStride, l4 = t5.length, d2 = o6[0], u5 = o6[1], p4 = o6[2], y4 = o6[4], B = o6[5], g3 = o6[6], b3 = o6[8], O5 = o6[9], h2 = o6[10], N2 = o6[12], S3 = o6[13], R2 = o6[14];
  s6 *= c5;
  let A4 = 0, E2 = 0, L = 0;
  const z = H(o6) ? (e3) => {
    A4 = f2[e3] + N2, E2 = f2[e3 + 1] + S3, L = f2[e3 + 2] + R2;
  } : (e3) => {
    const t6 = f2[e3], o7 = f2[e3 + 1], r9 = f2[e3 + 2];
    A4 = d2 * t6 + y4 * o7 + b3 * r9 + N2, E2 = u5 * t6 + B * o7 + O5 * r9 + S3, L = p4 * t6 + g3 * o7 + h2 * r9 + R2;
  };
  if (1 === n3)
    for (let e3 = 0; e3 < l4; ++e3)
      z(3 * t5[e3]), i3[s6] = A4, i3[s6 + 1] = E2, i3[s6 + 2] = L, s6 += c5;
  else
    for (let e3 = 0; e3 < l4; ++e3) {
      z(3 * t5[e3]);
      for (let e4 = 0; e4 < n3; ++e4)
        i3[s6] = A4, i3[s6 + 1] = E2, i3[s6 + 2] = L, s6 += c5;
    }
}
function O4(f2, o6, r8, s6, n3, i3 = 1) {
  if (!r8)
    return void a3(f2, o6, s6, n3, i3);
  const c5 = r8, l4 = s6.typedBuffer, d2 = s6.typedBufferStride, u5 = f2.length, p4 = c5[0], y4 = c5[1], B = c5[2], g3 = c5[4], b3 = c5[5], O5 = c5[6], h2 = c5[8], N2 = c5[9], S3 = c5[10], R2 = !G(c5), A4 = 1e-6, E2 = 1 - A4;
  n3 *= d2;
  let L = 0, z = 0, F = 0;
  const v3 = H(c5) ? (e3) => {
    L = o6[e3], z = o6[e3 + 1], F = o6[e3 + 2];
  } : (e3) => {
    const t5 = o6[e3], f3 = o6[e3 + 1], r9 = o6[e3 + 2];
    L = p4 * t5 + g3 * f3 + h2 * r9, z = y4 * t5 + b3 * f3 + N2 * r9, F = B * t5 + O5 * f3 + S3 * r9;
  };
  if (1 === i3)
    if (R2)
      for (let e3 = 0; e3 < u5; ++e3) {
        v3(3 * f2[e3]);
        const t5 = L * L + z * z + F * F;
        if (t5 < E2 && t5 > A4) {
          const e4 = 1 / Math.sqrt(t5);
          l4[n3] = L * e4, l4[n3 + 1] = z * e4, l4[n3 + 2] = F * e4;
        } else
          l4[n3] = L, l4[n3 + 1] = z, l4[n3 + 2] = F;
        n3 += d2;
      }
    else
      for (let e3 = 0; e3 < u5; ++e3)
        v3(3 * f2[e3]), l4[n3] = L, l4[n3 + 1] = z, l4[n3 + 2] = F, n3 += d2;
  else
    for (let e3 = 0; e3 < u5; ++e3) {
      if (v3(3 * f2[e3]), R2) {
        const e4 = L * L + z * z + F * F;
        if (e4 < E2 && e4 > A4) {
          const t5 = 1 / Math.sqrt(e4);
          L *= t5, z *= t5, F *= t5;
        }
      }
      for (let e4 = 0; e4 < i3; ++e4)
        l4[n3] = L, l4[n3 + 1] = z, l4[n3 + 2] = F, n3 += d2;
    }
}
function h(e3, f2, o6, r8, s6, n3 = 1) {
  if (!o6)
    return void p3(e3, f2, r8, s6, n3);
  const i3 = o6, c5 = r8.typedBuffer, l4 = r8.typedBufferStride, d2 = e3.length, u5 = i3[0], a4 = i3[1], y4 = i3[2], B = i3[4], g3 = i3[5], b3 = i3[6], O5 = i3[8], h2 = i3[9], N2 = i3[10], S3 = !G(i3), R2 = 1e-6, A4 = 1 - R2;
  if (s6 *= l4, 1 === n3)
    for (let t5 = 0; t5 < d2; ++t5) {
      const o7 = 4 * e3[t5], r9 = f2[o7], n4 = f2[o7 + 1], i4 = f2[o7 + 2], d3 = f2[o7 + 3];
      let p4 = u5 * r9 + B * n4 + O5 * i4, E2 = a4 * r9 + g3 * n4 + h2 * i4, L = y4 * r9 + b3 * n4 + N2 * i4;
      if (S3) {
        const e4 = p4 * p4 + E2 * E2 + L * L;
        if (e4 < A4 && e4 > R2) {
          const t6 = 1 / Math.sqrt(e4);
          p4 *= t6, E2 *= t6, L *= t6;
        }
      }
      c5[s6] = p4, c5[s6 + 1] = E2, c5[s6 + 2] = L, c5[s6 + 3] = d3, s6 += l4;
    }
  else
    for (let t5 = 0; t5 < d2; ++t5) {
      const o7 = 4 * e3[t5], r9 = f2[o7], i4 = f2[o7 + 1], d3 = f2[o7 + 2], p4 = f2[o7 + 3];
      let E2 = u5 * r9 + B * i4 + O5 * d3, L = a4 * r9 + g3 * i4 + h2 * d3, z = y4 * r9 + b3 * i4 + N2 * d3;
      if (S3) {
        const e4 = E2 * E2 + L * L + z * z;
        if (e4 < A4 && e4 > R2) {
          const t6 = 1 / Math.sqrt(e4);
          E2 *= t6, L *= t6, z *= t6;
        }
      }
      for (let e4 = 0; e4 < n3; ++e4)
        c5[s6] = E2, c5[s6 + 1] = L, c5[s6 + 2] = z, c5[s6 + 3] = p4, s6 += l4;
    }
}
function N(e3, t5, f2, o6, r8, s6 = 1) {
  const n3 = o6.typedBuffer, i3 = o6.typedBufferStride, c5 = e3.length;
  if (r8 *= i3, f2 !== t5.length || 4 !== f2)
    if (1 !== s6)
      if (4 !== f2)
        for (let l4 = 0; l4 < c5; ++l4) {
          const f3 = 3 * e3[l4];
          for (let e4 = 0; e4 < s6; ++e4)
            n3[r8] = t5[f3], n3[r8 + 1] = t5[f3 + 1], n3[r8 + 2] = t5[f3 + 2], n3[r8 + 3] = 255, r8 += i3;
        }
      else
        for (let l4 = 0; l4 < c5; ++l4) {
          const f3 = 4 * e3[l4];
          for (let e4 = 0; e4 < s6; ++e4)
            n3[r8] = t5[f3], n3[r8 + 1] = t5[f3 + 1], n3[r8 + 2] = t5[f3 + 2], n3[r8 + 3] = t5[f3 + 3], r8 += i3;
        }
    else {
      if (4 === f2) {
        for (let f3 = 0; f3 < c5; ++f3) {
          const o7 = 4 * e3[f3];
          n3[r8] = t5[o7], n3[r8 + 1] = t5[o7 + 1], n3[r8 + 2] = t5[o7 + 2], n3[r8 + 3] = t5[o7 + 3], r8 += i3;
        }
        return;
      }
      for (let f3 = 0; f3 < c5; ++f3) {
        const o7 = 3 * e3[f3];
        n3[r8] = t5[o7], n3[r8 + 1] = t5[o7 + 1], n3[r8 + 2] = t5[o7 + 2], n3[r8 + 3] = 255, r8 += i3;
      }
    }
  else {
    n3[r8] = t5[0], n3[r8 + 1] = t5[1], n3[r8 + 2] = t5[2], n3[r8 + 3] = t5[3];
    const e4 = new Uint32Array(o6.typedBuffer.buffer, o6.start), f3 = i3 / 4, l4 = e4[r8 /= 4];
    r8 += f3;
    const d2 = c5 * s6;
    for (let t6 = 1; t6 < d2; ++t6)
      e4[r8] = l4, r8 += f3;
  }
}
function S2(e3, t5, f2, o6) {
  const r8 = f2.typedBuffer, s6 = f2.typedBufferStride, n3 = e3.length, i3 = t5[0];
  o6 *= s6;
  for (let c5 = 0; c5 < n3; ++c5)
    r8[o6] = i3, o6 += s6;
}
function R(e3, t5, f2, o6, r8 = 1) {
  const s6 = t5.typedBuffer, n3 = t5.typedBufferStride;
  if (o6 *= n3, 1 === r8)
    for (let i3 = 0; i3 < f2; ++i3)
      s6[o6] = e3[0], s6[o6 + 1] = e3[1], s6[o6 + 2] = e3[2], s6[o6 + 3] = e3[3], o6 += n3;
  else
    for (let i3 = 0; i3 < f2; ++i3)
      for (let t6 = 0; t6 < r8; ++t6)
        s6[o6] = e3[0], s6[o6 + 1] = e3[1], s6[o6 + 2] = e3[2], s6[o6 + 3] = e3[3], o6 += n3;
}
function A3(e3, t5, o6, r8, s6, n3) {
  for (const i3 of t5.fields.keys()) {
    const t6 = e3.vertexAttributes.get(i3), d2 = e3.indices.get(i3);
    if (t6 && d2)
      E(i3, t6, d2, o6, r8, s6, n3);
    else if (i3 === O2.OBJECTANDLAYERIDCOLOR && null != e3.objectAndLayerIdColor) {
      const t7 = e3.indices.get(O2.POSITION);
      if (s3(!!t7, `No buffer view for ${i3}`), t7) {
        const o7 = t7.length, r9 = s6.getField(i3, x);
        R(e3.objectAndLayerIdColor, r9, o7, n3);
      }
    }
  }
}
function E(e3, t5, d2, a4, y4, B, g3) {
  switch (e3) {
    case O2.POSITION: {
      s3(3 === t5.size);
      const f2 = B.getField(e3, i);
      s3(!!f2, `No buffer view for ${e3}`), f2 && b2(d2, t5.data, a4, f2, g3);
      break;
    }
    case O2.NORMAL: {
      s3(3 === t5.size);
      const f2 = B.getField(e3, i);
      s3(!!f2, `No buffer view for ${e3}`), f2 && O4(d2, t5.data, y4, f2, g3);
      break;
    }
    case O2.NORMALCOMPRESSED: {
      s3(2 === t5.size);
      const f2 = B.getField(e3, q);
      s3(!!f2, `No buffer view for ${e3}`), f2 && u4(d2, t5.data, f2, g3);
      break;
    }
    case O2.UV0: {
      s3(2 === t5.size);
      const f2 = B.getField(e3, u2);
      s3(!!f2, `No buffer view for ${e3}`), f2 && u4(d2, t5.data, f2, g3);
      break;
    }
    case O2.COLOR:
    case O2.SYMBOLCOLOR: {
      const o6 = B.getField(e3, x);
      s3(!!o6, `No buffer view for ${e3}`), s3(3 === t5.size || 4 === t5.size), !o6 || 3 !== t5.size && 4 !== t5.size || N(d2, t5.data, t5.size, o6, g3);
      break;
    }
    case O2.COLORFEATUREATTRIBUTE: {
      const f2 = B.getField(e3, y);
      s3(!!f2, `No buffer view for ${e3}`), s3(1 === t5.size), f2 && 1 === t5.size && S2(d2, t5.data, f2, g3);
      break;
    }
    case O2.TANGENT: {
      s3(4 === t5.size);
      const f2 = B.getField(e3, c2);
      s3(!!f2, `No buffer view for ${e3}`), f2 && h(d2, t5.data, y4, f2, g3);
      break;
    }
    case O2.PROFILERIGHT:
    case O2.PROFILEUP:
    case O2.PROFILEVERTEXANDNORMAL:
    case O2.FEATUREVALUE: {
      s3(4 === t5.size);
      const f2 = B.getField(e3, c2);
      s3(!!f2, `No buffer view for ${e3}`), f2 && p3(d2, t5.data, f2, g3);
    }
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultBufferWriter.js
var r7 = class {
  constructor(t5) {
    this.vertexBufferLayout = t5;
  }
  elementCount(e3) {
    return e3.indices.get(O2.POSITION).length;
  }
  write(t5, r8, i3, o6, s6) {
    A3(i3, this.vertexBufferLayout, t5, r8, o6, s6);
  }
};

export {
  o4 as o,
  S,
  n2 as n,
  r6 as r,
  s5 as s,
  b,
  d,
  p3 as p,
  y3 as y,
  b2,
  O4 as O,
  N,
  R,
  A3 as A,
  E,
  r7 as r2
};
//# sourceMappingURL=chunk-BDX5TRUE.js.map
