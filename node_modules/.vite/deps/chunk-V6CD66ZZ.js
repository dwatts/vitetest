import {
  a
} from "./chunk-WTPQKRQM.js";
import {
  a as a2
} from "./chunk-BO2REVMA.js";
import {
  E
} from "./chunk-BCDDCNQ2.js";
import {
  l
} from "./chunk-HB2SQRT2.js";
import {
  t
} from "./chunk-DWOEYHKS.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ReloadableShaderModule.js
var t2 = class {
  constructor(t3, o) {
    this._module = t3, this._loadModule = o;
  }
  get() {
    return this._module;
  }
  async reload() {
    return this._module = await this._loadModule(), this._module;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechnique.js
var e = class {
  constructor(i2, t3, e2) {
    this.release = e2, this.initializeConfiguration(i2, t3), this._configuration = t3.snapshot(), this._program = this.initializeProgram(i2), this._pipeline = this.initializePipeline(i2.rctx.capabilities);
  }
  destroy() {
    this._program = t(this._program), this._pipeline = this._configuration = null;
  }
  reload(t3) {
    t(this._program), this._program = this.initializeProgram(t3), this._pipeline = this.initializePipeline(t3.rctx.capabilities);
  }
  get program() {
    return this._program;
  }
  get compiled() {
    return this.program.compiled;
  }
  get key() {
    return this._configuration.key;
  }
  get configuration() {
    return this._configuration;
  }
  bindPipelineState(i2, t3 = null, e2) {
    i2.setPipelineState(this.getPipelineState(t3, e2));
  }
  ensureAttributeLocations(i2) {
    this.program.assertCompatibleVertexAttributeLocations(i2);
  }
  get primitiveType() {
    return E.TRIANGLES;
  }
  getPipelineState(i2, t3) {
    return this._pipeline;
  }
  initializeConfiguration(i2, t3) {
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Program.js
var i = class {
  constructor(i2, s, o) {
    this._context = i2, this._locations = o, this._textures = /* @__PURE__ */ new Map(), this._freeTextureUnits = new l({ deallocator: null }), this._glProgram = i2.programCache.acquire(s.generate("vertex"), s.generate("fragment"), o), this._glProgram.stop = () => {
      throw new Error("Wrapped _glProgram used directly");
    }, this.bindPass = s.generateBind(a2.Pass, this), this.bindDraw = s.generateBind(a2.Draw, this), this._fragmentUniforms = a() ? s.fragmentUniforms : null;
  }
  dispose() {
    this._glProgram.dispose();
  }
  get glName() {
    return this._glProgram.glName;
  }
  get compiled() {
    return this._glProgram.compiled;
  }
  setUniform1b(t3, e2) {
    this._glProgram.setUniform1i(t3, e2 ? 1 : 0);
  }
  setUniform1i(t3, e2) {
    this._glProgram.setUniform1i(t3, e2);
  }
  setUniform1f(t3, e2) {
    this._glProgram.setUniform1f(t3, e2);
  }
  setUniform2fv(t3, e2) {
    this._glProgram.setUniform2fv(t3, e2);
  }
  setUniform3fv(t3, e2) {
    this._glProgram.setUniform3fv(t3, e2);
  }
  setUniform4fv(t3, e2) {
    this._glProgram.setUniform4fv(t3, e2);
  }
  setUniformMatrix3fv(t3, e2) {
    this._glProgram.setUniformMatrix3fv(t3, e2);
  }
  setUniformMatrix4fv(t3, e2) {
    this._glProgram.setUniformMatrix4fv(t3, e2);
  }
  setUniform1fv(t3, e2) {
    this._glProgram.setUniform1fv(t3, e2);
  }
  setUniform1iv(t3, e2) {
    this._glProgram.setUniform1iv(t3, e2);
  }
  setUniform2iv(t3, e2) {
    this._glProgram.setUniform3iv(t3, e2);
  }
  setUniform3iv(t3, e2) {
    this._glProgram.setUniform3iv(t3, e2);
  }
  setUniform4iv(t3, e2) {
    this._glProgram.setUniform4iv(t3, e2);
  }
  assertCompatibleVertexAttributeLocations(t3) {
    t3.locations !== this._locations && console.error("VertexAttributeLocations are incompatible");
  }
  stop() {
    this._textures.clear(), this._freeTextureUnits.clear();
  }
  bindTexture(t3, e2) {
    if (null == e2 || null == e2.glName) {
      const e3 = this._textures.get(t3);
      return e3 && (this._context.bindTexture(null, e3.unit), this._freeTextureUnit(e3), this._textures.delete(t3)), null;
    }
    let r = this._textures.get(t3);
    return null == r ? (r = this._allocTextureUnit(e2), this._textures.set(t3, r)) : r.texture = e2, this._context.useProgram(this), this.setUniform1i(t3, r.unit), this._context.bindTexture(e2, r.unit), r.unit;
  }
  rebindTextures() {
    this._context.useProgram(this), this._textures.forEach((t3, e2) => {
      this._context.bindTexture(t3.texture, t3.unit), this.setUniform1i(e2, t3.unit);
    }), null != this._fragmentUniforms && this._fragmentUniforms.forEach((t3) => {
      "sampler2D" !== t3.type && "samplerCube" !== t3.type || this._textures.has(t3.name) || console.error(`Texture sampler ${t3.name} has no bound texture`);
    });
  }
  _allocTextureUnit(t3) {
    return { texture: t3, unit: 0 === this._freeTextureUnits.length ? this._textures.size : this._freeTextureUnits.pop() };
  }
  _freeTextureUnit(t3) {
    this._freeTextureUnits.push(t3.unit);
  }
};

export {
  t2 as t,
  e,
  i
};
//# sourceMappingURL=chunk-V6CD66ZZ.js.map
