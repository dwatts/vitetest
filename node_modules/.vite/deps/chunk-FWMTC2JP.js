import {
  X
} from "./chunk-FIJZ6LYC.js";
import {
  u
} from "./chunk-4YXJLES6.js";
import {
  d
} from "./chunk-JHDKOKT6.js";
import {
  e as e3
} from "./chunk-PV5KBAYL.js";
import {
  e as e2
} from "./chunk-YVVROPAO.js";
import {
  n as n3
} from "./chunk-GYNE34WO.js";
import {
  e as e5
} from "./chunk-QS45OHBM.js";
import {
  a as a2
} from "./chunk-IVMJPIWO.js";
import {
  a
} from "./chunk-3I3GE5YW.js";
import {
  e as e4
} from "./chunk-WRFNQB7U.js";
import {
  o as o2
} from "./chunk-UUW6REOV.js";
import {
  o as o3
} from "./chunk-2US5EKDI.js";
import {
  s
} from "./chunk-Z3NHJA5D.js";
import {
  i2
} from "./chunk-BO2REVMA.js";
import {
  o
} from "./chunk-V66LHQVK.js";
import {
  e
} from "./chunk-CW7LIPBH.js";
import {
  r
} from "./chunk-NLWV7Q6F.js";
import {
  f,
  n as n2
} from "./chunk-SS3YG6J3.js";
import {
  h,
  i
} from "./chunk-7EG7BYWF.js";
import {
  O,
  z
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";

// node_modules/@arcgis/core/chunks/ShadowHighlight.glsl.js
var S = { highlightedThreshold: 0.99999, selfShadowThreshold: 0.025 };
function F(r2) {
  const a3 = new i2();
  a3.include(u, r2);
  const h2 = a3.fragment;
  return h2.include(a), h2.include(a2), a3.include(n3), a3.include(o3), h2.uniforms.add(new s("defaultDepthTex", (e6, o4) => o4.shadowMap.getSnapshot(X.Default)), new s("highlightDepthTex", (e6, o4) => o4.shadowMap.getSnapshot(X.Highlight)), new s("depthMap", (e6, o4) => o4.linearDepthTexture), new s("highlightMap", (e6, o4) => o4.highlightColorTexture), new e5("uColor", (e6) => e6.shadowColor), new e4("nearFar", (e6, o4) => o4.camera.nearFar), new o2("opacity", (e6) => e6.shadowOpacity), new o2("occludedOpacity", (e6) => e6.occludedShadowOpacity), new o2("terminationFactor", (e6) => e6.opacityElevation * e6.dayNightTerminator), new e2("lightingMainDirectionView", (e6, o4) => z(z2, O(z2, o4.lighting.mainLight.direction, o4.camera.viewInverseTransposeMatrix))), new e4("texelSize", (e6, o4) => null != o4.linearDepthTexture ? r(T, 1 / o4.linearDepthTexture.descriptor.width, 1 / o4.linearDepthTexture.descriptor.height) : f), new e3("inverseViewMatrix", (r3, i3) => h(y, i(y, i3.camera.viewMatrix, i3.camera.center)))), h2.constants.add("unoccludedHighlightFlag", "vec4", d).add("highlightedThreshold", "float", S.highlightedThreshold).add("selfShadowThreshold", "float", S.selfShadowThreshold), h2.code.add(o`vec3 normalFromDepth(vec3 pixelPos, vec2 fragCoord, vec2 uv, vec2 texelSize, sampler2D depthMap, vec2 nearFar) {
float leftPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(-1.0, 0.0) * texelSize, nearFar);
float rightPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(1.0, 0.0) * texelSize, nearFar);
float bottomPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(0.0, -1.0) * texelSize, nearFar);
float topPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(0.0, 1.0) * texelSize, nearFar);
bool pickLeft = abs(pixelPos.z - leftPixelDepth) < abs(pixelPos.z - rightPixelDepth);
bool pickBottom = abs(pixelPos.z - bottomPixelDepth) < abs(pixelPos.z - topPixelDepth);
vec3 fragCoordHorizontal = pickLeft
? vec3(fragCoord + vec2(-1.0, 0.0), leftPixelDepth)
: vec3(fragCoord + vec2(1.0, 0.0), rightPixelDepth);
vec3 fragCoordVertical = pickBottom
? vec3(fragCoord + vec2(0.0, -1.0), bottomPixelDepth)
: vec3(fragCoord + vec2(0.0, 1.0), topPixelDepth);
vec3 verticalPixelPos = reconstructPosition(fragCoordHorizontal.xy, fragCoordHorizontal.z);
vec3 horizontalPixelPos = reconstructPosition(fragCoordVertical.xy, fragCoordVertical.z);
vec3 normal = normalize(cross(verticalPixelPos - pixelPos, horizontalPixelPos - pixelPos));
return pickLeft == pickBottom ? normal : -normal;
}`), h2.code.add(o`void main(void) {
vec4 highlightInfo = texture(highlightMap, uv);
float visiblyHighlighted = (1.0 - clamp(distance(unoccludedHighlightFlag, highlightInfo), 0.0, 1.0)) * highlightInfo.a;
if (visiblyHighlighted > highlightedThreshold) {
discard;
}
float depth = rgba2float(texture(depthMap, uv));
if (depth == 0.0) {
discard;
}
float currentPixelDepth = linearDepthFromFloat(depth, nearFar);
if (-currentPixelDepth>nearFar.y || -currentPixelDepth<nearFar.x) {
discard;
}
vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);
vec4 worldSpacePos = inverseViewMatrix * currentPixelPos;
mat4 shadowMatrix;
float linearDepth = -currentPixelDepth;
int i = chooseCascade(linearDepth, shadowMatrix);
if (i >= numCascades) {
discard;
}
vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);
if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
discard;
}
vec2 uvShadow = cascadeCoordinates(i, lvpos);
float depthHighlight = readShadowMapDepth(uvShadow, highlightDepthTex);
bool shadowHighlight = depthHighlight < lvpos.z;
if (!shadowHighlight) {
discard;
}
float depthDefault = readShadowMapDepth(uvShadow, defaultDepthTex);
bool shadowDefault = depthDefault < lvpos.z;
vec3 normal = normalFromDepth(currentPixelPos.xyz, gl_FragCoord.xy, uv, texelSize, depthMap, nearFar);
bool shaded = dot(normal, lightingMainDirectionView) < selfShadowThreshold;
float fragOpacity = (shadowDefault || shaded) ? occludedOpacity : opacity;
fragColor = vec4(uColor.rgb, uColor.a * fragOpacity * terminationFactor);
}`), a3;
}
var y = e();
var z2 = n();
var T = n2();
var j = Object.freeze(Object.defineProperty({ __proto__: null, build: F }, Symbol.toStringTag, { value: "Module" }));

export {
  F,
  j
};
//# sourceMappingURL=chunk-FWMTC2JP.js.map
