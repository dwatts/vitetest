import {
  n as n3
} from "./chunk-3TTW7E7W.js";
import {
  _
} from "./chunk-LEDSC236.js";
import {
  S
} from "./chunk-OKABUMQT.js";
import {
  e as e3
} from "./chunk-CW7LIPBH.js";
import {
  e as e4
} from "./chunk-TYOIANOD.js";
import {
  e as e2
} from "./chunk-VN2IXVGV.js";
import {
  y
} from "./chunk-JB7FDW5N.js";
import {
  c,
  h,
  n as n2,
  o
} from "./chunk-7EG7BYWF.js";
import {
  E,
  e,
  u
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/verticalOffsetUtils.js
var p = class {
  constructor() {
    this._transform = e3(), this._transformInverse = new u2({ value: this._transform }, h, e3), this._transformInverseTranspose = new u2(this._transformInverse, o, e3), this._transformTranspose = new u2({ value: this._transform }, o, e3), this._transformInverseRotation = new u2({ value: this._transform }, y, e2);
  }
  _invalidateLazyTransforms() {
    this._transformInverse.invalidate(), this._transformInverseTranspose.invalidate(), this._transformTranspose.invalidate(), this._transformInverseRotation.invalidate();
  }
  get transform() {
    return this._transform;
  }
  get inverse() {
    return this._transformInverse.value;
  }
  get inverseTranspose() {
    return this._transformInverseTranspose.value;
  }
  get inverseRotation() {
    return this._transformInverseRotation.value;
  }
  get transpose() {
    return this._transformTranspose.value;
  }
  setTransformMatrix(t) {
    n2(this._transform, t);
  }
  multiplyTransform(t) {
    c(this._transform, this._transform, t);
  }
  set(t) {
    n2(this._transform, t), this._invalidateLazyTransforms();
  }
  setAndInvalidateLazyTransforms(t, s) {
    this.setTransformMatrix(t), this.multiplyTransform(s), this._invalidateLazyTransforms();
  }
};
var u2 = class {
  constructor(t, s, e5) {
    this._original = t, this._update = s, this._dirty = true, this._transform = e5();
  }
  invalidate() {
    this._dirty = true;
  }
  get value() {
    return this._dirty && (this._update(this._transform, this._original.value), this._dirty = false), this._transform;
  }
};
var M = class {
  constructor(t = 0) {
    this.offset = t, this.tmpVertex = n();
  }
  applyToVertex(t, s, e5) {
    const i = t + this.localOrigin[0], r = s + this.localOrigin[1], a = e5 + this.localOrigin[2], o2 = this.offset / Math.sqrt(i * i + r * r + a * a);
    return this.tmpVertex[0] = t + i * o2, this.tmpVertex[1] = s + r * o2, this.tmpVertex[2] = e5 + a * o2, this.tmpVertex;
  }
  applyToAabb(t) {
    for (let r = 0; r < 3; ++r)
      v[r] = t[0 + r] + this.localOrigin[r], O[r] = t[3 + r] + this.localOrigin[r], z[r] = v[r];
    const s = this.applyToVertex(v[0], v[1], v[2]);
    for (let r = 0; r < 3; ++r)
      t[r] = s[r], t[r + 3] = s[r];
    const e5 = (s2) => {
      const e6 = this.applyToVertex(s2[0], s2[1], s2[2]);
      for (let i2 = 0; i2 < 3; ++i2)
        t[i2] = Math.min(t[i2], e6[i2]), t[i2 + 3] = Math.max(t[i2 + 3], e6[i2]);
    };
    for (let r = 1; r < 8; ++r) {
      for (let t2 = 0; t2 < 3; ++t2)
        z[t2] = 0 == (r & 1 << t2) ? v[t2] : O[t2];
      e5(z);
    }
    let i = 0;
    for (let r = 0; r < 3; ++r) {
      v[r] * O[r] < 0 && (i |= 1 << r);
    }
    if (0 !== i && 7 !== i) {
      for (let r = 0; r < 8; ++r)
        if (0 == (i & r)) {
          for (let t2 = 0; t2 < 3; ++t2)
            z[t2] = 0 != (i & 1 << t2) ? 0 : 0 != (r & 1 << t2) ? v[t2] : O[t2];
          e5(z);
        }
    }
    for (let r = 0; r < 3; ++r)
      t[r] -= this.localOrigin[r], t[r + 3] -= this.localOrigin[r];
    return t;
  }
};
var v = n();
var O = n();
var z = n();
var T = class {
  constructor(t = 0) {
    this.componentLocalOriginLength = 0, this._tmpVertex = n(), this._mbs = _(), this._obb = { center: n(), halfSize: n3(), quaternion: null }, this._totalOffset = 0, this._offset = 0, this._resetOffset(t);
  }
  _resetOffset(t) {
    this._offset = t, this._totalOffset = t;
  }
  set offset(t) {
    this._resetOffset(t);
  }
  get offset() {
    return this._offset;
  }
  set componentOffset(t) {
    this._totalOffset = this._offset + t;
  }
  set localOrigin(t) {
    this.componentLocalOriginLength = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
  }
  applyToVertex(t, s, e5) {
    const i = t, r = s, a = e5 + this.componentLocalOriginLength, o2 = this._totalOffset / Math.sqrt(i * i + r * r + a * a);
    return this._tmpVertex[0] = t + i * o2, this._tmpVertex[1] = s + r * o2, this._tmpVertex[2] = e5 + a * o2, this._tmpVertex;
  }
  applyToAabb(t) {
    const s = t[0], e5 = t[1], i = t[2] + this.componentLocalOriginLength, r = t[3], a = t[4], o2 = t[5] + this.componentLocalOriginLength, h2 = s * r < 0 ? 0 : Math.min(Math.abs(s), Math.abs(r)), n4 = e5 * a < 0 ? 0 : Math.min(Math.abs(e5), Math.abs(a)), f = i * o2 < 0 ? 0 : Math.min(Math.abs(i), Math.abs(o2)), l = Math.sqrt(h2 * h2 + n4 * n4 + f * f);
    if (l < this._totalOffset)
      return t[0] -= s < 0 ? this._totalOffset : 0, t[1] -= e5 < 0 ? this._totalOffset : 0, t[2] -= i < 0 ? this._totalOffset : 0, t[3] += r > 0 ? this._totalOffset : 0, t[4] += a > 0 ? this._totalOffset : 0, t[5] += o2 > 0 ? this._totalOffset : 0, t;
    const _2 = Math.max(Math.abs(s), Math.abs(r)), m = Math.max(Math.abs(e5), Math.abs(a)), b = Math.max(Math.abs(i), Math.abs(o2)), c2 = Math.sqrt(_2 * _2 + m * m + b * b), p2 = this._totalOffset / c2, u3 = this._totalOffset / l;
    return t[0] += s * (s > 0 ? p2 : u3), t[1] += e5 * (e5 > 0 ? p2 : u3), t[2] += i * (i > 0 ? p2 : u3), t[3] += r * (r < 0 ? p2 : u3), t[4] += a * (a < 0 ? p2 : u3), t[5] += o2 * (o2 < 0 ? p2 : u3), t;
  }
  applyToMbs(t) {
    const s = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]), e5 = this._totalOffset / s;
    return this._mbs[0] = t[0] + t[0] * e5, this._mbs[1] = t[1] + t[1] * e5, this._mbs[2] = t[2] + t[2] * e5, this._mbs[3] = t[3] + t[3] * this._totalOffset / s, this._mbs;
  }
  applyToObb(t) {
    const s = t.center, e5 = this._totalOffset / Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]);
    this._obb.center[0] = s[0] + s[0] * e5, this._obb.center[1] = s[1] + s[1] * e5, this._obb.center[2] = s[2] + s[2] * e5, E(this._obb.halfSize, t.halfSize, t.quaternion), u(this._obb.halfSize, this._obb.halfSize, t.center);
    const i = this._totalOffset / Math.sqrt(this._obb.halfSize[0] * this._obb.halfSize[0] + this._obb.halfSize[1] * this._obb.halfSize[1] + this._obb.halfSize[2] * this._obb.halfSize[2]);
    return this._obb.halfSize[0] += this._obb.halfSize[0] * i, this._obb.halfSize[1] += this._obb.halfSize[1] * i, this._obb.halfSize[2] += this._obb.halfSize[2] * i, e(this._obb.halfSize, this._obb.halfSize, t.center), S(j, t.quaternion), E(this._obb.halfSize, this._obb.halfSize, j), this._obb.halfSize[0] *= this._obb.halfSize[0] < 0 ? -1 : 1, this._obb.halfSize[1] *= this._obb.halfSize[1] < 0 ? -1 : 1, this._obb.halfSize[2] *= this._obb.halfSize[2] < 0 ? -1 : 1, this._obb.quaternion = t.quaternion, this._obb;
  }
};
var g = class {
  constructor(t = 0) {
    this.offset = t, this.sphere = _(), this.tmpVertex = n();
  }
  applyToVertex(t, s, e5) {
    const i = this.objectTransform.transform;
    let r = i[0] * t + i[4] * s + i[8] * e5 + i[12], a = i[1] * t + i[5] * s + i[9] * e5 + i[13], o2 = i[2] * t + i[6] * s + i[10] * e5 + i[14];
    const h2 = this.offset / Math.sqrt(r * r + a * a + o2 * o2);
    r += r * h2, a += a * h2, o2 += o2 * h2;
    const n4 = this.objectTransform.inverse;
    return this.tmpVertex[0] = n4[0] * r + n4[4] * a + n4[8] * o2 + n4[12], this.tmpVertex[1] = n4[1] * r + n4[5] * a + n4[9] * o2 + n4[13], this.tmpVertex[2] = n4[2] * r + n4[6] * a + n4[10] * o2 + n4[14], this.tmpVertex;
  }
  applyToMinMax(t, s) {
    const e5 = this.offset / Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
    t[0] += t[0] * e5, t[1] += t[1] * e5, t[2] += t[2] * e5;
    const i = this.offset / Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]);
    s[0] += s[0] * i, s[1] += s[1] * i, s[2] += s[2] * i;
  }
  applyToAabb(t) {
    const s = this.offset / Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
    t[0] += t[0] * s, t[1] += t[1] * s, t[2] += t[2] * s;
    const e5 = this.offset / Math.sqrt(t[3] * t[3] + t[4] * t[4] + t[5] * t[5]);
    return t[3] += t[3] * e5, t[4] += t[4] * e5, t[5] += t[5] * e5, t;
  }
  applyToBoundingSphere(t) {
    const s = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]), e5 = this.offset / s;
    return this.sphere[0] = t[0] + t[0] * e5, this.sphere[1] = t[1] + t[1] * e5, this.sphere[2] = t[2] + t[2] * e5, this.sphere[3] = t[3] + t[3] * this.offset / s, this.sphere;
  }
};
var x = new g();
function S2(t) {
  return null != t ? (x.offset = t, x) : null;
}
var q = new T();
function y2(t) {
  return null != t ? (q.offset = t, q) : null;
}
var V = new M();
function d(t) {
  return null != t ? (V.offset = t, V) : null;
}
var L = "terrain";
var j = e4();

export {
  p,
  S2 as S,
  y2 as y,
  d,
  L
};
//# sourceMappingURL=chunk-YEDW7SLL.js.map
