import {
  c as c4
} from "./chunk-NBIX5G6B.js";
import {
  R as R2,
  b as b3,
  e as e6,
  e2 as e7,
  t as t6,
  t2 as t7
} from "./chunk-SY3LKERQ.js";
import {
  _ as _3,
  l as l6,
  p as p2,
  w as w2
} from "./chunk-EKZRSO4Y.js";
import {
  f as f5,
  f2 as f6,
  g as g2,
  h as h5,
  l as l5,
  m as m3,
  r as r7
} from "./chunk-KF45Y73U.js";
import {
  a as a7,
  a2 as a8,
  i as i3,
  s as s5,
  s2 as s6,
  t2 as t5,
  u as u2,
  u2 as u3
} from "./chunk-W2MFIVLD.js";
import "./chunk-VIDC736D.js";
import "./chunk-V6RPZZQL.js";
import "./chunk-2NUCTFTS.js";
import "./chunk-67UNUI4B.js";
import {
  k
} from "./chunk-RX622OY6.js";
import "./chunk-2735WBYK.js";
import "./chunk-VJPLCQI5.js";
import "./chunk-KEWRTE2K.js";
import {
  h as h4
} from "./chunk-JQKL7AD5.js";
import {
  a as a6
} from "./chunk-I7EXY23J.js";
import "./chunk-SCHIU6CT.js";
import "./chunk-DBIFU6GO.js";
import {
  c as c3,
  e as e5
} from "./chunk-2EO2WRP7.js";
import "./chunk-CERU5LKM.js";
import "./chunk-JZVYLVFO.js";
import "./chunk-FAOMDC3K.js";
import "./chunk-SCAYUERS.js";
import "./chunk-N4JKQR77.js";
import {
  S,
  b as b2,
  r2 as r5
} from "./chunk-BDX5TRUE.js";
import {
  A as A2,
  E as E2,
  l as l4
} from "./chunk-LIXBKTBN.js";
import "./chunk-VDSNHCMM.js";
import {
  E as E3
} from "./chunk-6LC2JTLC.js";
import {
  s as s4
} from "./chunk-XM3YSFN6.js";
import "./chunk-NIZWDAMQ.js";
import "./chunk-DU3C7D26.js";
import "./chunk-Z2RTGLQI.js";
import {
  e as e4,
  i as i2,
  t as t4
} from "./chunk-V6CD66ZZ.js";
import {
  W,
  _ as _2,
  a as a5,
  l as l3
} from "./chunk-6FHMQNMS.js";
import "./chunk-D7YAG5U3.js";
import "./chunk-LGDKASPG.js";
import "./chunk-YQDOKTNT.js";
import "./chunk-SH6HJSS2.js";
import {
  r as r6
} from "./chunk-KFDARCTS.js";
import "./chunk-TRGMWULG.js";
import "./chunk-WTPQKRQM.js";
import {
  c as c2,
  o2
} from "./chunk-SMDDCTGQ.js";
import {
  E
} from "./chunk-NU4UASX6.js";
import {
  t as t3
} from "./chunk-FB4A6PBH.js";
import "./chunk-AB23UNQC.js";
import "./chunk-RDWKBYTH.js";
import "./chunk-IBJTEQQG.js";
import {
  o as o3
} from "./chunk-SADO52IH.js";
import "./chunk-WVOBJDWI.js";
import "./chunk-LIO6VZRI.js";
import "./chunk-7DFZCT3D.js";
import "./chunk-ASBUA7EG.js";
import "./chunk-FY4ZONHH.js";
import {
  h as h3
} from "./chunk-73PNWDTS.js";
import "./chunk-PKS3ZVLN.js";
import "./chunk-N3RXOITN.js";
import "./chunk-DOR4M5EA.js";
import "./chunk-3ROGWJVH.js";
import "./chunk-BUCIQGFS.js";
import "./chunk-CR5XNTAP.js";
import "./chunk-Z6IKMUOC.js";
import "./chunk-PV5KBAYL.js";
import "./chunk-YVVROPAO.js";
import "./chunk-QS45OHBM.js";
import "./chunk-IVMJPIWO.js";
import "./chunk-3I3GE5YW.js";
import "./chunk-WRFNQB7U.js";
import "./chunk-UUW6REOV.js";
import "./chunk-Z3NHJA5D.js";
import "./chunk-BO2REVMA.js";
import "./chunk-V66LHQVK.js";
import "./chunk-JP7O2ZWE.js";
import "./chunk-Z6R62RNV.js";
import "./chunk-3LLZ72VA.js";
import "./chunk-4SIKLJSS.js";
import "./chunk-WDZ5AAFL.js";
import {
  i
} from "./chunk-PR2OEILG.js";
import "./chunk-UM64E5NS.js";
import "./chunk-2XKILFME.js";
import "./chunk-G4LSNP77.js";
import "./chunk-BA6PBZHC.js";
import "./chunk-Z7LZRT7C.js";
import "./chunk-SGBMUZSF.js";
import "./chunk-3TMT4LDG.js";
import {
  t as t2
} from "./chunk-BDWD2ZNU.js";
import {
  R
} from "./chunk-BCDDCNQ2.js";
import "./chunk-FIBWCATC.js";
import {
  s as s3
} from "./chunk-6S2FCH6S.js";
import {
  b,
  d,
  q as q2
} from "./chunk-FOEAKQNX.js";
import {
  n as n5
} from "./chunk-LEDSC236.js";
import {
  a as a4,
  c,
  f as f4
} from "./chunk-NETCTS4Y.js";
import {
  e as e3
} from "./chunk-CW7LIPBH.js";
import "./chunk-TYOIANOD.js";
import "./chunk-VN2IXVGV.js";
import "./chunk-WWUAHPIM.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  n as n3,
  r as r2
} from "./chunk-YGUWDSEH.js";
import "./chunk-ZWFMUHG3.js";
import "./chunk-EFRTD25L.js";
import "./chunk-GSS6WNQU.js";
import "./chunk-C2EHS6UI.js";
import "./chunk-63ERNIOV.js";
import "./chunk-XABSD6D5.js";
import {
  a as a3,
  m as m2,
  r as r3
} from "./chunk-NLWV7Q6F.js";
import "./chunk-RVS5HU2K.js";
import "./chunk-JB7FDW5N.js";
import {
  n as n4,
  r as r4
} from "./chunk-SS3YG6J3.js";
import {
  Bn,
  Cn,
  En,
  Hn,
  In,
  Un,
  ce,
  gn
} from "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import {
  I,
  q
} from "./chunk-7EG7BYWF.js";
import "./chunk-AQ7R6V4L.js";
import "./chunk-DOQ3SAAR.js";
import "./chunk-OZXJDVTE.js";
import {
  h as h2
} from "./chunk-RRJGZKNX.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import {
  j as j3
} from "./chunk-4OR73Y2R.js";
import {
  C,
  f as f3
} from "./chunk-EKJ2DJIR.js";
import {
  M,
  f
} from "./chunk-TEHNQYQD.js";
import {
  P,
  _,
  e as e2,
  g,
  j,
  o,
  p,
  r,
  u,
  x,
  z
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import {
  D,
  a2
} from "./chunk-3CQBBMMD.js";
import "./chunk-Z2ZUNW5S.js";
import "./chunk-7L7Z2HXM.js";
import "./chunk-75NKPXTR.js";
import "./chunk-EUVARFSM.js";
import {
  G
} from "./chunk-3VUFACNT.js";
import {
  f as f2,
  x2
} from "./chunk-ZEEBL7ZN.js";
import {
  A2 as A,
  F,
  J,
  K,
  j as j2,
  v
} from "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-RLLQRKO4.js";
import "./chunk-57CHUY45.js";
import "./chunk-SJ2GJCS2.js";
import {
  U,
  l as l2,
  w
} from "./chunk-H7RDAEPY.js";
import "./chunk-ODFH3BSN.js";
import {
  h
} from "./chunk-S5OISW44.js";
import {
  n as n2
} from "./chunk-7KH4CLS5.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-JL3TJGVW.js";
import {
  s as s2
} from "./chunk-JZM5YUHA.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import {
  m,
  t2 as t,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import "./chunk-7I33FAWS.js";
import {
  l
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/3d/analysis/support/measurementUtils.js
function w3(o4, s8) {
  const i5 = s8.center;
  o(i5, 0, 0, 0);
  for (let t8 = 0; t8 < o4.length; ++t8)
    u(i5, i5, o4[t8]);
  g(i5, i5, 1 / o4.length);
  let f8 = 0;
  for (let t8 = 0; t8 < o4.length; ++t8)
    f8 = Math.max(f8, p(i5, o4[t8]));
  s8.radius = Math.sqrt(f8);
}
function P2(t8, e8) {
  if (t8.length < 3)
    throw new Error("need at least 3 points to fit a plane");
  d(t8[0], t8[1], t8[2], e8);
}
function M2(t8, e8) {
  return P(t8, e8) + t8[3];
}
function b4(t8, e8, r8) {
  return In(t8, R3, r8) && In(e8, S2, r8) ? x(R3, S2) : 0;
}
function k2(t8, e8) {
  if (!gn(t8, R3) || !gn(e8, S2))
    return 0;
  const r8 = new R2();
  return b3(r8, [R3[0], R3[1]], [S2[0], S2[1]]), r8.distance;
}
function q3(t8, e8, r8) {
  const n6 = new R2();
  return b3(n6, [t8[0], t8[1]], [e8[0], e8[1]], r8), n6.distance;
}
function v2(t8, e8, r8, n6) {
  const o4 = G2;
  return Bn(t8, n6, R3) && Bn(e8, n6, S2) && Bn(r8, n6, U2) ? (o4.setPoint(0, 0, R3), o4.setPoint(0, 1, S2), o4.setPoint(0, 2, U2), Math.abs(k(o4, "square-meters"))) : 0;
}
function x3(r8, n6 = null, s8 = true) {
  const a9 = 1e-6, c6 = (t8, e8) => {
    if (0 === e8[0] && 0 === e8[1] && 0 === e8[2])
      return false;
    for (let r9 = 0; r9 < t8.length; ++r9)
      if (P(e8, t8[r9]) < -a9)
        return false;
    return true;
  };
  if (0 === r8.length)
    return false;
  if (1 === r8.length)
    return n6 && r(n6, r8[0]), true;
  o(T, 0, 0, 0);
  for (let t8 = 0; t8 < r8.length; ++t8)
    u(T, T, r8[t8]);
  if (z(T, T), c6(r8, T))
    return n6 && r(n6, T), true;
  if (!s8)
    return false;
  for (let t8 = 0; t8 < r8.length; ++t8)
    for (let e8 = 0; e8 < r8.length; ++e8)
      if (t8 !== e8 && (_(T, r8[t8], r8[e8]), z(T, T), c6(r8, T)))
        return n6 && r(n6, T), true;
  return false;
}
var R3 = n();
var S2 = n();
var U2 = n();
var G2 = new j3({ rings: [[R3, S2, U2]], spatialReference: f2.WGS84 });
var T = n();

// node_modules/@arcgis/core/views/support/euclideanAreaMeasurementUtils.js
var y2 = n();
var d2 = n();
function U3(t8) {
  return i(v4(t8), [], 2);
}
function v4(t8) {
  const o4 = new Float64Array(2 * t8.length);
  for (let r8 = 0; r8 < t8.length; ++r8) {
    const n6 = t8[r8], e8 = 2 * r8;
    o4[e8] = n6[0], o4[e8 + 1] = n6[1];
  }
  return o4;
}

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/MeasurementData.js
var B = class {
  constructor(e8, t8) {
    this.positionsWorldCoords = [], this.positionsRenderCoords = [], this.positionsProjectedWorldCoords = [], this.positionsFittedRenderCoords = [], this.positionsGeographic = [], this.positionsSpherical = [], this.positionsStereographic = [], this.pathSegmentLengths = [], this.geodesicPathSegmentLengths = [], this.perimeterSegmentLengths = [], this.intersectingSegments = /* @__PURE__ */ new Set(), this.geodesicIntersectingSegments = /* @__PURE__ */ new Set(), this.triangleIndices = null, this.geodesicTriangleIndices = null, this.areaCentroidWorldCoords = n(), this.areaCentroidRenderCoords = n(), this.geodesicAreaCentroidRenderCoords = n(), this.area = null, this.geodesicArea = null, this.pathLength = null, this.geodesicPathLength = null, this.perimeterLength = null, this._length = 0, this._centroidRenderCoords = n(), this._planeWorldCoords = n3(), this._worldUp = n(), this._worldTangent = n(), this._frame = [n(), n(), n()], this._pathVersion = -1, this._validMeasurement = false, this._hasCursorPoint = false, this._mode = null, this._tempU = n(), this._tempV = n(), this._tempVec3 = n(), this._tempSphere = { center: n(), radius: 0 }, this._sceneView = e8, this.unitNormalizer = t8;
  }
  update(e8, s8, i5, o4, r8, h8, a9) {
    const d4 = this.unitNormalizer, l8 = this._sceneView.renderSpatialReference, g4 = this.unitNormalizer.spatialReference, p4 = null != s8;
    if (this._pathVersion === e8.version && this._validMeasurement === o4 && !a9 && this._hasCursorPoint === p4 && this._mode === h8) {
      return !e8.isValidPolygon && (this._updateCursorSegmentLength(e8, s8), true);
    }
    this._pathVersion = e8.version, this._validMeasurement = o4, this._hasCursorPoint = p4;
    const c6 = e8.numVertices;
    this._resize(c6);
    const m5 = c(i5.spatialReference), u5 = Cn(i5.spatialReference, m5) && ce(i5.spatialReference), { positionsGeographic: _6, positionsWorldCoords: f8, positionsRenderCoords: R4, positionsSpherical: j4 } = this;
    e8.forEachVertexPosition((e9, t8) => {
      H(i5.elevationProvider, e9), In(e9, f8[t8], g4), In(e9, R4[t8], l8), u5 && (gn(e9, _6[t8]), In(e9, j4[t8], m5), z(j4[t8], j4[t8]));
    });
    const M3 = this._updatePathLengths(o4);
    if (this.pathLength = this._length > 1 ? r7(d4.normalizeDistance(M3), "meters") : null, u5) {
      const e9 = this._updateGeodesicPathLengths(o4, g4);
      this.geodesicPathLength = this._length > 1 ? r7(e9, "meters") : null;
    } else
      this.geodesicPathLength = null;
    return this._updateCursorSegmentLength(e8, s8), this._updateMode(e8, h8), o4 ? (this._updateArea(i5, d4, l8, g4, r8), u5 && this._updateGeodesicArea(i5), true) : (this.area = null, this.geodesicArea = null, this.perimeterLength = null, this.triangleIndices = null, this.geodesicTriangleIndices = null, this.intersectingSegments.clear(), this.geodesicIntersectingSegments.clear(), true);
  }
  getData() {
    return { positionsWorldCoords: this.positionsWorldCoords, positionsRenderCoords: this.positionsRenderCoords, positionsProjectedWorldCoords: this.positionsProjectedWorldCoords, positionsFittedRenderCoords: this.positionsFittedRenderCoords, positionsGeographic: this.positionsGeographic, positionsSpherical: this.positionsSpherical, positionsStereographic: this.positionsStereographic, pathSegmentLengths: this.pathSegmentLengths, geodesicPathSegmentLengths: this.geodesicPathSegmentLengths, perimeterSegmentLengths: this.perimeterSegmentLengths, intersectingSegments: this.intersectingSegments, geodesicIntersectingSegments: this.geodesicIntersectingSegments, triangleIndices: this.triangleIndices, geodesicTriangleIndices: this.geodesicTriangleIndices, areaCentroidWorldCoords: this.areaCentroidWorldCoords, areaCentroidRenderCoords: this.areaCentroidRenderCoords, geodesicAreaCentroidRenderCoords: this.geodesicAreaCentroidRenderCoords, fittingMode: this.fittingMode, area: this.area, geodesicArea: this.geodesicArea, pathLength: this.pathLength, geodesicPathLength: this.geodesicPathLength, perimeterLength: this.perimeterLength, cursorSegmentLength: this.cursorSegmentLength, geodesicCursorSegmentLength: this.geodesicCursorSegmentLength, unitNormalizer: this.unitNormalizer, actualMeasurementMode: this.actualMeasurementMode };
  }
  _resize(e8) {
    for (e8 < this._length && (this.positionsWorldCoords.length = e8, this.positionsRenderCoords.length = e8, this.positionsProjectedWorldCoords.length = e8, this.positionsFittedRenderCoords.length = e8, this.positionsGeographic.length = e8, this.positionsSpherical.length = e8, this.positionsStereographic.length = e8, this.pathSegmentLengths.length = e8, this.geodesicPathSegmentLengths.length = e8, this.perimeterSegmentLengths.length = e8, this._length = e8); this._length < e8; )
      this.positionsWorldCoords.push(n()), this.positionsRenderCoords.push(n()), this.positionsProjectedWorldCoords.push(n4()), this.positionsFittedRenderCoords.push(n()), this.positionsGeographic.push(n()), this.positionsSpherical.push(n()), this.positionsStereographic.push(n4()), this.pathSegmentLengths.push(0), this.geodesicPathSegmentLengths.push(0), this.perimeterSegmentLengths.push(0), ++this._length;
  }
  _updatePathLengths(e8) {
    const t8 = this.positionsWorldCoords, s8 = this.pathSegmentLengths;
    let i5 = 0;
    for (let o4 = 0; o4 < this._length; ++o4) {
      const r8 = s8[o4] = x(t8[o4], t8[(o4 + 1) % this._length]);
      (o4 < this._length - 1 || e8) && (i5 += r8);
    }
    return i5;
  }
  _updateGeodesicPathLengths(e8, t8) {
    const s8 = this.positionsGeographic, i5 = this.geodesicPathSegmentLengths;
    let o4 = 0;
    for (let r8 = 0; r8 < this._length; ++r8) {
      const n6 = i5[r8] = q3(s8[r8], s8[(r8 + 1) % this._length], t8 ?? void 0);
      (r8 < this._length - 1 || e8) && (o4 += n6);
    }
    return o4;
  }
  _updateArea(e8, o4, r8, n6, h8) {
    const u5 = e8.renderCoordsHelper, _6 = this.positionsWorldCoords, f8 = this.positionsRenderCoords, C2 = this.positionsProjectedWorldCoords, S3 = this.positionsFittedRenderCoords, L = this._planeWorldCoords, P3 = this._centroidRenderCoords;
    t6(f8, P3), u5.worldUpAtPosition(P3, this._worldUp), u5.worldBasisAtPosition(P3, n5.X, this._worldTangent), Un(P3, this._worldUp, r8, this._worldUp, n6), Un(P3, this._worldTangent, r8, this._worldTangent, n6), _6.length > 2 && P2(_6, L), this.fittingMode = this._selectFittingMode(L, _6, this._worldUp, h8);
    let M3 = 0;
    if ("horizontal" === this.fittingMode) {
      let e9 = -1 / 0;
      f8.forEach((t8, s8) => {
        const i5 = u5.getAltitude(f8[s8]);
        i5 > e9 && (e9 = i5, M3 = s8);
      });
    }
    const A3 = _6[M3];
    let W3 = L, I2 = this._worldTangent;
    "horizontal" === this.fittingMode ? W3 = this._worldUp : "vertical" === this.fittingMode && (W3 = this._tempVec3, I2 = this._worldUp, q2(L, this._worldUp, W3)), r(this._frame[2], W3), q2(I2, W3, this._frame[0]), _(this._frame[1], this._frame[0], this._frame[2]), j(this._frame[1], this._frame[1]);
    const w4 = this._tempVec3, z3 = this._tempU, U4 = this._tempV;
    for (let t8 = 0; t8 < this._length; ++t8) {
      const e9 = C2[t8], s8 = S3[t8];
      e2(w4, _6[t8], A3), r3(e9, P(this._frame[0], w4), P(this._frame[1], w4)), g(z3, this._frame[0], e9[0]), g(U4, this._frame[1], e9[1]), u(w4, z3, U4), u(w4, w4, A3), Hn(w4, n6, s8, r8);
    }
    this.perimeterLength = this._length > 0 ? r7(o4.normalizeDistance(this._updatePerimeterLengths()), "meters") : null, t6(S3, this.areaCentroidRenderCoords), Hn(this.areaCentroidRenderCoords, r8, this.areaCentroidWorldCoords, n6), this._updateIntersectingSegments(), this.area = 0 === this.intersectingSegments.size ? l5(o4.normalizeArea(this._computeArea()), "square-meters") : null;
  }
  _updateGeodesicArea(e8) {
    const { renderCoordsHelper: t8, spatialReference: o4 } = e8, { positionsSpherical: r8, positionsStereographic: n6 } = this, h8 = this._tempVec3, a9 = x3(r8, h8);
    if (!a9)
      return void (this.geodesicArea = null);
    const d4 = this._tempU, l8 = this._tempV;
    b(h8, d4, l8);
    for (let s8 = 0; s8 < this._length; ++s8) {
      const e9 = P(r8[s8], d4), t9 = P(r8[s8], l8), o5 = P(r8[s8], h8);
      r3(n6[s8], e9 / o5, t9 / o5);
    }
    g(h8, h8, A(o4).radius), t8.toRenderCoords(h8, c(o4), this.geodesicAreaCentroidRenderCoords), this._updateGeodesicIntersectingSegments(), this.geodesicArea = a9 && 0 === this.geodesicIntersectingSegments.size ? l5(this._computeGeodesicArea(), "square-meters") : null;
  }
  _updatePerimeterLengths() {
    const e8 = this.positionsProjectedWorldCoords, t8 = this.perimeterSegmentLengths;
    let s8 = 0;
    for (let i5 = 0; i5 < this._length; ++i5) {
      s8 += t8[i5] = m2(e8[i5], e8[(i5 + 1) % this._length]);
    }
    return s8;
  }
  _updateIntersectingSegments() {
    const e8 = this.positionsProjectedWorldCoords, t8 = this.intersectingSegments;
    t8.clear();
    for (let s8 = 0; s8 < this._length; ++s8)
      for (let i5 = s8 + 2; i5 < this._length; ++i5) {
        if ((i5 + 1) % this._length === s8)
          continue;
        const o4 = e8[s8], r8 = e8[(s8 + 1) % this._length], n6 = e8[i5], h8 = e8[(i5 + 1) % this._length];
        G(o4, r8, n6, h8) && (t8.add(s8), t8.add(i5));
      }
  }
  _computeArea() {
    const e8 = this.positionsProjectedWorldCoords, t8 = this.triangleIndices = t2(U3(e8));
    let s8 = 0;
    for (let i5 = 0; i5 < t8.length; i5 += 3)
      s8 += S(e8[t8[i5]], e8[t8[i5 + 1]], e8[t8[i5 + 2]]);
    return s8;
  }
  _updateGeodesicIntersectingSegments() {
    const e8 = this.positionsStereographic, t8 = this.geodesicIntersectingSegments;
    t8.clear();
    for (let s8 = 0; s8 < this._length; ++s8)
      for (let i5 = s8 + 2; i5 < this._length; ++i5) {
        if ((i5 + 1) % this._length === s8)
          continue;
        const o4 = e8[s8], r8 = e8[(s8 + 1) % this._length], n6 = e8[i5], h8 = e8[(i5 + 1) % this._length];
        G(o4, r8, n6, h8) && (t8.add(s8), t8.add(i5));
      }
  }
  _computeGeodesicArea() {
    const e8 = this.positionsGeographic, t8 = this.positionsStereographic, s8 = this.geodesicTriangleIndices = t2(U3(t8));
    let i5 = 0;
    for (let o4 = 0; o4 < s8.length; o4 += 3)
      i5 += v2(e8[s8[o4]], e8[s8[o4 + 1]], e8[s8[o4 + 2]], f2.WGS84);
    return i5;
  }
  _selectFittingMode(t8, s8, i5, o4) {
    const r8 = s8.map((e8) => Math.abs(M2(t8, e8))).reduce((e8, t9) => Math.max(e8, t9), 0);
    w3(s8, this._tempSphere);
    const n6 = r8 / (2 * this._tempSphere.radius), h8 = n6 < o4.maxRelativeErrorCoplanar, a9 = n6 < o4.maxRelativeErrorAlmostCoplanar;
    let d4 = "horizontal";
    if (h8)
      d4 = "oblique";
    else if (a9) {
      d4 = Math.abs(P(i5, t8)) > Math.cos(M(o4.verticalAngleThreshold)) ? "horizontal" : "vertical";
    }
    return d4;
  }
  _updateCursorSegmentLength(e8, s8) {
    const i5 = e8.lastPoint;
    e8.isValidPolygon || null == i5 || null == s8 ? (this.geodesicCursorSegmentLength = null, this.cursorSegmentLength = null) : (this.geodesicCursorSegmentLength = r7(k2(i5, s8), "meters"), this.cursorSegmentLength = r7(this.unitNormalizer.normalizeDistance(b4(i5, s8, this.unitNormalizer.spatialReference)), "meters"));
  }
  _updateMode(e8, t8) {
    if (t8 === e7.Auto) {
      this.actualMeasurementMode = "euclidean";
      let t9 = 0;
      null != this.geodesicPathLength && (t9 += this.geodesicPathLength.value), e8.isValidPolygon || null == this.geodesicCursorSegmentLength || (t9 += this.geodesicCursorSegmentLength.value), t9 > X && (this.actualMeasurementMode = "geodesic");
    } else
      this.actualMeasurementMode = t8 === e7.Euclidean ? "euclidean" : "geodesic";
    null == this.geodesicPathLength && (this.actualMeasurementMode = "euclidean"), this._mode = t8;
  }
};
function H(e8, t8) {
  t8.hasZ || (t8.z = a6(e8, t8, "ground") ?? 0);
}
var X = 1e5;

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/AreaMeasurementController.js
var u4 = class extends m {
  constructor(e8) {
    super(e8);
  }
  initialize() {
    const e8 = this.view.spatialReference, t8 = c(e8), a9 = t8 === f4 ? a4 : t8, o4 = !e8 || Cn(e8, a9) ? a9 : e8, u5 = new t7(o4);
    this._measurementDataManager = new B(this.view, u5), this.addHandles([this.analysisViewData.path.on("change", () => this._update()), l2(() => this.analysisViewData.cursorPoint, () => this._update(), U), l2(() => this.analysisViewData.mode, () => this._update(), U)]), this._update();
  }
  _update(e8 = false) {
    const { analysisViewData: t8, view: r8 } = this, s8 = { maxRelativeErrorCoplanar: 5e-3, maxRelativeErrorAlmostCoplanar: 0.01, verticalAngleThreshold: 80 };
    this._measurementDataManager.update(t8.path, t8.cursorPoint, r8, t8.validMeasurement, s8, t8.mode, e8) && (t8.measurementData = this._measurementDataManager.getData());
  }
};
e([y({ constructOnly: true })], u4.prototype, "view", void 0), e([y({ constructOnly: true })], u4.prototype, "analysis", void 0), e([y({ constructOnly: true })], u4.prototype, "analysisViewData", void 0), u4 = e([a("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementController")], u4);

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/AreaMeasurementPathHelper.js
var G3 = "esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurement3DPathHelper";
var f7 = s.getLogger(G3);
var v5 = class extends n2.EventedAccessor {
  constructor(e8 = {}) {
    super(e8), this._handles = new t(), this._version = 0, this._internalGeometryChange = false, this._extent = C();
  }
  destroy() {
    this._handles = l(this._handles);
  }
  set areaMeasurement(e8) {
    this._set("areaMeasurement", e8), null != e8 && null != this.view && this._initialize(e8, this.view);
  }
  set view(e8) {
    this._set("view", e8), null != e8 && null != this.areaMeasurement && this._initialize(this.areaMeasurement, e8);
  }
  get constructed() {
    return null != this.areaMeasurement && null != this.view;
  }
  get version() {
    return this._version;
  }
  get isValidPolygon() {
    return this.constructed && this._editGeometry.components.length > 0 && this._editGeometry.components[0].isClosed();
  }
  get extent() {
    if (this.constructed && this._editGeometry.components.length > 0 && this._editGeometry.components[0].vertices.length > 0) {
      const e8 = C(this._extent);
      return this.forEachVertex((t8) => {
        f3(e8, t8.pos);
      }), e8;
    }
    return null;
  }
  get spatialReference() {
    return this.constructed ? this._editGeometry.coordinateHelper.spatialReference : null;
  }
  _initialize(e8, t8) {
    this._handles.removeAll(), this._handles.add(l2(() => e8.geometry, () => {
      this._updateEditGeometryFromModelGeometry(e8, t8);
    }, w)), this._makeDirty(true);
  }
  _makeDirty(e8 = false) {
    this.notifyChange("isValidPolygon"), this.notifyChange("initialized"), this.notifyChange("extent"), e8 && this.notifyChange("numVertices");
  }
  _updateEditGeometryFromModelGeometry(e8, t8) {
    if (this._version++, this._internalGeometryChange)
      return;
    this._handles.remove("EditGeometry");
    let r8 = e8.geometry;
    if (null != r8) {
      const o4 = En(r8, t8.spatialReference);
      null == o4 && t5(e8, r8.spatialReference, f7), r8 = o4;
    }
    this._editGeometryOperations = null != r8 ? _3.fromGeometry(r8, t8.state.viewingMode) : new _3(new p2("polygon", w2(true, false, t8.spatialReference))), this._makeDirty(true), this.emit("change"), this._handles.add(this._editGeometry.on("change", (t9) => {
      this._makeDirty(null != t9.addedVertices || null != t9.removedVertices), this._internalGeometryChange = true, e8.geometry = this.numVertices > 0 ? this._editGeometry.geometry : null, this._internalGeometryChange = false;
    }), "EditGeometry");
  }
  get _editGeometry() {
    return this._editGeometryOperations.data;
  }
  get vertices() {
    const e8 = [];
    return this.forEachVertex((t8) => {
      e8.push(t8);
    }), e8;
  }
  get numVertices() {
    return this.constructed && this._editGeometry.components.length > 0 ? this._editGeometry.components[0].vertices.length : 0;
  }
  get lastPoint() {
    if (this.constructed && this._editGeometry.components.length > 0) {
      const e8 = this._editGeometry.components[0].getLastVertex();
      if (null != e8)
        return this._editGeometry.coordinateHelper.vectorToPoint(e8.pos);
    }
    return null;
  }
  getVertex(e8) {
    if (!this.constructed || 0 === this._editGeometry.components.length || 0 === this._editGeometry.components[0].vertices.length)
      return null;
    const t8 = this._editGeometry.components[0].vertices[0];
    let r8 = t8;
    do {
      if (r8.index === e8)
        return r8;
      r8 = r8.rightEdge.rightVertex;
    } while (r8 !== t8 && null != r8);
    return null;
  }
  getVertexPositionAsPoint(e8) {
    return this._editGeometry.coordinateHelper.vectorToPoint(e8.pos);
  }
  getVertexPositionAsPointFromIndex(e8) {
    return this._editGeometry.coordinateHelper.vectorToPoint(this.getVertex(e8).pos);
  }
  forEachVertex(e8) {
    this.constructed && this._editGeometry.components.length > 0 && this._editGeometry.components[0].iterateVertices(e8);
  }
  forEachVertexPosition(e8) {
    const t8 = this._editGeometry.coordinateHelper;
    this.forEachVertex((r8, o4) => {
      t8.vectorToPoint(r8.pos, V), e8(V, o4);
    });
  }
  clear() {
    null != this.areaMeasurement && (this.areaMeasurement.geometry = null);
  }
  add(e8) {
    if (!this.constructed)
      return null;
    if (0 === this._editGeometry.components.length) {
      const e9 = this.view;
      this._editGeometry.components.push(new l6(e9.spatialReference, e9.state.viewingMode));
    }
    const t8 = this._editGeometryOperations.appendVertex(this._editGeometry.coordinateHelper.pointToVector(e8));
    return this.emit("change"), t8;
  }
  close() {
    if (!this.constructed || 0 === this._editGeometry.components.length)
      return null;
    const e8 = this._editGeometryOperations.closeComponent(this._editGeometry.components[0]);
    return this.emit("change"), e8;
  }
  ensureContains(e8, t8 = "") {
    let r8 = false;
    if (this._editGeometry.components.forEach((t9) => {
      t9.iterateVertices((t10) => {
        t10 === e8 && (r8 = true);
      });
    }), !r8)
      throw new Error(`vertex doesnt exist ${t8}`);
    return r8;
  }
  setVertexPosition(e8, t8) {
    if (!this.constructed)
      return null;
    const r8 = this._editGeometryOperations.setVertexPosition(e8, this._editGeometry.coordinateHelper.pointToVector(t8));
    return this.emit("change"), r8;
  }
  equals(e8) {
    if (this.numVertices !== e8.numVertices)
      return false;
    let t8 = true;
    return this.forEachVertexPosition((r8, o4) => {
      const i5 = e8.getVertexPositionAsPointFromIndex(o4);
      r8.equals(i5) || (t8 = false);
    }), !!t8;
  }
};
e([y({ value: null })], v5.prototype, "areaMeasurement", null), e([y({ value: null })], v5.prototype, "view", null), e([y()], v5.prototype, "isValidPolygon", null), e([y()], v5.prototype, "extent", null), e([y()], v5.prototype, "spatialReference", null), e([y()], v5.prototype, "numVertices", null), v5 = e([a(G3)], v5);
var V = new x2();

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/CheckerBoardTechnique.js
var d3 = class _d extends e4 {
  initializeProgram(e8) {
    return new i2(e8.rctx, _d.shader.get().build(this.configuration), E);
  }
  _setPipelineState(e8) {
    const r8 = this.configuration, t8 = e8 === o3.NONE, s8 = e8 === o3.FrontFace;
    return W({ blending: r8.transparent ? t8 ? g3 : A2(e8) : null, depthTest: { func: l4(e8) }, depthWrite: t8 ? r8.writeDepth ? a5 : null : E2(e8), colorWrite: _2, polygonOffset: t8 || s8 ? r8.polygonOffset ? h6 : null : { factor: -1, units: -25 } });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
};
d3.shader = new t4(c4, () => import("./CheckerBoard.glsl-3NFGBHJW.js"));
var h6 = { factor: 0, units: -25 };
var g3 = l3(R.SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE_MINUS_SRC_ALPHA);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/CheckerBoardTechniqueConfiguration.js
var s7 = class extends s4 {
  constructor() {
    super(...arguments), this.transparencyPassType = o3.NONE, this.transparent = false, this.writeDepth = true, this.polygonOffset = false, this.hasMultipassTerrain = false, this.cullAboveGround = false;
  }
};
e([r6({ count: o3.COUNT })], s7.prototype, "transparencyPassType", void 0), e([r6()], s7.prototype, "transparent", void 0), e([r6()], s7.prototype, "writeDepth", void 0), e([r6()], s7.prototype, "polygonOffset", void 0), e([r6()], s7.prototype, "hasMultipassTerrain", void 0), e([r6()], s7.prototype, "cullAboveGround", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/CheckerBoardMaterial.js
var h7 = class extends e5 {
  constructor(r8) {
    super(r8, new l7()), this._configuration = new s7();
  }
  dispose() {
  }
  getConfiguration(r8, t8) {
    return this._configuration.transparent = this.parameters.transparent, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.polygonOffset = this.parameters.polygonOffset, this._configuration.transparencyPassType = t8.transparencyPassType, this._configuration.hasMultipassTerrain = t8.multipassTerrain.enabled, this._configuration.cullAboveGround = t8.multipassTerrain.cullAboveGround, this._configuration;
  }
  requiresSlot(r8, t8) {
    if (t8 === h3.Color || t8 === h3.Alpha) {
      return r8 === (this.parameters.transparent ? this.parameters.writeDepth ? E3.TRANSPARENT_MATERIAL : E3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL : E3.OPAQUE_MATERIAL) || r8 === E3.DRAPED_MATERIAL;
    }
    return false;
  }
  createGLMaterial(r8) {
    return new c5(r8);
  }
  createBufferWriter() {
    return new r5(c3);
  }
};
var c5 = class extends t3 {
  beginSlot(r8) {
    return this.ensureTechnique(d3, r8);
  }
};
var l7 = class extends c2 {
  constructor() {
    super(...arguments), this.size = r4(1, 1), this.color1 = r2(0.75, 0.75, 0.75, 1), this.color2 = r2(0.5, 0.5, 0.5, 1), this.transparent = false, this.writeDepth = true, this.polygonOffset = false;
  }
};

// node_modules/@arcgis/core/views/3d/interactive/visualElements/MeasurementAreaVisualElement.js
var _5 = class extends a8 {
  constructor(e8) {
    super(e8), this._checkerBoardMaterial = null, this._renderOccluded = o2.OccludeAndTransparent, this._geometry = null, this._size = r4(1, 1), this._color1 = r2(1, 0.5, 0, 0.5), this._color2 = r2(1, 1, 1, 0.5), this.applyProps(e8);
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(e8) {
    e8 !== this._renderOccluded && (this._renderOccluded = e8, this._updateMaterial());
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e8) {
    this._geometry = e8, this._geometryChanged();
  }
  get size() {
    return this._size;
  }
  set size(e8) {
    a3(this._size, e8), this._updateMaterial();
  }
  get color1() {
    return this._color1;
  }
  set color1(e8) {
    D(e8, this._color1) || (a2(this._color1, e8), this._updateMaterial());
  }
  get color2() {
    return this._color2;
  }
  set color2(e8) {
    D(e8, this._color2) || (a2(this._color2, e8), this._updateMaterial());
  }
  _updateMaterial() {
    null != this._checkerBoardMaterial && this._checkerBoardMaterial.setParameters({ size: this._size, color1: this._color1, color2: this._color2, renderOccluded: this._renderOccluded });
  }
  createExternalResources() {
    this._checkerBoardMaterial = new h7({ size: this._size, color1: this._color1, color2: this._color2, transparent: true, writeDepth: false, polygonOffset: true, renderOccluded: o2.OccludeAndTransparent });
  }
  destroyExternalResources() {
    this._checkerBoardMaterial = null;
  }
  forEachExternalMaterial(e8) {
    null != this._checkerBoardMaterial && e8(this._checkerBoardMaterial);
  }
  createGeometries(r8) {
    if (null == this._geometry || null == this._checkerBoardMaterial)
      return;
    const t8 = p3;
    I(t8, this.transform);
    const i5 = this._geometry, c6 = [], a9 = n();
    i5.position.forEach((e8) => {
      e2(a9, e8, t8), c6.push(a9[0], a9[1], a9[2]);
    });
    const l8 = [];
    i5.uv.forEach((e8) => {
      l8.push(e8[0], e8[1]);
    });
    const d4 = new b2(this._checkerBoardMaterial, [[O.POSITION, new s3(c6, 3, true)], [O.UV0, new s3(l8, 2, true)]], [[O.POSITION, i5.triangleIndices], [O.UV0, i5.triangleIndices]]);
    r8.addGeometry(d4);
  }
  _geometryChanged() {
    this.recreateGeometry();
  }
};
var p3 = n();

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/AreaMeasurementVisualization.js
var z2 = class extends m {
  get visible() {
    return this.analysisViewData.visible;
  }
  get testData() {
    return { labels: { area: this._areaLabel, pathLength: this._pathLengthLabel, cursorSegmentLength: this._cursorSegmentLengthLabel, perimeterLength: this._perimeterLengthLabel } };
  }
  constructor(e8) {
    super(e8), this._handles = new t(), this._params = { pathLineColor: h2.toUnitRGBA(i3()), pathLineWidth: 3, intersectingLineColor: [1, 0.2, 0, 1], perimeterLineColor: h2.toUnitRGBA(i3()), perimeterLineWidth: 2, projectionLineColor: h2.toUnitRGBA(i3()), projectionLineWidth: 2, projectionLineStippleSize: 5, areaColor1: h2.toUnitRGBA(i3(0.5)), areaColor2: h2.toUnitRGBA(u2(0.5)), labelDistance: 25 }, this._path = null, this._intersectedPath = null, this._perimeter = null, this._intersectedPerimeter = null, this._projectionLines = null, this._measurementArea = null, this._areaLabel = null, this._pathLengthLabel = null, this._cursorSegmentLengthLabel = null, this._perimeterLengthLabel = null, this._pathSegments = [], this._perimeterSegments = [], this._cursorSegment = null, this._origin = n(), this._originTransform = e3(), this._cursorPositionRenderSpace = n(), this.messages = null, this.viewData = q5, this.areaLabel = null, this.perimeterLengthLabel = null, this.loadingMessages = true;
  }
  initialize() {
    const { analysisViewData: e8, _params: t8, view: i5 } = this;
    this._path = new u3({ view: i5, attached: true, width: t8.pathLineWidth, color: t8.pathLineColor, polygonOffset: true, renderOccluded: o2.OccludeAndTransparent }), this._intersectedPath = new u3({ view: i5, attached: true, width: t8.pathLineWidth, color: t8.intersectingLineColor, polygonOffset: true, renderOccluded: o2.OccludeAndTransparent }), this._perimeter = new u3({ view: i5, attached: true, width: t8.perimeterLineWidth, color: t8.perimeterLineColor, polygonOffset: true, renderOccluded: o2.OccludeAndTransparent }), this._intersectedPerimeter = new u3({ view: i5, attached: true, width: t8.perimeterLineWidth, color: t8.intersectingLineColor, polygonOffset: true, renderOccluded: o2.OccludeAndTransparent }), this._projectionLines = new u3({ view: i5, attached: true, width: t8.projectionLineWidth, color: t8.projectionLineColor, stipplePattern: h4(t8.projectionLineStippleSize), polygonOffset: true, renderOccluded: o2.OccludeAndTransparent }), this._measurementArea = new _5({ view: i5, attached: true, color1: t8.areaColor1, color2: t8.areaColor2 });
    const s8 = { attached: true, backgroundColor: s6(0.6), calloutColor: s6(0.5), textColor: a7(), view: i5 };
    this._areaLabel = new g2({ ...s8, fontSize: k3.Large }), this._pathLengthLabel = new g2({ ...s8, fontSize: k3.Small }), this._cursorSegmentLengthLabel = new g2({ ...s8, fontSize: k3.Small }), this._perimeterLengthLabel = new g2({ ...s8, fontSize: k3.Small }), this._handles.add([l2(() => [e8.mode, this.visible, e8.unit, e8.measurementData, e8.cursorPoint], () => this._update(), w), l2(() => {
      var _a;
      return (_a = i5.state) == null ? void 0 : _a.camera;
    }, () => this._updateLabels(), w), s2(() => this._updateMessageBundle())]), this._updateMessageBundle();
  }
  destroy() {
    this._measurementArea = l(this._measurementArea), this._path = l(this._path), this._intersectedPath = l(this._intersectedPath), this._perimeter = l(this._perimeter), this._intersectedPerimeter = l(this._intersectedPerimeter), this._areaLabel = l(this._areaLabel), this._pathLengthLabel = l(this._pathLengthLabel), this._cursorSegmentLengthLabel = l(this._cursorSegmentLengthLabel), this._perimeterLengthLabel = l(this._perimeterLengthLabel), this._projectionLines = l(this._projectionLines), this._handles = l(this._handles), this.set("view", null);
  }
  _update() {
    if (this.destroyed || !this.view.ready || !this.view.renderCoordsHelper)
      return;
    const { analysisViewData: { measurementData: e8 }, analysisViewData: t8 } = this;
    null != e8 && (this._updateViewData(e8, t8.path, t8.cursorPoint), this._updateOrigin(), this._updatePathSegments(), this._updatePerimeterSegments(), this._updateArea(), this._updateProjectionLines(), this._updateLabels());
  }
  _updateViewData(e8, t8, i5) {
    const s8 = t8.isValidPolygon, r8 = "geodesic" === e8.actualMeasurementMode, n6 = r8 ? e8.geodesicArea : e8.area;
    let a9 = 1;
    if (n6) {
      const t9 = this._toPreferredAreaUnit(n6, this.analysisViewData.unit);
      a9 = f(Math.sqrt(t9.value) / Math.sqrt(300)), a9 *= Math.sqrt(j2(1, t9.unit, "square-meters")), a9 /= e8.unitNormalizer.normalizeDistance(1);
    }
    const o4 = { validMeasurement: s8, path: t8, pathVersion: t8.version, cursorPoint: i5, measurementData: e8, mode: e8.actualMeasurementMode, positionsGeographic: e8.positionsGeographic, positionsRenderCoords: e8.positionsRenderCoords, positionsProjected: e8.positionsProjectedWorldCoords, positionsFittedRenderCoords: e8.positionsFittedRenderCoords, intersectingSegments: r8 ? e8.geodesicIntersectingSegments : e8.intersectingSegments, triangleIndices: r8 ? e8.geodesicTriangleIndices : e8.triangleIndices, fittingMode: e8.fittingMode, areaCentroid: r8 ? e8.geodesicAreaCentroidRenderCoords : e8.areaCentroidRenderCoords, pathLengthLabelSegmentIndex: s8 ? 0 : t8.numVertices - 2, perimeterLengthLabelSegmentIndex: 0, checkerSize: a9 };
    this._set("viewData", o4);
  }
  _updateOrigin() {
    const e8 = this.viewData;
    t6(e8.positionsRenderCoords, this._origin), q(this._originTransform, this._origin), this._measurementArea.transform = this._originTransform, this._projectionLines.transform = this._originTransform;
  }
  _createSegments(e8) {
    const t8 = this.viewData, i5 = t8.path, s8 = this.view.renderCoordsHelper.spatialReference, r8 = t8.mode, n6 = [], a9 = [], o4 = [], l8 = t8.validMeasurement ? i5.numVertices : i5.numVertices - 1;
    for (let h8 = 0; h8 < l8; ++h8) {
      const l9 = t8[e8][h8], m5 = t8[e8][(h8 + 1) % i5.numVertices];
      let c6 = null;
      switch (r8) {
        case "euclidean":
          c6 = new f6(l9, m5);
          break;
        case "geodesic":
          c6 = new m3(l9, m5, s8);
      }
      t8.intersectingSegments.has(h8) ? o4.push(c6) : a9.push(c6), n6.push(c6);
    }
    return { all: n6, nonIntersecting: a9, intersecting: o4 };
  }
  _updatePathSegments() {
    const { view: { renderCoordsHelper: e8 }, viewData: t8, visible: i5 } = this, s8 = this._createSegments("positionsRenderCoords"), { cursorPoint: r8, mode: n6, path: a9 } = t8, o4 = !a9.isValidPolygon, l8 = e8.spatialReference;
    if (this._cursorSegment = null, a9.numVertices > 0 && o4 && null != r8) {
      if (e8.toRenderCoords(r8, this._cursorPositionRenderSpace)) {
        const e9 = t8.positionsRenderCoords[a9.numVertices - 1], i6 = this._cursorPositionRenderSpace;
        let r9 = null;
        switch (n6) {
          case "euclidean":
            r9 = new f6(e9, i6);
            break;
          case "geodesic":
            r9 = new m3(e9, i6, l8);
        }
        s8.nonIntersecting.push(r9), this._cursorSegment = r9;
      }
    }
    this._path.setGeometryFromSegments(s8.nonIntersecting, this._origin), this._path.visible = i5, this._intersectedPath.setGeometryFromSegments(s8.intersecting, this._origin), this._intersectedPath.visible = i5, this._pathSegments = s8.all;
  }
  _updatePerimeterSegments() {
    const e8 = this.visible && "euclidean" === this.viewData.mode, t8 = this._createSegments("positionsFittedRenderCoords");
    this._perimeter.setGeometryFromSegments(t8.nonIntersecting, this._origin), this._perimeter.visible = e8, this._intersectedPerimeter.setGeometryFromSegments(t8.intersecting, this._origin), this._intersectedPerimeter.visible = e8, this._perimeterSegments = t8.all;
  }
  _updateArea() {
    const e8 = this.viewData;
    switch (e8.mode) {
      case "euclidean":
        this._updateAreaEuclidean(e8);
        break;
      case "geodesic":
        this._updateAreaGeodesic();
    }
  }
  _updateAreaEuclidean(e8) {
    const t8 = this.visible;
    e8.validMeasurement && 0 === e8.intersectingSegments.size && e8.triangleIndices ? (this._measurementArea.geometry = { uv: e8.positionsProjected, position: e8.positionsFittedRenderCoords, triangleIndices: e8.triangleIndices }, this._measurementArea.size = [e8.checkerSize, e8.checkerSize], this._measurementArea.visible = t8) : this._measurementArea.visible = false;
  }
  _updateAreaGeodesic() {
    this._measurementArea.visible = false;
  }
  _updateProjectionLines() {
    const e8 = this.viewData, t8 = this.visible, i5 = e8.path, s8 = e8.mode;
    if (i5.numVertices > 0 && e8.validMeasurement && "euclidean" === s8) {
      const s9 = [];
      for (let t9 = 0; t9 < i5.numVertices; ++t9) {
        const i6 = n();
        e2(i6, e8.positionsRenderCoords[t9], this._origin);
        const r8 = n();
        e2(r8, e8.positionsFittedRenderCoords[t9], this._origin), s9.push([i6, r8]);
      }
      this._projectionLines.geometry = s9, this._projectionLines.visible = t8;
    } else
      this._projectionLines.geometry = null, this._projectionLines.visible = false;
  }
  _updateLabels() {
    if (this.destroyed)
      return;
    const { viewData: e8 } = this, { measurementData: t8, mode: i5, path: s8 } = e8;
    if (!s8)
      return;
    const r8 = !s8.isValidPolygon, n6 = this.visible, a9 = this._formatAreaLabel(this.messages, "geodesic" === i5 ? t8.geodesicArea : t8.area, this.analysisViewData.unit);
    null != a9 ? (this._areaLabel.geometry = { type: "point", point: e8.areaCentroid }, this._areaLabel.text = a9, this._areaLabel.visible = e8.validMeasurement && 0 === e8.intersectingSegments.size && n6) : this._areaLabel.visible = false, this._set("areaLabel", a9);
    const o4 = this._formatLengthLabel(this.messages, "geodesic" === i5 ? t8.geodesicPathLength : t8.pathLength, this.analysisViewData.unit);
    if (null != o4 && e8.pathLengthLabelSegmentIndex >= 0 && e8.pathLengthLabelSegmentIndex < this._pathSegments.length) {
      const t9 = this._pathSegments[e8.pathLengthLabelSegmentIndex], i6 = null != this._cursorSegment ? this._cursorSegment : x4;
      this._pathLengthLabel.distance = this._params.labelDistance, this._pathLengthLabel.geometry = { type: "corner", left: t9, right: i6 }, this._pathLengthLabel.text = o4, this._pathLengthLabel.visible = r8 && s8.numVertices > 0 && n6;
    } else
      this._pathLengthLabel.visible = false;
    const l8 = "geodesic" === i5 ? e8.measurementData.geodesicCursorSegmentLength : e8.measurementData.cursorSegmentLength;
    if (null != l8) {
      const e9 = this._formatLengthLabel(this.messages, l8, this.analysisViewData.unit);
      this._cursorSegmentLengthLabel.distance = this._params.labelDistance, this._cursorSegmentLengthLabel.geometry = null != this._cursorSegment ? { type: "segment", segment: this._cursorSegment, sampleLocation: "end" } : null, this._cursorSegmentLengthLabel.anchor = "bottom", this._cursorSegmentLengthLabel.text = e9, this._cursorSegmentLengthLabel.visible = r8 && 0 !== l8.value && n6;
    } else
      this._cursorSegmentLengthLabel.visible = false;
    this._cursorSegmentLengthLabel.overlaps(this._pathLengthLabel) && (this._cursorSegmentLengthLabel.visible = false), this._pathLengthLabel.overlaps(this._areaLabel) && (this._pathLengthLabel.visible = false);
    const h8 = "geodesic" === e8.mode, m5 = h8 ? t8.geodesicPathLength : t8.perimeterLength, c6 = this._formatLengthLabel(this.messages, m5, this.analysisViewData.unit);
    if (this._set("perimeterLengthLabel", c6), e8.validMeasurement && 0 === e8.intersectingSegments.size) {
      this._perimeterLengthLabel.distance = this._params.labelDistance, this._perimeterLengthLabel.anchor = "top", this._perimeterLengthLabel.text = c6, this._perimeterLengthLabel.visible = true;
      let t9 = true;
      for (let i6 = 0; i6 < e8.path.numVertices; ++i6) {
        const s9 = (e8.perimeterLengthLabelSegmentIndex + i6) % e8.path.numVertices, r9 = h8 ? this._pathSegments[s9] : this._perimeterSegments[s9];
        if (t9 = true, this._perimeterLengthLabel.geometry = { type: "segment", segment: r9, sampleLocation: "center" }, !this._perimeterLengthLabel.overlaps(this._areaLabel))
          break;
        t9 = false;
      }
      this._perimeterLengthLabel.visible = t9 && n6;
    } else
      this._perimeterLengthLabel.visible = false;
  }
  _toPreferredAreaUnit(e8, t8) {
    return f5(e8, this._preferredAreaUnit(e8, t8));
  }
  _preferredAreaUnit(e8, t8) {
    switch (t8) {
      case "metric":
        return J(e8.value, e8.unit);
      case "imperial":
        return K(e8.value, e8.unit);
      default:
        return t8;
    }
  }
  _preferredLengthUnit(e8, t8) {
    const i5 = this._deriveLengthUnitFromAreaUnit(t8);
    switch (i5) {
      case "metric":
        return v(e8.value, e8.unit);
      case "imperial":
        return F(e8.value, e8.unit);
      default:
        return i5;
    }
  }
  _deriveLengthUnitFromAreaUnit(e8) {
    switch (e8) {
      case "metric":
      case "ares":
      case "hectares":
        return "metric";
      case "imperial":
      case "acres":
        return "imperial";
      case "square-inches":
        return "inches";
      case "square-feet":
        return "feet";
      case "square-yards":
        return "yards";
      case "square-miles":
        return "miles";
      case "square-us-feet":
        return "us-feet";
      case "square-millimeters":
        return "millimeters";
      case "square-centimeters":
        return "centimeters";
      case "square-decimeters":
        return "decimeters";
      case "square-meters":
        return "meters";
      case "square-kilometers":
        return "kilometers";
    }
    throw new Error("unhandled area unit");
  }
  _formatAreaLabel(e8, t8, i5) {
    return e8 && t8 && h5(e8, t8, this._preferredAreaUnit(t8, i5));
  }
  _formatLengthLabel(e8, t8, i5) {
    return e8 && t8 && h5(e8, t8, this._preferredLengthUnit(t8, i5));
  }
  _updateMessageBundle() {
    this.loadingMessages = true, h("esri/core/t9n/Units").then((e8) => {
      this.messages = e8, this.view && this._update();
    }).finally(() => {
      this.loadingMessages = false;
    });
  }
};
var k3;
e([y()], z2.prototype, "view", void 0), e([y()], z2.prototype, "messages", void 0), e([y()], z2.prototype, "analysis", void 0), e([y()], z2.prototype, "viewData", void 0), e([y()], z2.prototype, "analysisViewData", void 0), e([y({ readOnly: true })], z2.prototype, "areaLabel", void 0), e([y({ readOnly: true })], z2.prototype, "perimeterLengthLabel", void 0), e([y()], z2.prototype, "loadingMessages", void 0), e([y()], z2.prototype, "visible", null), z2 = e([a("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementVisualization")], z2), function(e8) {
  e8[e8.Small = 12] = "Small", e8[e8.Large = 16] = "Large";
}(k3 || (k3 = {}));
var q5 = { validMeasurement: false, path: null, pathVersion: -1, cursorPoint: null, measurementData: null, mode: null, positionsGeographic: null, positionsRenderCoords: null, positionsProjected: null, positionsFittedRenderCoords: null, intersectingSegments: null, triangleIndices: null, fittingMode: null, areaCentroid: null, pathLengthLabelSegmentIndex: null, perimeterLengthLabelSegmentIndex: null, checkerSize: null };
var x4 = new f6(n(), n());

// node_modules/@arcgis/core/views/3d/analysis/AreaMeasurementAnalysisView3D.js
var m4 = class extends s5(m) {
  constructor(e8) {
    super(e8), this.type = "area-measurement-view-3d", this.analysis = null, this.measurementData = null, this.lastDraggedVertex = null, this.cursorPoint = null, this.mode = e7.Auto;
  }
  initialize() {
    const { analysis: e8, view: t8 } = this;
    this.path = new v5({ view: t8, areaMeasurement: e8 }), this.analysisVisualization = new z2({ view: t8, analysis: e8, analysisViewData: this }), this.analysisController = new u4({ view: t8, analysis: e8, analysisViewData: this });
  }
  destroy() {
    this.analysisController = l(this.analysisController), this.analysisVisualization = l(this.analysisVisualization), this.path.destroy();
  }
  get updating() {
    var _a;
    return !!((_a = this.analysisVisualization) == null ? void 0 : _a.loadingMessages);
  }
  get result() {
    const { measurementData: e8 } = this;
    return null == e8 ? { area: null, mode: null, perimeter: null } : "euclidean" === e8.actualMeasurementMode ? { area: e8.area, perimeter: e8.perimeterLength, mode: "euclidean" } : { area: e8.geodesicArea, perimeter: e8.pathLength, mode: "geodesic" };
  }
  get viewData() {
    return this.analysisVisualization.viewData;
  }
  get validMeasurement() {
    return this.path.isValidPolygon;
  }
  get unit() {
    return this.analysis.unit ?? this._defaultUnit;
  }
  get testData() {
    return { visualization: this.analysisVisualization, controller: this.analysisController };
  }
};
e([y({ readOnly: true })], m4.prototype, "type", void 0), e([y({ constructOnly: true, nonNullable: true })], m4.prototype, "analysis", void 0), e([y()], m4.prototype, "updating", null), e([y()], m4.prototype, "analysisVisualization", void 0), e([y()], m4.prototype, "analysisController", void 0), e([y()], m4.prototype, "result", null), e([y()], m4.prototype, "measurementData", void 0), e([y()], m4.prototype, "viewData", null), e([y()], m4.prototype, "validMeasurement", null), e([y()], m4.prototype, "path", void 0), e([y()], m4.prototype, "lastDraggedVertex", void 0), e([y()], m4.prototype, "cursorPoint", void 0), e([y()], m4.prototype, "mode", void 0), e([y()], m4.prototype, "unit", null), e([y(e6)], m4.prototype, "_defaultUnit", void 0), m4 = e([a("esri.views.3d.analysis.AreaMeasurementAnalysisView3D")], m4);
var y3 = m4;
export {
  y3 as default
};
//# sourceMappingURL=AreaMeasurementAnalysisView3D-S7AUJ2VL.js.map
