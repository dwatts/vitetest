import {
  r as r2
} from "./chunk-7YCGPGGL.js";
import {
  u
} from "./chunk-H3DKDGMJ.js";
import {
  c
} from "./chunk-FB6EWBGE.js";
import {
  e
} from "./chunk-AER5JAFS.js";
import {
  E
} from "./chunk-FKEHFW5J.js";
import {
  F
} from "./chunk-BCDDCNQ2.js";
import {
  e as e2
} from "./chunk-D5NSNTGJ.js";
import {
  M,
  f,
  h,
  r
} from "./chunk-JB7FDW5N.js";
import {
  t
} from "./chunk-DWOEYHKS.js";
import {
  m
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/core.js
var t2 = class {
  constructor(t3) {
    this.xTile = 0, this.yTile = 0, this.hash = 0, this.priority = 1, this.colliders = [], this.textVertexRanges = [], this.iconVertexRanges = [], this.tile = t3;
  }
};
var s = class {
  constructor() {
    this.tileSymbols = [], this.parts = [{ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }, { startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }], this.show = false;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/util.js
function s2(t3, e3, s3, o3, l3, i2) {
  const r4 = s3 - l3;
  if (r4 >= 0)
    return (e3 >> r4) + (o3 - (i2 << r4)) * (t3 >> r4);
  const n = -r4;
  return e3 - (i2 - (o3 << n)) * (t3 >> n) << n;
}
var o = class {
  constructor(t3, e3, s3) {
    this._rows = Math.ceil(e3 / s3), this._columns = Math.ceil(t3 / s3), this._cellSize = s3, this.cells = new Array(this._rows);
    for (let o3 = 0; o3 < this._rows; o3++) {
      this.cells[o3] = new Array(this._columns);
      for (let t4 = 0; t4 < this._columns; t4++)
        this.cells[o3][t4] = [];
    }
  }
  getCell(t3, e3) {
    const s3 = Math.min(Math.max(Math.floor(e3 / this._cellSize), 0), this._rows - 1), o3 = Math.min(Math.max(Math.floor(t3 / this._cellSize), 0), this._columns - 1);
    return this.cells[s3] && this.cells[s3][o3] || null;
  }
  getCellSpan(t3, e3, s3, o3) {
    return [Math.min(Math.max(Math.floor(t3 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(e3 / this._cellSize), 0), this.rows - 1), Math.min(Math.max(Math.floor(s3 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(o3 / this._cellSize), 0), this.rows - 1)];
  }
  get cellSize() {
    return this._cellSize;
  }
  get columns() {
    return this._columns;
  }
  get rows() {
    return this._rows;
  }
};
function l(t3, s3, o3, l3, i2, r4) {
  const n = s3[l3++];
  for (let a = 0; a < n; a++) {
    const n2 = new t2(r4);
    n2.xTile = s3[l3++], n2.yTile = s3[l3++], n2.hash = s3[l3++], n2.priority = s3[l3++];
    const a2 = s3[l3++];
    for (let t4 = 0; t4 < a2; t4++) {
      const t5 = s3[l3++], e3 = s3[l3++], i3 = s3[l3++], r5 = s3[l3++], a3 = !!s3[l3++], c4 = s3[l3++], h4 = o3[l3++], f3 = o3[l3++], u3 = s3[l3++], m3 = s3[l3++];
      n2.colliders.push({ xTile: t5, yTile: e3, dxPixels: i3, dyPixels: r5, hard: a3, partIndex: c4, width: u3, height: m3, minLod: h4, maxLod: f3 });
    }
    const c3 = t3[l3++];
    for (let e3 = 0; e3 < c3; e3++)
      n2.textVertexRanges.push([t3[l3++], t3[l3++]]);
    const h3 = t3[l3++];
    for (let e3 = 0; e3 < h3; e3++)
      n2.iconVertexRanges.push([t3[l3++], t3[l3++]]);
    i2.push(n2);
  }
  return l3;
}
function i(t3, e3, s3) {
  for (const [o3, l3] of t3.symbols)
    r3(t3, e3, s3, l3, o3);
}
function r3(e3, s3, o3, l3, i2) {
  const r4 = e3.layerData.get(i2);
  if (r4.type === E.SYMBOL) {
    for (const t3 of l3) {
      const s4 = t3.unique;
      let l4;
      if (t3.selectedForRendering) {
        const t4 = s4.parts[0], i3 = t4.startOpacity, r5 = t4.targetOpacity;
        e3.allSymbolsFadingOut = e3.allSymbolsFadingOut && 0 === r5;
        const n = o3 ? Math.floor(127 * i3) | r5 << 7 : r5 ? 255 : 0;
        l4 = n << 24 | n << 16 | n << 8 | n;
      } else
        l4 = 0;
      for (const [e4, o4] of t3.iconVertexRanges)
        for (let t4 = e4; t4 < e4 + o4; t4 += 4)
          r4.iconOpacity[t4 / 4] = l4;
      if (t3.selectedForRendering) {
        const t4 = s4.parts[1], i3 = t4.startOpacity, r5 = t4.targetOpacity;
        e3.allSymbolsFadingOut = e3.allSymbolsFadingOut && 0 === r5;
        const n = o3 ? Math.floor(127 * i3) | r5 << 7 : r5 ? 255 : 0;
        l4 = n << 24 | n << 16 | n << 8 | n;
      } else
        l4 = 0;
      for (const [e4, o4] of t3.textVertexRanges)
        for (let t4 = e4; t4 < e4 + o4; t4 += 4)
          r4.textOpacity[t4 / 4] = l4;
    }
    r4.lastOpacityUpdate = s3, r4.opacityChanged = true;
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RenderBucket.js
var o2 = class {
  constructor(t3, e3) {
    this.layerUIDs = [], this.isDestroyed = false, this._data = t3;
    let r4 = 1;
    const n = new Uint32Array(t3);
    this.layerUIDs = [];
    const s3 = n[r4++];
    for (let i2 = 0; i2 < s3; i2++)
      this.layerUIDs[i2] = n[r4++];
    this.bufferDataOffset = r4, e3 && (this.layer = e3.getStyleLayerByUID(this.layerUIDs[0]));
  }
  get isPreparedForRendering() {
    return null == this._data;
  }
  get offset() {
    return this.bufferDataOffset;
  }
  get data() {
    return this._data;
  }
  destroy() {
    this.isDestroyed || (this.doDestroy(), this.isDestroyed = true);
  }
  prepareForRendering(t3) {
    null != this._data && (this.doPrepareForRendering(t3, this._data, this.bufferDataOffset), this._data = null);
  }
};
var h2 = class extends o2 {
  constructor(t3, e3) {
    super(t3, e3), this.type = E.LINE, this.lineIndexStart = 0, this.lineIndexCount = 0;
    const n = new Uint32Array(t3);
    let s3 = this.bufferDataOffset;
    this.lineIndexStart = n[s3++], this.lineIndexCount = n[s3++];
    const i2 = n[s3++];
    if (i2 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t4 = 0; t4 < i2; t4++) {
        const t5 = n[s3++], e4 = n[s3++], r4 = n[s3++];
        this.patternMap.set(t5, [e4, r4]);
      }
    }
    this.bufferDataOffset = s3;
  }
  get memoryUsed() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.memoryEstimate) ?? 0);
  }
  hasData() {
    return this.lineIndexCount > 0;
  }
  triangleCount() {
    return this.lineIndexCount / 3;
  }
  doDestroy() {
    this.vao = t(this.vao);
  }
  doPrepareForRendering(t3, e3, r4) {
    const n = new Uint32Array(e3), o3 = new Int32Array(n.buffer), h3 = n[r4++], f3 = c.createVertex(t3, F.STATIC_DRAW, new Int32Array(o3.buffer, 4 * r4, h3));
    r4 += h3;
    const c3 = n[r4++], l3 = c.createIndex(t3, F.STATIC_DRAW, new Uint32Array(n.buffer, 4 * r4, c3));
    r4 += c3;
    const y = this.layer.lineMaterial;
    this.vao = new u(t3, y.getAttributeLocations(), y.getLayoutInfo(), { geometry: f3 }, l3);
  }
};
var f2 = class extends o2 {
  constructor(t3, e3) {
    super(t3, e3), this.type = E.FILL, this.fillIndexStart = 0, this.fillIndexCount = 0, this.outlineIndexStart = 0, this.outlineIndexCount = 0;
    const n = new Uint32Array(t3);
    let s3 = this.bufferDataOffset;
    this.fillIndexStart = n[s3++], this.fillIndexCount = n[s3++], this.outlineIndexStart = n[s3++], this.outlineIndexCount = n[s3++];
    const i2 = n[s3++];
    if (i2 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t4 = 0; t4 < i2; t4++) {
        const t5 = n[s3++], e4 = n[s3++], r4 = n[s3++];
        this.patternMap.set(t5, [e4, r4]);
      }
    }
    this.bufferDataOffset = s3;
  }
  get memoryUsed() {
    var _a, _b, _c;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.fillVAO) == null ? void 0 : _b.memoryEstimate) ?? 0) + (((_c = this.outlineVAO) == null ? void 0 : _c.memoryEstimate) ?? 0);
  }
  hasData() {
    return this.fillIndexCount > 0 || this.outlineIndexCount > 0;
  }
  triangleCount() {
    return (this.fillIndexCount + this.outlineIndexCount) / 3;
  }
  doDestroy() {
    this.fillVAO = t(this.fillVAO), this.outlineVAO = t(this.outlineVAO);
  }
  doPrepareForRendering(t3, e3, r4) {
    const n = new Uint32Array(e3), o3 = new Int32Array(n.buffer), h3 = n[r4++], f3 = c.createVertex(t3, F.STATIC_DRAW, new Int32Array(o3.buffer, 4 * r4, h3));
    r4 += h3;
    const c3 = n[r4++], l3 = c.createIndex(t3, F.STATIC_DRAW, new Uint32Array(n.buffer, 4 * r4, c3));
    r4 += c3;
    const y = n[r4++], u3 = c.createVertex(t3, F.STATIC_DRAW, new Int32Array(o3.buffer, 4 * r4, y));
    r4 += y;
    const A = n[r4++], d2 = c.createIndex(t3, F.STATIC_DRAW, new Uint32Array(n.buffer, 4 * r4, A));
    r4 += A;
    const I = this.layer, g = I.fillMaterial, p = I.outlineMaterial;
    this.fillVAO = new u(t3, g.getAttributeLocations(), g.getLayoutInfo(), { geometry: f3 }, l3), this.outlineVAO = new u(t3, p.getAttributeLocations(), p.getLayoutInfo(), { geometry: u3 }, d2);
  }
};
var c2 = class extends o2 {
  constructor(t3, e3, s3) {
    super(t3, e3), this.type = E.SYMBOL, this.iconPerPageElementsMap = /* @__PURE__ */ new Map(), this.glyphPerPageElementsMap = /* @__PURE__ */ new Map(), this.symbolInstances = [], this.isIconSDF = false, this.opacityChanged = false, this.lastOpacityUpdate = 0, this.symbols = [];
    const i2 = new Uint32Array(t3), a = new Int32Array(t3), o3 = new Float32Array(t3);
    let h3 = this.bufferDataOffset;
    this.isIconSDF = !!i2[h3++];
    const f3 = i2[h3++];
    for (let r4 = 0; r4 < f3; r4++) {
      const t4 = i2[h3++], e4 = i2[h3++], r5 = i2[h3++];
      this.iconPerPageElementsMap.set(t4, [e4, r5]);
    }
    const c3 = i2[h3++];
    for (let r4 = 0; r4 < c3; r4++) {
      const t4 = i2[h3++], e4 = i2[h3++], r5 = i2[h3++];
      this.glyphPerPageElementsMap.set(t4, [e4, r5]);
    }
    const l3 = i2[h3++], y = i2[h3++];
    this.iconOpacity = new Int32Array(l3), this.textOpacity = new Int32Array(y), h3 = l(i2, a, o3, h3, this.symbols, s3), this.bufferDataOffset = h3;
  }
  get memoryUsed() {
    var _a, _b, _c2;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.iconVAO) == null ? void 0 : _b.memoryEstimate) ?? 0) + (((_c2 = this.textVAO) == null ? void 0 : _c2.memoryEstimate) ?? 0) + m(this.iconOpacity) + m(this.textOpacity);
  }
  hasData() {
    return this.iconPerPageElementsMap.size > 0 || this.glyphPerPageElementsMap.size > 0;
  }
  triangleCount() {
    let t3 = 0;
    for (const [e3, r4] of this.iconPerPageElementsMap)
      t3 += r4[1];
    for (const [e3, r4] of this.glyphPerPageElementsMap)
      t3 += r4[1];
    return t3 / 3;
  }
  doDestroy() {
    this.iconVAO = t(this.iconVAO), this.textVAO = t(this.textVAO);
  }
  updateOpacityInfo() {
    if (!this.opacityChanged)
      return;
    this.opacityChanged = false;
    const t3 = this.iconOpacity, e3 = this.iconVAO.vertexBuffers.opacity;
    t3.length > 0 && t3.byteLength === e3.byteLength && e3.setSubData(t3, 0, 0, t3.length);
    const r4 = this.textOpacity, n = this.textVAO.vertexBuffers.opacity;
    r4.length > 0 && r4.byteLength === n.byteLength && n.setSubData(r4, 0, 0, r4.length);
  }
  doPrepareForRendering(t3, e3, r4) {
    const n = new Uint32Array(e3), o3 = new Int32Array(n.buffer), h3 = n[r4++], f3 = c.createVertex(t3, F.STATIC_DRAW, new Int32Array(o3.buffer, 4 * r4, h3));
    r4 += h3;
    const c3 = n[r4++], l3 = c.createIndex(t3, F.STATIC_DRAW, new Uint32Array(n.buffer, 4 * r4, c3));
    r4 += c3;
    const y = n[r4++], u3 = c.createVertex(t3, F.STATIC_DRAW, new Int32Array(o3.buffer, 4 * r4, y));
    r4 += y;
    const A = n[r4++], d2 = c.createIndex(t3, F.STATIC_DRAW, new Uint32Array(n.buffer, 4 * r4, A));
    r4 += A;
    const I = c.createVertex(t3, F.STATIC_DRAW, this.iconOpacity.buffer), g = c.createVertex(t3, F.STATIC_DRAW, this.textOpacity.buffer), p = this.layer, m3 = p.iconMaterial, x = p.textMaterial;
    this.iconVAO = new u(t3, m3.getAttributeLocations(), m3.getLayoutInfo(), { geometry: f3, opacity: I }, l3), this.textVAO = new u(t3, x.getAttributeLocations(), x.getLayoutInfo(), { geometry: u3, opacity: g }, d2);
  }
};
var l2 = class extends o2 {
  constructor(t3, e3) {
    super(t3, e3), this.type = E.CIRCLE, this.circleIndexStart = 0, this.circleIndexCount = 0;
    const n = new Uint32Array(t3);
    let s3 = this.bufferDataOffset;
    this.circleIndexStart = n[s3++], this.circleIndexCount = n[s3++], this.bufferDataOffset = s3;
  }
  get memoryUsed() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.memoryEstimate) ?? 0);
  }
  hasData() {
    return this.circleIndexCount > 0;
  }
  triangleCount() {
    return this.circleIndexCount / 3;
  }
  doDestroy() {
    this.vao = t(this.vao);
  }
  doPrepareForRendering(t3, e3, r4) {
    const n = new Uint32Array(e3), o3 = new Int32Array(n.buffer), h3 = n[r4++], f3 = c.createVertex(t3, F.STATIC_DRAW, new Int32Array(o3.buffer, 4 * r4, h3));
    r4 += h3;
    const c3 = n[r4++], l3 = c.createIndex(t3, F.STATIC_DRAW, new Uint32Array(n.buffer, 4 * r4, c3));
    r4 += c3;
    const y = this.layer.circleMaterial;
    this.vao = new u(t3, y.getAttributeLocations(), y.getLayoutInfo(), { geometry: f3 }, l3);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTile.js
var d = class _d extends r2 {
  constructor(e3, t3, s3, a, r4, i2, o3, h3 = null) {
    super(e3, t3, s3, a, r4, i2, 4096, 4096), this.styleRepository = o3, this._memCache = h3, this.type = "vector-tile", this._referenced = 0, this._hasSymbolBuckets = false, this._memoryUsedByLayerData = 0, this.layerData = /* @__PURE__ */ new Map(), this.layerCount = 0, this.status = "loading", this.allSymbolsFadingOut = false, this.lastOpacityUpdate = 0, this.symbols = /* @__PURE__ */ new Map(), this.isCoverage = false, this.neededForCoverage = false, this.decluttered = false, this.invalidating = false, this.parentTile = null, this.childrenTiles = /* @__PURE__ */ new Set(), this._processed = false, this._referenced = 1, this.id = e3.id;
  }
  get hasSymbolBuckets() {
    return this._hasSymbolBuckets;
  }
  get isFading() {
    return this._hasSymbolBuckets && performance.now() - this.lastOpacityUpdate < e;
  }
  get isHoldingForFade() {
    return this._hasSymbolBuckets && (!this.allSymbolsFadingOut || performance.now() - this.lastOpacityUpdate < e);
  }
  get wasRequested() {
    return "errored" === this.status || "loaded" === this.status || "reloading" === this.status;
  }
  setData(e3) {
    this.changeDataImpl(e3), this.requestRender(), this.ready(), this.invalidating = false, this._processed = true;
  }
  deleteLayerData(e3) {
    var _a;
    let t3 = false;
    for (const s3 of e3)
      if (this.layerData.has(s3)) {
        const e4 = this.layerData.get(s3);
        this._memoryUsedByLayerData -= e4.memoryUsed, e4.type === E.SYMBOL && this.symbols.has(s3) && (this.symbols.delete(s3), t3 = true), e4.destroy(), this.layerData.delete(s3), this.layerCount--;
      }
    (_a = this._memCache) == null ? void 0 : _a.updateSize(this.key.id, this, this._memoryUsedByLayerData), t3 && this.emit("symbols-changed"), this.requestRender();
  }
  processed() {
    return this._processed;
  }
  hasData() {
    return this.layerCount > 0;
  }
  dispose() {
    "unloaded" !== this.status && (m2.delete(this), _d._destroyRenderBuckets(this.layerData), this.layerData = null, this.layerCount = 0, this._memoryUsedByLayerData = 0, this.destroy(), this.status = "unloaded");
  }
  release() {
    return 0 == --this._referenced && (this.dispose(), this.stage = null, true);
  }
  retain() {
    ++this._referenced;
  }
  get referenced() {
    return this._referenced;
  }
  get memoryUsed() {
    return this._memoryUsedByLayerData + 256;
  }
  changeDataImpl(e3) {
    var _a;
    let t3 = false;
    if (e3) {
      const { bucketsWithData: s3, emptyBuckets: a } = e3, r4 = this._createRenderBuckets(s3);
      if (a && a.byteLength > 0) {
        const e4 = new Uint32Array(a);
        for (const t4 of e4)
          this._deleteLayerData(t4);
      }
      for (const [e4, o3] of r4)
        this._deleteLayerData(e4), o3.type === E.SYMBOL && (this.symbols.set(e4, o3.symbols), t3 = true), this._memoryUsedByLayerData += o3.memoryUsed, this.layerData.set(e4, o3), this.layerCount++;
      (_a = this._memCache) == null ? void 0 : _a.updateSize(this.key.id, this, this.memoryUsed);
    }
    this._hasSymbolBuckets = false;
    for (const [s3, a] of this.layerData)
      a.type === E.SYMBOL && (this._hasSymbolBuckets = true);
    t3 && this.emit("symbols-changed");
  }
  attachWithContext(e3) {
    this.stage = { context: e3, trashDisplayObject(e4) {
      e4.processDetach();
    }, untrashDisplayObject: () => false };
  }
  setTransform(r4) {
    super.setTransform(r4);
    const i2 = this.resolution / (r4.resolution * r4.pixelRatio), o3 = this.width / this.rangeX * i2, h3 = this.height / this.rangeY * i2, n = [0, 0];
    r4.toScreen(n, [this.x, this.y]);
    const l3 = this.transforms.tileUnitsToPixels;
    r(l3), M(l3, l3, n), h(l3, l3, Math.PI * r4.rotation / 180), f(l3, l3, [o3, h3, 1]);
  }
  _createTransforms() {
    return { dvs: e2(), tileMat3: e2(), tileUnitsToPixels: e2() };
  }
  static _destroyRenderBuckets(e3) {
    if (!e3)
      return;
    const t3 = /* @__PURE__ */ new Set();
    e3.forEach((e4) => {
      t3.has(e4) || (e4.destroy(), t3.add(e4));
    }), e3.clear();
  }
  _createRenderBuckets(e3) {
    const t3 = /* @__PURE__ */ new Map(), s3 = /* @__PURE__ */ new Map();
    for (const a of e3) {
      const e4 = this._deserializeBucket(a, s3);
      for (const s4 of e4.layerUIDs)
        t3.set(s4, e4);
    }
    return t3;
  }
  _deserializeBucket(e3, t3) {
    let s3 = t3.get(e3);
    if (s3)
      return s3;
    switch (new Uint32Array(e3)[0]) {
      case E.FILL:
        s3 = new f2(e3, this.styleRepository);
        break;
      case E.LINE:
        s3 = new h2(e3, this.styleRepository);
        break;
      case E.SYMBOL:
        s3 = new c2(e3, this.styleRepository, this);
        break;
      case E.CIRCLE:
        s3 = new l2(e3, this.styleRepository);
    }
    return t3.set(e3, s3), s3;
  }
  _deleteLayerData(e3) {
    if (!this.layerData.has(e3))
      return;
    const t3 = this.layerData.get(e3);
    this._memoryUsedByLayerData -= t3.memoryUsed, t3.destroy(), this.layerData.delete(e3), this.layerCount--;
  }
};
var m2 = /* @__PURE__ */ new Map();
function u2() {
  m2.forEach((e3, t3) => {
    console.log(`
${t3.key}:`), e3[0].forEach((e4) => console.log(e4)), console.log("========"), e3[1].forEach((e4) => console.log(e4));
  });
}

export {
  s,
  s2,
  o,
  i,
  d,
  u2 as u
};
//# sourceMappingURL=chunk-3VN6RF6P.js.map
