import {
  u
} from "./chunk-JKNFSP7C.js";
import {
  r as r2,
  t as t2
} from "./chunk-KFDARCTS.js";
import {
  n as n2
} from "./chunk-GYNE34WO.js";
import {
  e as e2
} from "./chunk-QS45OHBM.js";
import {
  a as a2
} from "./chunk-IVMJPIWO.js";
import {
  a
} from "./chunk-3I3GE5YW.js";
import {
  o as o2
} from "./chunk-UUW6REOV.js";
import {
  o as o3
} from "./chunk-2US5EKDI.js";
import {
  s
} from "./chunk-Z3NHJA5D.js";
import {
  i2 as i
} from "./chunk-BO2REVMA.js";
import {
  n,
  o
} from "./chunk-V66LHQVK.js";
import {
  r,
  t
} from "./chunk-YGUWDSEH.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/ShadowCastVisualizeTechniqueConfiguration.js
var t3;
!function(o4) {
  o4[o4.Gradient = 0] = "Gradient", o4[o4.Threshold = 1] = "Threshold", o4[o4.COUNT = 2] = "COUNT";
}(t3 || (t3 = {}));
var r3 = class extends t2 {
  constructor() {
    super(...arguments), this.visualization = t3.Gradient, this.bandsEnabled = false;
  }
};
e([r2({ count: t3.COUNT })], r3.prototype, "visualization", void 0), e([r2()], r3.prototype, "bandsEnabled", void 0);

// node_modules/@arcgis/core/chunks/ShadowCastVisualize.glsl.js
var p = class extends n {
  constructor(s2) {
    super(), this._data = s2, this.sampleScale = 0, this.opacityFromElevation = 1, this.color = t(g), this.bandSize = 0.1, this.threshold = 0.5;
  }
  get shadowCastMap() {
    return this._data.shadowCastTexture;
  }
};
var g = r(0.01, 0, 0.25, 1);
function w(e3) {
  const s2 = new i(), n3 = s2.fragment;
  n3.include(a), n3.include(a2), s2.include(n2), s2.include(o3);
  const { visualization: p2, bandsEnabled: g2 } = e3;
  n3.constants.add("inverseSampleValue", "float", u), n3.uniforms.add(new s("shadowCastMap", (e4) => e4.shadowCastMap), new o2("sampleScale", (e4) => e4.sampleScale), new o2("opacityFromElevation", (e4) => e4.opacityFromElevation), new e2("uColor", (e4) => e4.color));
  const w2 = p2 === t3.Gradient, f2 = p2 === t3.Threshold;
  return w2 && g2 ? n3.uniforms.add(new o2("bandSize", (e4) => e4.bandSize)) : f2 && n3.uniforms.add(new o2("threshold", (e4) => e4.threshold)), n3.code.add(o`
      void main(void) {
        vec4 record = texture(shadowCastMap, uv);
        float pixelSamples = record.r * inverseSampleValue;
        if (pixelSamples < 1.0) {
          discard;
        }

        float strength = pixelSamples * sampleScale;

        ${f2 ? o`
            if (strength <= threshold) {
              discard;
            }` : ""}

        ${w2 && g2 ? o`strength = ceil(strength / bandSize) * bandSize;` : ""}

        fragColor = vec4(uColor.xyz, uColor.a * opacityFromElevation ${w2 ? o`* strength` : ""});
      }
    `), s2;
}
var f = Object.freeze(Object.defineProperty({ __proto__: null, ShadowCastVisualizePassParameters: p, build: w }, Symbol.toStringTag, { value: "Module" }));

export {
  t3 as t,
  r3 as r,
  p,
  w,
  f
};
//# sourceMappingURL=chunk-42GKKMUF.js.map
