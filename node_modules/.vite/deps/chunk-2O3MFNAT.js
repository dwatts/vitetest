import {
  o as o3
} from "./chunk-CG3URTR2.js";
import {
  n as n2
} from "./chunk-IBJTEQQG.js";
import {
  o as o2
} from "./chunk-SADO52IH.js";
import {
  e as e3
} from "./chunk-WVOBJDWI.js";
import {
  h
} from "./chunk-73PNWDTS.js";
import {
  t
} from "./chunk-PKS3ZVLN.js";
import {
  P
} from "./chunk-N3RXOITN.js";
import {
  f,
  p,
  u
} from "./chunk-DOR4M5EA.js";
import {
  e
} from "./chunk-YVVROPAO.js";
import {
  e as e2
} from "./chunk-QS45OHBM.js";
import {
  o as o4
} from "./chunk-UUW6REOV.js";
import {
  i2 as i
} from "./chunk-BO2REVMA.js";
import {
  o
} from "./chunk-V66LHQVK.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  n
} from "./chunk-YGUWDSEH.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ScreenSizeScaling.glsl.js
function o5(o6, c) {
  if (!c.screenSizeEnabled)
    return;
  const n3 = o6.vertex;
  f(n3, c), n3.uniforms.add(new o4("perScreenPixelRatio", (e4, i2) => i2.camera.perScreenPixelRatio), new o4("screenSizeScale", (e4) => e4.screenSizeScale)), n3.code.add(o`float computeRenderPixelSizeAt( vec3 pWorld ){
vec3 viewForward = - vec3(view[0][2], view[1][2], view[2][2]);
float viewDirectionDistance = abs(dot(viewForward, pWorld - cameraPosition));
return viewDirectionDistance * perScreenPixelRatio;
}
vec3 screenSizeScaling(vec3 position, vec3 anchor){
return position * screenSizeScale * computeRenderPixelSizeAt(anchor) + anchor;
}`);
}

// node_modules/@arcgis/core/chunks/ShadedColorMaterial.glsl.js
function p2(e4) {
  const p3 = new i(), b2 = e4.hasMultipassTerrain && (e4.output === h.Color || e4.output === h.Alpha);
  p3.include(o3, e4), p3.include(o5, e4), p3.include(P, e4);
  const { vertex: h3, fragment: C } = p3;
  return C.include(e3), p(h3, e4), C.uniforms.add(new e2("uColor", (e5) => e5.color)), p3.attributes.add(O.POSITION, "vec3"), p3.varyings.add("vWorldPosition", "vec3"), b2 && p3.varyings.add("depth", "float"), e4.screenSizeEnabled && p3.attributes.add(O.OFFSET, "vec3"), e4.shadingEnabled && (u(h3), p3.attributes.add(O.NORMAL, "vec3"), p3.varyings.add("vViewNormal", "vec3")), h3.code.add(o`
    void main(void) {
      vWorldPosition = ${e4.screenSizeEnabled ? "screenSizeScaling(offset, position)" : "position"};
  `), e4.shadingEnabled && h3.code.add(o`vec3 worldNormal = normal;
vViewNormal = (viewNormal * vec4(worldNormal, 1)).xyz;`), h3.code.add(o`
    ${b2 ? "depth = (view * vec4(vWorldPosition, 1.0)).z;" : ""}
    gl_Position = transformPosition(proj, view, vWorldPosition);
  }
  `), b2 && p3.include(n2, e4), C.code.add(o`
    void main() {
      discardBySlice(vWorldPosition);
      ${b2 ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
    `), e4.shadingEnabled ? (C.uniforms.add(new e("shadingDirection", (e5) => e5.shadingDirection)), C.uniforms.add(new e2("shadedColor", (e5) => w(e5.shadingTint, e5.color))), C.code.add(o`vec3 viewNormalNorm = normalize(vViewNormal);
float shadingFactor = 1.0 - clamp(-dot(viewNormalNorm, shadingDirection), 0.0, 1.0);
vec4 finalColor = mix(uColor, shadedColor, shadingFactor);`)) : C.code.add(o`vec4 finalColor = uColor;`), C.code.add(o`
      ${e4.output === h.ObjectAndLayerIdColor ? o`finalColor.a = 1.0;` : ""}
      if (finalColor.a < ${o.float(t)}) {
        discard;
      }
      ${e4.output === h.Alpha ? o`fragColor = vec4(finalColor.a);` : ""}

      ${e4.output === h.Color ? o`fragColor = highlightSlice(finalColor, vWorldPosition); ${e4.transparencyPassType === o2.Color ? "fragColor = premultiplyAlpha(fragColor);" : ""}` : ""}
    }
    `), p3;
}
function w(e4, o6) {
  const r = 1 - e4[3], i2 = e4[3] + o6[3] * r;
  return 0 === i2 ? (b[3] = i2, b) : (b[0] = (e4[0] * e4[3] + o6[0] * o6[3] * r) / i2, b[1] = (e4[1] * e4[3] + o6[1] * o6[3] * r) / i2, b[2] = (e4[2] * e4[3] + o6[2] * o6[3] * r) / i2, b[3] = o6[3], b);
}
var b = n();
var h2 = Object.freeze(Object.defineProperty({ __proto__: null, build: p2 }, Symbol.toStringTag, { value: "Module" }));

export {
  p2 as p,
  h2 as h
};
//# sourceMappingURL=chunk-2O3MFNAT.js.map
