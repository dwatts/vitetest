import {
  a as a5,
  h as h3,
  i,
  m as m4,
  o as o3
} from "./chunk-EQRBSFVE.js";
import {
  D,
  I,
  N,
  O as O2,
  o as o2,
  q,
  r as r3
} from "./chunk-NJB7437O.js";
import {
  m as m3,
  p as p3
} from "./chunk-RZONPIMD.js";
import {
  m as m2
} from "./chunk-FAU6BZC4.js";
import {
  l as l4
} from "./chunk-4Y7ZTMES.js";
import {
  g as g4,
  p as p4
} from "./chunk-ODTMOFOP.js";
import {
  g as g3,
  h,
  l as l3,
  w,
  x as x2
} from "./chunk-JPKFB2QL.js";
import {
  E,
  R,
  _ as _2,
  h as h2,
  j as j2,
  v
} from "./chunk-KSBQD24F.js";
import {
  c as c2
} from "./chunk-NETCTS4Y.js";
import {
  e as e4
} from "./chunk-CW7LIPBH.js";
import {
  e as e3
} from "./chunk-VN2IXVGV.js";
import {
  d
} from "./chunk-CEFGWR5H.js";
import {
  a as a4
} from "./chunk-JB7FDW5N.js";
import {
  a as a3
} from "./chunk-VMTVUE47.js";
import {
  h as h4
} from "./chunk-XWGNMTES.js";
import {
  In,
  zn
} from "./chunk-BNBT4QTW.js";
import {
  g as g2
} from "./chunk-7EG7BYWF.js";
import {
  l
} from "./chunk-TFIKV5RU.js";
import {
  e as e5
} from "./chunk-XR4HIGQP.js";
import {
  V
} from "./chunk-7EQSYZHW.js";
import {
  j
} from "./chunk-4OR73Y2R.js";
import {
  O,
  S,
  e as e2,
  g,
  o,
  u,
  z
} from "./chunk-TPJLFGOT.js";
import {
  f,
  n,
  r as r2
} from "./chunk-CQX57DED.js";
import {
  _
} from "./chunk-7L7Z2HXM.js";
import {
  M
} from "./chunk-3VUFACNT.js";
import {
  f as f2,
  p as p2,
  x2 as x
} from "./chunk-ZEEBL7ZN.js";
import {
  l as l2
} from "./chunk-H7RDAEPY.js";
import {
  m
} from "./chunk-JL3TJGVW.js";
import {
  G,
  Ut
} from "./chunk-ZJEWQGHG.js";
import {
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  r
} from "./chunk-3R7FAT25.js";
import {
  P,
  a,
  c,
  p,
  s as s3
} from "./chunk-7I33FAWS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/bounds.js
function e6({ xmin: t, xmax: e7, ymin: i3, ymax: o4, zmin: r4, zmax: x6 }, l7, c5, s4) {
  r4 ?? (r4 = 0), x6 ?? (x6 = 0), a6 ?? (a6 = new Float64Array(24));
  const f6 = a6;
  return f6[0] = t, f6[1] = i3, f6[2] = r4, f6[3] = t, f6[4] = o4, f6[5] = r4, f6[6] = e7, f6[7] = o4, f6[8] = r4, f6[9] = e7, f6[10] = i3, f6[11] = r4, f6[12] = t, f6[13] = i3, f6[14] = x6, f6[15] = t, f6[16] = o4, f6[17] = x6, f6[18] = e7, f6[19] = o4, f6[20] = x6, f6[21] = e7, f6[22] = i3, f6[23] = x6, I({ positions: f6, transform: l7, vertexSpace: c5, inSpatialReference: s4, outSpatialReference: s4, outPositions: f6, local: false }), m5(f6, s4);
}
var a6 = null;
function m5(n2, e7) {
  let a7 = 1 / 0, m9 = 1 / 0, i3 = 1 / 0, o4 = -1 / 0, r4 = -1 / 0, x6 = -1 / 0;
  const l7 = n2.length;
  let c5 = 0;
  for (; c5 < l7; ) {
    const t = n2[c5++], e8 = n2[c5++], l8 = n2[c5++];
    a7 = Math.min(a7, t), m9 = Math.min(m9, e8), i3 = Math.min(i3, l8), o4 = Math.max(o4, t), r4 = Math.max(r4, e8), x6 = Math.max(x6, l8);
  }
  return new M({ xmin: a7, ymin: m9, zmin: i3, xmax: o4, ymax: r4, zmax: x6, spatialReference: e7 });
}

// node_modules/@arcgis/core/geometry/support/meshUtils/centerAt.js
var l5 = "esri.geometry.support.meshUtils.centerAt";
function p5(e7, t, i3) {
  if (!e7.vertexAttributes || !e7.vertexAttributes.position)
    return;
  const { vertexSpace: r4 } = e7, o4 = (i3 == null ? void 0 : i3.origin) ?? e7.origin;
  if (r4.isRelative)
    o2(r4, l5, i3), f3(e7, t, o4);
  else {
    r3(e7.spatialReference, i3) ? g5(e7, t, o4) : d2(e7, t, o4);
  }
}
function f3(n2, s4, a7) {
  const { vertexSpace: c5 } = n2;
  if (!c5.isRelative)
    return;
  const p9 = j3, f6 = u2;
  if (!In(s4, f6, n2.spatialReference))
    return void s.getLogger(l5).error(`Failed to project centerAt location (wkid:${s4.spatialReference.wkid}) to mesh spatial reference (wkid:${n2.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  if (!In(a7, p9, n2.spatialReference)) {
    const t = n2.origin;
    p9[0] = t.x, p9[1] = t.y, p9[2] = t.z, s.getLogger(l5).error(`Failed to project specified origin (wkid:${a7.spatialReference.wkid}) to mesh spatial reference (wkid:${n2.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  }
  const g8 = e2(b, f6, p9), d8 = c5.origin;
  c5.origin = u(n(), d8, g8);
}
function g5(e7, t, i3) {
  const r4 = D(e7.vertexAttributes, i3, { geographic: true }), { position: o4, normal: n2, tangent: s4 } = O2(r4, t, { geographic: true });
  e7.vertexAttributes.position = o4, e7.vertexAttributes.normal = n2, e7.vertexAttributes.tangent = s4, e7.vertexAttributesChanged();
}
function d2(t, i3, r4) {
  const n2 = j3, s4 = u2;
  if (In(i3, s4, t.spatialReference)) {
    if (!In(r4, n2, t.spatialReference)) {
      const i4 = t.origin;
      n2[0] = i4.x, n2[1] = i4.y, n2[2] = i4.z, s.getLogger(l5).error(`Failed to project specified origin (wkid:${r4.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
    }
    m6(t.vertexAttributes.position, s4, n2), t.vertexAttributesChanged();
  } else
    s.getLogger(l5).error(`Failed to project centerAt location (wkid:${i3.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
}
function m6(e7, t, i3) {
  if (e7)
    for (let r4 = 0; r4 < e7.length; r4 += 3)
      for (let o4 = 0; o4 < 3; o4++)
        e7[r4 + o4] += t[o4] - i3[o4];
}
var u2 = n();
var j3 = n();
var b = n();

// node_modules/@arcgis/core/geometry/support/meshUtils/loadExternal.js
async function c3(e7, r4, n2) {
  const { source: o4 } = r4, { loadGLTFMesh: i3 } = await p(import("./loadGLTFMesh-HTG3GH73.js"), n2), a7 = await f4(o4, n2);
  s3(n2);
  const c5 = i3(new x({ x: 0, y: 0, z: 0, spatialReference: e7.spatialReference }), a7.url, { resolveFile: u3(a7), useTransform: true, signal: n2 == null ? void 0 : n2.signal });
  c5.then(() => a7.dispose(), () => a7.dispose());
  const { vertexAttributes: m9, components: p9 } = await c5;
  e7.vertexAttributes = m9, e7.components = p9;
}
function u3(e7) {
  const t = Ut(e7.url);
  return (s4) => {
    const r4 = G(s4, t, t), n2 = r4 ? r4.replace(/^ *\.\//, "") : null;
    return (n2 ? e7.files.get(n2) : null) ?? s4;
  };
}
async function f4(t, s4) {
  if (Array.isArray(t)) {
    if (!t.length)
      throw new s2("mesh-load-external:missing-assets", "There must be at least one file to load");
    return t[0] instanceof File ? h5(t) : w2(t, s4);
  }
  return p6(t);
}
async function m7(e7, t) {
  const { parts: r4 } = e7;
  if (1 === r4.length)
    return new b2(r4[0].partUrl);
  const n2 = await e7.toBlob(t);
  return s3(t), b2.fromBlob(n2);
}
function p6(e7) {
  return b2.fromBlob(e7);
}
function h5(e7) {
  return g6(e7.map((e8) => ({ name: e8.name, mimeType: e8.type, source: p6(e8) })));
}
async function w2(e7, t) {
  const i3 = await P(e7.map(async (e8) => {
    const r4 = await m7(e8);
    return s3(t), { name: e8.assetName, mimeType: e8.assetMimeType, source: r4 };
  }));
  if (a(t))
    throw i3.forEach((e8) => e8.source.dispose()), c();
  return g6(i3);
}
var y2 = /^(model\/gltf\+json)|(model\/gltf-binary)$/;
var d3 = /\.(gltf|glb)/i;
function g6(t) {
  const s4 = /* @__PURE__ */ new Map();
  let r4 = null;
  for (const { name: e7, mimeType: n2, source: o4 } of t)
    (null == r4 || y2.test(n2) || d3.test(e7)) && (r4 = o4.url), s4.set(e7, o4.url), o4.files.forEach((e8, t2) => s4.set(t2, e8));
  if (null == r4)
    throw new s2("mesh-load-external:missing-files", "Missing files to load external mesh source");
  return new b2(r4, () => t.forEach(({ source: e7 }) => e7.dispose()), s4);
}
var b2 = class _b {
  constructor(e7, t = () => {
  }, s4 = /* @__PURE__ */ new Map()) {
    this.url = e7, this.dispose = t, this.files = s4;
  }
  static fromBlob(e7) {
    const t = URL.createObjectURL(e7);
    return new _b(t, () => URL.revokeObjectURL(t));
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/Metadata.js
var p7 = class extends l {
  constructor() {
    super(), this.externalSources = new V(), this._explicitDisplaySource = null;
  }
  get displaySource() {
    return this._explicitDisplaySource ?? this._implicitDisplaySource;
  }
  set displaySource(r4) {
    if (null != r4 && !o3(r4))
      throw new Error("Cannot use this source for display: it is not in a supported format.");
    this._explicitDisplaySource = r4, r4 && this.externalSources.every((e7) => !h3(e7, r4)) && this.externalSources.add(r4);
  }
  clearSources() {
    this.displaySource = null, this.externalSources.removeAll();
  }
  getExternalSourcesOnService(r4) {
    return this.externalSources.items.filter((e7) => m4(e7, r4));
  }
  get _implicitDisplaySource() {
    return this.externalSources.find(o3);
  }
};
e([y()], p7.prototype, "externalSources", void 0), e([y()], p7.prototype, "displaySource", null), e([y()], p7.prototype, "_implicitDisplaySource", null), e([y()], p7.prototype, "_explicitDisplaySource", void 0), p7 = e([a2("esri.geometry.support.meshUtils.Metadata")], p7);

// node_modules/@arcgis/core/geometry/support/meshUtils/offset.js
var v2 = "esri.geometry.support.meshUtils.offset";
function x3(t, e7, r4) {
  if (!t.vertexAttributes || !t.vertexAttributes.position)
    return;
  const { vertexSpace: n2 } = t;
  if (n2.isRelative)
    o2(n2, v2, r4), j4(n2, e7);
  else {
    r3(t.spatialReference, r4) ? A(t, e7) : b3(t, e7);
  }
}
function j4(t, e7) {
  const r4 = t.origin;
  t.origin = u(n(), r4, e7);
}
function A(e7, r4) {
  const n2 = e7.spatialReference, i3 = e7.vertexAttributes.position, u5 = e7.vertexAttributes.normal, a7 = e7.vertexAttributes.tangent, v4 = new Float64Array(i3.length), x6 = null != u5 ? new Float32Array(u5.length) : null, j6 = null != a7 ? new Float32Array(a7.length) : null, A4 = e7.extent.center, b5 = y3;
  zn(n2, [A4.x, A4.y, A4.z], R2, c2(n2)), a4(d4, R2), S(b5, r4, d4), h2(i3, n2, v4), null != u5 && null != x6 && _2(u5, i3, v4, n2, x6), null != a7 && null != j6 && R(a7, i3, v4, n2, j6), k(v4, b5), E(v4, i3, n2), null != u5 && null != x6 && j2(x6, i3, v4, n2, u5), null != a7 && null != j6 && v(j6, i3, v4, n2, a7), e7.vertexAttributesChanged();
}
function b3(t, e7) {
  k(t.vertexAttributes.position, e7), t.vertexAttributesChanged();
}
function k(t, e7) {
  if (t)
    for (let r4 = 0; r4 < t.length; r4 += 3)
      for (let n2 = 0; n2 < 3; n2++)
        t[r4 + n2] += e7[n2];
}
var y3 = n();
var R2 = e4();
var d4 = e3();

// node_modules/@arcgis/core/geometry/support/meshUtils/primitives.js
function i2() {
  const { faceDescriptions: t, faceVertexOffsets: e7, uvScales: n2 } = y4, r4 = 4 * t.length, o4 = new Float64Array(3 * r4), s4 = new Float32Array(3 * r4), a7 = new Float32Array(2 * r4), i3 = new Uint32Array(2 * t.length * 3);
  let l7 = 0, c5 = 0, f6 = 0, u5 = 0;
  for (let h8 = 0; h8 < t.length; h8++) {
    const r5 = t[h8], p9 = l7 / 3;
    for (const t2 of e7)
      i3[u5++] = p9 + t2;
    const w6 = r5.corners;
    for (let t2 = 0; t2 < 4; t2++) {
      const e8 = w6[t2];
      let i4 = 0;
      a7[f6++] = 0.25 * n2[t2][0] + r5.uvOrigin[0], a7[f6++] = r5.uvOrigin[1] - 0.25 * n2[t2][1];
      for (let t3 = 0; t3 < 3; t3++)
        0 !== r5.axis[t3] ? (o4[l7++] = 0.5 * r5.axis[t3], s4[c5++] = r5.axis[t3]) : (o4[l7++] = 0.5 * e8[i4++], s4[c5++] = 0);
    }
  }
  return { position: o4, normal: s4, uv: a7, faces: i3 };
}
function l6(t, e7) {
  const n2 = t.components[0], r4 = n2.faces, s4 = d5[e7], a7 = 6 * s4, i3 = new Array(6), l7 = new Array(r4.length - 6);
  let c5 = 0, f6 = 0;
  for (let o4 = 0; o4 < r4.length; o4++)
    o4 >= a7 && o4 < a7 + 6 ? i3[c5++] = r4[o4] : l7[f6++] = r4[o4];
  if (null != t.vertexAttributes.uv) {
    const e8 = new Float32Array(t.vertexAttributes.uv), n3 = 4 * s4 * 2, r5 = [0, 1, 1, 1, 1, 0, 0, 0];
    for (let t2 = 0; t2 < r5.length; t2++)
      e8[n3 + t2] = r5[t2];
    t.vertexAttributes.uv = e8;
  }
  return t.components = [new g4({ faces: i3, material: n2.material }), new g4({ faces: l7 })], t;
}
function c4(t = 0) {
  const e7 = Math.round(8 * 2 ** t), n2 = 2 * e7, r4 = (e7 - 1) * (n2 + 1) + 2 * n2, o4 = new Float64Array(3 * r4), s4 = new Float32Array(3 * r4), a7 = new Float32Array(2 * r4), i3 = new Uint32Array(3 * ((e7 - 1) * n2 * 2));
  let l7 = 0, c5 = 0, f6 = 0, u5 = 0;
  for (let h8 = 0; h8 <= e7; h8++) {
    const t2 = h8 / e7 * Math.PI + 0.5 * Math.PI, r5 = Math.cos(t2), p9 = Math.sin(t2);
    M2[2] = p9;
    const w6 = 0 === h8 || h8 === e7, m9 = w6 ? n2 - 1 : n2;
    for (let v4 = 0; v4 <= m9; v4++) {
      const t3 = v4 / m9 * 2 * Math.PI;
      M2[0] = -Math.sin(t3) * r5, M2[1] = Math.cos(t3) * r5;
      for (let e8 = 0; e8 < 3; e8++)
        o4[l7] = 0.5 * M2[e8], s4[l7] = M2[e8], ++l7;
      a7[c5++] = (v4 + (w6 ? 0.5 : 0)) / n2, a7[c5++] = h8 / e7, 0 !== h8 && v4 !== n2 && (h8 !== e7 && (i3[f6++] = u5, i3[f6++] = u5 + 1, i3[f6++] = u5 - n2), 1 !== h8 && (i3[f6++] = u5, i3[f6++] = u5 - n2, i3[f6++] = u5 - n2 - 1)), u5++;
    }
  }
  return { position: o4, normal: s4, uv: a7, faces: i3 };
}
function f5(t = 0) {
  const e7 = 5, n2 = Math.round(16 * 2 ** t), r4 = (e7 - 1) * (n2 + 1) + 2 * n2, o4 = new Float64Array(3 * r4), s4 = new Float32Array(3 * r4), a7 = new Float32Array(2 * r4), i3 = new Uint32Array(3 * (4 * n2));
  let l7 = 0, c5 = 0, f6 = 0, u5 = 0, h8 = 0;
  for (let p9 = 0; p9 <= e7; p9++) {
    const t2 = 0 === p9 || p9 === e7, r5 = p9 <= 1 || p9 >= e7 - 1, w6 = 2 === p9 || 4 === p9, m9 = t2 ? n2 - 1 : n2;
    for (let v4 = 0; v4 <= m9; v4++) {
      const g8 = v4 / m9 * 2 * Math.PI, A4 = t2 ? 0 : 0.5;
      M2[0] = A4 * Math.sin(g8), M2[1] = A4 * -Math.cos(g8), M2[2] = p9 <= 2 ? 0.5 : -0.5;
      for (let t3 = 0; t3 < 3; t3++)
        o4[l7++] = M2[t3], s4[c5++] = r5 ? 2 === t3 ? p9 <= 1 ? 1 : -1 : 0 : 2 === t3 ? 0 : M2[t3] / A4;
      a7[f6++] = (v4 + (t2 ? 0.5 : 0)) / n2, a7[f6++] = p9 <= 1 ? 1 * p9 / 3 : p9 <= 3 ? 1 * (p9 - 2) / 3 + 1 / 3 : 1 * (p9 - 4) / 3 + 2 / 3, w6 || 0 === p9 || v4 === n2 || (p9 !== e7 && (i3[u5++] = h8, i3[u5++] = h8 + 1, i3[u5++] = h8 - n2), 1 !== p9 && (i3[u5++] = h8, i3[u5++] = h8 - n2, i3[u5++] = h8 - n2 - 1)), h8++;
    }
  }
  return { position: o4, normal: s4, uv: a7, faces: i3 };
}
function u4(t, e7) {
  const n2 = "number" == typeof e7 ? e7 : null != e7 ? e7.width : 1, r4 = "number" == typeof e7 ? e7 : null != e7 ? e7.height : 1;
  switch (t) {
    case "up":
    case "down":
      return { width: n2, depth: r4 };
    case "north":
    case "south":
      return { width: n2, height: r4 };
    case "east":
    case "west":
      return { depth: n2, height: r4 };
  }
}
function h6(t) {
  const e7 = v3.facingAxisOrderSwap[t], n2 = v3.position, r4 = v3.normal, o4 = new Float64Array(n2.length), s4 = new Float32Array(r4.length);
  let a7 = 0;
  for (let i3 = 0; i3 < 4; i3++) {
    const t2 = a7;
    for (let i4 = 0; i4 < 3; i4++) {
      const l7 = e7[i4], c5 = Math.abs(l7) - 1, f6 = l7 >= 0 ? 1 : -1;
      o4[a7] = n2[t2 + c5] * f6, s4[a7] = r4[t2 + c5] * f6, a7++;
    }
  }
  return { position: o4, normal: s4, uv: new Float32Array(v3.uv), faces: new Uint32Array(v3.faces), isPlane: true };
}
var p8 = 1;
var w3 = 2;
var m8 = 3;
var v3 = { position: [-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0], normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], uv: [0, 1, 1, 1, 1, 0, 0, 0], faces: [0, 1, 2, 0, 2, 3], facingAxisOrderSwap: { east: [m8, p8, w3], west: [-m8, -p8, w3], north: [-p8, m8, w3], south: [p8, -m8, w3], up: [p8, w3, m8], down: [p8, -w3, -m8] } };
function g7(t, e7, n2) {
  t.isPlane || A2(t), x4(t, n2 == null ? void 0 : n2.size);
  const { vertexAttributes: r4, vertexSpace: i3, transform: l7 } = q(t, e7, n2);
  return { vertexAttributes: new p4({ ...r4, uv: t.uv }), vertexSpace: i3, transform: l7, components: [new g4({ faces: t.faces, material: n2 && n2.material || null })], spatialReference: e7.spatialReference };
}
function A2(t) {
  for (let e7 = 0; e7 < t.position.length; e7 += 3)
    t.position[e7 + 2] += 0.5;
}
function x4(t, r4) {
  if (null == r4)
    return;
  const o4 = "number" == typeof r4 ? [r4, r4, r4] : [null != r4.width ? r4.width : 1, null != r4.depth ? r4.depth : 1, null != r4.height ? r4.height : 1];
  F[0] = o4[0], F[4] = o4[1], F[8] = o4[2];
  for (let n2 = 0; n2 < t.position.length; n2 += 3) {
    for (let e7 = 0; e7 < 3; e7++)
      M2[e7] = t.position[n2 + e7];
    S(M2, M2, F);
    for (let e7 = 0; e7 < 3; e7++)
      t.position[n2 + e7] = M2[e7];
  }
  if (o4[0] !== o4[1] || o4[1] !== o4[2]) {
    F[0] = 1 / o4[0], F[4] = 1 / o4[1], F[8] = 1 / o4[2];
    for (let r5 = 0; r5 < t.normal.length; r5 += 3) {
      for (let e7 = 0; e7 < 3; e7++)
        M2[e7] = t.normal[r5 + e7];
      S(M2, M2, F), z(M2, M2);
      for (let e7 = 0; e7 < 3; e7++)
        t.normal[r5 + e7] = M2[e7];
    }
  }
}
var y4 = { faceDescriptions: [{ axis: [0, -1, 0], uvOrigin: [0, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [1, 0, 0], uvOrigin: [0.25, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 1, 0], uvOrigin: [0.5, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [-1, 0, 0], uvOrigin: [0.75, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [0, 0, 1], uvOrigin: [0, 0.375], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 0, -1], uvOrigin: [0, 0.875], corners: [[-1, 1], [1, 1], [1, -1], [-1, -1]] }], uvScales: [[0, 0], [1, 0], [1, 1], [0, 1]], faceVertexOffsets: [0, 1, 2, 0, 2, 3] };
var d5 = { south: 0, east: 1, north: 2, west: 3, up: 4, down: 5 };
var M2 = n();
var F = e3();

// node_modules/@arcgis/core/geometry/support/meshUtils/rotate.js
var U = "esri.geometry.support.meshUtils.rotate";
function z2(t, e7, r4) {
  if (!t.vertexAttributes || !t.vertexAttributes.position || 0 === e7[3])
    return;
  const { spatialReference: o4, vertexSpace: n2 } = t;
  if (n2.isRelative) {
    o2(n2, U, r4);
    const o5 = (r4 == null ? void 0 : r4.origin) ?? t.origin;
    t.transform ?? (t.transform = new N()), C(t.transform, n2, e7, o5);
  } else {
    const n3 = (r4 == null ? void 0 : r4.origin) ?? t.origin;
    r3(o4, r4) ? I2(t, e7, n3) : $(t, e7, n3);
  }
}
function C(t, e7, r4, o4) {
  const n2 = e7.origin, l7 = o(E2, o4.x, o4.y, o4.z ?? 0), c5 = e2(E2, l7, n2);
  t.applyLocalInverse(c5, M3), t.rotation = g3(t.rotation, r4, h()), t.applyLocalInverse(c5, c5), e2(c5, c5, M3), t.translation = u(n(), t.translation, c5);
}
function I2(t, r4, o4) {
  const n2 = t.spatialReference, i3 = c2(n2), s4 = Z;
  In(o4, s4, i3) || In(t.origin, s4, i3);
  const a7 = t.vertexAttributes.position, c5 = t.vertexAttributes.normal, f6 = t.vertexAttributes.tangent, m9 = new Float64Array(a7.length), j6 = null != c5 ? new Float32Array(c5.length) : null, h8 = null != f6 ? new Float32Array(f6.length) : null;
  zn(i3, s4, S2, i3), a4(T, S2);
  const x6 = P2;
  S(x2(P2), x2(r4), T), x6[3] = r4[3], h2(a7, n2, m9), null != c5 && null != j6 && _2(c5, a7, m9, n2, j6), null != f6 && null != h8 && R(f6, a7, m9, n2, h8), D2(m9, x6, 3, s4), E(m9, a7, n2), null != c5 && null != j6 && (D2(j6, x6, 3), j2(j6, a7, m9, n2, c5)), null != f6 && null != h8 && (D2(h8, x6, 4), v(h8, a7, m9, n2, f6)), t.vertexAttributesChanged();
}
function $(e7, r4, o4) {
  const n2 = Z;
  if (!In(o4, n2, e7.spatialReference)) {
    const r5 = e7.origin;
    n2[0] = r5.x, n2[1] = r5.y, n2[2] = r5.z, s.getLogger(U).error(`Failed to project specified origin (wkid:${o4.spatialReference.wkid}) to mesh spatial reference (wkid:${e7.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  }
  D2(e7.vertexAttributes.position, r4, 3, n2), D2(e7.vertexAttributes.normal, r4, 3), D2(e7.vertexAttributes.tangent, r4, 4), e7.vertexAttributesChanged();
}
function D2(t, e7, r4, n2 = f) {
  if (null != t) {
    g2(S2, w(e7), x2(e7));
    for (let e8 = 0; e8 < t.length; e8 += r4) {
      for (let r5 = 0; r5 < 3; r5++)
        E2[r5] = t[e8 + r5] - n2[r5];
      O(E2, E2, S2);
      for (let r5 = 0; r5 < 3; r5++)
        t[e8 + r5] = E2[r5] + n2[r5];
    }
  }
}
var E2 = n();
var M3 = n();
var P2 = h();
var S2 = e4();
var T = e3();
var Z = n();

// node_modules/@arcgis/core/geometry/support/meshUtils/scale.js
var x5 = "esri.geometry.support.meshUtils.scale";
function b4(e7, t, r4) {
  if (!e7.vertexAttributes || !e7.vertexAttributes.position)
    return;
  const { spatialReference: o4, vertexSpace: n2 } = e7;
  if (n2.isRelative) {
    o2(n2, x5, r4);
    const o5 = (r4 == null ? void 0 : r4.origin) ?? e7.origin;
    e7.transform ?? (e7.transform = new N()), A3(e7.transform, n2, t, o5);
  } else {
    const n3 = r3(o4, r4), i3 = (r4 == null ? void 0 : r4.origin) ?? e7.origin;
    n3 ? d6(e7, t, i3) : y5(e7, t, i3);
  }
}
function A3(e7, s4, l7, a7) {
  const c5 = s4.origin, p9 = o(R3, a7.x, a7.y, a7.z), f6 = e2(R3, p9, c5);
  e7.applyLocalInverse(f6, k2);
  const u5 = g(n(), e7.scale, l7);
  e7.scale = u5, e7.applyLocalInverse(f6, f6), e2(f6, f6, k2), e7.translation = u(n(), e7.translation, f6);
}
function d6(e7, t, r4) {
  const o4 = e7.spatialReference, n2 = c2(o4), i3 = F2;
  In(r4, i3, n2) || In(e7.origin, i3, n2);
  const s4 = e7.vertexAttributes.position, c5 = e7.vertexAttributes.normal, p9 = e7.vertexAttributes.tangent, f6 = new Float64Array(s4.length), x6 = null != c5 ? new Float32Array(c5.length) : null, b5 = null != p9 ? new Float32Array(p9.length) : null;
  h2(s4, o4, f6), null != c5 && null != x6 && _2(c5, s4, f6, o4, x6), null != p9 && null != b5 && R(p9, s4, f6, o4, b5), w4(f6, t, i3), E(f6, s4, o4), null != c5 && null != x6 && j2(x6, s4, f6, o4, c5), null != p9 && null != b5 && v(b5, s4, f6, o4, p9), e7.vertexAttributesChanged();
}
function y5(t, r4, o4) {
  const n2 = F2;
  if (!In(o4, n2, t.spatialReference)) {
    const r5 = t.origin;
    n2[0] = r5.x, n2[1] = r5.y, n2[2] = r5.z, s.getLogger(x5).error(`Failed to project specified origin (wkid:${o4.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  }
  w4(t.vertexAttributes.position, r4, n2), t.vertexAttributesChanged();
}
function w4(e7, t, r4 = f) {
  if (e7)
    for (let n2 = 0; n2 < e7.length; n2 += 3) {
      for (let t2 = 0; t2 < 3; t2++)
        R3[t2] = e7[n2 + t2] - r4[t2];
      g(R3, R3, t);
      for (let t2 = 0; t2 < 3; t2++)
        e7[n2 + t2] = R3[t2] + r4[t2];
    }
}
var R3 = n();
var k2 = n();
var F2 = n();

// node_modules/@arcgis/core/geometry/Mesh.js
var B;
var k3 = "esri.geometry.Mesh";
var D3 = { base: null, key: "type", defaultKeyValue: "georeferenced", typeMap: { georeferenced: p3, "georeferenced-relative": m2, local: m3 } };
var N2 = B = class extends a3(_.LoadableMixin(m(p2))) {
  constructor(e7) {
    super(e7), this.components = null, this.vertexSpace = new p3(), this.transform = null, this.metadata = new p7(), this.hasZ = true, this.hasM = false, this.vertexAttributes = new p4(), this.type = "mesh";
  }
  initialize() {
    (0 === this.metadata.externalSources.length || this.vertexAttributes.position.length) && (this.loadStatus = "loaded"), this.when(() => {
      this.handles.add(l2(() => {
        var _a;
        return { vertexAttributes: this.vertexAttributes, components: (_a = this.components) == null ? void 0 : _a.map((e7) => e7.clone()) };
      }, () => this._clearSources(), { once: true, sync: true }));
    });
  }
  get hasExtent() {
    var _a;
    return this.loaded ? this.vertexAttributes.position.length > 0 && (!this.components || this.components.length > 0) : null != ((_a = this.metadata.displaySource) == null ? void 0 : _a.extent);
  }
  get _transformedExtent() {
    const { components: e7, spatialReference: t, vertexAttributes: r4, vertexSpace: o4 } = this, s4 = r4.position;
    if (0 === s4.length || e7 && 0 === e7.length)
      return new M({ xmin: 0, ymin: 0, zmin: 0, xmax: 0, ymax: 0, zmax: 0, spatialReference: t });
    if ("local" === o4.type) {
      const { _untransformedExtent: e8, transform: r5 } = this;
      return e6(e8, r5, o4, t);
    }
    if ("georeferenced-relative" === o4.type) {
      const { transform: e8 } = this, r5 = I({ positions: s4, transform: e8, vertexSpace: o4, inSpatialReference: t, outSpatialReference: t, local: false });
      return m5(r5, t);
    }
    return m5(s4, t);
  }
  get _untransformedExtent() {
    return m5(this.vertexAttributes.position, this.spatialReference);
  }
  get anchor() {
    const { vertexSpace: e7 } = this;
    if (e7.isRelative)
      return e7.getOriginPoint(this.spatialReference);
    const { center: t, zmin: r4 } = this._transformedExtent;
    return new x({ x: t.x, y: t.y, z: r4, spatialReference: this.spatialReference });
  }
  get origin() {
    const { vertexSpace: e7 } = this;
    return e7.isRelative ? e7.getOriginPoint(this.spatialReference) : this._transformedExtent.center;
  }
  get extent() {
    var _a, _b;
    return this.loaded || null == ((_b = (_a = this.metadata) == null ? void 0 : _a.displaySource) == null ? void 0 : _b.extent) ? this._transformedExtent : this.metadata.displaySource.extent.clone();
  }
  addComponent(e7) {
    this.loaded ? (this.components || (this.components = []), this.components.push(g4.from(e7)), this.notifyChange("components")) : s.getLogger(this).error("addComponent()", "Mesh must be loaded before applying operations");
  }
  removeComponent(e7) {
    if (this.loaded) {
      if (this.components) {
        const t = this.components.indexOf(e7);
        if (-1 !== t)
          return this.components.splice(t, 1), void this.notifyChange("components");
      }
      s.getLogger(this).error("removeComponent()", "Provided component is not part of the list of components");
    } else
      s.getLogger(this).error("removeComponent()", "Mesh must be loaded before applying operations");
  }
  rotate(e7, t, r4, o4) {
    return l3(e7, t, r4, H), z2(this, H, o4), this;
  }
  offset(e7, t, r4, o4) {
    return this.loaded ? (Z2[0] = e7, Z2[1] = t, Z2[2] = r4, x3(this, Z2, o4), this) : (s.getLogger(this).error("offset()", "Mesh must be loaded before applying operations"), this);
  }
  scale(e7, t) {
    return this.loaded ? (b4(this, e7, t), this) : (s.getLogger(this).error("scale()", "Mesh must be loaded before applying operations"), this);
  }
  centerAt(e7, t) {
    return this.loaded ? (p5(this, e7, t), this) : (s.getLogger(this).error("centerAt()", "Mesh must be loaded before applying operations"), this);
  }
  load(e7) {
    const { metadata: { displaySource: t } } = this;
    return t && this.addResolvingPromise(c3(this, t, e7)), Promise.resolve(this);
  }
  addExternalSources(e7) {
    this.metadata.externalSources.addMany(e7);
  }
  updateDisplaySource(e7) {
    this.metadata.displaySource = e7;
  }
  clone() {
    return this.cloneWithVertexSpace(this.vertexSpace.clone());
  }
  cloneWithVertexSpace(e7) {
    var _a;
    let t = null;
    if (this.components) {
      const e8 = /* @__PURE__ */ new Map(), r5 = /* @__PURE__ */ new Map();
      t = this.components.map((t2) => t2.cloneWithDeduplication(e8, r5));
    }
    const r4 = { components: t, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes.clone(), vertexSpace: e7, transform: ((_a = this.transform) == null ? void 0 : _a.clone()) ?? null, metadata: this.metadata.clone() };
    return new B(r4);
  }
  cloneShallow() {
    return new B({ components: this.components, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes, vertexSpace: this.vertexSpace.clone(), transform: this.transform, metadata: this.metadata });
  }
  vertexAttributesChanged() {
    this.notifyChange("vertexAttributes");
  }
  async toBinaryGLTF(e7) {
    const t = import("./gltfexport-IZAKX2CE.js"), r4 = this.load(), o4 = await Promise.all([t, r4]), { toBinaryGLTF: s4 } = o4[0];
    return s4(this, e7);
  }
  get memoryUsage() {
    let e7 = 0;
    if (e7 += this.vertexAttributes.memoryUsage, null != this.components)
      for (const t of this.components)
        e7 += t.memoryUsage;
    return e7;
  }
  _clearSources() {
    this.metadata.clearSources();
  }
  static createBox(e7, t) {
    if (!(e7 instanceof x))
      return s.getLogger(k3).error(".createBox()", "expected location to be a Point instance"), null;
    const r4 = new B(g7(i2(), e7, t));
    return t && t.imageFace && "all" !== t.imageFace ? l6(r4, t.imageFace) : r4;
  }
  static createSphere(e7, t) {
    return e7 instanceof x ? new B(g7(c4(t && t.densificationFactor || 0), e7, t)) : (s.getLogger(k3).error(".createSphere()", "expected location to be a Point instance"), null);
  }
  static createCylinder(e7, t) {
    return e7 instanceof x ? new B(g7(f5(t && t.densificationFactor || 0), e7, t)) : (s.getLogger(k3).error(".createCylinder()", "expected location to be a Point instance"), null);
  }
  static createPlane(e7, t) {
    if (!(e7 instanceof x))
      return s.getLogger(k3).error(".createPlane()", "expected location to be a Point instance"), null;
    const r4 = (t == null ? void 0 : t.facing) ?? "up", o4 = u4(r4, t == null ? void 0 : t.size);
    return new B(g7(h6(r4), e7, { ...t, size: o4 }));
  }
  static createFromPolygon(e7, t) {
    if (!(e7 instanceof j))
      return s.getLogger(k3).error(".createFromPolygon()", "expected polygon to be a Polygon instance"), null;
    const r4 = l4(e7);
    return new B({ vertexAttributes: new p4({ position: r4.position }), components: [new g4({ faces: r4.faces, shading: "flat", material: (t == null ? void 0 : t.material) ?? null })], spatialReference: e7.spatialReference, vertexSpace: new p3() });
  }
  static async createFromGLTF(e7, r4, o4) {
    if (!(e7 instanceof x))
      throw s.getLogger(k3).error(".createfromGLTF()", "expected location to be a Point instance"), new s2("invalid-input", "Expected location to be a Point instance");
    const { loadGLTFMesh: n2 } = await p(import("./loadGLTFMesh-HTG3GH73.js"), o4);
    return new B(await n2(e7, r4, o4));
  }
  static async createFromFiles(e7, r4, o4) {
    if (!(e7 instanceof x)) {
      const e8 = "Expected location to be a Point instance";
      throw s.getLogger(k3).error(".createFromFiles()", e8), new s2("invalid-input", e8);
    }
    const n2 = B.createWithExternalSource(e7, r4), i3 = o4 == null ? void 0 : o4.layer;
    if (!i3) {
      const e8 = "A layer is needed to convert the files";
      throw s.getLogger(k3).error(".createFromFiles()", e8), new s2("invalid-input", e8);
    }
    const [a7] = await i3.uploadAssets([n2], o4);
    return a7;
  }
  static createWithExternalSource(e7, t, r4) {
    var _a;
    const o4 = (r4 == null ? void 0 : r4.extent) ?? null, { x: s4, y: n2, z: i3, spatialReference: a7 } = e7, c5 = ((_a = r4 == null ? void 0 : r4.transform) == null ? void 0 : _a.clone()) ?? new N(), p9 = (r4 == null ? void 0 : r4.vertexSpace) ?? new m3({ origin: [s4, n2, i3 ?? 0] }), l7 = { source: t, extent: o4 }, m9 = new p7();
    return m9.externalSources.push(l7), new B({ metadata: m9, transform: c5, vertexSpace: p9, spatialReference: a7 });
  }
  static createIncomplete(e7, r4) {
    var _a;
    const { x: o4, y: s4, z: n2, spatialReference: i3 } = e7, a7 = ((_a = r4 == null ? void 0 : r4.transform) == null ? void 0 : _a.clone()) ?? new N(), c5 = (r4 == null ? void 0 : r4.vertexSpace) ?? new m3({ origin: [o4, s4, n2 ?? 0] }), p9 = new B({ transform: a7, vertexSpace: c5, spatialReference: i3 });
    return p9.addResolvingPromise(Promise.reject(new s2("mesh-incomplete", "Mesh resources are not complete"))), p9;
  }
};
e([y({ type: [g4], json: { write: true } })], N2.prototype, "components", void 0), e([y({ nonNullable: true, types: D3, constructOnly: true, json: { write: true } })], N2.prototype, "vertexSpace", void 0), e([y({ type: N, json: { write: true } })], N2.prototype, "transform", void 0), e([y({ constructOnly: true })], N2.prototype, "metadata", void 0), e([y()], N2.prototype, "hasExtent", null), e([y()], N2.prototype, "_transformedExtent", null), e([y()], N2.prototype, "_untransformedExtent", null), e([y()], N2.prototype, "anchor", null), e([y()], N2.prototype, "origin", null), e([y({ readOnly: true, json: { read: false } })], N2.prototype, "extent", null), e([y({ readOnly: true, json: { read: false, write: true, default: true } })], N2.prototype, "hasZ", void 0), e([y({ readOnly: true, json: { read: false, write: true, default: false } })], N2.prototype, "hasM", void 0), e([y({ type: p4, nonNullable: true, json: { write: true } })], N2.prototype, "vertexAttributes", void 0), N2 = B = e([a2(k3)], N2);
var Z2 = n();
var H = h();
var I3 = N2;

// node_modules/@arcgis/core/rest/support/meshFeatureSet.js
var h7 = () => s.getLogger("esri.rest.support.meshFeatureSet");
function y6(t, r4, o4) {
  const n2 = o4.features;
  o4.features = [], delete o4.geometryType;
  const s4 = d.fromJSON(o4);
  if (s4.geometryType = "mesh", !o4.assetMaps)
    return s4;
  const i3 = M4(r4, o4.assetMaps), u5 = t.sourceSpatialReference ?? f2.WGS84, c5 = o4.globalIdFieldName, { outFields: f6 } = t, m9 = null != f6 && f6.length > 0 ? E3(f6.includes("*") ? null : new Set(f6)) : () => ({});
  for (const a7 of n2) {
    const t2 = S3(a7, c5, u5, r4, i3);
    null != t2 && s4.features.push(new h4({ geometry: t2, attributes: m9(a7) }));
  }
  return s4;
}
function E3(e7) {
  return ({ attributes: t }) => {
    if (!t)
      return {};
    if (!e7)
      return t;
    for (const r4 in t)
      e7.has(r4) || delete t[r4];
    return t;
  };
}
function S3(e7, t, r4, o4, i3) {
  const a7 = e7.attributes[t], f6 = i3.get(a7);
  if (null == f6)
    return h7().error("mesh-feature-set:asset-not-found", "Service returned a feature which was not found in the asset map", e7), null;
  if (!e7.geometry)
    return h7().error("mesh-feature-set:no-geometry", "Service returned a feature without geometry", e7), null;
  const { originPoint: m9, originVector: p9 } = d7(e7, r4, o4), l7 = M.fromJSON(e7.geometry);
  l7.spatialReference = r4;
  const g8 = j5(e7.attributes, o4), y7 = f6.projectVertices ? new m2({ origin: p9 }) : new m3({ origin: p9 }), E4 = T2(f6);
  return E4 ? I3.createWithExternalSource(m9, E4, { extent: l7, transform: g8, vertexSpace: y7 }) : I3.createIncomplete(m9, { extent: l7, transform: g8, vertexSpace: y7 });
}
function d7({ attributes: e7 }, t, { transformFieldRoles: r4 }) {
  const n2 = e7[r4.originX], s4 = e7[r4.originY], a7 = e7[r4.originZ];
  return { originPoint: new x({ x: n2, y: s4, z: a7, spatialReference: t }), originVector: r2(n2, s4, a7) };
}
function j5(e7, { transformFieldRoles: t }) {
  return new N({ translation: [e7[t.translationX], -e7[t.translationZ], e7[t.translationY]], rotationAxis: [e7[t.rotationX], e7[t.rotationZ], e7[t.rotationY]], rotationAngle: e7[t.rotationDeg], scale: [e7[t.scaleX], e7[t.scaleY], e7[t.scaleZ]] });
}
var w5;
function M4(e7, t) {
  const o4 = /* @__PURE__ */ new Map();
  for (const n2 of t) {
    const t2 = n2.parentGlobalId;
    if (null == t2)
      continue;
    const s4 = n2.assetName, i3 = n2.assetType, a7 = n2.assetHash, u5 = n2.assetURL, c5 = n2.conversionStatus, f6 = n2.seqNo, m9 = e5(i3, e7.supportedFormats);
    if (!m9) {
      h7().error("mesh-feature-set:unknown-format", `Service returned an asset of type ${i3}, but it does not list it as a supported type`);
      continue;
    }
    const p9 = r(o4, t2, () => ({ projectVertices: P3(n2.flags).projectVertices, files: /* @__PURE__ */ new Map() }));
    r(p9.files, s4, () => ({ name: s4, type: i3, mimeType: m9, status: D4(c5), parts: [] })).parts[f6] = { hash: a7, url: u5 };
  }
  return o4;
}
function T2(e7) {
  const t = Array.from(e7.files.values()), r4 = new Array();
  for (const o4 of t) {
    if (o4.status !== w5.COMPLETED)
      return null;
    const e8 = new Array();
    for (const t2 of o4.parts) {
      if (!t2)
        return null;
      e8.push(new i(t2.url, t2.hash));
    }
    r4.push(new a5(o4.name, o4.mimeType, e8));
  }
  return r4;
}
function D4(e7) {
  switch (e7) {
    case "COMPLETED":
    case "SUBMITTED":
      return w5.COMPLETED;
    case "INPROGRESS":
      return w5.PENDING;
    default:
      return w5.FAILED;
  }
}
function P3(e7) {
  return { projectVertices: e7.includes("PROJECT_VERTICES") };
}
!function(e7) {
  e7[e7.FAILED = 0] = "FAILED", e7[e7.PENDING = 1] = "PENDING", e7[e7.COMPLETED = 2] = "COMPLETED";
}(w5 || (w5 = {}));

export {
  y6 as y,
  S3 as S,
  M4 as M
};
//# sourceMappingURL=chunk-BM4PSBXP.js.map
