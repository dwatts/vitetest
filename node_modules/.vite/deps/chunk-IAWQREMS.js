import {
  m,
  o as o3
} from "./chunk-EPDLDPS4.js";
import {
  a
} from "./chunk-NBYHM3OO.js";
import {
  i
} from "./chunk-5ZW42GDY.js";
import {
  P
} from "./chunk-N3RXOITN.js";
import {
  e as e2
} from "./chunk-QS45OHBM.js";
import {
  e
} from "./chunk-WRFNQB7U.js";
import {
  o as o2
} from "./chunk-UUW6REOV.js";
import {
  i2
} from "./chunk-BO2REVMA.js";
import {
  o
} from "./chunk-V66LHQVK.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  l
} from "./chunk-YGUWDSEH.js";
import {
  r
} from "./chunk-NLWV7Q6F.js";
import {
  n
} from "./chunk-SS3YG6J3.js";

// node_modules/@arcgis/core/chunks/LineCallout.glsl.js
function v(i3) {
  const r2 = new i2(), { vertex: v2, fragment: m3 } = r2;
  return v2.include(o3), r2.include(m, i3), r2.include(P, i3), r2.attributes.add(O.UV0, "vec2"), v2.uniforms.add(new e2("viewport", (e3, i4) => i4.camera.fullViewport), new o2("lineSize", (e3, i4) => e3.size > 0 ? Math.max(1, e3.size) * i4.camera.pixelRatio : 0), new e("pixelToNDC", (i4, r3) => r(h, 2 / r3.camera.fullViewport[2], 2 / r3.camera.fullViewport[3])), new o2("borderSize", (e3, i4) => null != e3.borderColor ? i4.camera.pixelRatio : 0), new e("screenOffset", (i4, r3) => r(h, i4.screenOffset[0] * r3.camera.pixelRatio, i4.screenOffset[1] * r3.camera.pixelRatio))), r2.varyings.add("coverageSampling", "vec4"), r2.varyings.add("lineSizes", "vec2"), i3.hasMultipassGeometry && r2.varyings.add("depth", "float"), i3.hasScreenSizePerspective && i(v2), v2.code.add(o`
    void main(void) {
      ProjectHUDAux projectAux;
      vec4 endPoint = projectPositionHUD(projectAux);

      vec3 vpos = projectAux.posModel;
      if (rejectBySlice(vpos)) {
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }
    ${i3.occlusionTestEnabled ? o`
      if (!testVisibilityHUD(endPoint)) {
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }` : ""}

    ${i3.hasScreenSizePerspective ? o`
      vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);
      vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);
        ` : o`vec2 screenOffsetScaled = screenOffset;`}
      // Add view dependent polygon offset to get exact same original starting point. This is mostly used to get the
      // correct depth value
      vec3 posView = (view * vec4(position, 1.0)).xyz;
      ${i3.hasMultipassGeometry ? "depth = posView.z;" : ""}

      applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);
      vec4 startPoint = proj * vec4(posView, 1.0);
      // Apply screen offset to both start and end point
      vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;
      startPoint.xy += screenOffsetNorm * startPoint.w;
      endPoint.xy += screenOffsetNorm * endPoint.w;
      // Align start and end to pixel origin
      vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);
      vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);
    ${i3.depthHudEnabled ? i3.depthHudAlignStartEnabled ? o`endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);` : o`startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);` : ""}
      vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);
      // The direction of the line in screen space
      vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);
      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);
    ${i3.hasScreenSizePerspective ? o`
      float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);
      float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);
        ` : o`
      float lineSizeScaled = lineSize;
      float borderSizeScaled = borderSize;
        `}
      float halfPixelSize = lineSizeScaled * 0.5;

      // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size
      float padding = 1.0 + borderSizeScaled;
      vec2 ndcOffset = (-halfPixelSize - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;

      // Offset x/y from the center of the line in screen space
      projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;

      // Compute a coverage varying which we can use in the fragment shader to determine
      // how much a pixel is actually covered by the line (i.e. to anti alias the line).
      // This works by computing two coordinates that can be linearly interpolated and then
      // subtracted to find out how far away from the line edge we are.
      float edgeDirection = (uv0.x * 2.0 - 1.0);

      float halfBorderSize = 0.5 * borderSizeScaled;
      float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;
      float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);

      float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);

      coverageSampling = vec4(
        // Edge coordinate
        outerEdgeCoverageSampler,

        // Border edge coordinate
        outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,

        // Line offset
        halfPixelSize - 0.5,

        // Border offset
        halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)
      );

      lineSizes = vec2(lineSizeScaled, borderSizeScaled);

      gl_Position = projectedPosition;
    }
  `), m3.uniforms.add(new e2("uColor", (e3) => S(e3.color)), new e2("borderColor", (e3) => S(e3.borderColor))), i3.hasMultipassGeometry && (m3.include(a, i3), m3.uniforms.add(new e("inverseViewport", (e3, i4) => i4.inverseViewport))), m3.code.add(o`
    void main() {
      ${i3.hasMultipassGeometry ? "if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }" : ""}

      // Mix between line and border coverage offsets depending on whether we need
      // a border (based on the sidedness).
      vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);

      // Mix between border and line color based on the line coverage (conceptually the line blends on top of the
      // border background).
      //
      // Anti-alias by blending final result using the full (including optional border) coverage and the color alpha
      float borderAlpha = uColor.a * borderColor.a * coverage.y;
      float colorAlpha = uColor.a * coverage.x;

      float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);

    ${i3.depthHudEnabled ? o`
      if (finalAlpha < 0.01) {
        discard;
      }
      ` : o`
      vec3 finalRgb = mix(borderColor.rgb * borderAlpha, uColor.rgb, colorAlpha);
      fragColor = vec4(finalRgb, finalAlpha);
      `}
  }
  `), r2;
}
function S(e3) {
  return null != e3 ? e3 : l;
}
var h = n();
var m2 = Object.freeze(Object.defineProperty({ __proto__: null, build: v }, Symbol.toStringTag, { value: "Module" }));

export {
  v,
  m2 as m
};
//# sourceMappingURL=chunk-IAWQREMS.js.map
