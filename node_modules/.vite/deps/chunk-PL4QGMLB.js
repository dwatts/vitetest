import {
  u
} from "./chunk-67UNUI4B.js";
import {
  R,
  a,
  c,
  d2 as d,
  o
} from "./chunk-6WY3ZZYN.js";
import {
  Z
} from "./chunk-2XKILFME.js";
import {
  i
} from "./chunk-4BXK4H4L.js";
import {
  f
} from "./chunk-ZEEBL7ZN.js";
import {
  s
} from "./chunk-7I33FAWS.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/elevationAlignPointsInFeatures.js
async function f2(o2, n, s2, p, f3) {
  const { elevationProvider: d2, renderCoordsHelper: j, spatialReference: u2 } = o2, { elevationInfo: v } = n, y = d(v, true), I = await a(y, u2, f3);
  s(f3);
  const g = [], x = /* @__PURE__ */ new Set(), h = /* @__PURE__ */ new Set();
  for (const { objectId: e, points: i2 } of p) {
    const a2 = s2(e);
    if (null == a2) {
      for (const e2 of i2)
        g.push(e2.z ?? 0);
      x.add(e);
      continue;
    }
    a2.isDraped && h.add(e);
    const p2 = a2.graphic.geometry;
    c2.setFromElevationInfo(u(p2, v)), c2.updateFeatureExpressionInfoContext(I, a2.graphic, n), l.spatialReference = o2.spatialReference;
    for (const { x: e2, y: o3, z: t2 } of i2)
      l.x = e2, l.y = o3, l.z = t2 ?? 0, c(l, d2, c2, j, m), g.push(m.z);
  }
  return { elevations: g, drapedObjectIds: h, failedObjectIds: x };
}
var c2 = new o();
var l = Z(0, 0, 0, f.WGS84);
var m = new R();

// node_modules/@arcgis/core/views/3d/layers/graphics/queryForSymbologySnapping.js
async function r(r2, a2, s2) {
  if (null == r2 || 0 === a2.candidates.length)
    return t;
  const i2 = r2.graphics3DGraphicsByObjectID ?? r2.graphics3DGraphics, c3 = [], o2 = [], { renderer: d2 } = r2, p = null != d2 && "arcadeRequired" in d2 && d2.arcadeRequired ? i() : null, l2 = async (n, { graphic: e, graphics3DSymbol: t2 }) => {
    const a3 = await p, i3 = await r2.getRenderingInfoAsync(e, d2, a3, { signal: s2 });
    return null == i3 ? [] : t2.queryForSnapping(n, g, i3, s2);
  }, { candidates: u2, spatialReference: g } = a2;
  for (let n = 0; n < u2.length; ++n) {
    const e = u2[n], { objectId: r3 } = e, t2 = "number" == typeof r3 ? i2 == null ? void 0 : i2.get(r3) : void 0;
    if (null == t2)
      continue;
    const { graphics3DSymbol: a3 } = t2;
    a3.symbologySnappingSupported && (c3.push(l2(e, t2)), o2.push(n));
  }
  if (0 === c3.length)
    return t;
  const h = await Promise.all(c3);
  s(s2);
  const f3 = [], m2 = [];
  for (let n = 0; n < h.length; ++n) {
    const e = h[n], r3 = o2[n];
    for (const n2 of e)
      f3.push(n2), m2.push(r3);
  }
  return { candidates: f3, sourceCandidateIndices: m2 };
}
var t = { candidates: [], sourceCandidateIndices: [] };

export {
  f2 as f,
  r
};
//# sourceMappingURL=chunk-PL4QGMLB.js.map
