import {
  c as c2
} from "./chunk-NVZXNBIH.js";
import {
  M
} from "./chunk-A4HFWKMU.js";
import {
  T
} from "./chunk-TBHRKIAA.js";
import {
  ee,
  re,
  te
} from "./chunk-J6SRKANJ.js";
import {
  r as r2
} from "./chunk-KILCBNKU.js";
import {
  u
} from "./chunk-H3DKDGMJ.js";
import {
  c as c3
} from "./chunk-FB6EWBGE.js";
import {
  e
} from "./chunk-AER5JAFS.js";
import {
  l,
  n as n2,
  r
} from "./chunk-7HZ72XIE.js";
import {
  C,
  E,
  F,
  I,
  L
} from "./chunk-BCDDCNQ2.js";
import {
  e as e2
} from "./chunk-D5NSNTGJ.js";
import {
  n,
  t
} from "./chunk-5KLICR5E.js";
import {
  c
} from "./chunk-TEHNQYQD.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrush.js
var t2 = class {
  constructor() {
    this.name = this.constructor.name || "UnnamedBrush", this.brushEffect = null;
  }
  prepareState(t3, r3) {
  }
  draw(t3, r3, s) {
  }
  drawMany(t3, r3, s) {
    for (const a of r3)
      a.visible && this.draw(t3, a, s);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLBackground.js
var _ = class extends t2 {
  constructor() {
    super(...arguments), this._color = r2(1, 0, 0, 1), this._patternMatrix = e2(), this._programOptions = { id: false, pattern: false };
  }
  dispose() {
    this._vao && (this._vao.dispose(), this._vao = null);
  }
  drawMany(e3, r3) {
    const { context: n3, painter: c4, styleLayerUID: u3, requestRender: p, allowDelayedRender: _3 } = e3;
    this._loadWGLResources(e3);
    const d2 = e3.displayLevel, h = e3.styleLayer, g = h.backgroundMaterial, v = c4.vectorTilesMaterialManager, y2 = h.getPaintValue("background-color", d2), b = h.getPaintValue("background-opacity", d2), x = h.getPaintValue("background-pattern", d2), M2 = void 0 !== x, j = y2[3] * b, U = 1 | window.devicePixelRatio, w = e3.spriteMosaic;
    let L2, A;
    const P = U > te ? 2 : 1, I2 = e3.drawPhase === T.HITTEST, R = this._programOptions;
    R.id = I2, R.pattern = M2;
    const k = v.getMaterialProgram(n3, g, R);
    if (!_3 || null == p || k.compiled) {
      if (n3.bindVAO(this._vao), n3.useProgram(k), M2) {
        const t3 = w.getMosaicItemPosition(x, true);
        if (null != t3) {
          const { tl: e4, br: r4, page: i } = t3;
          L2 = r4[0] - e4[0], A = r4[1] - e4[1];
          const s = w.getPageSize(i);
          null != s && (w.bind(n3, L.LINEAR, i, ee), k.setUniform4f("u_tlbr", e4[0], e4[1], r4[0], r4[1]), k.setUniform2fv("u_mosaicSize", s), k.setUniform1i("u_texture", ee));
        }
        k.setUniform1f("u_opacity", b);
      } else
        this._color[0] = j * y2[0], this._color[1] = j * y2[1], this._color[2] = j * y2[2], this._color[3] = j, k.setUniform4fv("u_color", this._color);
      if (k.setUniform1f("u_depth", h.z || 0), I2) {
        const t3 = M(u3 + 1);
        k.setUniform4fv("u_id", t3);
      }
      for (const e4 of r3) {
        if (k.setUniform1f("u_coord_range", e4.rangeX), k.setUniformMatrix3fv("u_dvsMat3", e4.transforms.dvs), M2) {
          const r4 = Math.max(2 ** (Math.round(d2) - e4.key.level), 1), o2 = P * e4.width * r4, i = o2 / c(L2), s = o2 / c(A);
          this._patternMatrix[0] = i, this._patternMatrix[4] = s, k.setUniformMatrix3fv("u_pattern_matrix", this._patternMatrix);
        }
        n3.setStencilFunction(I.EQUAL, 0, 255), n3.drawArrays(E.TRIANGLE_STRIP, 0, 4);
      }
    } else
      p();
  }
  _loadWGLResources(t3) {
    if (this._vao)
      return;
    const { context: e3, styleLayer: r3 } = t3, o2 = r3.backgroundMaterial, i = new Int8Array([0, 0, 1, 0, 0, 1, 1, 1]), s = c3.createVertex(e3, F.STATIC_DRAW, i), a = new u(e3, o2.getAttributeLocations(), o2.getLayoutInfo(), { geometry: s });
    this._vao = a;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLCircle.js
var o = class extends t2 {
  constructor() {
    super(...arguments), this._programOptions = { id: false };
  }
  dispose() {
  }
  drawMany(i, o2) {
    const { context: l2, displayLevel: c4, requiredLevel: u3, state: d2, drawPhase: f2, painter: m, spriteMosaic: p, styleLayerUID: y2, requestRender: v, allowDelayedRender: g } = i;
    if (!o2.some((e3) => {
      var _a;
      return ((_a = e3.layerData.get(y2)) == null ? void 0 : _a.circleIndexCount) ?? false;
    }))
      return;
    const E2 = i.styleLayer, M2 = E2.circleMaterial, T2 = m.vectorTilesMaterialManager, I2 = 1.2, U = E2.getPaintValue("circle-translate", c4), _3 = E2.getPaintValue("circle-translate-anchor", c4), x = f2 === T.HITTEST, R = this._programOptions;
    R.id = x;
    const h = T2.getMaterialProgram(l2, M2, R);
    if (g && null != v && !h.compiled)
      return void v();
    l2.useProgram(h), h.setUniformMatrix3fv("u_displayMat3", _3 === r.VIEWPORT ? d2.displayMat3 : d2.displayViewMat3), h.setUniform2fv("u_circleTranslation", U), h.setUniform1f("u_depth", E2.z), h.setUniform1f("u_antialiasingWidth", I2);
    let D = -1;
    if (x) {
      const e3 = M(y2 + 1);
      h.setUniform4fv("u_id", e3);
    }
    for (const e3 of o2) {
      if (!e3.layerData.has(y2))
        continue;
      e3.key.level !== D && (D = e3.key.level, M2.setDataUniforms(h, c4, E2, D, p));
      const t3 = e3.layerData.get(y2);
      if (!t3.circleIndexCount)
        continue;
      t3.prepareForRendering(l2);
      const r3 = t3.vao;
      null != r3 && (l2.bindVAO(r3), h.setUniformMatrix3fv("u_dvsMat3", e3.transforms.dvs), u3 !== e3.key.level ? l2.setStencilFunction(I.EQUAL, e3.stencilRef, 255) : l2.setStencilFunction(I.GREATER, 255, 255), l2.drawElements(E.TRIANGLES, t3.circleIndexCount, C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * t3.circleIndexStart), e3.triangleCount += t3.circleIndexCount / 3);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLFill.js
var u2 = 1 / 65536;
var d = class extends t2 {
  constructor() {
    super(...arguments), this._fillProgramOptions = { id: false, pattern: false }, this._outlineProgramOptions = { id: false };
  }
  dispose() {
  }
  drawMany(t3, e3) {
    const { displayLevel: i, drawPhase: r3, renderPass: l2, spriteMosaic: o2, styleLayerUID: s } = t3;
    let f2 = false;
    for (const n3 of e3)
      if (n3.layerData.has(s)) {
        const t4 = n3.layerData.get(s);
        if (t4.fillIndexCount > 0 || t4.outlineIndexCount > 0) {
          f2 = true;
          break;
        }
      }
    if (!f2)
      return;
    const u3 = t3.styleLayer, d2 = u3.getPaintProperty("fill-pattern"), c4 = void 0 !== d2, m = c4 && d2.isDataDriven;
    let p;
    if (c4 && !m) {
      const t4 = d2.getValue(i);
      p = o2.getMosaicItemPosition(t4, true);
    }
    const y2 = !c4 && u3.getPaintValue("fill-antialias", i);
    let g = true, _3 = 1;
    if (!c4) {
      const t4 = u3.getPaintProperty("fill-color"), e4 = u3.getPaintProperty("fill-opacity");
      if (!(t4 == null ? void 0 : t4.isDataDriven) && !(e4 == null ? void 0 : e4.isDataDriven)) {
        const t5 = u3.getPaintValue("fill-color", i);
        _3 = u3.getPaintValue("fill-opacity", i) * t5[3], _3 >= 1 && (g = false);
      }
    }
    if (g && "opaque" === l2)
      return;
    let E2;
    r3 === T.HITTEST && (E2 = M(s + 1));
    const v = u3.getPaintValue("fill-translate", i), M2 = u3.getPaintValue("fill-translate-anchor", i);
    (g || "translucent" !== l2) && this._drawFill(t3, s, u3, e3, v, M2, c4, p, m, E2);
    const P = !u3.hasDataDrivenOutlineColor && u3.outlineUsesFillColor && _3 < 1;
    y2 && "opaque" !== l2 && !P && this._drawOutline(t3, s, u3, e3, v, M2, E2);
  }
  _drawFill(a, r3, d2, c4, m, p, y2, g, _3, E2) {
    if (y2 && !_3 && null == g)
      return;
    const { context: v, displayLevel: M2, state: P, drawPhase: I2, painter: T2, pixelRatio: U, spriteMosaic: x, requestRender: D, allowDelayedRender: h } = a, S = d2.fillMaterial, R = T2.vectorTilesMaterialManager, w = U > te ? 2 : 1, N = I2 === T.HITTEST, L2 = this._fillProgramOptions;
    L2.id = N, L2.pattern = y2;
    const A = R.getMaterialProgram(v, S, L2);
    if (h && null != D && !A.compiled)
      return void D();
    if (v.useProgram(A), null != g) {
      const { page: t3 } = g, i = x.getPageSize(t3);
      null != i && (x.bind(v, L.LINEAR, t3, ee), A.setUniform2fv("u_mosaicSize", i), A.setUniform1i("u_texture", ee));
    }
    A.setUniformMatrix3fv("u_displayMat3", p === r.VIEWPORT ? P.displayMat3 : P.displayViewMat3), A.setUniform2fv("u_fillTranslation", m), A.setUniform1f("u_depth", d2.z + u2), N && A.setUniform4fv("u_id", E2);
    let V = -1;
    for (const t3 of c4) {
      if (!t3.layerData.has(r3))
        continue;
      t3.key.level !== V && (V = t3.key.level, S.setDataUniforms(A, M2, d2, V, x));
      const i = t3.layerData.get(r3);
      if (!i.fillIndexCount)
        continue;
      i.prepareForRendering(v);
      const n3 = i.fillVAO;
      if (null != n3) {
        if (v.bindVAO(n3), A.setUniformMatrix3fv("u_dvsMat3", t3.transforms.dvs), v.setStencilFunction(I.EQUAL, t3.stencilRef, 255), y2) {
          const e3 = Math.max(2 ** (Math.round(M2) - t3.key.level), 1), i2 = t3.rangeX / (w * t3.width * e3);
          A.setUniform1f("u_patternFactor", i2);
        }
        if (_3) {
          const t4 = i.patternMap;
          if (!t4)
            continue;
          for (const [i2, n4] of t4) {
            const t5 = x.getPageSize(i2);
            null != t5 && (x.bind(v, L.LINEAR, i2, ee), A.setUniform2fv("u_mosaicSize", t5), A.setUniform1i("u_texture", ee), v.drawElements(E.TRIANGLES, n4[1], C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * n4[0]));
          }
        } else
          v.drawElements(E.TRIANGLES, i.fillIndexCount, C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * i.fillIndexStart);
        t3.triangleCount += i.fillIndexCount / 3;
      }
    }
  }
  _drawOutline(e3, i, a, r3, l2, d2, c4) {
    const { context: m, displayLevel: p, state: y2, drawPhase: g, painter: _3, pixelRatio: E2, spriteMosaic: v, requestRender: M2, allowDelayedRender: P } = e3, I2 = a.outlineMaterial, T2 = _3.vectorTilesMaterialManager, U = 0.75 / E2, x = g === T.HITTEST, D = this._outlineProgramOptions;
    D.id = x;
    const h = T2.getMaterialProgram(m, I2, D);
    if (P && null != M2 && !h.compiled)
      return void M2();
    m.useProgram(h), h.setUniformMatrix3fv("u_displayMat3", d2 === r.VIEWPORT ? y2.displayMat3 : y2.displayViewMat3), h.setUniform2fv("u_fillTranslation", l2), h.setUniform1f("u_depth", a.z + u2), h.setUniform1f("u_outline_width", U), x && h.setUniform4fv("u_id", c4);
    let S = -1;
    for (const t3 of r3) {
      if (!t3.layerData.has(i))
        continue;
      t3.key.level !== S && (S = t3.key.level, I2.setDataUniforms(h, p, a, S, v));
      const e4 = t3.layerData.get(i);
      if (e4.prepareForRendering(m), !e4.outlineIndexCount)
        continue;
      const n3 = e4.outlineVAO;
      null != n3 && (m.bindVAO(n3), h.setUniformMatrix3fv("u_dvsMat3", t3.transforms.dvs), m.setStencilFunction(I.EQUAL, t3.stencilRef, 255), m.drawElements(E.TRIANGLES, e4.outlineIndexCount, C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * e4.outlineIndexStart), t3.triangleCount += e4.outlineIndexCount / 3);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLLine.js
var f = class extends t2 {
  constructor() {
    super(...arguments), this._programOptions = { id: false, pattern: false, sdf: false };
  }
  dispose() {
  }
  drawMany(a, f2) {
    const { context: u3, displayLevel: m, state: d2, drawPhase: c4, painter: p, pixelRatio: g, spriteMosaic: y2, styleLayerUID: E2, requestRender: v, allowDelayedRender: M2 } = a;
    if (!f2.some((e3) => {
      var _a;
      return ((_a = e3.layerData.get(E2)) == null ? void 0 : _a.lineIndexCount) ?? false;
    }))
      return;
    const _3 = a.styleLayer, U = _3.lineMaterial, I2 = p.vectorTilesMaterialManager, P = _3.getPaintValue("line-translate", m), T2 = _3.getPaintValue("line-translate-anchor", m), x = _3.getPaintProperty("line-pattern"), D = void 0 !== x, S = D && x.isDataDriven;
    let L2, N;
    if (D && !S) {
      const e3 = x.getValue(m);
      L2 = y2.getMosaicItemPosition(e3);
    }
    let R = false;
    if (!D) {
      const e3 = _3.getPaintProperty("line-dasharray");
      if (N = void 0 !== e3, R = N && e3.isDataDriven, N && !R) {
        const t3 = e3.getValue(m), i = _3.getDashKey(t3, _3.getLayoutValue("line-cap", m));
        L2 = y2.getMosaicItemPosition(i);
      }
    }
    const V = 1 / g, h = c4 === T.HITTEST, w = this._programOptions;
    w.id = h, w.pattern = D, w.sdf = N;
    const A = I2.getMaterialProgram(u3, U, w);
    if (M2 && null != v && !A.compiled)
      return void v();
    if (u3.useProgram(A), A.setUniformMatrix3fv("u_displayViewMat3", d2.displayViewMat3), A.setUniformMatrix3fv("u_displayMat3", T2 === r.VIEWPORT ? d2.displayMat3 : d2.displayViewMat3), A.setUniform2fv("u_lineTranslation", P), A.setUniform1f("u_depth", _3.z), A.setUniform1f("u_antialiasing", V), h) {
      const e3 = M(E2 + 1);
      A.setUniform4fv("u_id", e3);
    }
    if (L2 && null != L2) {
      const { page: e3 } = L2, i = y2.getPageSize(e3);
      null != i && (y2.bind(u3, L.LINEAR, e3, ee), A.setUniform2fv("u_mosaicSize", i), A.setUniform1i("u_texture", ee));
    }
    let j = -1;
    for (const e3 of f2) {
      if (!e3.layerData.has(E2))
        continue;
      e3.key.level !== j && (j = e3.key.level, U.setDataUniforms(A, m, _3, j, y2));
      const i = 2 ** (m - j) / g;
      A.setUniform1f("u_zoomFactor", i);
      const n3 = e3.layerData.get(E2);
      if (!n3.lineIndexCount)
        continue;
      n3.prepareForRendering(u3);
      const a2 = n3.vao;
      if (null != a2) {
        if (u3.bindVAO(a2), A.setUniformMatrix3fv("u_dvsMat3", e3.transforms.dvs), u3.setStencilFunction(I.EQUAL, e3.stencilRef, 255), S || R) {
          const e4 = n3.patternMap;
          if (!e4)
            continue;
          for (const [i2, n4] of e4) {
            const e5 = y2.getPageSize(i2);
            null != e5 && (y2.bind(u3, L.LINEAR, i2, ee), A.setUniform2fv("u_mosaicSize", e5), A.setUniform1i("u_texture", ee), u3.drawElements(E.TRIANGLES, n4[1], C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * n4[0]));
          }
        } else
          u3.drawElements(E.TRIANGLES, n3.lineIndexCount, C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * n3.lineIndexStart);
        e3.triangleCount += n3.lineIndexCount / 3;
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLSymbol.js
var y = 1 / 65536;
var _2 = class extends t2 {
  constructor() {
    super(...arguments), this._iconProgramOptions = { id: false, sdf: false }, this._sdfProgramOptions = { id: false }, this._spritesTextureSize = n();
  }
  dispose() {
  }
  drawMany(e3, t3) {
    const { drawPhase: i, styleLayerUID: a } = e3, r3 = e3.styleLayer;
    let n3;
    i === T.HITTEST && (n3 = M(a + 1)), this._drawIcons(e3, r3, t3, n3), this._drawText(e3, r3, t3, n3);
  }
  _drawIcons(e3, t3, o2, u3) {
    const { context: p, displayLevel: c4, drawPhase: m, painter: d2, spriteMosaic: g, state: y2, styleLayerUID: _3, requestRender: h, allowDelayedRender: M2 } = e3, P = t3.iconMaterial, T2 = d2.vectorTilesMaterialManager;
    let U, E2 = false;
    for (const i of o2)
      if (i.layerData.has(_3) && (U = i.layerData.get(_3), U.iconPerPageElementsMap.size > 0)) {
        E2 = true;
        break;
      }
    if (!E2)
      return;
    const v = t3.getPaintValue("icon-translate", c4), x = t3.getPaintValue("icon-translate-anchor", c4);
    let D = t3.getLayoutValue("icon-rotation-alignment", c4);
    D === l.AUTO && (D = t3.getLayoutValue("symbol-placement", c4) === n2.POINT ? l.VIEWPORT : l.MAP);
    const I2 = D === l.MAP, R = t3.getLayoutValue("icon-keep-upright", c4) && I2, S = U.isIconSDF, V = m === T.HITTEST, w = this._iconProgramOptions;
    w.id = V, w.sdf = S;
    const A = T2.getMaterialProgram(p, P, w);
    if (M2 && null != h && !A.compiled)
      return void h();
    p.useProgram(A), A.setUniformMatrix3fv("u_displayViewMat3", D === l.MAP ? y2.displayViewMat3 : y2.displayMat3), A.setUniformMatrix3fv("u_displayMat3", x === r.VIEWPORT ? y2.displayMat3 : y2.displayViewMat3), A.setUniform2fv("u_iconTranslation", v), A.setUniform1f("u_depth", t3.z), A.setUniform1f("u_mapRotation", c2(y2.rotation)), A.setUniform1f("u_keepUpright", R ? 1 : 0), A.setUniform1f("u_level", 10 * c4), A.setUniform1i("u_texture", ee), A.setUniform1f("u_fadeDuration", e / 1e3), V && A.setUniform4fv("u_id", u3);
    let L2 = -1;
    for (const i of o2) {
      if (!i.layerData.has(_3))
        continue;
      if (i.key.level !== L2 && (L2 = i.key.level, P.setDataUniforms(A, c4, t3, L2, g)), U = i.layerData.get(_3), 0 === U.iconPerPageElementsMap.size)
        continue;
      U.prepareForRendering(p), U.updateOpacityInfo();
      const a = U.iconVAO;
      if (null != a) {
        p.bindVAO(a), A.setUniformMatrix3fv("u_dvsMat3", i.transforms.dvs), A.setUniform1f("u_time", (performance.now() - U.lastOpacityUpdate) / 1e3);
        for (const [t4, a2] of U.iconPerPageElementsMap)
          this._renderIconRange(e3, A, a2, t4, i);
      }
    }
  }
  _renderIconRange(e3, t3, i, a, r3) {
    const { context: n3, spriteMosaic: o2 } = e3;
    this._spritesTextureSize[0] = o2.getWidth(a) / 4, this._spritesTextureSize[1] = o2.getHeight(a) / 4, t3.setUniform2fv("u_mosaicSize", this._spritesTextureSize), o2.bind(n3, L.LINEAR, a, ee), n3.setStencilTestEnabled(true), n3.setStencilFunction(I.GREATER, 255, 255), n3.setStencilWriteMask(0), n3.drawElements(E.TRIANGLES, i[1], C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * i[0]), r3.triangleCount += i[1] / 3;
  }
  _drawText(e3, s, u3, p) {
    const { context: c4, displayLevel: d2, drawPhase: g, glyphMosaic: _3, painter: h, pixelRatio: M2, spriteMosaic: P, state: T2, styleLayerUID: U, requestRender: E2, allowDelayedRender: v } = e3, x = s.textMaterial, D = h.vectorTilesMaterialManager;
    let I2, R = false;
    for (const t3 of u3)
      if (t3.layerData.has(U) && (I2 = t3.layerData.get(U), I2.glyphPerPageElementsMap.size > 0)) {
        R = true;
        break;
      }
    if (!R)
      return;
    const S = s.getPaintProperty("text-opacity");
    if (S && !S.isDataDriven && 0 === S.getValue(d2))
      return;
    const V = s.getPaintProperty("text-color"), w = !V || V.isDataDriven || V.getValue(d2)[3] > 0, A = s.getPaintProperty("text-halo-width"), L2 = s.getPaintProperty("text-halo-color"), O = (!A || A.isDataDriven || A.getValue(d2) > 0) && (!L2 || L2.isDataDriven || L2.getValue(d2)[3] > 0);
    if (!w && !O)
      return;
    const N = 24 / 8;
    let z = s.getLayoutValue("text-rotation-alignment", d2);
    z === l.AUTO && (z = s.getLayoutValue("symbol-placement", d2) === n2.POINT ? l.VIEWPORT : l.MAP);
    const k = z === l.MAP, b = s.getLayoutValue("text-keep-upright", d2) && k, G = g === T.HITTEST, j = 0.8 * N / M2;
    this._glyphTextureSize || (this._glyphTextureSize = t(_3.width / 4, _3.height / 4));
    const W = s.getPaintValue("text-translate", d2), F2 = s.getPaintValue("text-translate-anchor", d2), B = this._sdfProgramOptions;
    B.id = G;
    const H = D.getMaterialProgram(c4, x, B);
    if (v && null != E2 && !H.compiled)
      return void E2();
    c4.useProgram(H), H.setUniformMatrix3fv("u_displayViewMat3", z === l.MAP ? T2.displayViewMat3 : T2.displayMat3), H.setUniformMatrix3fv("u_displayMat3", F2 === r.VIEWPORT ? T2.displayMat3 : T2.displayViewMat3), H.setUniform2fv("u_textTranslation", W), H.setUniform1f("u_depth", s.z + y), H.setUniform2fv("u_mosaicSize", this._glyphTextureSize), H.setUniform1f("u_mapRotation", c2(T2.rotation)), H.setUniform1f("u_keepUpright", b ? 1 : 0), H.setUniform1f("u_level", 10 * d2), H.setUniform1i("u_texture", re), H.setUniform1f("u_antialiasingWidth", j), H.setUniform1f("u_fadeDuration", e / 1e3), G && H.setUniform4fv("u_id", p);
    let C2 = -1;
    for (const t3 of u3) {
      if (!t3.layerData.has(U))
        continue;
      if (t3.key.level !== C2 && (C2 = t3.key.level, x.setDataUniforms(H, d2, s, C2, P)), I2 = t3.layerData.get(U), 0 === I2.glyphPerPageElementsMap.size)
        continue;
      I2.prepareForRendering(c4), I2.updateOpacityInfo();
      const e4 = I2.textVAO;
      if (null == e4)
        continue;
      c4.bindVAO(e4), H.setUniformMatrix3fv("u_dvsMat3", t3.transforms.dvs), c4.setStencilTestEnabled(true), c4.setStencilFunction(I.GREATER, 255, 255), c4.setStencilWriteMask(0);
      const i = (performance.now() - I2.lastOpacityUpdate) / 1e3;
      H.setUniform1f("u_time", i), I2.glyphPerPageElementsMap.forEach((e5, i2) => {
        this._renderGlyphRange(c4, e5, i2, _3, H, O, w, t3);
      });
    }
  }
  _renderGlyphRange(e3, t3, i, a, r3, n3, s, l2) {
    a.bind(e3, L.LINEAR, i, re), n3 && (r3.setUniform1f("u_halo", 1), e3.drawElements(E.TRIANGLES, t3[1], C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * t3[0]), l2.triangleCount += t3[1] / 3), s && (r3.setUniform1f("u_halo", 0), e3.drawElements(E.TRIANGLES, t3[1], C.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * t3[0]), l2.triangleCount += t3[1] / 3);
  }
};

export {
  t2 as t,
  _,
  o,
  d,
  f,
  _2
};
//# sourceMappingURL=chunk-3MPC6MVT.js.map
