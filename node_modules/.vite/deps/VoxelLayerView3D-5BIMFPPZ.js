import {
  i
} from "./chunk-N5A7N3L3.js";
import {
  n as n2
} from "./chunk-XGIDQJNQ.js";
import {
  d
} from "./chunk-TYEEWKIN.js";
import "./chunk-BFVDDR4R.js";
import "./chunk-F4ILXEXC.js";
import "./chunk-NVGPNIR6.js";
import "./chunk-VMTVUE47.js";
import "./chunk-GDZM4A6K.js";
import {
  Hn
} from "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import "./chunk-W4KI5YEI.js";
import "./chunk-7EG7BYWF.js";
import {
  P,
  h as h2
} from "./chunk-AQ7R6V4L.js";
import "./chunk-4BXK4H4L.js";
import "./chunk-SLVNG7FV.js";
import "./chunk-DEZCXTA3.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-HXPVVSLV.js";
import "./chunk-4OR73Y2R.js";
import "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import {
  _,
  o,
  z
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-3VUFACNT.js";
import {
  f
} from "./chunk-ZEEBL7ZN.js";
import {
  S2 as S
} from "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import {
  h,
  l
} from "./chunk-H7RDAEPY.js";
import "./chunk-7KH4CLS5.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-JL3TJGVW.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import {
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import "./chunk-7I33FAWS.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/3d/layers/VoxelLayerView3D.js
var w;
!function(e2) {
  e2[e2.API = 1] = "API", e2[e2.VerboseAPI = 2] = "VerboseAPI", e2[e2.Error = 3] = "Error";
}(w || (w = {}));
var v = n();
var W = n();
var f2 = class extends i(n2(d)) {
  constructor() {
    super(...arguments), this._suspendedHandle = null, this._usedMemory = 0, this._futureMemory = 0, this.type = "voxel-3d", this.slicePlaneEnabled = false, this._wasmLayerId = -1, this.ignoresMemoryFactor = true, this._dbgFlags = /* @__PURE__ */ new Set();
  }
  get baseUrl() {
    var _a;
    return ((_a = this.layer.parsedUrl) == null ? void 0 : _a.path) ?? "";
  }
  get wasmLayerId() {
    return this._wasmLayerId;
  }
  initialize() {
    var _a;
    if (this._dbgFlags.add(w.Error), "local" !== this.view.viewingMode)
      throw new s2("voxel:unsupported-viewingMode", "Voxel layers support local viewingMode only.", {});
    if (!!!((_a = this.view._stage.renderView.renderingContext.capabilities.colorBufferFloat) == null ? void 0 : _a.textureFloat))
      throw new s2("voxel:missing-color-buffer-float", "Voxel layers require the WebGL2 extension EXT_color_buffer_float", {});
    const e2 = this.layer.spatialReference;
    if (!S(e2, this.view.spatialReference))
      throw new s2("layerview:spatial-reference-incompatible", "The spatial reference of this scene layer is incompatible with the spatial reference of the view", {});
    const t = this.layer.currentVariableId, o2 = this.layer.getVolume(t), r = this.layer.getVariable(t);
    if (null != o2 && null != r) {
      const e3 = o2.dimensions[0], s3 = o2.dimensions[1], t2 = o2.zDimension;
      if (t2 > 1) {
        const i2 = o2.dimensions[t2], a2 = e3.size * s3.size * i2.size;
        let l3 = 1;
        switch (r.renderingFormat.type) {
          case "Int16":
          case "UInt16":
            l3 = 2;
            break;
          case "Int32":
          case "UInt32":
          case "Float32":
            l3 = 4;
        }
        this._futureMemory = l3 * a2;
      }
    }
    const l2 = this.view.addVoxelLayerViewToWasm(this).then((e3) => {
      this._wasmLayerId = e3, this._suspendedHandle = l(() => this.suspended, (e4) => {
        const s3 = this.view.voxelWasm;
        null != s3 && s3.setEnabled(this, !e4);
      }, h), this.handles.add([l(() => this.layer.renderMode, (e4) => this._pushRenderModeToWasm(e4)), l(() => this.layer.currentVariableId, (e4) => this._pushCurrentVariableIdToWasm(e4)), l(() => this.layer.getSections(), (e4) => this._pushSectionsToWasm(e4)), l(() => this.layer.getVariableStyles(), (e4) => this._pushVariableStylesToWasm(e4)), l(() => this.layer.getVolumeStyles(), (e4) => this._pushVolumeStylesToWasm(e4)), l(() => this.layer.enableDynamicSections, (e4) => this._pushEnableDynamicSectionsToWasm(e4)), l(() => this.layer.enableIsosurfaces, (e4) => this._pushEnableIsosurfacesToWasm(e4)), l(() => this.layer.enableSections, (e4) => this._pushEnableSectionsToWasm(e4)), l(() => this.layer.enableSlices, (e4) => this._pushEnableSlicesToWasm(e4)), l(() => this.slicePlaneEnabled, (e4) => this._pushAnalysisSliceToWasm(e4, this.view.slicePlane)), l(() => this.view.slicePlane, (e4) => this._pushAnalysisSliceToWasm(this.slicePlaneEnabled, e4))]);
    }).catch((e3) => {
      if (this.view.removeVoxelLayerViewFromWasm(this), this._wasmLayerId = -1, -1 === e3)
        throw new s2("voxel:addLayer-failure", "The voxel layer description was invalid.", {});
      if (-2 === e3)
        throw new s2("voxel:addLayer-failure", "The voxel layer web assembly module failed to download.", {});
    });
    this.addResolvingPromise(l2);
  }
  destroy() {
    this.view.removeVoxelLayerViewFromWasm(this), this._suspendedHandle && (this._suspendedHandle.remove(), this._suspendedHandle = null);
  }
  isUpdating() {
    const e2 = this.view.voxelWasm;
    return !(this._wasmLayerId < 0 || null == e2) && e2.isUpdating(this._wasmLayerId);
  }
  updatingFlagChanged() {
    this.notifyChange("updating");
  }
  get usedMemory() {
    return this._usedMemory;
  }
  get unloadedMemory() {
    return this._futureMemory;
  }
  get performanceInfo() {
    return { nodes: 0, displayedNumberOfFeatures: 0, maximumNumberOfFeatures: 0, totalNumberOfFeatures: 0, core: null };
  }
  whenGraphicBounds(e2, s3) {
    const t = e2.attributes["Voxel.WorldPosition"];
    if (t) {
      const e3 = P(), s4 = JSON.parse(t);
      if (Hn(s4, this.view.renderSpatialReference, W, this.view.spatialReference || f.WGS84))
        return h2(e3, W), Promise.resolve({ boundingBox: e3, screenSpaceObjects: [] });
    }
    return Promise.reject();
  }
  setUsedMemory(e2) {
    this._usedMemory = e2, this._futureMemory = 0;
  }
  captureFrustum() {
    const e2 = this.view.voxelWasm;
    null != e2 && e2.captureFrustum();
  }
  toggleFullVolumeExtentDraw() {
    const e2 = this.view.voxelWasm;
    null != e2 && e2.toggleFullVolumeExtentDraw(this);
  }
  getLayerTimes() {
    let e2 = [];
    const s3 = this.view.voxelWasm;
    return null != s3 && (e2 = s3.getLayerTimes(this)), e2;
  }
  getCurrentLayerTimeIndex() {
    let e2 = 0;
    const s3 = this.view.voxelWasm;
    return null != s3 && (e2 = s3.getCurrentLayerTimeIndex(this)), e2;
  }
  _pushRenderModeToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(w.VerboseAPI, "VoxelLayerView3D._pushRenderModeToWasm() called, " + (s3 ? "have WASM" : "don't have WASM!!!"));
    null != s3 && s3.setRenderMode(this, e2) || this._dbg(w.Error, "VoxelLayerView3D._pushRenderModeToWasm() failed!");
  }
  _pushSectionsToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(w.VerboseAPI, "VoxelLayerView3D._pushSectionsToWasm() called, " + (s3 ? "have WASM" : "don't have WASM!!!"));
    null != s3 && s3.setStaticSections(this, e2) || this._dbg(w.Error, "VoxelLayerView3D._pushSectionsToWasm() failed!");
  }
  _pushCurrentVariableIdToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(w.VerboseAPI, "VoxelLayerView3D._pushCurrentVariableIdToWasm() called!, " + (null != s3 ? "have WASM" : "don't have WASM!!!"));
    null != s3 && s3.setCurrentVariable(this, e2) || this._dbg(w.Error, "VoxelLayerView3D._pushCurrentVariableIdToWasm() failed!");
  }
  _pushVariableStylesToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(w.VerboseAPI, "VoxelLayerView3D._pushVariableStylesToWasm() called, " + (s3 ? "have WASM" : "don't have WASM!!!"));
    let t = false;
    null != s3 && (t = s3.setVariableStyles(this, e2), t || this._dbg(w.Error, "VoxelLayerView3D._pushVariableStylesToWasm() failed!"));
  }
  _accountForEnableSlices(e2, s3) {
    const t = null != s3 ? s3 : this.layer.enableSlices;
    for (let i2 = 0; i2 < e2.length; ++i2) {
      const s4 = e2[i2];
      for (const e3 of s4.slices)
        e3.enabled = e3.enabled && t;
    }
  }
  _pushVolumeStylesToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(w.VerboseAPI, "VoxelLayerView3D._pushVolumeStylesToWasm() called, " + (s3 ? "have WASM" : "don't have WASM!!!"));
    let t = false;
    null != s3 && (this._accountForEnableSlices(e2, null), t = s3.setVolumeStyles(this, e2), t || this._dbg(w.Error, "VoxelLayerView3D._pushVolumeStylesToWasm() failed!"));
  }
  _pushAnalysisSliceToWasm(e2, s3) {
    const t = this.view.voxelWasm;
    this._dbg(w.VerboseAPI, "VoxelLayerView3D._pushAnalysisSliceToWasm() called, " + (t ? "have WASM" : "don't have WASM!!!"));
    let i2 = false;
    if (null != t) {
      if (null != s3) {
        const a2 = s3.origin;
        _(v, s3.basis1, s3.basis2), z(v, v), i2 = t.setAnalysisSlice(this, e2, a2, v);
      } else
        o(v, 0, 0, 1), i2 = t.setAnalysisSlice(this, false, v, v);
      i2 || this._dbg(w.Error, "VoxelLayerView3D._pushAnalysisSliceToWasm() failed!");
    }
  }
  _pushEnableDynamicSectionsToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(w.VerboseAPI, "VoxelLayerView3D._pushEnableDynamicSectionsToWasm() called, " + (null != s3 ? "have WASM" : "don't have WASM!!!"));
    let t = false;
    null != s3 && (t = s3.setEnableDynamicSections(this, e2), t || this._dbg(w.Error, "VoxelLayerView3D._pushEnableDynamicSectionsToWasm() failed!"));
  }
  _pushEnableSlicesToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(w.VerboseAPI, "VoxelLayerView3D._pushEnableSlicesToWasm() called, " + (s3 ? "have WASM" : "don't have WASM!!!"));
    let t = false;
    if (null != s3) {
      const i2 = this.layer.getVolumeStyles();
      this._accountForEnableSlices(i2, e2), t = s3.setVolumeStyles(this, i2), t || this._dbg(w.Error, "VoxelLayerView3D._pushEnableSlicesToWasm() failed!");
    }
  }
  _pushEnableIsosurfacesToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(w.VerboseAPI, "VoxelLayerView3D._pushEnableIsosurfacesToWasm() called, " + (null != s3 ? "have WASM" : "don't have WASM!!!"));
    let t = false;
    null != s3 && (t = s3.setEnableIsosurfaces(this, e2), t || this._dbg(w.Error, "VoxelLayerView3D._pushEnableIsosurfacesToWasm() failed!"));
  }
  _pushEnableSectionsToWasm(e2) {
    const s3 = this.view.voxelWasm;
    this._dbg(w.VerboseAPI, "VoxelLayerView3D._pushEnableSectionsToWasm() called, " + (s3 ? "have WASM" : "don't have WASM!!!"));
    let t = false;
    null != s3 && (t = s3.setEnableSections(this, e2), t || this._dbg(w.Error, "VoxelLayerView3D._pushEnableSectionsToWasm() failed!"));
  }
  async whenGraphicAttributes(e2, s3) {
    return e2;
  }
  _dbg(e2, s3) {
    this._dbgFlags.has(e2) && (e2 === w.Error ? s.getLogger(this).error(s3) : s.getLogger(this).warn(s3));
  }
};
e([y()], f2.prototype, "layer", void 0), e([y()], f2.prototype, "baseUrl", null), e([y({ type: Boolean })], f2.prototype, "slicePlaneEnabled", void 0), f2 = e([a("esri.views.3d.layers.VoxelLayerView3D")], f2);
var g = f2;
export {
  g as default
};
//# sourceMappingURL=VoxelLayerView3D-5BIMFPPZ.js.map
