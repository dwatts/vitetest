import {
  s as s3
} from "./chunk-R5Y2SULF.js";
import {
  n as n5
} from "./chunk-WON6TZX6.js";
import {
  n as n4
} from "./chunk-OLCZX7MC.js";
import {
  b
} from "./chunk-ERFCZMKG.js";
import {
  i as i3,
  r as r3
} from "./chunk-FJA4J75M.js";
import {
  f as f2,
  i as i2,
  s as s2
} from "./chunk-X3YW4YOG.js";
import {
  n as n3,
  p as p2
} from "./chunk-BFVDDR4R.js";
import {
  n as n2
} from "./chunk-CMNAZRWU.js";
import {
  h
} from "./chunk-XWGNMTES.js";
import {
  c
} from "./chunk-CAFGOFIE.js";
import {
  y as y2
} from "./chunk-JNDFAMXY.js";
import {
  F,
  i as i4
} from "./chunk-4BXK4H4L.js";
import {
  V
} from "./chunk-7EQSYZHW.js";
import {
  n
} from "./chunk-GGOVZ2GK.js";
import {
  i
} from "./chunk-HIPTG7BJ.js";
import {
  p,
  v as v2
} from "./chunk-HXPVVSLV.js";
import {
  M
} from "./chunk-3VUFACNT.js";
import {
  f
} from "./chunk-ZEEBL7ZN.js";
import {
  H,
  o,
  r as r2
} from "./chunk-RTDN6KAT.js";
import {
  a as a2
} from "./chunk-H7RDAEPY.js";
import {
  j as j2
} from "./chunk-43LWRDQS.js";
import {
  l
} from "./chunk-MP6GH2AC.js";
import {
  m,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a,
  e as e2
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  r,
  v
} from "./chunk-3R7FAT25.js";
import {
  j,
  k
} from "./chunk-7I33FAWS.js";
import {
  s3 as s
} from "./chunk-HMVAPW5X.js";
import {
  R,
  has
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/rest/operations/identify.js
var s4 = (e3) => e3.spatialReference.wkid || JSON.stringify(e3.spatialReference);
function l2(e3, t) {
  const { dpi: i5, gdbVersion: n6, geometry: l3, geometryPrecision: a6, height: f4, layerOption: p4, mapExtent: m5, maxAllowableOffset: y3, returnFieldName: u3, returnGeometry: c2, returnUnformattedValues: d, returnZ: g, spatialReference: x, timeExtent: b2, tolerance: h2, width: E } = e3.toJSON(), { dynamicLayers: O, layerDefs: S2, layerIds: N } = o2(e3), j3 = t && null != t.geometry ? t.geometry : null, J = { geometryPrecision: a6, maxAllowableOffset: y3, returnFieldName: u3, returnGeometry: c2, returnUnformattedValues: d, returnZ: g, tolerance: h2 }, R3 = j3 && j3.toJSON() || l3;
  if (J.imageDisplay = `${E},${f4},${i5}`, n6 && (J.gdbVersion = n6), R3 && (delete R3.spatialReference, J.geometry = JSON.stringify(R3), J.geometryType = v2(R3)), x ? J.sr = x.wkid || JSON.stringify(x) : R3 && R3.spatialReference ? J.sr = s4(R3) : m5 && m5.spatialReference && (J.sr = s4(m5)), J.time = b2 ? [b2.start, b2.end].join(",") : null, m5) {
    const { xmin: e4, ymin: r4, xmax: t2, ymax: i6 } = m5;
    J.mapExtent = `${e4},${r4},${t2},${i6}`;
  }
  return S2 && (J.layerDefs = S2), O && !S2 && (J.dynamicLayers = O), J.layers = "popup" === p4 ? "visible" : p4, N && !O && (J.layers += `:${N.join(",")}`), J;
}
function o2(e3) {
  var _a, _b;
  const { mapExtent: r4, floors: s5, width: l3, sublayers: o3, layerIds: f4, layerOption: p4, gdbVersion: m5 } = e3, y3 = (_b = (_a = o3 == null ? void 0 : o3.find((e4) => null != e4.layer)) == null ? void 0 : _a.layer) == null ? void 0 : _b.serviceSublayers, u3 = "popup" === p4, c2 = {}, d = i3({ extent: r4, width: l3, spatialReference: r4 == null ? void 0 : r4.spatialReference }), g = [], x = (e4) => {
    const r5 = 0 === d, t = 0 === e4.minScale || d <= e4.minScale, i5 = 0 === e4.maxScale || d >= e4.maxScale;
    if (e4.visible && (r5 || t && i5))
      if (e4.sublayers)
        e4.sublayers.forEach(x);
      else {
        if (false === (f4 == null ? void 0 : f4.includes(e4.id)) || u3 && (!e4.popupTemplate || !e4.popupEnabled))
          return;
        g.unshift(e4);
      }
  };
  if (o3 == null ? void 0 : o3.forEach(x), o3 && !g.length)
    c2.layerIds = [];
  else {
    const e4 = n4(g, y3, m5), r5 = g.map((e5) => {
      const r6 = n5(s5, e5);
      return e5.toExportImageJSON(r6);
    });
    if (e4)
      c2.dynamicLayers = JSON.stringify(r5);
    else {
      if (o3) {
        let e6 = g.map(({ id: e7 }) => e7);
        f4 && (e6 = e6.filter((e7) => f4.includes(e7))), c2.layerIds = e6;
      } else
        (f4 == null ? void 0 : f4.length) && (c2.layerIds = f4);
      const e5 = a3(s5, g);
      if (null != e5 && e5.length) {
        const r6 = {};
        for (const t of e5)
          t.definitionExpression && (r6[t.id] = t.definitionExpression);
        Object.keys(r6).length && (c2.layerDefs = JSON.stringify(r6));
      }
    }
  }
  return c2;
}
function a3(r4, t) {
  const n6 = !!(r4 == null ? void 0 : r4.length), s5 = t.filter((e3) => null != e3.definitionExpression || n6 && null != e3.floorInfo);
  return s5.length ? s5.map((t2) => {
    const n7 = n5(r4, t2), s6 = n2(n7, t2.definitionExpression);
    return { id: t2.id, definitionExpression: s6 ?? void 0 };
  }) : null;
}

// node_modules/@arcgis/core/rest/support/IdentifyParameters.js
var m2;
var a4 = m2 = class extends l {
  static from(t) {
    return v(m2, t);
  }
  constructor(t) {
    super(t), this.dpi = 96, this.floors = null, this.gdbVersion = null, this.geometry = null, this.geometryPrecision = null, this.height = 400, this.layerIds = null, this.layerOption = "top", this.mapExtent = null, this.maxAllowableOffset = null, this.returnFieldName = true, this.returnGeometry = false, this.returnM = false, this.returnUnformattedValues = true, this.returnZ = false, this.spatialReference = null, this.sublayers = null, this.timeExtent = null, this.tolerance = null, this.width = 400;
  }
};
e([y({ type: Number, json: { write: true } })], a4.prototype, "dpi", void 0), e([y()], a4.prototype, "floors", void 0), e([y({ type: String, json: { write: true } })], a4.prototype, "gdbVersion", void 0), e([y({ types: n, json: { read: p, write: true } })], a4.prototype, "geometry", void 0), e([y({ type: Number, json: { write: true } })], a4.prototype, "geometryPrecision", void 0), e([y({ type: Number, json: { write: true } })], a4.prototype, "height", void 0), e([y({ type: [Number], json: { write: true } })], a4.prototype, "layerIds", void 0), e([y({ type: ["top", "visible", "all", "popup"], json: { write: true } })], a4.prototype, "layerOption", void 0), e([y({ type: M, json: { write: true } })], a4.prototype, "mapExtent", void 0), e([y({ type: Number, json: { write: true } })], a4.prototype, "maxAllowableOffset", void 0), e([y({ type: Boolean, json: { write: true } })], a4.prototype, "returnFieldName", void 0), e([y({ type: Boolean, json: { write: true } })], a4.prototype, "returnGeometry", void 0), e([y({ type: Boolean, json: { write: true } })], a4.prototype, "returnM", void 0), e([y({ type: Boolean, json: { write: true } })], a4.prototype, "returnUnformattedValues", void 0), e([y({ type: Boolean, json: { write: true } })], a4.prototype, "returnZ", void 0), e([y({ type: f, json: { write: true } })], a4.prototype, "spatialReference", void 0), e([y()], a4.prototype, "sublayers", void 0), e([y({ type: c, json: { write: true } })], a4.prototype, "timeExtent", void 0), e([y({ type: Number, json: { write: true } })], a4.prototype, "tolerance", void 0), e([y({ type: Number, json: { write: true } })], a4.prototype, "width", void 0), a4 = m2 = e([a("esri.rest.support.IdentifyParameters")], a4);
var u = a4;

// node_modules/@arcgis/core/rest/support/IdentifyResult.js
var u2 = class extends l {
  constructor(r4) {
    super(r4), this.displayFieldName = null, this.feature = null, this.layerId = null, this.layerName = null;
  }
  readFeature(r4, t) {
    return h.fromJSON({ attributes: { ...t.attributes }, geometry: { ...t.geometry } });
  }
  writeFeature(r4, e3) {
    if (!r4)
      return;
    const { attributes: t, geometry: o3 } = r4;
    t && (e3.attributes = { ...t }), null != o3 && (e3.geometry = o3.toJSON(), e3.geometryType = i.toJSON(o3.type));
  }
};
e([y({ type: String, json: { write: true } })], u2.prototype, "displayFieldName", void 0), e([y({ type: h })], u2.prototype, "feature", void 0), e([o("feature", ["attributes", "geometry"])], u2.prototype, "readFeature", null), e([r2("feature")], u2.prototype, "writeFeature", null), e([y({ type: Number, json: { write: true } })], u2.prototype, "layerId", void 0), e([y({ type: String, json: { write: true } })], u2.prototype, "layerName", void 0), u2 = e([a("esri.rest.support.IdentifyResult")], u2);
var m3 = u2;

// node_modules/@arcgis/core/rest/identify.js
async function f3(u3, i5, f4) {
  const c2 = (i5 = a5(i5)).geometry ? [i5.geometry] : [], l3 = f2(u3);
  return l3.path += "/identify", b(c2).then((e3) => {
    const t = l2(i5, { geometry: e3 && e3[0] }), u4 = s2({ ...l3.query, f: "json", ...t }), a6 = i2(u4, f4);
    return j2(l3.path, a6).then(m4).then((r4) => p3(r4, i5.sublayers));
  });
}
function m4(r4) {
  const e3 = r4.data;
  return e3.results = e3.results || [], e3.exceededTransferLimit = Boolean(e3.exceededTransferLimit), e3.results = e3.results.map((r5) => m3.fromJSON(r5)), e3;
}
function a5(r4) {
  return r4 = u.from(r4);
}
function p3(r4, e3) {
  if (!(e3 == null ? void 0 : e3.length))
    return r4;
  const t = /* @__PURE__ */ new Map();
  function o3(r5) {
    t.set(r5.id, r5), r5.sublayers && r5.sublayers.forEach(o3);
  }
  e3.forEach(o3);
  for (const s5 of r4.results)
    s5.feature.sourceLayer = t.get(s5.layerId);
  return r4;
}

// node_modules/@arcgis/core/views/layers/support/MapServiceLayerViewHelper.js
var P = null;
function S(e3, t) {
  return "tile" === t.type || "map-image" === t.type;
}
var U = class extends m {
  constructor(e3) {
    super(e3), this._featuresResolutions = /* @__PURE__ */ new WeakMap(), this.highlightGraphics = null, this.highlightGraphicUpdated = null, this.updateHighlightedFeatures = k(async (e4) => {
      this.destroyed || this.updatingHandles.addPromise(this._updateHighlightedFeaturesGeometries(e4).catch(() => {
      }));
    });
  }
  initialize() {
    const e3 = (e4) => {
      this.updatingHandles.addPromise(this._updateHighlightedFeaturesSymbols(e4).catch(() => {
      })), this.updateHighlightedFeatures(this._highlightGeometriesResolution);
    };
    this.addHandles([a2(() => this.highlightGraphics, "change", (t) => e3(t.added), { onListenerAdd: (t) => e3(t) })]);
  }
  async fetchPopupFeatures(e3, t) {
    var _a, _b;
    const { layerView: { layer: r4, view: { scale: s5 } } } = this;
    if (!e3)
      throw new s("fetchPopupFeatures:invalid-area", "Nothing to fetch without area", { layer: r4 });
    const i5 = _(r4.sublayers, s5, t);
    if (!i5.length)
      return [];
    const a6 = await A(r4, i5);
    if (!((((_b = (_a = r4.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsIdentify) ?? true) && r4.version >= 10.5) && !a6)
      throw new s("fetchPopupFeatures:not-supported", "query operation is disabled for this service", { layer: r4 });
    return a6 ? this._fetchPopupFeaturesUsingQueries(e3, i5, t) : this._fetchPopupFeaturesUsingIdentify(e3, i5, t);
  }
  clearHighlights() {
    var _a;
    (_a = this.highlightGraphics) == null ? void 0 : _a.removeAll();
  }
  highlight(e3) {
    const r4 = this.highlightGraphics;
    if (!r4)
      return { remove() {
      } };
    let o3 = null;
    if (e3 instanceof h ? o3 = [e3] : V.isCollection(e3) && e3.length > 0 ? o3 = e3.toArray() : Array.isArray(e3) && e3.length > 0 && (o3 = e3), o3 = o3 == null ? void 0 : o3.filter(R), !o3 || !o3.length)
      return e2();
    for (const t of o3) {
      const e4 = t.sourceLayer;
      null != e4 && "geometryType" in e4 && "point" === e4.geometryType && (t.visible = false);
    }
    return r4.addMany(o3), { remove: () => {
      r4.removeMany(o3 ?? []);
    } };
  }
  async _updateHighlightedFeaturesSymbols(e3) {
    const { layerView: { view: t }, highlightGraphics: r4, highlightGraphicUpdated: s5 } = this;
    if (r4 && s5)
      for (const i5 of e3) {
        const e4 = i5.sourceLayer && "renderer" in i5.sourceLayer && i5.sourceLayer.renderer;
        i5.sourceLayer && "geometryType" in i5.sourceLayer && "point" === i5.sourceLayer.geometryType && e4 && "getSymbolAsync" in e4 && e4.getSymbolAsync(i5).then(async (o3) => {
          var _a;
          o3 || (o3 = new y2());
          let a6 = null;
          const n6 = "visualVariables" in e4 ? (_a = e4.visualVariables) == null ? void 0 : _a.find((e5) => "size" === e5.type) : void 0;
          n6 && (P || (P = (await import("./visualVariableUtils-2EXVHBG2.js")).getSize), a6 = P(n6, i5, { view: t.type, scale: t.scale, shape: "simple-marker" === o3.type ? o3.style : null })), a6 || (a6 = "width" in o3 && "height" in o3 && null != o3.width && null != o3.height ? Math.max(o3.width, o3.height) : "size" in o3 ? o3.size : 16), r4.includes(i5) && (i5.symbol = new y2({ style: "square", size: a6, xoffset: "xoffset" in o3 ? o3.xoffset : 0, yoffset: "yoffset" in o3 ? o3.yoffset : 0 }), s5(i5, "symbol"), i5.visible = true);
        });
      }
  }
  async _updateHighlightedFeaturesGeometries(e3) {
    const { layerView: { layer: t, view: r4 }, highlightGraphics: s5, highlightGraphicUpdated: i5 } = this;
    if (this._highlightGeometriesResolution = e3, !i5 || !(s5 == null ? void 0 : s5.length) || !t.capabilities.operations.supportsQuery)
      return;
    const o3 = this._getTargetResolution(e3), a6 = /* @__PURE__ */ new Map();
    for (const c2 of s5)
      if (!this._featuresResolutions.has(c2) || this._featuresResolutions.get(c2) > o3) {
        const e4 = c2.sourceLayer;
        r(a6, e4, () => /* @__PURE__ */ new Map()).set(c2.getObjectId(), c2);
      }
    const l3 = Array.from(a6, ([e4, t2]) => {
      const s6 = e4.createQuery();
      return s6.objectIds = [...t2.keys()], s6.outFields = [e4.objectIdField], s6.returnGeometry = true, s6.maxAllowableOffset = o3, s6.outSpatialReference = r4.spatialReference, e4.queryFeatures(s6);
    }), p4 = await Promise.all(l3);
    if (!this.destroyed)
      for (const { features: n6 } of p4)
        for (const e4 of n6) {
          const t2 = e4.sourceLayer, r5 = a6.get(t2).get(e4.getObjectId());
          r5 && s5.includes(r5) && (r5.geometry = e4.geometry, i5(r5, "geometry"), this._featuresResolutions.set(r5, o3));
        }
  }
  _getTargetResolution(e3) {
    const t = e3 * H(this.layerView.view.spatialReference), r4 = t / 16;
    return r4 <= 10 ? 0 : e3 / t * r4;
  }
  async _fetchPopupFeaturesUsingIdentify(e3, t, r4) {
    const s5 = await this._createIdentifyParameters(e3, t, r4);
    if (null == s5)
      return [];
    const { results: i5 } = await f3(this.layerView.layer.parsedUrl, s5);
    return i5.map((e4) => e4.feature);
  }
  async _createIdentifyParameters(e3, t, r4) {
    const { floors: s5, layer: i5, timeExtent: o3, view: { spatialReference: a6, scale: n6 } } = this.layerView, l3 = null != r4 ? r4.event : null;
    if (!t.length)
      return null;
    await Promise.all(t.map(({ sublayer: e4 }) => e4.load().catch(() => {
    })));
    const p4 = Math.min(has("mapservice-popup-identify-max-tolerance"), i5.allSublayers.reduce((e4, t2) => t2.renderer ? s3({ renderer: t2.renderer, event: l3 }) : e4, 2)), c2 = this.createFetchPopupFeaturesQueryGeometry(e3, p4), u3 = r3(n6, a6), h2 = Math.round(c2.width / u3), y3 = new M({ xmin: c2.center.x - u3 * h2, ymin: c2.center.y - u3 * h2, xmax: c2.center.x + u3 * h2, ymax: c2.center.y + u3 * h2, spatialReference: c2.spatialReference });
    return new u({ floors: s5, gdbVersion: "gdbVersion" in i5 ? i5.gdbVersion : void 0, geometry: e3, height: h2, layerOption: "popup", mapExtent: y3, returnGeometry: true, spatialReference: a6, sublayers: i5.sublayers, timeExtent: o3, tolerance: p4, width: h2 });
  }
  async _fetchPopupFeaturesUsingQueries(e3, t, r4) {
    const { layerView: { floors: i5, timeExtent: o3 } } = this, a6 = null != r4 ? r4.event : null, n6 = t.map(async ({ sublayer: t2, popupTemplate: r5 }) => {
      var _a;
      if (await t2.load().catch(() => {
      }), t2.capabilities && !t2.capabilities.operations.supportsQuery)
        return [];
      const s5 = t2.createQuery(), n7 = s3({ renderer: t2.renderer, event: a6 }), l3 = this.createFetchPopupFeaturesQueryGeometry(e3, n7), p4 = /* @__PURE__ */ new Set(), [c2] = await Promise.all([n3(t2, r5), (_a = t2.renderer) == null ? void 0 : _a.collectRequiredFields(p4, t2.fieldsIndex)]);
      F(p4, t2.fieldsIndex, c2);
      const u3 = Array.from(p4).sort();
      if (s5.geometry = l3, s5.outFields = u3, s5.timeExtent = o3, i5) {
        const e4 = i5.clone(), r6 = n5(e4, t2);
        null != r6 && (s5.where = s5.where ? `(${s5.where}) AND (${r6})` : r6);
      }
      const h2 = this._getTargetResolution(l3.width / n7), y3 = await R2(r5), m5 = "point" === t2.geometryType || y3 && y3.arcadeUtils.hasGeometryOperations(r5);
      m5 || (s5.maxAllowableOffset = h2);
      let { features: f4 } = await t2.queryFeatures(s5);
      const b2 = m5 ? 0 : h2;
      f4 = await V2(t2, f4);
      for (const e4 of f4)
        this._featuresResolutions.set(e4, b2);
      return f4;
    });
    return (await j(n6)).reverse().reduce((e4, t2) => t2.value ? [...e4, ...t2.value] : e4, []).filter(R);
  }
};
function _(e3, t, r4) {
  const s5 = [], i5 = (e4) => {
    const o3 = 0 === e4.minScale || t <= e4.minScale, a6 = 0 === e4.maxScale || t >= e4.maxScale;
    if (e4.visible && o3 && a6) {
      if (e4.sublayers)
        e4.sublayers.forEach(i5);
      else if (e4.popupEnabled) {
        const t2 = p2(e4, { ...r4, defaultPopupTemplateEnabled: false });
        null != t2 && s5.unshift({ sublayer: e4, popupTemplate: t2 });
      }
    }
  };
  return ((e3 == null ? void 0 : e3.toArray()) ?? []).reverse().map(i5), s5;
}
function R2(e3) {
  var _a;
  return ((_a = e3.expressionInfos) == null ? void 0 : _a.length) || Array.isArray(e3.content) && e3.content.some((e4) => "expression" === e4.type) ? i4() : Promise.resolve();
}
async function A(e3, t) {
  var _a, _b;
  if ((_b = (_a = e3.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsQuery)
    return true;
  try {
    return await Promise.any(t.map(({ sublayer: e4 }) => e4.load().then(() => e4.capabilities.operations.supportsQuery)));
  } catch {
    return false;
  }
}
async function V2(e3, t) {
  const r4 = e3.renderer;
  return r4 && "defaultSymbol" in r4 && !r4.defaultSymbol && (t = r4.valueExpression ? await Promise.all(t.map((e4) => r4.getSymbolAsync(e4).then((t2) => t2 ? e4 : null))).then((e4) => e4.filter((e5) => null != e5)) : t.filter((e4) => null != r4.getSymbol(e4))), t;
}
e([y({ constructOnly: true })], U.prototype, "createFetchPopupFeaturesQueryGeometry", void 0), e([y({ constructOnly: true })], U.prototype, "layerView", void 0), e([y({ constructOnly: true })], U.prototype, "highlightGraphics", void 0), e([y({ constructOnly: true })], U.prototype, "highlightGraphicUpdated", void 0), e([y({ constructOnly: true })], U.prototype, "updatingHandles", void 0), U = e([a("esri.views.layers.support.MapService")], U);

export {
  S,
  U
};
//# sourceMappingURL=chunk-7LWWKPW7.js.map
