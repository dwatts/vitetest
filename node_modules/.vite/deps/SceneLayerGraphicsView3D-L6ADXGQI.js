import {
  i as i3,
  j,
  l as l3,
  p,
  r
} from "./chunk-IGOMD64Y.js";
import {
  i as i2
} from "./chunk-N5A7N3L3.js";
import {
  t2 as t6
} from "./chunk-6SPYK5IY.js";
import {
  D2 as D,
  ee
} from "./chunk-2HZ6BJUS.js";
import "./chunk-CKDYQJAJ.js";
import "./chunk-LJPYEVZC.js";
import "./chunk-ETXJI6IO.js";
import {
  _,
  c as c2
} from "./chunk-UK4ZDRLR.js";
import "./chunk-ULFDJHIR.js";
import "./chunk-ZCXCGUT2.js";
import "./chunk-PL4QGMLB.js";
import "./chunk-HBJAGP7O.js";
import "./chunk-KSNS4RYW.js";
import "./chunk-MYPCEJEE.js";
import "./chunk-F6PJCZPH.js";
import "./chunk-32IFRFHL.js";
import {
  n as n4
} from "./chunk-XGIDQJNQ.js";
import "./chunk-TYEEWKIN.js";
import "./chunk-ANLIVU2T.js";
import "./chunk-67UNUI4B.js";
import "./chunk-WON6TZX6.js";
import "./chunk-BM4PSBXP.js";
import "./chunk-EQRBSFVE.js";
import "./chunk-IMCUA6JI.js";
import "./chunk-NJB7437O.js";
import "./chunk-RZONPIMD.js";
import "./chunk-FAU6BZC4.js";
import "./chunk-D6UIL3LF.js";
import "./chunk-B5TYSRH2.js";
import "./chunk-XBN7M5OG.js";
import "./chunk-BPITJIFG.js";
import "./chunk-3BTM6YO4.js";
import "./chunk-6OVHX5ZO.js";
import "./chunk-N6RC4PHI.js";
import "./chunk-CPHFVZ42.js";
import "./chunk-LLQHB2ZB.js";
import "./chunk-CFEAJLOI.js";
import "./chunk-RBDJB3ZY.js";
import "./chunk-RRRAGAMB.js";
import "./chunk-ERFCZMKG.js";
import "./chunk-C2GW4T2D.js";
import "./chunk-FLA7Z76H.js";
import "./chunk-LFQ3TKCC.js";
import "./chunk-ZD5B6I7X.js";
import "./chunk-HAYOKZGJ.js";
import "./chunk-SO7CVIZK.js";
import "./chunk-FJYIB7HF.js";
import "./chunk-23N5B2NF.js";
import "./chunk-BUKSB3RJ.js";
import "./chunk-7FGF24AQ.js";
import "./chunk-YOWAMJJI.js";
import "./chunk-PFDC65N2.js";
import "./chunk-6HOJZLKI.js";
import "./chunk-ZIIRSX6D.js";
import "./chunk-JQKL7AD5.js";
import "./chunk-6WY3ZZYN.js";
import {
  c
} from "./chunk-CS6BZGQO.js";
import "./chunk-YZTKL3LQ.js";
import "./chunk-I7EXY23J.js";
import "./chunk-SCHIU6CT.js";
import "./chunk-XXN3TEOU.js";
import "./chunk-FIJZ6LYC.js";
import "./chunk-MUANV6E3.js";
import "./chunk-SFIT2AUF.js";
import "./chunk-DBIFU6GO.js";
import "./chunk-V33FVMPT.js";
import "./chunk-U67EYFX3.js";
import "./chunk-5GYSL2SB.js";
import "./chunk-3NWIYHNX.js";
import "./chunk-PLKG3UR7.js";
import "./chunk-BD4RGMMN.js";
import "./chunk-4BA5YJ7C.js";
import "./chunk-LBRZG7XH.js";
import {
  t as t5
} from "./chunk-644IM3NW.js";
import "./chunk-TE7N6C3J.js";
import "./chunk-WRC5WFEM.js";
import "./chunk-UYTAZUBJ.js";
import {
  C
} from "./chunk-2EO2WRP7.js";
import "./chunk-IAWQREMS.js";
import "./chunk-EPDLDPS4.js";
import "./chunk-NBYHM3OO.js";
import "./chunk-CERU5LKM.js";
import "./chunk-JZVYLVFO.js";
import "./chunk-FAOMDC3K.js";
import "./chunk-SCAYUERS.js";
import "./chunk-B76MSEZ4.js";
import "./chunk-ZYHVS2T2.js";
import "./chunk-XYSQCP5F.js";
import "./chunk-W5D3JTKS.js";
import "./chunk-XACNEHDM.js";
import "./chunk-IRBH32SX.js";
import "./chunk-MPIXWRXJ.js";
import {
  o as o3
} from "./chunk-PC4A4CQR.js";
import "./chunk-VYGC2LVC.js";
import "./chunk-CXYYGJUL.js";
import "./chunk-FJA4J75M.js";
import "./chunk-AN3WFAN2.js";
import "./chunk-XKYCNHCM.js";
import "./chunk-YEDW7SLL.js";
import "./chunk-N4JKQR77.js";
import "./chunk-BDX5TRUE.js";
import "./chunk-LIXBKTBN.js";
import "./chunk-VDSNHCMM.js";
import "./chunk-6LC2JTLC.js";
import "./chunk-XM3YSFN6.js";
import "./chunk-NIZWDAMQ.js";
import "./chunk-DU3C7D26.js";
import "./chunk-YQALOTSV.js";
import "./chunk-T52K6PNI.js";
import "./chunk-UPDSQXLR.js";
import "./chunk-NOWEY45I.js";
import "./chunk-FNMOXP37.js";
import "./chunk-7BSXIYP2.js";
import "./chunk-ACTOBSLJ.js";
import "./chunk-XUU35WPC.js";
import "./chunk-6QR5R4JX.js";
import "./chunk-KSA6GV6M.js";
import "./chunk-K4WBDIIJ.js";
import "./chunk-ROPKVK6V.js";
import "./chunk-KM375BNF.js";
import "./chunk-H3DKDGMJ.js";
import "./chunk-FB6EWBGE.js";
import "./chunk-3TDCCT2R.js";
import "./chunk-CWXDLB2P.js";
import "./chunk-Z2RTGLQI.js";
import "./chunk-V6CD66ZZ.js";
import "./chunk-6FHMQNMS.js";
import "./chunk-5ZW42GDY.js";
import "./chunk-D7YAG5U3.js";
import "./chunk-LGDKASPG.js";
import "./chunk-YQDOKTNT.js";
import "./chunk-SH6HJSS2.js";
import "./chunk-KFDARCTS.js";
import "./chunk-TRGMWULG.js";
import "./chunk-WTPQKRQM.js";
import {
  t as t4
} from "./chunk-SMDDCTGQ.js";
import "./chunk-NU4UASX6.js";
import "./chunk-PKCLTDZO.js";
import "./chunk-4YXJLES6.js";
import "./chunk-EHQZFPMP.js";
import "./chunk-VC3BY3DV.js";
import "./chunk-WH76OAIT.js";
import "./chunk-B4ONZAW2.js";
import "./chunk-JHDKOKT6.js";
import "./chunk-YLTVH2K4.js";
import "./chunk-FB4A6PBH.js";
import "./chunk-CG3URTR2.js";
import "./chunk-UX3LCC3X.js";
import "./chunk-AB23UNQC.js";
import "./chunk-RDWKBYTH.js";
import "./chunk-IBJTEQQG.js";
import "./chunk-SADO52IH.js";
import "./chunk-WVOBJDWI.js";
import "./chunk-LIO6VZRI.js";
import "./chunk-7DFZCT3D.js";
import "./chunk-ASBUA7EG.js";
import "./chunk-FY4ZONHH.js";
import "./chunk-73PNWDTS.js";
import "./chunk-PKS3ZVLN.js";
import "./chunk-N3RXOITN.js";
import "./chunk-DOR4M5EA.js";
import "./chunk-3ROGWJVH.js";
import "./chunk-BUCIQGFS.js";
import "./chunk-CR5XNTAP.js";
import "./chunk-Z6IKMUOC.js";
import "./chunk-PV5KBAYL.js";
import "./chunk-YVVROPAO.js";
import "./chunk-2EWAI4LP.js";
import "./chunk-DNEN337Y.js";
import {
  h as h2
} from "./chunk-IWA3Q52A.js";
import "./chunk-4KPDZI74.js";
import "./chunk-WA4HIOYR.js";
import "./chunk-BFVOSCOB.js";
import "./chunk-QALEHGSZ.js";
import "./chunk-GYNE34WO.js";
import "./chunk-QS45OHBM.js";
import "./chunk-IVMJPIWO.js";
import "./chunk-3I3GE5YW.js";
import "./chunk-WRFNQB7U.js";
import "./chunk-UUW6REOV.js";
import "./chunk-2US5EKDI.js";
import "./chunk-Z3NHJA5D.js";
import "./chunk-BO2REVMA.js";
import "./chunk-V66LHQVK.js";
import "./chunk-UAIJDJWO.js";
import "./chunk-2CKXYQCA.js";
import "./chunk-JP7O2ZWE.js";
import "./chunk-4Y7ZTMES.js";
import "./chunk-ODTMOFOP.js";
import "./chunk-AHBQVOT4.js";
import "./chunk-Z6R62RNV.js";
import "./chunk-3LLZ72VA.js";
import "./chunk-4SIKLJSS.js";
import "./chunk-ALPCRJS4.js";
import "./chunk-WDZ5AAFL.js";
import "./chunk-XL7RF4A6.js";
import "./chunk-ZL3HOHNK.js";
import "./chunk-PR2OEILG.js";
import "./chunk-JPKFB2QL.js";
import "./chunk-KSBQD24F.js";
import {
  e as e2,
  t as t2
} from "./chunk-UM64E5NS.js";
import "./chunk-2SZNVP5H.js";
import {
  M,
  Z
} from "./chunk-2XKILFME.js";
import "./chunk-G4LSNP77.js";
import "./chunk-S5RIUWET.js";
import "./chunk-MVWFPLOX.js";
import "./chunk-X3YW4YOG.js";
import "./chunk-IG234GCS.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-BA6PBZHC.js";
import "./chunk-M7PTINEZ.js";
import "./chunk-Z7LZRT7C.js";
import "./chunk-SGBMUZSF.js";
import "./chunk-3TMT4LDG.js";
import "./chunk-OX5TJXHM.js";
import "./chunk-BDWD2ZNU.js";
import "./chunk-FF5LS3YE.js";
import "./chunk-BCDDCNQ2.js";
import "./chunk-FIBWCATC.js";
import "./chunk-D3BOGOKY.js";
import "./chunk-QOWAKGE4.js";
import {
  Z as Z2,
  fe,
  ge,
  ne,
  ye
} from "./chunk-SLMR4CTS.js";
import {
  t as t3
} from "./chunk-BFVDDR4R.js";
import "./chunk-XKENZ7D5.js";
import {
  R
} from "./chunk-GZTS5346.js";
import "./chunk-EK3Y2IYO.js";
import {
  s as s2
} from "./chunk-6S2FCH6S.js";
import "./chunk-BZL5MAFP.js";
import "./chunk-XY26YCFX.js";
import "./chunk-3TTW7E7W.js";
import "./chunk-FOEAKQNX.js";
import "./chunk-LEDSC236.js";
import "./chunk-NETCTS4Y.js";
import "./chunk-OKABUMQT.js";
import "./chunk-CW7LIPBH.js";
import "./chunk-TYOIANOD.js";
import "./chunk-VN2IXVGV.js";
import "./chunk-WWUAHPIM.js";
import "./chunk-BN6X2OXK.js";
import "./chunk-DZRIMGKU.js";
import {
  d
} from "./chunk-MRYR5ID7.js";
import "./chunk-EG6CFIHA.js";
import "./chunk-KE6VYSDW.js";
import "./chunk-XIYY37WZ.js";
import "./chunk-P4PDTNIU.js";
import "./chunk-CEFGWR5H.js";
import "./chunk-NX5NNI52.js";
import "./chunk-G2DTL6AE.js";
import "./chunk-Q6HN54VB.js";
import "./chunk-NDKDK4Y5.js";
import {
  b
} from "./chunk-O443WBFA.js";
import "./chunk-RGS3ANC3.js";
import "./chunk-Z3GCSCQI.js";
import "./chunk-PPNAO2PM.js";
import "./chunk-UU2XJGLA.js";
import "./chunk-CGJNVOU3.js";
import "./chunk-YA7WDOJK.js";
import "./chunk-IQRLZSBX.js";
import "./chunk-OZL6Q7O2.js";
import "./chunk-EV77QZBT.js";
import "./chunk-QZ6WR57P.js";
import "./chunk-467UETSR.js";
import "./chunk-SHFLRM67.js";
import "./chunk-YGUWDSEH.js";
import "./chunk-GOK4EI36.js";
import "./chunk-LO3LAMAS.js";
import "./chunk-ZWFMUHG3.js";
import "./chunk-EFRTD25L.js";
import "./chunk-EAGDM3GO.js";
import "./chunk-GSS6WNQU.js";
import "./chunk-C2EHS6UI.js";
import "./chunk-GZTLZ6RD.js";
import "./chunk-CEUJOC5P.js";
import "./chunk-F4ILXEXC.js";
import "./chunk-D5NSNTGJ.js";
import "./chunk-63ERNIOV.js";
import "./chunk-DTEODQ6R.js";
import "./chunk-5KLICR5E.js";
import {
  I
} from "./chunk-KRCNIFX2.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-M6OG7C2T.js";
import "./chunk-GOK5MP3B.js";
import "./chunk-NLWV7Q6F.js";
import "./chunk-DSWGERIY.js";
import "./chunk-Y2ZDD3I4.js";
import "./chunk-RVS5HU2K.js";
import "./chunk-JB7FDW5N.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-H37COY3W.js";
import "./chunk-NVGPNIR6.js";
import "./chunk-B4D7M7HT.js";
import "./chunk-3T2ETA25.js";
import "./chunk-5IYCCZ54.js";
import "./chunk-VMTVUE47.js";
import "./chunk-GDZM4A6K.js";
import {
  h as h3
} from "./chunk-XWGNMTES.js";
import "./chunk-6NNEHJYI.js";
import {
  Hn,
  yn
} from "./chunk-BNBT4QTW.js";
import {
  t
} from "./chunk-3FQOSG5O.js";
import "./chunk-W4KI5YEI.js";
import "./chunk-CAFGOFIE.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-JNDFAMXY.js";
import "./chunk-NTEKJWGF.js";
import "./chunk-TFIKV5RU.js";
import "./chunk-KW6QQDGN.js";
import "./chunk-AQ7R6V4L.js";
import "./chunk-DOQ3SAAR.js";
import "./chunk-4BXK4H4L.js";
import "./chunk-SLVNG7FV.js";
import "./chunk-OZXJDVTE.js";
import {
  m as m2
} from "./chunk-DTYFMKYK.js";
import "./chunk-7S7LC3XK.js";
import "./chunk-XR4HIGQP.js";
import "./chunk-KK5CYPXW.js";
import "./chunk-JNO3YVNK.js";
import "./chunk-DKJBDKGA.js";
import "./chunk-4CZO65BK.js";
import "./chunk-SVCGLUNW.js";
import "./chunk-3KEIFTQ6.js";
import "./chunk-DEZCXTA3.js";
import "./chunk-RRJGZKNX.js";
import "./chunk-PL5Q4C6Y.js";
import "./chunk-A6VKJXIH.js";
import "./chunk-KFSY6ZZH.js";
import "./chunk-7EQSYZHW.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import "./chunk-4OR73Y2R.js";
import "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import {
  o
} from "./chunk-TPJLFGOT.js";
import {
  n as n2
} from "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-2CTB7MKH.js";
import "./chunk-Z2ZUNW5S.js";
import "./chunk-7L7Z2HXM.js";
import "./chunk-75NKPXTR.js";
import "./chunk-EUVARFSM.js";
import {
  i,
  o as o2
} from "./chunk-3VUFACNT.js";
import "./chunk-ZEEBL7ZN.js";
import "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-5EXFDBQJ.js";
import "./chunk-57CHUY45.js";
import "./chunk-SJ2GJCS2.js";
import {
  h,
  l as l2
} from "./chunk-H7RDAEPY.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-S5OISW44.js";
import {
  n as n3
} from "./chunk-7KH4CLS5.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-JL3TJGVW.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import {
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import {
  n
} from "./chunk-3R7FAT25.js";
import "./chunk-7I33FAWS.js";
import {
  l
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  m,
  x
} from "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/3d/layers/I3SPointsWorkerHandle.js
var r2 = class extends h2 {
  constructor(e3) {
    super("SceneLayerWorker", "dracoDecompressPointCloudData", { dracoDecompressPointCloudData: (e4) => [e4.geometryBuffer] }, e3, { hasInitialize: true });
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SGraphicsMap.js
var s3 = class extends n3 {
  constructor(e3, t7) {
    super(), this._updateAndCompare = e3, this._notifyUpdated = t7, this._nodes = /* @__PURE__ */ new Map(), this._graphics = /* @__PURE__ */ new Map(), this._duplicates = /* @__PURE__ */ new Map();
  }
  clear() {
    if (this._graphics.size > 0) {
      const e3 = this.toArray();
      this._graphics.clear(), this.emit("change", { added: [], removed: e3 });
    }
    this._nodes.clear();
  }
  get length() {
    return this._graphics.size;
  }
  get(e3) {
    return this._graphics.get(e3);
  }
  getNode(e3) {
    return this._nodes.get(e3);
  }
  hasNode(e3) {
    return this._nodes.has(e3);
  }
  nodes() {
    return this._nodes.values();
  }
  addNode(e3, t7) {
    this._nodes.set(e3, t7);
    const s4 = t7.graphics;
    if (0 === s4.length)
      return;
    const n5 = /* @__PURE__ */ new Set();
    for (let i4 = 0; i4 < s4.length; i4++) {
      const t8 = s4[i4], o5 = t8.objectId, r3 = this._graphics.get(o5);
      if (r3) {
        n5.add(o5), t8 !== r3 && (s4[i4] = r3);
        const d2 = this._duplicates.get(o5);
        d2 ? d2.push(e3) : this._duplicates.set(o5, [r3.nodeIndex, e3]);
      } else
        t8.nodeIndex = e3, this._graphics.set(o5, t8);
    }
    n5.size && this._updateForeignGraphics(t7);
    const o4 = n5.size > 0 ? s4.filter((e4) => !n5.has(e4.objectId)) : s4;
    o4.length > 0 && this.emit("change", { added: o4, removed: [] });
  }
  removeNode(e3) {
    const t7 = this._nodes.get(e3);
    if (!t7)
      return void console.error("Removing unknown node");
    this._nodes.delete(e3);
    const s4 = /* @__PURE__ */ new Set(), n5 = [];
    for (const o4 of t7.graphics) {
      const t8 = o4.objectId, i4 = this._graphics.get(t8);
      if (!i4)
        continue;
      const r3 = this._duplicates.get(t8);
      if (r3) {
        const n6 = r3.indexOf(e3);
        if (-1 === n6) {
          console.error("error: removing graphic from node that should not reference it.");
          continue;
        }
        if (r3.splice(n6, 1), i4.nodeIndex === e3) {
          let e4 = this.getNode(r3[0]);
          for (let t9 = 1; t9 < r3.length; t9++) {
            const s5 = this.getNode(r3[t9]);
            (null == e4 || null != s5 && s5.node.level > e4.node.level) && (e4 = s5);
          }
          null != e4 && s4.add(e4);
        }
        1 === r3.length && this._duplicates.delete(t8);
      } else
        this._graphics.delete(t8), n5.push(o4);
    }
    n5.length > 0 && this.emit("change", { added: [], removed: n5 }), s4.forEach((e4) => this._updateForeignGraphics(e4));
  }
  _updateForeignGraphics(e3) {
    const t7 = [], s4 = e3.node.index, n5 = e3.node.level;
    let o4 = 0;
    for (; o4 < e3.graphics.length; ) {
      const i4 = e3.graphics[o4].nodeIndex;
      if (i4 === s4) {
        o4++;
        continue;
      }
      let r3 = 1;
      for (; o4 + r3 < e3.graphics.length && e3.graphics[o4 + r3].nodeIndex === i4; )
        r3++;
      const d2 = this.getNode(i4);
      if (null != d2 && d2.node.level > n5)
        o4 += r3;
      else {
        for (let n6 = o4; n6 < o4 + r3; n6++) {
          const o5 = e3.graphics[n6];
          o5.nodeIndex = s4, this._updateAndCompare(o5, e3, n6) && t7.push(o5);
        }
        o4 += r3;
      }
    }
    this._notifyUpdated(t7);
  }
  toArray() {
    return Array.from(this._graphics.values());
  }
  find(e3) {
    let s4;
    return n(this._graphics, (t7) => !!e3(t7) && (s4 = t7, true)), s4;
  }
  forEach(e3) {
    this._graphics.forEach((t7) => e3(t7));
  }
  forEachNode(e3) {
    this._nodes.forEach((t7, s4) => e3(t7, s4));
  }
  get nodeCount() {
    return this._nodes.size;
  }
  _checkInvariants() {
    const e3 = /* @__PURE__ */ new Map();
    this._nodes.forEach((t8, s4) => {
      s4 !== t8.node.index && console.error("Mismatched node index"), t8.graphics.forEach((t9) => {
        e3.set(t9.objectId, 1 + (e3.get(t9.objectId) ?? 0));
        const n5 = this._duplicates.get(t9.objectId);
        n5 && !n5.includes(s4) && console.error("Node not listed in duplicate list"), n5 || t9.nodeIndex === s4 || console.error("Unique graphic does not reference owning node index");
      });
    }), this._graphics.size !== e3.size && console.error("Mismatch between actual and expected number of graphics");
    let t7 = 0;
    e3.forEach((e4, s4) => {
      t7 += e4 > 1 ? 1 : 0;
      const n5 = this._graphics.get(s4);
      if (!n5)
        return void console.error("Missing graphic entry");
      const o4 = this._nodes.get(n5.nodeIndex);
      if (!o4)
        return void console.error("Graphic references unkown node");
      const i4 = this._duplicates.get(s4);
      i4 ? (i4.length !== e4 && console.error("Wrong number of entries in duplicate list"), i4.forEach((e5) => {
        const t8 = this._nodes.get(e5);
        t8 ? t8.node.level > o4.node.level && console.error("Duplicated graphic does not reference highest level node") : console.error("Unknown node in duplicate list");
      })) : e4 > 1 && console.error("Missing duplicates entry");
    }), this._duplicates.size !== t7 && console.error("Mismatch between expected and actual number of duplicate entries");
  }
};

// node_modules/@arcgis/core/views/3d/layers/SceneLayerGraphicsView3D.js
var J = i3();
var X = class {
  constructor(e3, t7, r3, i4) {
    this.graphics = e3, this.featureIds = t7, this.attributeInfo = r3, this.node = i4;
  }
};
var ee2 = class extends t6(i2(n4(j))) {
  constructor() {
    super(...arguments), this.type = "scene-layer-graphics-3d", this._queryEngine = null, this._memCache = null, this._interactiveEditingSessions = /* @__PURE__ */ new Map(), this.loadedGraphics = new s3((e3, t7, r3) => se(e3, t7, r3), (e3) => this.processor.graphicsCore.recreateGraphics(e3)), this.holeFilling = "always", this.progressiveLoadFactor = 1, this.supportsHeightUnitConversion = true, this._coordinatesOutsideExtentErrors = 0, this._maxCoordinatesOutsideExtentErrors = 20;
  }
  tryRecycleWith(e3, t7) {
    return e3.url === this.layer.url && this._i3sOverrides.isEmpty ? e3.load(t7).then(() => {
      var _a;
      ye(this.layer, e3, this._i3sOverrides), this.layer = e3, this._i3sOverrides.destroy();
      const t8 = (_a = this.view.resourceController) == null ? void 0 : _a.memoryController;
      this._i3sOverrides = new D({ view: this.view, layer: e3, memoryController: t8 }), l(this._queryEngine), this._setupQueryEngine(), this.processor.resetObjectStates();
    }) : null;
  }
  initialize() {
    var _a, _b;
    this.addResolvingPromise(this.layer.indexInfo);
    const e3 = (_a = this.view.resourceController) == null ? void 0 : _a.memoryController;
    this._i3sOverrides = new D({ view: this.view, layer: this.layer, memoryController: e3 }), ge(this.layer, this.view.spatialReference, this.view.viewingMode), this._fieldsHelper = new p({ layerView: this }), this.updatingHandles.add(() => this.layer.rangeInfos, (e4) => this._rangeInfosChanged(e4), h), this.updatingHandles.add(() => this.layer.renderer, (e4, t7) => this._rendererChange(e4, t7)), this.updatingHandles.add(() => [this.parsedDefinitionExpression, this._excludeObjectIdsSorted], () => this._filterChange()), this.handles.add(l2(() => t4.I3S_TREE_SHOW_TILES, (e4) => {
      if (e4 && !this._treeDebugger) {
        const e5 = this._controller.crsIndex;
        import("./I3STreeDebugger-A6VDXWTZ.js").then(({ I3STreeDebugger: t7 }) => {
          !this._treeDebugger && t4.I3S_TREE_SHOW_TILES && (this._treeDebugger = new t7({ lv: this, view: this.view, nodeSR: e5 }));
        });
      } else
        e4 || !this._treeDebugger || t4.I3S_TREE_SHOW_TILES || (this._treeDebugger.destroy(), this._treeDebugger = null);
    }, h)), this._set("processor", new _({ owner: this, preferredUpdatePolicy: C.ASYNC, scaleVisibilityEnabled: true, filterVisibilityEnabled: true, timeExtentEnabled: false, frustumVisibilityEnabled: false, elevationAlignmentEnabled: true, elevationFeatureExpressionEnabled: false, setUidToIdOnAdd: false, dataExtent: this.layer.fullExtent, updateClippingExtent: (e4) => this._updateClippingExtent(e4) })), (_b = this.processor.elevationAlignment) == null ? void 0 : _b.events.on("invalidate-elevation", (e4) => this._controller.updateElevationChanged(e4.extent, e4.spatialReference)), this.supportsHeightUnitConversion && (this._verticalScale = t("point", this.layer.spatialReference, this.view.spatialReference)), this.addResolvingPromise(this.processor.initializePromise), this._memCache = this.view.resourceController.memoryController.newCache(`psl-${this.uid}`), this._controller = new ee({ layerView: this, scaleVisibilityEnabled: false }), Z2(this.layer.geometryDefinitions) && (this._worker = new r2((e4) => this.view.resourceController.immediate.schedule(e4))), this.handles.add(this.layer.on("apply-edits", (e4) => this.updatingHandles.addPromise(e4.result))), this.handles.add(this.layer.on("edits", (e4) => this._handleEdits(e4))), this.when(() => {
      this._setupQueryEngine(), this.updatingHandles.add(() => this.maximumNumberOfFeatures, (e4) => this._controller.featureTarget = e4, h), this.updatingHandles.add(() => this.suspended, (e4) => {
        e4 && this._removeAllNodeData();
      });
    });
  }
  destroy() {
    this._treeDebugger = l(this._treeDebugger), this._i3sOverrides = l(this._i3sOverrides), this._set("processor", l(this.processor)), this._controller = l(this._controller), this._queryEngine = l(this._queryEngine), this._worker = l(this._worker), this._memCache = l(this._memCache), this.loadedGraphics.clear(), this._fieldsHelper = l(this._fieldsHelper);
  }
  get i3slayer() {
    return this.layer;
  }
  get updatingProgressValue() {
    var _a;
    return ((_a = this._controller) == null ? void 0 : _a.updatingProgress) ?? 1;
  }
  get requiredFields() {
    var _a;
    return ((_a = this._fieldsHelper) == null ? void 0 : _a.requiredFields) ?? [];
  }
  get maximumNumberOfFeatures() {
    var _a, _b;
    const e3 = (_b = (_a = this.processor) == null ? void 0 : _a.graphicsCore) == null ? void 0 : _b.displayFeatureLimit;
    return (e3 == null ? void 0 : e3.maximumNumberOfFeatures) ?? 0;
  }
  set maximumNumberOfFeatures(e3) {
    null != e3 ? (this._override("maximumNumberOfFeatures", e3), this._controller.fixedFeatureTarget = true) : (this._clearOverride("maximumNumberOfFeatures"), this._controller.fixedFeatureTarget = false);
  }
  get maximumNumberOfFeaturesExceeded() {
    var _a;
    return !this.suspended && (!!((_a = this._controller) == null ? void 0 : _a.useMaximumNumberOfFeatures) && !this._controller.leavesReached);
  }
  get _excludeObjectIdsSorted() {
    const e3 = this.layer.excludeObjectIds;
    return e3.length ? e3.toArray().sort((e4, t7) => e4 - t7) : null;
  }
  get lodFactor() {
    return "Labels" === this.layer.semantic ? 1 : this.view.qualitySettings.sceneService.point.lodFactor;
  }
  get hasM() {
    return false;
  }
  get hasZ() {
    return true;
  }
  get contentVisible() {
    var _a;
    return !this.suspended && !!((_a = this._controller) == null ? void 0 : _a.rootNodeVisible);
  }
  get legendEnabled() {
    var _a;
    return this.contentVisible && true === ((_a = this.i3slayer) == null ? void 0 : _a.legendEnabled);
  }
  async whenGraphicAttributes(e3, t7) {
    return ne(this.layer, e3, this._getObjectIdField(), t7, () => [...this.loadedGraphics.nodes()]);
  }
  getHit(e3) {
    if (!this.loadedGraphics)
      return null;
    const t7 = c(this.loadedGraphics.find((t8) => t8.uid === e3), this.layer), r3 = this._getObjectIdField();
    return t7 && t7.attributes && t7.attributes[r3] ? (t7.layer = this.layer, t7.sourceLayer = this.layer, { type: "graphic", graphic: t7, layer: t7.layer }) : null;
  }
  whenGraphicBounds(e3, t7) {
    return this.processor.whenGraphicBounds(e3, t7);
  }
  computeAttachmentOrigin(e3, t7) {
    return this.processor.computeAttachmentOrigin(e3, t7);
  }
  isUpdating() {
    var _a, _b, _c;
    return !!(((_a = this._controller) == null ? void 0 : _a.updating) || ((_b = this.processor) == null ? void 0 : _b.updating) || ((_c = this._fieldsHelper) == null ? void 0 : _c.updating) || this.layerFilterUpdating);
  }
  highlight(e3) {
    return this.processor.highlight(e3, this.layer.objectIdField);
  }
  get updatePolicy() {
    return this.processor.graphicsCore.effectiveUpdatePolicy;
  }
  createInteractiveEditSession(e3) {
    return r(this._attributeEditingContext, e3);
  }
  async _decompressBinaryPointData(e3, t7) {
    const r3 = { geometryBuffer: e3.geometryBuffer };
    null == this._worker && (this._worker = new r2((e4) => this.view.resourceController.immediate.schedule(e4)));
    const i4 = await this._worker.invoke(r3, t7);
    if (null == i4)
      throw new Error("Failed to decompress Draco point data");
    return { positionData: i4.positions, featureIds: i4.featureIds };
  }
  async addNode(e3, t7, r3) {
    var _a;
    if (!ie(t7) && !re(t7))
      throw new Error();
    if (this.loadedGraphics.hasNode(e3.index))
      return void s.getLogger(this).error("I3S node " + e3.id + " already added");
    const s4 = null != this.layer.fullExtent ? ae(this.layer.fullExtent.clone(), 0.5) : null, o4 = [], { featureIds: a2, pointPositions: n5 } = ie(t7) ? await this._extractBinaryPointPositions(e3, t7, r3) : this._extractLegacyPointPositions(t7);
    this._validatePositions(e3, a2, n5, s4, o4);
    const l4 = this._controller.crsVertex, d2 = this.view.spatialReference;
    yn(n5, l4, 0, n5, d2, 0, a2.length);
    const u = ie(t7) ? e3.level : 0, h4 = this._createGraphics(a2, n5, e3.index, u), p2 = new X(h4, a2, t7.attributeDataInfo, e3);
    if (await this._i3sOverrides.applyAttributeOverrides(p2.featureIds, t7.attributeDataInfo, r3), e3.numFeatures = p2.graphics.length, this._updateNodeMemory(e3), oe(p2), o4.length > 0 && (this._computeObb(e3, o4, l4), this._controller.updateVisibility(e3.index)), !this._controller.isGeometryVisible(e3))
      return void this._cacheNodeData(p2);
    if (null != this._verticalScale)
      for (const i4 of p2.graphics)
        this._verticalScale(i4.geometry);
    const g = this.view._stage.renderView.objectAndLayerIdRenderHelper;
    if (null != g) {
      const e4 = m2(this.view.map, this.layer.uid);
      for (let t8 = 0; t8 < p2.featureIds.length; t8++) {
        const r4 = p2.featureIds[t8];
        g.setUidToObjectAndLayerId(r4, p2.graphics[t8].uid, this.layer.id, this.layer.uid, this.layer.popupEnabled && !e4 && t3(this.layer, (_a = this.view.popup) == null ? void 0 : _a.defaultPopupTemplateEnabled), p2.node.resources.attributes, t8);
      }
    }
    this.loadedGraphics.addNode(e3.index, p2), this._controller.updateLoadStatus(e3.index, true), this._filterNode(p2), this._treeDebugger && this._treeDebugger.update();
  }
  _computeObb(e3, t7, r3) {
    const i4 = this._controller.crsIndex, s4 = i4.isGeographic ? this.view.renderSpatialReference : i4;
    yn(t7, r3, 0, t7, s4, 0, t7.length / 3), e3.serviceObb = R(new s2(t7, 3)), i4.isGeographic && Hn(e3.serviceObb.center, s4, e3.serviceObb.center, i4);
  }
  isNodeLoaded(e3) {
    return this.loadedGraphics.hasNode(e3);
  }
  isNodeReloading() {
    return false;
  }
  updateNodeState() {
  }
  async _extractBinaryPointPositions(e3, t7, r3) {
    const i4 = await this._decompressBinaryPointData(t7, r3), s4 = i4.positionData, o4 = 3, a2 = s4.length / o4, n5 = t2(3 * a2), l4 = null != e3.serviceObb ? e3.serviceObb.center : [0, 0, 0], d2 = Math.abs(l4[2]) * 2 ** -20;
    for (let u = 0; u < a2; u++) {
      const e4 = u * o4;
      n5[e4] = s4[e4] + l4[0], n5[e4 + 1] = s4[e4 + 1] + l4[1], n5[e4 + 2] = s4[e4 + 2] + l4[2], Math.abs(n5[e4 + 2]) < d2 && (n5[e4 + 2] = 0);
    }
    return { featureIds: i4.featureIds ? e2(i4.featureIds) : [], pointPositions: n5 };
  }
  _extractLegacyPointPositions(e3) {
    var _a, _b;
    const t7 = e3.pointData.length, r3 = t2(3 * t7), i4 = new Array();
    for (let s4 = 0; s4 < t7; s4++) {
      const t8 = e3.pointData[s4], o4 = t8.featureDataPosition, a2 = o4.length, n5 = ((_a = t8.geometries) == null ? void 0 : _a[0]) ?? ne2[a2], l4 = t8.featureIds[0];
      if ("Embedded" !== n5.type || "points" !== n5.params.type || a2 < 2 || a2 > 3)
        continue;
      const d2 = ((_b = n5.params.vertexAttributes) == null ? void 0 : _b.position) ?? [0, 0, 0], u = 3 * i4.length;
      r3[u] = o4[0] + d2[0], r3[u + 1] = o4[1] + d2[1], r3[u + 2] = 3 === a2 ? o4[2] + d2[2] : NaN, i4.push(l4);
    }
    return { featureIds: i4, pointPositions: r3 };
  }
  _validatePositions(e3, t7, r3, s4, o4) {
    if (null == s4 && e3.serviceObb)
      return;
    const a2 = t7.length, n5 = 3;
    for (let l4 = 0; l4 < a2; l4++) {
      const t8 = l4 * n5;
      o(le, r3[t8], r3[t8 + 1], r3[t8 + 2]);
      const a3 = !Number.isNaN(r3[2]);
      null == s4 || (a3 ? o2(s4, le) : i(s4, le)) || (this._coordinatesOutsideExtentErrors < this._maxCoordinatesOutsideExtentErrors && s.getLogger(this).error("Service Error: Coordinates outside of layer extent"), this._coordinatesOutsideExtentErrors + 1 === this._maxCoordinatesOutsideExtentErrors && s.getLogger(this).error("Maximum number of errors reached. Further errors are ignored."), this._coordinatesOutsideExtentErrors++), e3.serviceObb || o4.push(le[0], le[1], le[2]);
    }
  }
  _createGraphics(e3, r3, i4, s4) {
    const o4 = e3.length, a2 = 3, n5 = this._getObjectIdField(), l4 = this.processor.graphicsCore, d2 = new Array(), u = this.view.spatialReference;
    for (let h4 = 0; h4 < o4; h4++) {
      const o5 = e3[h4], c3 = {};
      null != o5 && (c3[n5] = o5);
      const p2 = o5 ?? h3.generateUID(), g = h4 * a2, m3 = isNaN(r3[g + 2]) ? void 0 : r3[g + 2], y2 = Z(r3[g], r3[g + 1], m3, u), f = this.loadedGraphics.get(p2);
      if (null != f)
        (null == f.level || f.level < s4) && (de.property = "geometry", de.graphic = f, de.oldValue = f.geometry, de.newValue = y2, f.geometry = y2, f.level = s4, l4.graphicUpdateHandler(de)), d2.push(f);
      else {
        const e4 = h3.generateUID();
        d2.push({ objectId: p2, uid: e4, geometry: y2, attributes: c3, visible: true, nodeIndex: i4, level: s4 });
      }
    }
    return d2;
  }
  _updateNodeMemory(e3) {
    e3.memory = 4096 + (null != e3.numFeatures ? e3.numFeatures * this.processor.graphicsCore.usedMemoryPerGraphic : 0);
  }
  _cacheNodeData(e3) {
    const t7 = e3.graphics.reduce((e4, t8) => M(t8) + e4, m(e3.featureIds) + 1024);
    this._memCache.put(this._getMemCacheKey(e3.node), e3, t7);
  }
  _getMemCacheKey(e3) {
    return `${e3.index}`;
  }
  _removeAllNodeData() {
    this.loadedGraphics.forEachNode((e3, t7) => {
      if (e3) {
        const t8 = e3.node;
        this._updateNodeMemory(t8), this._cacheNodeData(e3);
      }
      this._controller.updateLoadStatus(t7, false);
    }), this._treeDebugger && this._treeDebugger.update(), this.loadedGraphics.clear();
  }
  removeNode(e3) {
    const t7 = this._removeNodeStageData(e3);
    t7 && (this._updateNodeMemory(t7.node), this._cacheNodeData(t7));
  }
  _removeNodeStageData(e3) {
    const t7 = this.loadedGraphics.getNode(e3);
    return null == t7 ? null : (this._controller.updateLoadStatus(e3, false), this.loadedGraphics.removeNode(e3), this._treeDebugger && this._treeDebugger.update(), t7);
  }
  async loadCachedNodeData(e3) {
    var _a;
    return (_a = this._memCache) == null ? void 0 : _a.pop(this._getMemCacheKey(e3));
  }
  async addCachedNodeData(e3, t7, r3, s4) {
    this.loadedGraphics.hasNode(e3.index) ? s.getLogger(this).error("I3S node " + e3.id + " already added") : (await this._i3sOverrides.applyAttributeOverrides(t7.featureIds, r3, s4), this.loadedGraphics.addNode(e3.index, t7), this._controller.updateLoadStatus(e3.index, true), this._updateNodeMemory(e3), t7.attributeInfo = r3, this._attributeValuesChanged(t7), this._filterNode(t7), this._treeDebugger && this._treeDebugger.update());
  }
  getLoadedNodeIds() {
    const e3 = [];
    return this.loadedGraphics.forEachNode((t7) => e3.push(t7.node.id)), e3.sort();
  }
  getVisibleNodes() {
    const e3 = new Array();
    return this.loadedGraphics.forEachNode((t7) => e3.push(t7.node)), e3;
  }
  getLoadedNodeIndices(e3) {
    this.loadedGraphics.forEachNode((t7, r3) => e3.push(r3));
  }
  getLoadedAttributes(e3) {
    const t7 = this.loadedGraphics.getNode(e3);
    if (null != t7 && null != t7.attributeInfo)
      return t7.attributeInfo.loadedAttributes;
  }
  getAttributeData(e3) {
    const t7 = this.loadedGraphics.getNode(e3);
    if (null != t7 && null != t7.attributeInfo)
      return t7.attributeInfo.attributeData;
  }
  _setAttributeData(e3, t7) {
    const r3 = this.loadedGraphics.getNode(e3);
    null != r3 && null != r3.attributeInfo && (r3.attributeInfo.attributeData = t7, this._attributeValuesChanged(r3));
  }
  async updateAttributes(e3, t7, r3) {
    const i4 = this.loadedGraphics.getNode(e3);
    null != i4 && (await this._i3sOverrides.applyAttributeOverrides(i4.featureIds, t7, r3), i4.attributeInfo = t7, this._attributeValuesChanged(i4));
  }
  _attributeValuesChanged(e3) {
    if (oe(e3), this._filterNode(e3), this.processor.graphicsCore.labelsEnabled) {
      const t7 = e3.graphics.map((e4) => e4.uid);
      this.processor.graphicsCore.updateLabelingInfo(t7);
    }
  }
  _updateClippingExtent(e3) {
    return this._controller && this._controller.updateClippingArea(e3), false;
  }
  _getObjectIdField() {
    return this.layer.objectIdField || o3;
  }
  _getGlobalIdField() {
    var _a;
    return (_a = this.layer.associatedLayer) == null ? void 0 : _a.globalIdField;
  }
  async _rendererChange(e3, t7) {
    const { layer: { fieldsIndex: r3 } } = this, i4 = /* @__PURE__ */ new Set();
    let s4, o4;
    e3 ? (await e3.collectRequiredFields(i4, r3), s4 = Array.from(i4).sort()) : s4 = [], i4.clear(), t7 ? (await t7.collectRequiredFields(i4, r3), o4 = Array.from(i4).sort()) : o4 = [], s4.length === o4.length && s4.every((e4, t8) => s4[t8] === o4[t8]) || this._reloadAllNodes();
  }
  _rangeInfosChanged(e3) {
    null != e3 && e3.length > 0 && s.getLogger(this).warn("Unsupported property: rangeInfos are currently only serialized to and from web scenes but do not affect rendering.");
  }
  _filterChange() {
    this.loadedGraphics.forEachNode((e3) => this._filterNode(e3));
  }
  _reloadAllNodes() {
    this._removeAllNodeData(), this._controller && this._controller.restartNodeLoading();
  }
  _filterNode(e3) {
    const t7 = this.parsedDefinitionExpression, i4 = this._excludeObjectIdsSorted, s4 = this._getObjectIdField();
    for (const o4 of e3.graphics) {
      const e4 = o4.visible, a2 = !t7 || this._evaluateClause(t7, o4), n5 = null == i4 || x(i4, o4.attributes[s4]) < 0;
      o4.visible = a2 && n5, e4 !== o4.visible && (de.graphic = o4, de.property = "visible", de.oldValue = e4, de.newValue = o4.visible, this.processor.graphicsCore.graphicUpdateHandler(de));
    }
  }
  createQuery() {
    const e3 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference };
    return null != this.filter ? this.filter.createQuery(e3) : new b(e3);
  }
  queryFeatures(e3, t7) {
    return this._queryEngine.executeQuery(this._ensureQuery(e3), t7 == null ? void 0 : t7.signal);
  }
  queryObjectIds(e3, t7) {
    return this._queryEngine.executeQueryForIds(this._ensureQuery(e3), t7 == null ? void 0 : t7.signal);
  }
  queryFeatureCount(e3, t7) {
    return this._queryEngine.executeQueryForCount(this._ensureQuery(e3), t7 == null ? void 0 : t7.signal);
  }
  queryExtent(e3, t7) {
    return this._queryEngine.executeQueryForExtent(this._ensureQuery(e3), t7 == null ? void 0 : t7.signal);
  }
  _ensureQuery(e3) {
    return this._addDefinitionExpressionToQuery(null == e3 ? this.createQuery() : b.from(e3));
  }
  _setupQueryEngine() {
    const e3 = () => this.processor.featureStore;
    this._queryEngine = new c2({ context: { spatialReference: this.view.spatialReference, layer: this.layer, scheduler: this.view.resourceController.scheduler, get featureStore() {
      return e3();
    }, hasZ: this.hasZ, hasM: this.hasM }, priority: I.FEATURE_QUERY_ENGINE });
  }
  get usedMemory() {
    var _a, _b;
    return ((_b = (_a = this.processor) == null ? void 0 : _a.graphicsCore) == null ? void 0 : _b.usedMemory) ?? 0;
  }
  get unloadedMemory() {
    var _a, _b, _c;
    return 0.8 * ((((_a = this._controller) == null ? void 0 : _a.unloadedMemoryEstimate) ?? 0) + (((_c = (_b = this.processor) == null ? void 0 : _b.graphicsCore) == null ? void 0 : _c.unprocessedMemoryEstimate) ?? 0));
  }
  get ignoresMemoryFactor() {
    return this._controller && this._controller.fixedFeatureTarget;
  }
  _handleEdits(e3) {
    l3(this._attributeEditingContext, e3);
  }
  get _attributeEditingContext() {
    const e3 = this._getObjectIdField(), t7 = this._getGlobalIdField();
    return { sessions: this._interactiveEditingSessions, fieldsIndex: this.layer.fieldsIndex, objectIdField: e3, globalIdField: t7, forEachNode: (e4) => this.loadedGraphics.forEachNode((t8) => e4(t8.node, t8.featureIds)), attributeStorageInfo: this.i3slayer.attributeStorageInfo ?? [], i3sOverrides: this._i3sOverrides, getAttributeData: (e4) => this.getAttributeData(e4), setAttributeData: (t8, r3, i4) => {
      this._setAttributeData(t8, r3);
      const s4 = this.loadedGraphics.getNode(t8);
      if (null != i4) {
        const t9 = this.loadedGraphics.get(i4.attributes[e3]);
        null != t9 && this.processor.graphicsCore.recreateGraphics([t9]);
      } else
        null != s4 && this.processor.graphicsCore.recreateGraphics(s4.graphics);
    }, clearMemCache: () => {
    } };
  }
  get performanceInfo() {
    const e3 = { displayedNumberOfFeatures: this.loadedGraphics.length, maximumNumberOfFeatures: this.maximumNumberOfFeatures, totalNumberOfFeatures: -1, nodes: this.loadedGraphics.nodeCount, core: this.processor.graphicsCore.performanceInfo };
    return this._controller && this._controller.updateStats(e3), e3;
  }
  get test() {
    return { controller: this._controller, numNodes: this.loadedGraphics.nodeCount, loadedGraphics: this.loadedGraphics };
  }
};
e([y()], ee2.prototype, "processor", void 0), e([y({ type: d })], ee2.prototype, "filter", void 0), e([y()], ee2.prototype, "loadedGraphics", void 0), e([y()], ee2.prototype, "i3slayer", null), e([y()], ee2.prototype, "_controller", void 0), e([y()], ee2.prototype, "updating", void 0), e([y()], ee2.prototype, "suspended", void 0), e([y()], ee2.prototype, "holeFilling", void 0), e([y(t5)], ee2.prototype, "updatingProgress", void 0), e([y()], ee2.prototype, "updatingProgressValue", null), e([y(J.requiredFields)], ee2.prototype, "requiredFields", null), e([y(J.availableFields)], ee2.prototype, "availableFields", void 0), e([y()], ee2.prototype, "_fieldsHelper", void 0), e([y({ type: Number })], ee2.prototype, "maximumNumberOfFeatures", null), e([y({ readOnly: true })], ee2.prototype, "maximumNumberOfFeaturesExceeded", null), e([y()], ee2.prototype, "_excludeObjectIdsSorted", null), e([y({ readOnly: true })], ee2.prototype, "lodFactor", null), e([y({ readOnly: true })], ee2.prototype, "hasM", null), e([y({ readOnly: true })], ee2.prototype, "hasZ", null), e([y()], ee2.prototype, "contentVisible", null), e([y({ readOnly: true })], ee2.prototype, "legendEnabled", null), ee2 = e([a("esri.views.3d.layers.SceneLayerGraphicsView3D")], ee2);
var te = ee2;
function re(e3) {
  return "pointData" in e3;
}
function ie(e3) {
  return "geometryBuffer" in e3 && null !== e3.geometryBuffer;
}
function se(e3, t7, r3) {
  const i4 = t7.attributeInfo;
  if (null == i4 || null == i4.loadedAttributes || null == i4.attributeData)
    return false;
  let s4 = false;
  for (const { name: o4 } of i4.loadedAttributes)
    if (i4.attributeData[o4]) {
      const t8 = fe(i4.attributeData[o4], r3);
      t8 !== e3.attributes[o4] && (e3.attributes[o4] = t8, s4 = true);
    }
  return s4;
}
function oe(e3) {
  const t7 = e3.attributeInfo, r3 = e3.node.index;
  if (null != t7 && null != t7.loadedAttributes && null != t7.attributeData)
    for (let i4 = 0; i4 < e3.graphics.length; i4++) {
      const s4 = e3.graphics[i4];
      if (s4.nodeIndex === r3) {
        s4.attributes || (s4.attributes = {});
        for (const { name: e4 } of t7.loadedAttributes)
          t7.attributeData[e4] && (s4.attributes[e4] = fe(t7.attributeData[e4], i4));
      }
    }
}
function ae(e3, t7) {
  return e3.xmin -= t7, e3.ymin -= t7, e3.xmax += t7, e3.ymax += t7, null != e3.zmin && null != e3.zmax && (e3.zmin -= t7, e3.zmax += t7), null != e3.mmin && null != e3.mmax && (e3.mmin -= t7, e3.mmax += t7), e3;
}
var ne2 = { 2: { type: "Embedded", params: { type: "points", vertexAttributes: { position: [0, 0] } } }, 3: { type: "Embedded", params: { type: "points", vertexAttributes: { position: [0, 0, 0] } } } };
var le = n2();
var de = { graphic: null, property: null, oldValue: null, newValue: null };
export {
  te as default
};
//# sourceMappingURL=SceneLayerGraphicsView3D-L6ADXGQI.js.map
