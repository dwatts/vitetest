import {
  u
} from "./chunk-FAOMDC3K.js";
import {
  s
} from "./chunk-XM3YSFN6.js";
import {
  l as l2
} from "./chunk-D7YAG5U3.js";
import {
  o as o4
} from "./chunk-SH6HJSS2.js";
import {
  r
} from "./chunk-KFDARCTS.js";
import {
  T,
  e2
} from "./chunk-TRGMWULG.js";
import {
  o as o2
} from "./chunk-SADO52IH.js";
import {
  h
} from "./chunk-73PNWDTS.js";
import {
  l
} from "./chunk-DOR4M5EA.js";
import {
  e as e3
} from "./chunk-YVVROPAO.js";
import {
  o as o3
} from "./chunk-UUW6REOV.js";
import {
  o
} from "./chunk-V66LHQVK.js";
import {
  D,
  G
} from "./chunk-BCDDCNQ2.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js
var p;
var s2;
!function(t) {
  t[t.Draped = 0] = "Draped", t[t.Screen = 1] = "Screen", t[t.World = 2] = "World", t[t.COUNT = 3] = "COUNT";
}(p || (p = {})), function(t) {
  t[t.Center = 0] = "Center", t[t.Tip = 1] = "Tip", t[t.COUNT = 2] = "COUNT";
}(s2 || (s2 = {}));
var a = class extends s {
  constructor() {
    super(...arguments), this.output = h.Color, this.transparencyPassType = o2.NONE, this.occluder = false, this.hasSlicePlane = false, this.writeDepth = false, this.space = p.Screen, this.hideOnShortSegments = false, this.hasCap = false, this.anchor = s2.Center, this.hasTip = false, this.vvSize = false, this.vvColor = false, this.vvOpacity = false, this.hasOccludees = false, this.hasMultipassTerrain = false, this.cullAboveGround = false;
  }
  get draped() {
    return this.space === p.Draped;
  }
};
e([r({ count: h.COUNT })], a.prototype, "output", void 0), e([r({ count: o2.COUNT })], a.prototype, "transparencyPassType", void 0), e([r()], a.prototype, "occluder", void 0), e([r()], a.prototype, "hasSlicePlane", void 0), e([r()], a.prototype, "writeDepth", void 0), e([r({ count: p.COUNT })], a.prototype, "space", void 0), e([r()], a.prototype, "hideOnShortSegments", void 0), e([r()], a.prototype, "hasCap", void 0), e([r({ count: s2.COUNT })], a.prototype, "anchor", void 0), e([r()], a.prototype, "hasTip", void 0), e([r()], a.prototype, "vvSize", void 0), e([r()], a.prototype, "vvColor", void 0), e([r()], a.prototype, "vvOpacity", void 0), e([r()], a.prototype, "hasOccludees", void 0), e([r()], a.prototype, "hasMultipassTerrain", void 0), e([r()], a.prototype, "cullAboveGround", void 0), e([r({ constValue: true })], a.prototype, "hasVvInstancing", void 0), e([r({ constValue: true })], a.prototype, "hasSliceTranslatedView", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js
var o5 = 8;
function c(c2, s4) {
  const l3 = c2.vertex;
  l3.uniforms.add(new o3("intrinsicWidth", (t) => t.width)), s4.vvSize ? (c2.attributes.add(O.SIZEFEATUREATTRIBUTE, "float"), l3.uniforms.add(new e3("vvSizeMinSize", (t) => t.vvSize.minSize), new e3("vvSizeMaxSize", (t) => t.vvSize.maxSize), new e3("vvSizeOffset", (t) => t.vvSize.offset), new e3("vvSizeFactor", (t) => t.vvSize.factor)), l3.code.add(o`float getSize() {
return intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;
}`)) : (c2.attributes.add(O.SIZE, "float"), l3.code.add(o`float getSize(){
return intrinsicWidth * size;
}`)), s4.vvOpacity ? (c2.attributes.add(O.OPACITYFEATUREATTRIBUTE, "float"), l3.constants.add("vvOpacityNumber", "int", 8), l3.uniforms.add(new o4("vvOpacityValues", (t) => t.vvOpacity.values, o5), new o4("vvOpacityOpacities", (t) => t.vvOpacity.opacityValues, o5)), l3.code.add(o`float interpolateOpacity( float value ){
if (value <= vvOpacityValues[0]) {
return vvOpacityOpacities[0];
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
}
}
return vvOpacityOpacities[vvOpacityNumber - 1];
}
vec4 applyOpacity( vec4 color ){
return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));
}`)) : l3.code.add(o`vec4 applyOpacity( vec4 color ){
return color;
}`), s4.vvColor ? (c2.include(l2, s4), c2.attributes.add(O.COLORFEATUREATTRIBUTE, "float"), l3.code.add(o`vec4 getColor(){
return applyOpacity(interpolateVVColor(colorFeatureAttribute));
}`)) : (c2.attributes.add(O.COLOR, "vec4"), l3.code.add(o`vec4 getColor(){
return applyOpacity(color);
}`));
}

// node_modules/@arcgis/core/views/3d/support/engineContent/marker.js
var m = 64;
var s3 = m / 2;
var n = s3 / 5;
var p2 = m / n;
var w = 0.25;
function f(p3, w2) {
  const f2 = u(p3, m, s3, n), u2 = new e2();
  return u2.internalFormat = G.RGBA, u2.width = m, u2.height = m, u2.wrapMode = D.CLAMP_TO_EDGE, new T(w2, u2, f2);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js
function n2(n3, i) {
  const { vertex: d, constants: s4 } = n3;
  s4.add("markerSizePerLineWidth", "float", p2), l(d, i), null == d.uniforms.get("markerScale") && d.constants.add("markerScale", "float", 1), d.code.add(o`float getLineWidth() {
return max(getSize(), 1.0) * pixelRatio;
}
float getScreenMarkerSize() {
return markerSizePerLineWidth * markerScale * getLineWidth();
}`), i.space === p.World && (d.constants.add("maxSegmentLengthFraction", "float", 0.45), d.uniforms.add(new o3("perRenderPixelRatio", (e4, r2) => r2.camera.perRenderPixelRatio)), d.code.add(o`bool areWorldMarkersHidden(vec4 pos, vec4 other) {
vec3 midPoint = mix(pos.xyz, other.xyz, 0.5);
float distanceToCamera = length(midPoint);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
float worldMarkerSize = getScreenMarkerSize() * screenToWorldRatio;
float segmentLen = length(pos.xyz - other.xyz);
return worldMarkerSize > maxSegmentLengthFraction * segmentLen;
}
float getWorldMarkerSize(vec4 pos) {
float distanceToCamera = length(pos.xyz);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
return getScreenMarkerSize() * screenToWorldRatio;
}`));
}

export {
  p,
  s2 as s,
  a,
  c,
  m,
  s3 as s2,
  p2,
  w,
  f,
  n2 as n
};
//# sourceMappingURL=chunk-JZVYLVFO.js.map
