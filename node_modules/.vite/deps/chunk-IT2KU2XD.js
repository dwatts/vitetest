import {
  C
} from "./chunk-5IRKUUA3.js";
import {
  e as e2,
  t
} from "./chunk-644IM3NW.js";
import {
  j
} from "./chunk-H7RDAEPY.js";
import {
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  s3 as s
} from "./chunk-HMVAPW5X.js";

// node_modules/@arcgis/core/views/3d/layers/TiledLayerView3D.js
var o = (o2) => {
  let c = class extends o2 {
    get imageFormatIsOpaque() {
      return false;
    }
    get fullExtent() {
      return this.layer.fullExtent;
    }
    get isOpaque() {
      return this.fullOpacity >= 1 && this.imageFormatIsOpaque;
    }
    get dataScaleRange() {
      const e3 = this.tileInfo.lods;
      let t2 = e3[0].scale, i = e3[e3.length - 1].scale;
      if ("tilemapCache" in this.layer && this.layer.tilemapCache) {
        const { effectiveMinLOD: e4, effectiveMaxLOD: r } = this.layer.tilemapCache;
        t2 = this.tileInfo.lodAt(e4).scale, i = this.tileInfo.lodAt(r).scale;
      }
      return { minScale: t2, maxScale: i };
    }
    get dataLevelRange() {
      const { minScale: e3, maxScale: t2 } = this.dataScaleRange;
      return this.levelRangeFromScaleRange(e3, t2);
    }
    get displayLevelRange() {
      const e3 = this.layer.minScale || this.dataScaleRange.minScale, t2 = this.layer.maxScale || this.dataScaleRange.maxScale, i = this.levelRangeFromScaleRange(e3, t2);
      return this.layer.maxScale && i.maxLevel++, i;
    }
    getTileUrl(e3, t2, i) {
      return this.layer.getTileUrl(e3, t2, i);
    }
    _addTilingSchemeMatchPromise() {
      if (null == this.fullExtent)
        return this.addResolvingPromise(Promise.reject(new s("tilingscheme:extent-not-defined", "This layer doesn't define a fullExtent.")));
      const e3 = this._getTileInfoSupportError(this.tileInfo, this.fullExtent);
      if (null != e3)
        return this.addResolvingPromise(Promise.reject(e3));
      const r = j(() => {
        var _a, _b;
        return (_b = (_a = this.view) == null ? void 0 : _a.basemapTerrain) == null ? void 0 : _b.tilingSchemeLocked;
      }).then(() => {
        const e4 = this.view.basemapTerrain.tilingScheme, t2 = this._getTileInfoCompatibilityError(this.tileInfo, e4);
        if (t2)
          throw t2;
      });
      this.addResolvingPromise(r);
    }
    _getTileInfoSupportError(e3, i) {
      const r = C(e3, i, this.view.spatialReference, this.view.state.viewingMode);
      if (r) {
        const e4 = { layer: this.layer, error: r };
        let i2;
        switch (r.name) {
          case "tilingscheme:spatial-reference-mismatch":
          case "tilingscheme:global-unsupported-spatial-reference":
          case "tilingscheme:local-unsupported-spatial-reference":
            i2 = new s("layerview:spatial-reference-incompatible", "The spatial reference of this layer does not meet the requirements of the view", e4);
            break;
          default:
            i2 = new s("layerview:tiling-scheme-unsupported", "The tiling scheme of this layer is not supported by SceneView", e4);
        }
        return i2;
      }
      return null;
    }
    _getTileInfoCompatibilityError(e3, i) {
      return null != e3 && i.compatibleWith(e3) ? null : new s("layerview:tiling-scheme-incompatible", "The tiling scheme of this layer is incompatible with the tiling scheme of the surface");
    }
    levelRangeFromScaleRange(e3, t2) {
      const i = { minLevel: 0, maxLevel: 1 / 0 }, r = this.view && this.view.basemapTerrain && this.view.basemapTerrain.tilingScheme;
      if (!r)
        return i;
      const a2 = r.levels[0], l = (e4) => {
        const t3 = Math.log(a2.scale / e4) / Math.LN2;
        return 0.5 - Math.abs(0.5 - t3 % 1) < 1e-9 ? Math.round(t3) : Math.ceil(t3);
      };
      return null != e3 && e3 > 0 && (i.minLevel = Math.max(0, l(e3))), null != t2 && t2 > 0 && (i.maxLevel = Math.max(0, l(t2))), i;
    }
    isUpdating() {
      return !!(this.view && this.view.basemapTerrain && this.view.basemapTerrain.updating);
    }
  };
  return e([y({ readOnly: true })], c.prototype, "imageFormatIsOpaque", null), e([y({ readOnly: true })], c.prototype, "updating", void 0), e([y(t)], c.prototype, "updatingProgress", void 0), e([y(e2)], c.prototype, "updatingProgressValue", void 0), e([y()], c.prototype, "fullExtent", null), e([y({ readOnly: true })], c.prototype, "isOpaque", null), e([y()], c.prototype, "dataScaleRange", null), e([y({ readOnly: true })], c.prototype, "dataLevelRange", null), e([y({ readOnly: true })], c.prototype, "displayLevelRange", null), e([y()], c.prototype, "layer", void 0), e([y()], c.prototype, "tileInfo", void 0), c = e([a("esri.views.3d.layers.TiledLayerView3D")], c), c;
};

export {
  o
};
//# sourceMappingURL=chunk-IT2KU2XD.js.map
