import {
  e as e4
} from "./chunk-7CCX4DKW.js";
import {
  c as c6
} from "./chunk-W2YWKOK7.js";
import {
  r as r3,
  t as t5
} from "./chunk-O62OS3ME.js";
import "./chunk-YOTOWDJK.js";
import "./chunk-ND7XUHDE.js";
import "./chunk-XG5SDOKD.js";
import {
  d
} from "./chunk-GSOTO7KE.js";
import "./chunk-UQHDCOJC.js";
import {
  h as h3
} from "./chunk-MF3HZ6GV.js";
import "./chunk-SNAARWF3.js";
import "./chunk-FQZ2JEHK.js";
import "./chunk-GZTLZ6RD.js";
import {
  C,
  U as U2,
  a2 as a4,
  a3 as a5,
  c as c3,
  c2 as c4,
  e as e2,
  e2 as e3,
  h as h5,
  i2 as i3,
  i3 as i4,
  l as l5,
  m as m3,
  m2 as m4,
  r2 as r5,
  s as s6,
  s2 as s7,
  t2 as t6,
  t3 as t7,
  w as w2,
  w2 as w3,
  z
} from "./chunk-CNMVDP2Z.js";
import {
  a as a6,
  c as c5,
  r as r6,
  s as s8
} from "./chunk-G3BNSWI4.js";
import {
  D,
  J,
  K,
  Rt,
  Z,
  bt,
  l as l4,
  lt,
  mt,
  pt,
  wt,
  xt,
  yt
} from "./chunk-ICGBQNK3.js";
import "./chunk-AAWIXPYE.js";
import {
  o2 as o4,
  r as r4
} from "./chunk-NEBQZ6AZ.js";
import {
  _,
  d as d2,
  i as i2
} from "./chunk-7JB7RSO7.js";
import "./chunk-CEUJOC5P.js";
import "./chunk-F4ILXEXC.js";
import "./chunk-QTN4N5B5.js";
import "./chunk-G3Q2URFK.js";
import "./chunk-F6TKAVSX.js";
import "./chunk-D5NSNTGJ.js";
import "./chunk-63ERNIOV.js";
import "./chunk-XABSD6D5.js";
import "./chunk-DTEODQ6R.js";
import "./chunk-QNFDBY7V.js";
import "./chunk-RVQLSA5X.js";
import "./chunk-5KLICR5E.js";
import "./chunk-YYTXJF6W.js";
import "./chunk-KRCNIFX2.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-M6OG7C2T.js";
import "./chunk-GOK5MP3B.js";
import {
  a as a3,
  m as m2,
  o as o3,
  r as r2
} from "./chunk-NLWV7Q6F.js";
import {
  j as j3,
  p
} from "./chunk-DSWGERIY.js";
import "./chunk-Y2ZDD3I4.js";
import "./chunk-RVS5HU2K.js";
import "./chunk-JB7FDW5N.js";
import {
  n as n3
} from "./chunk-SS3YG6J3.js";
import "./chunk-H37COY3W.js";
import "./chunk-NVGPNIR6.js";
import {
  c as c2
} from "./chunk-B4D7M7HT.js";
import "./chunk-3T2ETA25.js";
import "./chunk-5IYCCZ54.js";
import "./chunk-JLSXEPY6.js";
import "./chunk-VMTVUE47.js";
import "./chunk-GDZM4A6K.js";
import {
  h as h4
} from "./chunk-XWGNMTES.js";
import "./chunk-6NNEHJYI.js";
import {
  $,
  Cn,
  Y,
  nn,
  r
} from "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import "./chunk-W4KI5YEI.js";
import "./chunk-CAFGOFIE.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-JNDFAMXY.js";
import "./chunk-NTEKJWGF.js";
import "./chunk-TFIKV5RU.js";
import "./chunk-KW6QQDGN.js";
import "./chunk-AQ7R6V4L.js";
import {
  c
} from "./chunk-DOQ3SAAR.js";
import "./chunk-4BXK4H4L.js";
import "./chunk-SLVNG7FV.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-UXVZ4PI3.js";
import "./chunk-DTYFMKYK.js";
import "./chunk-7S7LC3XK.js";
import "./chunk-XR4HIGQP.js";
import "./chunk-AUKRB7YY.js";
import "./chunk-KK5CYPXW.js";
import "./chunk-JNO3YVNK.js";
import {
  n as n2
} from "./chunk-DU6E4DU3.js";
import "./chunk-DKJBDKGA.js";
import "./chunk-4CZO65BK.js";
import "./chunk-SVCGLUNW.js";
import "./chunk-3KEIFTQ6.js";
import {
  i
} from "./chunk-DEZCXTA3.js";
import {
  h as h2
} from "./chunk-RRJGZKNX.js";
import "./chunk-PL5Q4C6Y.js";
import "./chunk-A6VKJXIH.js";
import "./chunk-KFSY6ZZH.js";
import {
  V
} from "./chunk-7EQSYZHW.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import {
  j,
  o as o2
} from "./chunk-4OR73Y2R.js";
import "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-2CTB7MKH.js";
import "./chunk-Z2ZUNW5S.js";
import "./chunk-7L7Z2HXM.js";
import "./chunk-75NKPXTR.js";
import "./chunk-EUVARFSM.js";
import {
  M,
  f,
  t as t4
} from "./chunk-3VUFACNT.js";
import {
  x2 as x
} from "./chunk-ZEEBL7ZN.js";
import {
  S2 as S
} from "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-C5FJDP6J.js";
import "./chunk-AHL6RC7E.js";
import "./chunk-RLLQRKO4.js";
import "./chunk-XUY2GLHG.js";
import "./chunk-JYZSPYYW.js";
import "./chunk-5EXFDBQJ.js";
import "./chunk-57CHUY45.js";
import "./chunk-SJ2GJCS2.js";
import {
  U,
  f as f2,
  h,
  j as j2,
  l as l3,
  w
} from "./chunk-H7RDAEPY.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-S5OISW44.js";
import "./chunk-7KH4CLS5.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-JL3TJGVW.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import {
  s as s5
} from "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import {
  l as l2
} from "./chunk-MP6GH2AC.js";
import {
  A,
  m,
  t,
  t2,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2,
  s2 as s4
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import {
  n,
  v
} from "./chunk-3R7FAT25.js";
import {
  s as s3,
  t as t3
} from "./chunk-7I33FAWS.js";
import {
  l,
  o
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import {
  a
} from "./chunk-IYZKKFJM.js";
import {
  R,
  has
} from "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/2d/AnimationManager.js
var u = class {
  constructor(t12, i9, s10, e8) {
    const o8 = t12.targetGeometry, n6 = i9.targetGeometry;
    e8 ? "string" == typeof e8 && (e8 = r3(e8) || t5.ease) : e8 = t5.ease, this.easing = e8, this.duration = s10, this.sCenterX = o8.x, this.sCenterY = o8.y, this.sScale = t12.scale, this.sRotation = t12.rotation, this.tCenterX = n6.x, this.tCenterY = n6.y, this.tScale = i9.scale, this.tRotation = i9.rotation, this.dCenterX = this.tCenterX - this.sCenterX, this.dCenterY = this.tCenterY - this.sCenterY, this.dScale = this.tScale - this.sScale, this.dRotation = this.tRotation - this.sRotation, this.dRotation > 180 ? this.dRotation -= 360 : this.dRotation < -180 && (this.dRotation += 360);
  }
  applyRatio(t12, i9) {
    const s10 = this.easing(i9);
    let e8, o8, n6, a14;
    i9 >= 1 ? (e8 = this.tCenterX, o8 = this.tCenterY, n6 = this.tRotation, a14 = this.tScale) : (e8 = this.sCenterX + s10 * this.dCenterX, o8 = this.sCenterY + s10 * this.dCenterY, n6 = this.sRotation + s10 * this.dRotation, a14 = this.sScale + s10 * this.dScale), t12.targetGeometry.x = e8, t12.targetGeometry.y = o8, t12.scale = a14, t12.rotation = n6;
  }
};
var d3 = class extends m {
  constructor(t12) {
    super(t12), this.updateFunction = null, this.animation = null, this.duration = 200, this.transition = null, this.easing = t5.ease, this.view = null, this.viewpoint = new l4({ targetGeometry: new x(), scale: 0, rotation: 0 }), this._updateTask = A({ postRender: this._postRender.bind(this) }), this._updateTask.pause();
  }
  destroy() {
    this._updateTask = o(this._updateTask);
  }
  animate(t12, i9, s10) {
    this.stop();
    const e8 = this.viewpoint;
    K(e8, i9), this.transition = new u(this.viewpoint, t12.target, s10 && s10.duration || this.duration, s10 && s10.easing || this.easing);
    const o8 = () => {
      var _a, _b;
      this.animation === t12 && this._updateTask && ("finished" === t12.state && ((_a = this.transition) == null ? void 0 : _a.applyRatio(this.viewpoint, 1), ((_b = this.view) == null ? void 0 : _b.state) && (this.view.state.viewpoint = this.viewpoint.clone())), this.animation = null, this.updateFunction = null);
    };
    return t12.when(o8, o8), this._startTime = performance.now(), this._updateTask.resume(), this.animation = t12, t12;
  }
  animateContinous(t12, i9) {
    this.stop(), this.updateFunction = i9, this.viewpoint = t12;
    const s10 = new a4({ target: t12.clone() }), e8 = () => {
      this.animation === s10 && this._updateTask && (this.animation = null, this.updateFunction = null);
    };
    return s10.when(e8, e8), this._startTime = performance.now(), this._updateTask.resume(), this.animation = s10, s10;
  }
  stop() {
    this.animation && (this.animation.stop(), this.animation = null, this.updateFunction = null);
  }
  _postRender(t12) {
    var _a, _b;
    const i9 = this.animation;
    if (i9 && i9.state !== a4.State.STOPPED) {
      if (this.updateFunction)
        this.updateFunction(this.viewpoint, t12.deltaTime);
      else {
        const t13 = this.transition, i10 = (performance.now() - this._startTime) / t13.duration, s10 = i10 >= 1;
        t13.applyRatio(this.viewpoint, i10), s10 && ((_a = this.animation) == null ? void 0 : _a.finish());
      }
      ((_b = this.view) == null ? void 0 : _b.state) && (this.view.state.viewpoint = this.viewpoint.clone());
    } else
      this._updateTask.pause();
  }
};
e([y()], d3.prototype, "animation", void 0), e([y()], d3.prototype, "duration", void 0), e([y()], d3.prototype, "transition", void 0), e([y()], d3.prototype, "easing", void 0), e([y()], d3.prototype, "view", void 0), e([y()], d3.prototype, "viewpoint", void 0), d3 = e([a2("esri.views.2d.AnimationManager")], d3);
var l6 = d3;

// node_modules/@arcgis/core/views/2d/FrameTask.js
var a7 = class {
  constructor(t12) {
    this.view = t12, this._stationaryHandle = null, this._frameTaskHandle = null, this._updateParameters = null, this._updateRequested = false, this.stationary = true, this.animationInProgress = false, this.prepare = () => {
      this._updateParameters && (this._updateParameters.state = this.view.state, this._updateParameters.stationary = this.view.stationary, this._updateParameters.pixelRatio = window.devicePixelRatio, this._updateParameters.renderingOptions = this.view.renderingOptions);
    }, this.update = () => {
      var _a2, _b;
      if (this._updateRequested = false, (_a2 = this.view) == null ? void 0 : _a2.destroyed)
        return;
      const { allLayerViews: t13, graphicsView: e8, labelManager: a14, state: { id: s10 } } = this.view;
      t13.forEach(this._updateLayerView, this), null != a14 && (a14.lastUpdateId !== s10 && (a14.viewChange(), a14.lastUpdateId = s10), a14.updateRequested && a14.processUpdate(this._updateParameters)), null != e8 && (e8.lastUpdateId !== s10 && (e8.viewChange(), e8.lastUpdateId = s10), e8.updateRequested && e8.processUpdate(this._updateParameters)), this.view.graphicsTileStore.setViewState(this._updateParameters.state), this.animationInProgress || this._updateRequested || ((_b = this._frameTaskHandle) == null ? void 0 : _b.pause());
    };
  }
  destroy() {
    this.stop();
  }
  start() {
    if (this._frameTaskHandle)
      return;
    const a14 = this.view;
    this.stationary = a14.stationary, this._updateParameters = { state: a14.state, pixelRatio: window.devicePixelRatio, stationary: this.stationary, renderingOptions: a14.renderingOptions }, this._stationaryHandle = l3(() => a14.stationary, (t12) => {
      this.stationary = t12, this.requestFrame();
    }), this._frameTaskHandle = A(this), this.requestUpdate();
  }
  stop() {
    var _a2;
    this._frameTaskHandle && (this._updateRequested = false, (_a2 = this._stationaryHandle) == null ? void 0 : _a2.remove(), this._frameTaskHandle.remove(), this._updateParameters = this._stationaryHandle = this._frameTaskHandle = null, this.stationary = true, this.animationInProgress = false);
  }
  requestUpdate() {
    this._updateRequested || (this._updateRequested = true, this.requestFrame());
  }
  requestFrame() {
    this._frameTaskHandle && this._frameTaskHandle.resume();
  }
  _updateLayerView(t12) {
    var _a2;
    if (!t12.attached)
      return void this.requestUpdate();
    const e8 = this.view.state, a14 = t12.lastUpdateId;
    null != a14 && (this.stationary || t12.moving) || (t12.moving = true, t12.moveStart()), a14 !== e8.id && t12.viewChange(), this.stationary && t12.moving && (t12.moving = false, t12.moveEnd()), t12.lastUpdateId = e8.id, t12.updateRequested && t12.processUpdate(this._updateParameters), "layerViews" in t12 && ((_a2 = t12.layerViews) == null ? void 0 : _a2.forEach(this._updateLayerView, this));
  }
};

// node_modules/@arcgis/core/views/2d/layerViewModuleImportUtils.js
function r7() {
  return Promise.all([import("./webglDeps-6LQKKQHX.js"), import("./mapViewDeps-CDPYMB6A.js")]);
}
var a8 = () => r7().then(() => import("./TileLayerView2D-NBPOI5QR.js"));
var t8 = () => r7().then(() => import("./FeatureLayerView2D-RIDTAW6Y.js"));
var s9 = { "base-dynamic": () => r7().then(() => import("./BaseDynamicLayerView2D-SJNJMRIQ.js")), "base-tile": a8, "bing-maps": a8, csv: t8, "geo-rss": () => r7().then(() => import("./GeoRSSLayerView2D-K74VVZST.js")), feature: t8, geojson: t8, graphics: () => r7().then(() => import("./GraphicsLayerView2D-HS7EZAKI.js")), group: () => r7().then(() => import("./GroupLayerView2D-ORHHEPEV.js")), imagery: () => r7().then(() => import("./ImageryLayerView2D-QYO7LD5Y.js")), "imagery-tile": () => r7().then(() => import("./ImageryTileLayerView2D-TEHKPCLP.js")), kml: () => r7().then(() => import("./KMLLayerView2D-XYXQ2INX.js")), "knowledge-graph": () => r7().then(() => import("./KnowledgeGraphLayerView2D-53THZT3H.js")), "link-chart": () => r7().then(() => import("./KnowledgeGraphLayerView2D-53THZT3H.js")), "knowledge-graph-sublayer": t8, "map-image": () => r7().then(() => import("./MapImageLayerView2D-TRSSGI5U.js")), "map-notes": () => r7().then(() => import("./MapNotesLayerView2D-WZZ43C47.js")), media: () => r7().then(() => import("./MediaLayerView2D-ZJYMUP7L.js")), "ogc-feature": () => r7().then(() => import("./OGCFeatureLayerView2D-2ETZJSVA.js")), "open-street-map": a8, "oriented-imagery": t8, route: () => r7().then(() => import("./RouteLayerView2D-FRILKELP.js")), stream: () => r7().then(() => import("./StreamLayerView2D-SN3VXKSN.js")), "subtype-group": () => r7().then(() => import("./SubtypeGroupLayerView2D-RAURPSGT.js")), tile: a8, "vector-tile": () => r7().then(() => import("./VectorTileLayerView2D-3WFWAOJS.js")), video: () => r7().then(() => import("./VideoLayerView2D-4X2XACZS.js")), wcs: () => r7().then(() => import("./ImageryTileLayerView2D-TEHKPCLP.js")), "web-tile": a8, wfs: t8, wms: () => r7().then(() => import("./WMSLayerView2D-7M6SXSG2.js")), wmts: () => r7().then(() => import("./WMTSLayerView2D-W2TEVNGN.js")), "line-of-sight": null, "base-elevation": null, "building-scene": null, dimension: null, elevation: null, "integrated-mesh": null, "point-cloud": null, voxel: null, scene: null, unknown: null, unsupported: null };
function i5(r9) {
  const a14 = r9.declaredClass ? r9.declaredClass.slice(r9.declaredClass.lastIndexOf(".") + 1) : "Unknown", t12 = a14.replaceAll(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  return new s2(`${t12}:view-not-supported`, `${a14} is not supported in 2D`);
}
var l7 = { hasLayerViewModule: (e8) => null != s9[e8.type], importLayerView: (e8) => {
  const r9 = s9[e8.type];
  if (null == r9)
    throw i5(e8);
  return r9(e8);
} };

// node_modules/@arcgis/core/geometry/support/near.js
function o5(o8, m8) {
  const { spatialReference: r9 } = m8, i9 = [m8.x, m8.y];
  let s10 = Number.POSITIVE_INFINITY, x2 = 0, c9 = 0;
  const a14 = [0, 0], f5 = "extent" === o8.type ? [[[o8.xmin, o8.ymin], [o8.xmin, o8.ymax], [o8.xmax, o8.ymax], [o8.xmax, o8.ymin], [o8.xmin, o8.ymin]]] : o8.rings;
  for (const n6 of f5)
    for (let o9 = 0; o9 < n6.length - 1; o9++) {
      o2(a14, i9, n6, o9);
      const m9 = m2(i9, a14);
      m9 < s10 && (s10 = m9, x2 = a14[0], c9 = a14[1]);
    }
  return { coordinate: new x({ x: x2, y: c9, spatialReference: r9 }), distance: s10 };
}

// node_modules/@arcgis/core/views/2d/constraints/GeometryConstraint.js
var p2;
var l8 = p2 = class extends i(m) {
  constructor(e8) {
    super(e8), this.geometry = null, this.spatialReference = null;
  }
  get normalizedGeometry() {
    if (null == this.geometry || !this.spatialReference)
      return null;
    if (!this.spatialReference.equals(this.geometry.spatialReference))
      try {
        return nn(this.geometry, this.spatialReference);
      } catch (e8) {
        return s.getLogger(this).error("#constraints.geometry", "could not project the geometry to the view's spatial reference", { geometry: this.geometry, spatialReference: this.spatialReference, error: e8 }), null;
      }
    return this.geometry;
  }
  constrain(e8, r9) {
    if (null == this.normalizedGeometry)
      return e8;
    const t12 = e8.targetGeometry;
    if ("extent" === this.normalizedGeometry.type ? t4(this.normalizedGeometry, t12) : f(this.normalizedGeometry, t12))
      return e8;
    const { coordinate: o8 } = o5(this.normalizedGeometry, t12);
    return o8 ? (e8.targetGeometry = o8, e8) : e8;
  }
  clone() {
    var _a, _b;
    return new p2({ geometry: (_a = this.geometry) == null ? void 0 : _a.clone(), spatialReference: (_b = this.spatialReference) == null ? void 0 : _b.clone() });
  }
};
e([y({ constructOnly: true })], l8.prototype, "geometry", void 0), e([y({ readOnly: true })], l8.prototype, "normalizedGeometry", null), e([y({ constructOnly: true })], l8.prototype, "spatialReference", void 0), l8 = p2 = e([a2("esri.views.2d.constraints.GeometryConstraint")], l8);

// node_modules/@arcgis/core/views/2d/constraints/RotationConstraint.js
var a9;
var n4 = a9 = class extends i(m) {
  constructor() {
    super(...arguments), this.enabled = true, this.rotationEnabled = true;
  }
  constrain(o8, r9) {
    return this.enabled && r9 ? (this.rotationEnabled || (o8.rotation = r9.rotation), o8) : o8;
  }
  clone() {
    return new a9({ enabled: this.enabled, rotationEnabled: this.rotationEnabled });
  }
};
e([y()], n4.prototype, "enabled", void 0), e([y()], n4.prototype, "rotationEnabled", void 0), n4 = a9 = e([a2("esri.views.2d.constraints.RotationConstraint")], n4);
var i6 = n4;

// node_modules/@arcgis/core/views/2d/constraints/ZoomConstraint.js
var a10;
var c7 = a10 = class extends i(m) {
  constructor(e8) {
    super(e8), this._lodByScale = {}, this._scales = [], this.effectiveLODs = null, this.effectiveMinZoom = -1, this.effectiveMaxZoom = -1, this.effectiveMinScale = 0, this.effectiveMaxScale = 0, this.lods = null, this.minZoom = -1, this.maxZoom = -1, this.minScale = 0, this.maxScale = 0, this.snapToZoom = true;
  }
  initialize() {
    let e8, { lods: t12, minScale: o8, maxScale: s10, minZoom: i9, maxZoom: a14 } = this, c9 = -1, r9 = -1, l10 = false, n6 = false;
    if (0 !== o8 && 0 !== s10 && o8 < s10 && ([o8, s10] = [s10, o8]), !t12 || !t12.length)
      return this._set("effectiveMinScale", o8), void this._set("effectiveMaxScale", s10);
    t12 = t12.map((e9) => e9.clone()), t12.sort((e9, t13) => t13.scale - e9.scale), t12.forEach((e9, t13) => e9.level = t13);
    for (const f5 of t12)
      !l10 && o8 > 0 && o8 >= f5.scale && (c9 = f5.level, l10 = true), !n6 && s10 > 0 && s10 >= f5.scale && (r9 = e8 ? e8.level : -1, n6 = true), e8 = f5;
    -1 === i9 && (i9 = 0 === o8 ? 0 : c9), -1 === a14 && (a14 = 0 === s10 ? t12.length - 1 : r9), i9 = Math.max(i9, 0), i9 = Math.min(i9, t12.length - 1), a14 = Math.max(a14, 0), a14 = Math.min(a14, t12.length - 1), i9 > a14 && ([i9, a14] = [a14, i9]), o8 = t12[i9].scale, s10 = t12[a14].scale, t12.splice(0, i9), t12.splice(a14 - i9 + 1, t12.length), t12.forEach((e9, t13) => {
      this._lodByScale[e9.scale] = e9, this._scales[t13] = e9.scale;
    }), this._set("effectiveLODs", t12), this._set("effectiveMinZoom", i9), this._set("effectiveMaxZoom", a14), this._set("effectiveMinScale", o8), this._set("effectiveMaxScale", s10);
  }
  constrain(e8, t12) {
    if (t12 && e8.scale === t12.scale)
      return e8;
    const o8 = this.effectiveMinScale, s10 = this.effectiveMaxScale, i9 = e8.targetGeometry, a14 = t12 && t12.targetGeometry, c9 = 0 !== s10 && e8.scale < s10, r9 = 0 !== o8 && e8.scale > o8;
    if (c9 || r9) {
      const c10 = r9 ? o8 : s10;
      if (t12 && a14) {
        const o9 = (c10 - t12.scale) / (e8.scale - t12.scale);
        i9.x = a14.x + (i9.x - a14.x) * o9, i9.y = a14.y + (i9.y - a14.y) * o9;
      }
      e8.scale = c10;
    }
    return this.snapToZoom && this.effectiveLODs && (e8.scale = this._getClosestScale(e8.scale)), e8;
  }
  fit(e8) {
    if (!this.effectiveLODs || !this.snapToZoom)
      return this.constrain(e8, null);
    const t12 = this.scaleToZoom(e8.scale), o8 = Math.abs(t12 - Math.floor(t12));
    return e8.scale = this.zoomToScale(o8 > 0.99 ? Math.round(t12) : Math.floor(t12)), e8;
  }
  zoomToScale(e8) {
    if (!this.effectiveLODs)
      return 0;
    e8 -= this.effectiveMinZoom, e8 = Math.max(0, e8);
    const t12 = this._scales;
    if (e8 <= 0)
      return t12[0];
    if (e8 >= t12.length)
      return t12[t12.length - 1];
    const o8 = Math.round(e8 - 0.5), s10 = Math.round(e8);
    return t12[s10] + (s10 - e8) * (t12[o8] - t12[s10]);
  }
  scaleToZoom(e8) {
    if (!this.effectiveLODs)
      return -1;
    const t12 = this._scales;
    let o8, s10;
    if (e8 >= t12[0])
      return this.effectiveMinZoom;
    if (e8 <= t12[t12.length - 1])
      return this.effectiveMaxZoom;
    for (let i9 = 0; i9 < t12.length - 1; i9++) {
      if (o8 = t12[i9], s10 = t12[i9 + 1], s10 === e8) {
        return i9 + this.effectiveMinZoom + 1;
      }
      if (o8 > e8 && s10 < e8) {
        return i9 + this.effectiveMinZoom + 1 - (e8 - s10) / (o8 - s10);
      }
    }
    return -1;
  }
  snapToClosestScale(e8) {
    if (!this.effectiveLODs)
      return e8;
    const t12 = this.scaleToZoom(e8);
    return this.zoomToScale(Math.round(t12));
  }
  snapToNextScale(e8, t12 = 0.5) {
    if (!this.effectiveLODs)
      return e8 * t12;
    const o8 = Math.round(this.scaleToZoom(e8));
    return this.zoomToScale(o8 + 1);
  }
  snapToPreviousScale(e8, t12 = 2) {
    if (!this.effectiveLODs)
      return e8 * t12;
    const o8 = Math.round(this.scaleToZoom(e8));
    return this.zoomToScale(o8 - 1);
  }
  clone() {
    return new a10({ lods: this.lods, minZoom: this.minZoom, maxZoom: this.maxZoom, minScale: this.minScale, maxScale: this.maxScale });
  }
  _getClosestScale(e8) {
    return this._lodByScale[e8] || (e8 = this._scales.reduce((t12, o8) => Math.abs(o8 - e8) <= Math.abs(t12 - e8) ? o8 : t12, this._scales[0])), this._lodByScale[e8].scale;
  }
};
e([y({ readOnly: true })], c7.prototype, "effectiveLODs", void 0), e([y({ readOnly: true })], c7.prototype, "effectiveMinZoom", void 0), e([y({ readOnly: true })], c7.prototype, "effectiveMaxZoom", void 0), e([y({ readOnly: true })], c7.prototype, "effectiveMinScale", void 0), e([y({ readOnly: true })], c7.prototype, "effectiveMaxScale", void 0), e([y()], c7.prototype, "lods", void 0), e([y()], c7.prototype, "minZoom", void 0), e([y()], c7.prototype, "maxZoom", void 0), e([y()], c7.prototype, "minScale", void 0), e([y()], c7.prototype, "maxScale", void 0), e([y()], c7.prototype, "snapToZoom", void 0), c7 = a10 = e([a2("esri.views.2d.constraints.ZoomConstraint")], c7);
var r8 = c7;

// node_modules/@arcgis/core/views/2d/MapViewConstraints.js
var p3 = { base: null, key: "type", typeMap: { extent: M, polygon: j } };
var y2 = class extends m {
  constructor(o8) {
    super(o8), this.lods = null, this.minScale = 0, this.maxScale = 0, this.minZoom = -1, this.maxZoom = -1, this.rotationEnabled = true, this.snapToZoom = true, this.customConstraints = new V();
  }
  destroy() {
    this.view = null;
  }
  get effectiveLODs() {
    return this._zoom.effectiveLODs;
  }
  get effectiveMinScale() {
    return this._zoom.effectiveMinScale;
  }
  get effectiveMaxScale() {
    return this._zoom.effectiveMaxScale;
  }
  get effectiveMinZoom() {
    return this._zoom.effectiveMinZoom;
  }
  get effectiveMaxZoom() {
    return this._zoom.effectiveMaxZoom;
  }
  set geometry(o8) {
    o8 ? this._set("geometry", o8) : this._set("geometry", null);
  }
  get version() {
    var _a, _b, _c;
    return `${(_a = this._zoom) == null ? void 0 : _a.uid}/${(_b = this._rotation) == null ? void 0 : _b.uid}/${(_c = this._geometry) == null ? void 0 : _c.uid}`;
  }
  get _geometry() {
    var _a, _b;
    const o8 = this._get("_geometry");
    return o8 && this.geometry === o8.geometry && ((_a = this.view) == null ? void 0 : _a.constraintsInfo.spatialReference) === o8.spatialReference ? o8 : new l8({ geometry: this.geometry, spatialReference: (_b = this.view) == null ? void 0 : _b.constraintsInfo.spatialReference });
  }
  get _rotation() {
    return new i6({ rotationEnabled: this.rotationEnabled });
  }
  get _zoom() {
    var _a;
    const o8 = this._get("_zoom"), t12 = this.lods || ((_a = this.view) == null ? void 0 : _a.constraintsInfo.lods), e8 = this.minZoom, r9 = this.maxZoom, s10 = this.minScale, i9 = this.maxScale, n6 = this.snapToZoom;
    return o8 && o8.lods === t12 && o8.minZoom === e8 && o8.maxZoom === r9 && o8.minScale === s10 && o8.maxScale === i9 && o8.snapToZoom === n6 ? o8 : new r8({ lods: t12, minZoom: e8, maxZoom: r9, minScale: s10, maxScale: i9, snapToZoom: n6 });
  }
  canZoomInTo(o8) {
    const t12 = this.effectiveMaxScale;
    return 0 === t12 || o8 >= t12;
  }
  canZoomOutTo(o8) {
    const t12 = this.effectiveMinScale;
    return 0 === t12 || o8 <= t12;
  }
  constrain(o8, t12) {
    return this._zoom.constrain(o8, t12), this._rotation.constrain(o8, t12), this._geometry.constrain(o8, t12), this.customConstraints.forEach((e8) => e8.constrain(o8, t12)), o8;
  }
  constrainByGeometry(o8) {
    return this._geometry.constrain(o8);
  }
  fit(o8) {
    return this._zoom.fit(o8);
  }
  zoomToScale(o8) {
    return this._zoom.zoomToScale(o8);
  }
  scaleToZoom(o8) {
    return this._zoom.scaleToZoom(o8);
  }
  snapScale(o8) {
    return this._zoom.snapToClosestScale(o8);
  }
  snapToNextScale(o8) {
    return this._zoom.snapToNextScale(o8);
  }
  snapToPreviousScale(o8) {
    return this._zoom.snapToPreviousScale(o8);
  }
};
e([y({ readOnly: true })], y2.prototype, "effectiveLODs", null), e([y({ readOnly: true })], y2.prototype, "effectiveMinScale", null), e([y({ readOnly: true })], y2.prototype, "effectiveMaxScale", null), e([y({ readOnly: true })], y2.prototype, "effectiveMinZoom", null), e([y({ readOnly: true })], y2.prototype, "effectiveMaxZoom", null), e([y({ types: p3, value: null })], y2.prototype, "geometry", null), e([y({ type: [p] })], y2.prototype, "lods", void 0), e([y()], y2.prototype, "minScale", void 0), e([y()], y2.prototype, "maxScale", void 0), e([y()], y2.prototype, "minZoom", void 0), e([y()], y2.prototype, "maxZoom", void 0), e([y()], y2.prototype, "rotationEnabled", void 0), e([y()], y2.prototype, "snapToZoom", void 0), e([y({ type: V })], y2.prototype, "customConstraints", void 0), e([y()], y2.prototype, "view", void 0), e([y({ readOnly: true })], y2.prototype, "version", null), e([y({ type: l8, readOnly: true })], y2.prototype, "_geometry", null), e([y({ type: i6 })], y2.prototype, "_rotation", null), e([y({ readOnly: true, type: r8 })], y2.prototype, "_zoom", null), y2 = e([a2("esri.views.2d.MapViewConstraints")], y2);
var f3 = y2;

// node_modules/@arcgis/core/views/2d/PaddedViewState.js
var l9;
var m5;
var w4 = l9 = class extends m {
  constructor() {
    super(...arguments), this.left = 0, this.top = 0, this.right = 0, this.bottom = 0;
  }
  clone() {
    return new l9({ left: this.left, top: this.top, right: this.right, bottom: this.bottom });
  }
};
e([y()], w4.prototype, "left", void 0), e([y()], w4.prototype, "top", void 0), e([y()], w4.prototype, "right", void 0), e([y()], w4.prototype, "bottom", void 0), w4 = l9 = e([a2("esri.views.2d.PaddedViewState.Padding")], w4);
var u2 = m5 = class extends U2 {
  constructor(...t12) {
    super(...t12), this.paddedViewState = new U2(), this._updateContent = (() => {
      const t13 = n3();
      return () => {
        const e8 = this._get("size"), i9 = this._get("padding");
        if (!e8 || !i9)
          return;
        const o8 = this.paddedViewState;
        r2(t13, i9.left + i9.right, i9.top + i9.bottom), o3(t13, e8, t13), a3(o8.size, t13);
        const s10 = o8.viewpoint;
        s10 && (this.viewpoint = s10);
      };
    })(), this.addHandles(l3(() => [this.size, this.padding], () => this._updateContent(), U)), this.padding = new w4(), this.size = [0, 0];
  }
  set padding(t12) {
    this._set("padding", t12 || new w4());
  }
  set viewpoint(t12) {
    if (t12) {
      const e8 = t12.clone();
      this.paddedViewState.viewpoint = t12, mt(e8, t12, this._get("size"), this._get("padding"));
      const i9 = this._viewpoint2D, o8 = e8.targetGeometry;
      i9.center[0] = o8.x, i9.center[1] = o8.y, i9.rotation = e8.rotation, i9.scale = e8.scale, i9.spatialReference = o8.spatialReference, this._update();
    }
  }
  clone() {
    return new m5({ padding: this.padding.clone(), size: this.size.slice(), viewpoint: this.paddedViewState.viewpoint.clone(), pixelRatio: this.pixelRatio });
  }
};
e([y()], u2.prototype, "paddedViewState", void 0), e([y({ type: w4 })], u2.prototype, "padding", null), e([y()], u2.prototype, "viewpoint", null), u2 = m5 = e([a2("esri.views.2d.PaddedViewState")], u2);
var f4 = u2;

// node_modules/@arcgis/core/views/2d/ViewStateManager.js
var z2 = class extends m {
  constructor(t12) {
    super(t12), this.constraints = null, this.ready = false, this.resizeAlign = "center", this.addHandles([l3(() => {
      var _a;
      return (_a = this.constraints) == null ? void 0 : _a.version;
    }, (t13) => {
      this.constraints && t13 && this.ready && (this.state.viewpoint = this.constraints.fit(this.state.paddedViewState.viewpoint));
    }, U)]);
  }
  get center() {
    if (!this.ready)
      return this._get("center");
    const { center: t12, spatialReference: e8 } = this.state.paddedViewState;
    return this.state.commitProperty("id"), new x({ x: t12[0], y: t12[1], spatialReference: e8 });
  }
  set center(t12) {
    if (null == t12)
      return;
    if (!this.ready)
      return void this._set("center", t12);
    let e8;
    try {
      e8 = this._project(t12, this.state.spatialReference);
    } catch (o8) {
      return void s.getLogger(this).error(new s2("mapview:invalid-center", "could not project the value in the view's spatial reference", { input: t12, error: o8 }));
    }
    const i9 = this.viewpoint;
    yt(i9, i9, e8), this.viewpoint = i9;
  }
  get extent() {
    return this.ready ? (this.state.commitProperty("id"), this.state.paddedViewState.extent.clone()) : this._get("extent");
  }
  set extent(t12) {
    if (null == t12)
      return;
    if (!t12.width || !t12.height)
      return void s.getLogger(this).error(new s2("mapview:invalid-extent", "invalid extent size"));
    if (!this.ready)
      return this._set("extent", t12), this._set("center", void 0), this._set("viewpoint", void 0), this._set("scale", void 0), void this._set("zoom", void 0);
    let e8;
    try {
      e8 = this._project(t12, this.state.spatialReference);
    } catch (o8) {
      return void s.getLogger(this).error(new s2("mapview:invalid-extent", "could not project the value in the view's spatial reference", { error: o8 }));
    }
    const i9 = this.viewpoint;
    Z(i9, i9, e8, this.state.size, { constraints: this.constraints }), this.viewpoint = i9;
  }
  get padding() {
    return this.ready ? this.state.padding : this._get("padding");
  }
  set padding(t12) {
    this.ready ? (this.state.padding = t12, this._set("padding", this.state.padding)) : this._set("padding", t12);
  }
  get resolution() {
    return this.ready ? (this.state.commitProperty("id"), this.state.resolution) : 0;
  }
  get rotation() {
    return this.ready ? (this.state.commitProperty("id"), this.state.rotation) : this._get("rotation");
  }
  set rotation(t12) {
    if (isNaN(t12))
      return;
    if (!this.ready)
      return void this._set("rotation", t12);
    const e8 = this.viewpoint;
    xt(e8, e8, t12), this.viewpoint = e8;
  }
  get scale() {
    return this.ready ? (this.state.commitProperty("id"), this.state.scale) : this._get("scale");
  }
  set scale(t12) {
    if (!t12 || isNaN(t12))
      return;
    if (!this.ready) {
      this._set("scale", t12), this._set("zoom", void 0);
      const e9 = this._get("extent");
      return void (e9 && (this._set("extent", void 0), this._set("center", e9.center)));
    }
    const e8 = this.viewpoint;
    bt(e8, e8, t12), this.viewpoint = e8;
  }
  get viewpoint() {
    if (!this.ready)
      return this._get("viewpoint");
    return this.state.paddedViewState.viewpoint.clone();
  }
  set viewpoint(t12) {
    var _a;
    if (null == t12)
      return;
    if (!this.ready)
      return this._set("viewpoint", t12), this._set("extent", void 0), this._set("center", void 0), this._set("zoom", void 0), void this._set("scale", void 0);
    let i9, o8;
    try {
      i9 = this._project(t12, this.state.spatialReference), !t12.scale || isNaN(t12.scale) ? o8 = new s2("mapview:invalid-viewpoint", `invalid scale value of ${t12.scale}`) : null == t12.targetGeometry && (o8 = new s2("mapview:invalid-viewpoint", "geometry not defined"));
    } catch (a14) {
      o8 = new s2("mapview:invalid-viewpoint", "could not project the value in the view's spatial reference", { error: a14 });
    }
    if (o8)
      return void s.getLogger(this).error(o8);
    this._scaleBeforeChangingSpatialReference = null;
    const n6 = new l4({ targetGeometry: new x(), scale: 0, rotation: 0 });
    K(n6, i9), (_a = this.constraints) == null ? void 0 : _a.constrain(n6, this.state.paddedViewState.viewpoint), this.state.viewpoint = n6, this._set("viewpoint", n6);
  }
  get zoom() {
    var _a;
    return this.ready ? ((_a = this.constraints) == null ? void 0 : _a.scaleToZoom(this.scale)) ?? -1 : this._get("zoom");
  }
  set zoom(t12) {
    var _a, _b;
    if (!(t12 >= 0))
      return;
    if (!this.ready) {
      this._set("zoom", t12), this._set("scale", void 0);
      const e9 = this._get("extent");
      return void (e9 && (this._set("extent", void 0), this._set("center", e9.center)));
    }
    const e8 = ((_a = this.constraints) == null ? void 0 : _a.zoomToScale(t12)) ?? 0;
    if (!e8)
      return void this._set("zoom", -1);
    const i9 = this.viewpoint;
    bt(i9, i9, e8), this.viewpoint = i9, this._set("zoom", ((_b = this.constraints) == null ? void 0 : _b.scaleToZoom(this.scale)) ?? -1);
  }
  getUserStartupOptions(t12) {
    if (!t12[0] && !t12[1])
      return { center: void 0, rotation: void 0, scale: void 0 };
    const { padding: e8, constraints: i9 } = this, s10 = this._get("center"), r9 = this._get("extent"), o8 = this._get("scale"), n6 = this._get("rotation"), a14 = this._get("viewpoint"), c9 = this._get("zoom"), p7 = null != c9 && null != i9 && i9.zoomToScale(c9) || void 0;
    let h6, l10, d5;
    const v2 = a14 == null ? void 0 : a14.rotation, m8 = a14 == null ? void 0 : a14.targetGeometry;
    "extent" === (m8 == null ? void 0 : m8.type) ? h6 = m8 : "point" === (m8 == null ? void 0 : m8.type) && (l10 = m8, d5 = a14 == null ? void 0 : a14.scale);
    const u3 = r9 ?? h6;
    return { center: s10 ?? l10 ?? (u3 == null ? void 0 : u3.center), rotation: n6 ?? v2, scale: (o8 ?? p7 ?? d5 ?? (u3 && D(u3, [t12[0] - e8.left - e8.right, t12[1] - e8.top - e8.bottom]))) || void 0 };
  }
  startup(t12, e8, i9, s10) {
    var _a;
    const o8 = t12.targetGeometry;
    try {
      this._project(t12, i9);
    } catch (n6) {
      s.getLogger(this).warn(new s4("mapview:startup-projection-error", "projection of initial viewpoint to the view's spatial reference, defaulting to the initial viewpoint.", { center: o8.toJSON(), spatialReference: i9, error: n6 })), t12.targetGeometry = s10 || new x({ x: 0, y: 0, spatialReference: i9 });
    }
    (_a = this.constraints) == null ? void 0 : _a.fit(t12), this._set("state", new f4({ padding: this.padding, size: e8, viewpoint: t12 })), this._set("ready", true);
  }
  teardown() {
    this._set("ready", false);
    const { center: [t12, e8], spatialReference: i9, rotation: s10, scale: r9 } = this.state.paddedViewState, o8 = new x({ x: t12, y: e8, spatialReference: i9 });
    this._set("viewpoint", null), this._set("extent", null), this._set("center", o8), this._set("zoom", -1), this._set("rotation", s10), this._set("scale", r9), this._set("state", null);
  }
  changeSpatialReference(t12) {
    var _a;
    const i9 = this.state.paddedViewState.clone();
    if (null == this._scaleBeforeChangingSpatialReference)
      this._scaleBeforeChangingSpatialReference = i9.scale;
    else {
      const t13 = i9.viewpoint.clone();
      t13.scale = this._scaleBeforeChangingSpatialReference, i9.viewpoint = t13;
    }
    const s10 = i9.clone(), [o8, n6] = i9.center;
    let a14 = null;
    try {
      a14 = this._project(new x({ x: o8, y: n6, spatialReference: i9.spatialReference }), t12);
    } catch (h6) {
      r() || s.getLogger(this).warn(new s4("mapview:spatial-reference-change", "could not project the view's center to the new spatial reference", { center: a14 == null ? void 0 : a14.toJSON(), spatialReference: t12, error: h6 }));
    }
    a14 || (a14 = new x({ x: 0, y: 0, spatialReference: t12 }));
    const p7 = yt(new l4({ targetGeometry: new x(), scale: 0, rotation: 0 }), i9.viewpoint, a14);
    s10.viewpoint = p7;
    try {
      const e8 = 20, r9 = [i9.size[0] / 2, i9.size[1] / 2], o9 = [r9[0] + e8, r9[1]], n7 = i9.toMap([0, 0], o9), { x: a15, y: c9 } = this._project(new x({ x: n7[0], y: n7[1], spatialReference: i9.spatialReference }), t12);
      n7[0] = a15, n7[1] = c9, s10.toScreen(n7, n7);
      const h6 = lt(r9, n7, o9), l10 = Math.hypot(n7[0] - r9[0], n7[1] - r9[1]) / e8;
      !Number.isFinite(l10) || Math.abs(l10) > 4 ? (p7.rotation = 0, p7.targetGeometry = new x({ x: 0, y: 0, spatialReference: t12 })) : (p7.scale *= l10, p7.scale > has("mapview-srswitch-adjust-rotation-scale-threshold") ? p7.rotation = 0 : p7.rotation += Number.isFinite(h6) ? h6 : 0);
    } catch {
    }
    (_a = this._get("constraints")) == null ? void 0 : _a.constrain(p7, void 0), this._get("state").viewpoint = p7;
  }
  resize(t12, e8) {
    var _a;
    if (!this.ready)
      return;
    const i9 = this.state;
    let s10 = this.state.paddedViewState.viewpoint;
    const r9 = this.state.paddedViewState.size.concat();
    i9.size = [t12, e8], pt(s10, s10, r9, this.state.paddedViewState.size, this.resizeAlign), s10 = ((_a = this.constraints) == null ? void 0 : _a.constrain(s10, void 0)) ?? s10, this.state.viewpoint = s10;
  }
  toMap(t12) {
    if (!this.ready)
      return null;
    const e8 = [0, 0], [i9, s10] = this.state.toMap(e8, [t12.x, t12.y]), r9 = this.state.spatialReference;
    return new x({ x: i9, y: s10, spatialReference: r9 });
  }
  toScreen(t12) {
    if (!this.ready)
      return null;
    const e8 = this._project(t12, this.state.spatialReference), i9 = [e8.x, e8.y];
    return this.state.toScreen(i9, i9), c(i9[0], i9[1]);
  }
  _project(t12, e8) {
    var _a;
    const i9 = t12 && t12.targetGeometry || t12;
    if (!e8)
      return t12;
    if (!i9)
      return null;
    if (e8.imageCoordinateSystem || ((_a = i9.spatialReference) == null ? void 0 : _a.imageCoordinateSystem))
      return t12;
    if (S(e8, i9.spatialReference))
      return t12;
    const r9 = nn(i9, e8);
    if (!r9)
      throw new s2("mapview:projection-not-possible", "projecting input geometry to target spatial reference returned a null value", { geometry: i9, spatialReference: e8 });
    return V2(t12) ? (t12.targetGeometry = r9, t12) : r9;
  }
};
function V2(t12) {
  return "esri.Viewpoint" === (t12 == null ? void 0 : t12.declaredClass);
}
e([y({ type: x })], z2.prototype, "center", null), e([y()], z2.prototype, "constraints", void 0), e([y({ type: M })], z2.prototype, "extent", null), e([y({ value: { top: 0, right: 0, bottom: 0, left: 0 }, cast: (t12) => ({ top: 0, right: 0, bottom: 0, left: 0, ...t12 }) })], z2.prototype, "padding", null), e([y()], z2.prototype, "ready", void 0), e([y()], z2.prototype, "resizeAlign", void 0), e([y({ readOnly: true })], z2.prototype, "resolution", null), e([y({ type: Number })], z2.prototype, "rotation", null), e([y({ type: Number })], z2.prototype, "scale", null), e([y({ readOnly: true })], z2.prototype, "state", void 0), e([y({ type: l4 })], z2.prototype, "viewpoint", null), e([y()], z2.prototype, "zoom", null), z2 = e([a2("esri.views.2d.ViewStateManager")], z2);

// node_modules/@arcgis/core/views/2d/input/handlers/DoubleClickZoom.js
var a11 = class extends i2 {
  constructor(t12, i9) {
    super(true), this._view = t12, this.registerIncoming("double-click", i9, (t13) => this._handleDoubleClick(t13, i9));
  }
  _handleDoubleClick(t12, a14) {
    t6(t12.data, "primary") && (t12.stopPropagation(), a14 ? this._view.mapViewNavigation.zoomOut([t12.data.x, t12.data.y]) : this._view.mapViewNavigation.zoomIn([t12.data.x, t12.data.y]));
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/DoubleTapDragZoom.js
var e5 = class extends i2 {
  constructor(t12, e8, a14) {
    super(true), this.view = t12, this.pointerType = e8, this.registerIncoming("double-tap-drag", a14, (t13) => this._handleDoubleTapDrag(t13));
  }
  _handleDoubleTapDrag(t12) {
    const { data: e8 } = t12, { pointerType: a14 } = e8;
    if (a14 !== this.pointerType)
      return;
    t12.stopPropagation();
    const { action: s10, delta: i9 } = e8, { view: r9 } = this, { mapViewNavigation: n6 } = r9;
    switch (s10) {
      case "begin": {
        const { scale: t13 } = r9;
        this._startScale = t13, this._currentScale = t13, this._previousDelta = i9, n6.begin();
        break;
      }
      case "update": {
        if (this._previousDelta.y === i9.y)
          return;
        this._previousDelta = i9;
        const t13 = 1.015 ** i9.y, e9 = this._startScale * t13, a15 = e9 / this._currentScale;
        n6.setViewpointImmediate(a15), this._currentScale = e9;
        break;
      }
      case "end": {
        const { constraints: t13 } = r9, { effectiveLODs: e9, snapToZoom: a15 } = t13;
        if (!a15 || !e9)
          return void n6.end();
        const s11 = t13.snapScale(this._currentScale), o8 = (i9.y > 0 ? Math.max(s11, t13.snapToPreviousScale(this._startScale)) : Math.min(s11, t13.snapToNextScale(this._startScale))) / this._currentScale;
        n6.zoom(o8);
        break;
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/DragPan.js
var n5 = class extends i2 {
  constructor(t12, i9, a14) {
    super(true), this.view = t12, this.pointerAction = i9, this.registerIncoming("drag", a14, (t13) => this._handleDrag(t13)), this.registerIncoming("pointer-down", () => this.stopMomentumNavigation());
  }
  onInstall(i9) {
    super.onInstall(i9), this._dragEventSeparator = new t7({ start: (t12, i10) => {
      this.view.mapViewNavigation.pan.begin(this.view, i10.data), i10.stopPropagation();
    }, update: (t12, i10) => {
      this.view.mapViewNavigation.pan.update(this.view, i10.data), i10.stopPropagation();
    }, end: (t12, i10) => {
      this.view.mapViewNavigation.pan.end(this.view, i10.data), i10.stopPropagation();
    }, condition: (t12, i10) => 1 === t12 && t6(i10.data, this.pointerAction) });
  }
  _handleDrag(t12) {
    const i9 = this.view.mapViewNavigation;
    i9.pinch.zoomMomentum || i9.pinch.rotateMomentum ? this.stopMomentumNavigation() : this._dragEventSeparator.handle(t12);
  }
  stopMomentumNavigation() {
    this.view.mapViewNavigation.pan.stopMomentumNavigation();
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/DragRotate.js
var o6 = class extends i2 {
  constructor(a14, o8, r9) {
    super(true), this._view = a14, this.pointerAction = o8;
    const e8 = this._view.mapViewNavigation;
    this._dragEventSeparator = new t7({ start: (t12, a15) => {
      e8.rotate.begin(this._view, a15.data), a15.stopPropagation();
    }, update: (t12, a15) => {
      e8.rotate.update(this._view, a15.data), a15.stopPropagation();
    }, end: (t12, a15) => {
      e8.rotate.end(), a15.stopPropagation();
    }, condition: (t12, a15) => 1 === t12 && t6(a15.data, this.pointerAction) }), this.registerIncoming("drag", r9, (t12) => this._dragEventSeparator.handle(t12));
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/GamepadNavigation.js
var d4 = class extends i2 {
  constructor(i9) {
    super(true), this._view = i9, this._frameTask = null, this._watchHandles = new t2(), this._currentDevice = null, this._transformation = { translation: [0, 0, 0], heading: 0, tilt: 0, zoom: 0 }, this._handle = this.registerIncoming("gamepad", (t12) => this._handleGamePadEvent(t12)), this._handle.pause();
  }
  onInstall(t12) {
    super.onInstall(t12), this._watchHandles.add([l3(() => {
      var _a;
      return (_a = this._view.navigation.gamepad) == null ? void 0 : _a.enabled;
    }, (t13) => {
      t13 ? (this._handle.resume(), this._frameTask || (this._frameTask = A({ update: (t14) => this._frameUpdate(t14.deltaTime) }))) : (this._handle.pause(), this._frameTask && (this._frameTask.remove(), this._frameTask = null));
    }, h)]);
  }
  onUninstall() {
    this._watchHandles.removeAll(), this._frameTask && (this._frameTask.remove(), this._frameTask = null), super.onUninstall();
  }
  _handleGamePadEvent(t12) {
    const i9 = this._view.navigation.gamepad.device;
    i9 && t12.data.device !== i9 || this._currentDevice && this._currentDevice !== t12.data.device || ("end" === t12.data.action ? (this._currentDevice = null, a5(this._transformation)) : (this._currentDevice = t12.data.device, i3(t12.data, this._view.navigation.gamepad, this._transformation)));
  }
  _frameUpdate(t12) {
    const i9 = this._transformation;
    if (s6(i9))
      return;
    const e8 = this._view.viewpoint.clone(), a14 = this._view.navigation.gamepad.velocityFactor, r9 = _2 * a14 * t12;
    Rt(e8, e8, [i9.translation[0] * r9, -i9.translation[1] * r9]);
    const o8 = 1 + i9.translation[2] * c8 * t12, h6 = this._view.constraints.rotationEnabled ? -i9.heading * m6 * t12 : 0, d5 = this._view.size, v2 = [d5[0] / 2, d5[1]];
    wt(e8, e8, o8, h6, v2, d5);
    const p7 = this._view.constraints.constrain(e8, this._view.viewpoint);
    this._view.viewpoint = p7;
  }
};
var m6 = 0.06;
var _2 = 0.7;
var c8 = 6e-4;

// node_modules/@arcgis/core/views/2d/input/handlers/KeyPan.js
var i7 = class extends i2 {
  constructor(e8, i9, t12) {
    super(true), this.view = e8, this.keys = i9, this._pressed = false, this._keyMap = { [i9.left]: "left", [i9.right]: "right", [i9.up]: "up", [i9.down]: "down" }, this.registerIncoming("key-down", t12, (e9) => this._handleKeyDown(e9)), this.registerIncoming("key-up", t12, (e9) => this._handleKeyUp(e9)), this.registerIncoming("blur", t12, () => this._handleBlur());
  }
  _handleKeyDown(e8) {
    e8.data.repeat || this._handleKey(e8, true);
  }
  _handleKeyUp(e8) {
    this._handleKey(e8, false);
  }
  _handleBlur() {
    this._pressed && (this._pressed = false, this.view.mapViewNavigation.stop());
  }
  _handleKey(e8, i9) {
    const t12 = this._keyMap[e8.data.key];
    if (this._pressed = null != t12, this._pressed) {
      if (i9)
        switch (this.view.mapViewNavigation.begin(), t12) {
          case "left":
            this.view.mapViewNavigation.continousPanLeft();
            break;
          case "right":
            this.view.mapViewNavigation.continousPanRight();
            break;
          case "up":
            this.view.mapViewNavigation.continousPanUp();
            break;
          case "down":
            this.view.mapViewNavigation.continousPanDown();
        }
      else
        this._pressed = false, this.view.mapViewNavigation.stop();
      e8.stopPropagation();
    }
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/KeyRotate.js
var i8 = class extends i2 {
  constructor(e8, i9, t12) {
    super(true), this.view = e8, this.keys = i9, this._pressed = false, this._keyToDirection = { [i9.clockwiseOption1]: "clockwise", [i9.clockwiseOption2]: "clockwise", [i9.counterClockwiseOption1]: "counterClockwise", [i9.counterClockwiseOption2]: "counterClockwise", [i9.resetOption1]: "reset", [i9.resetOption2]: "reset" }, this.registerIncoming("key-down", t12, (e9) => this._handleKeyDown(e9)), this.registerIncoming("key-up", t12, (e9) => this._handleKeyUp(e9)), this.registerIncoming("blur", t12, () => this._handleBlur());
  }
  _handleKeyDown(e8) {
    e8.data.repeat || this._handleKey(e8, true);
  }
  _handleKeyUp(e8) {
    this._handleKey(e8, false);
  }
  _handleBlur() {
    this._pressed && (this._pressed = false, this.view.mapViewNavigation.stop());
  }
  _handleKey(e8, i9) {
    const t12 = e8.modifiers;
    if (t12.size > 0 && !t12.has("Shift") || !this.view.constraints.rotationEnabled)
      return;
    const s10 = this._keyToDirection[e8.data.key];
    if (this._pressed = null != s10, this._pressed) {
      if (i9)
        switch (this.view.mapViewNavigation.begin(), s10) {
          case "clockwise":
            this.view.mapViewNavigation.continousRotateClockwise();
            break;
          case "counterClockwise":
            this.view.mapViewNavigation.continousRotateCounterclockwise();
            break;
          case "reset":
            this.view.mapViewNavigation.resetRotation();
        }
      else
        this._pressed = false, this.view.mapViewNavigation.stop();
      e8.stopPropagation();
    }
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/KeyZoom.js
var t9;
!function(o8) {
  o8[o8.IN = 0] = "IN", o8[o8.OUT = 1] = "OUT";
}(t9 || (t9 = {}));
var e6 = class extends i2 {
  constructor(o8, e8, i9) {
    super(true), this.view = o8, this.keys = e8, this._keysToZoomAction = {}, this.registerIncoming("key-down", i9, (o9) => this._handleKeyDown(o9)), e8.zoomIn.forEach((o9) => this._keysToZoomAction[o9] = t9.IN), e8.zoomOut.forEach((o9) => this._keysToZoomAction[o9] = t9.OUT);
  }
  _handleKeyDown(o8) {
    this._handleKey(o8);
  }
  _handleKey(o8) {
    const e8 = o8.modifiers;
    if (e8.size > 0 && !e8.has("Shift"))
      return;
    const { key: i9 } = o8.data;
    if (!(i9 in this._keysToZoomAction))
      return;
    const n6 = this._keysToZoomAction[i9], { mapViewNavigation: s10 } = this.view;
    let r9 = null;
    switch (n6) {
      case t9.IN:
        r9 = s10.zoomIn();
        break;
      case t9.OUT:
        r9 = s10.zoomOut();
        break;
      default:
        return;
    }
    s10.begin(), r9.then(() => s10.end()), o8.stopPropagation();
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/MouseWheelZoom.js
var t10 = 0.6;
var o7 = class extends i2 {
  constructor(e8, t12) {
    super(true), this._view = e8, this._canZoom = true, this.registerIncoming("mouse-wheel", t12, (e9) => this._handleMouseWheel(e9));
  }
  _handleMouseWheel(e8) {
    if (!this._view.navigation.mouseWheelZoomEnabled)
      return;
    if (e8.preventDefault(), e8.stopPropagation(), !this._canZoom)
      return;
    const o8 = this._view.mapViewNavigation, { x: n6, y: i9, deltaY: s10 } = e8.data, a14 = 1 / t10 ** (1 / 60 * s10), h6 = o8.zoom(a14, [n6, i9]);
    h6 && (this._canZoom = false, h6.catch(() => {
    }).then(() => {
      this._canZoom = true, o8.end();
    }));
  }
};

// node_modules/@arcgis/core/views/2d/input/handlers/PinchAction.js
var a12 = class extends i2 {
  constructor(i9) {
    super(true), this.view = i9, this.registerIncoming("drag", (t12) => this._handleDrag(t12)), this.registerIncoming("pointer-down", () => this._stopMomentumNavigation());
    const a14 = this.view.mapViewNavigation;
    this._dragEventSeparator = new t7({ start: (t12, i10) => {
      a14.pinch.begin(this.view, i10.data), i10.stopPropagation();
    }, update: (t12, i10) => {
      a14.pinch.update(this.view, i10.data), i10.stopPropagation();
    }, end: (t12, i10) => {
      a14.pinch.end(this.view), i10.stopPropagation();
    }, condition: (t12) => t12 >= 2 });
  }
  _handleDrag(t12) {
    this._dragEventSeparator.handle(t12);
  }
  _stopMomentumNavigation() {
    this.view.mapViewNavigation.pinch.stopMomentumNavigation();
  }
};

// node_modules/@arcgis/core/views/input/recognizers/DoubleTapDrag.js
var p4 = class extends i2 {
  constructor(e8 = l5.maximumDoubleClickDelay, a14 = l5.maximumDoubleClickDistance, r9 = l5.maximumDoubleTouchDelay, n6 = l5.maximumDoubleTouchDistance, u3 = t3) {
    super(false), this._maximumDoubleClickDelay = e8, this._maximumDoubleClickDistance = a14, this._maximumDoubleTouchDelay = r9, this._maximumDoubleTouchDistance = n6, this._clock = u3, this._doubleTapDragReady = false, this._doubleTapDragActive = false, this._dragStartCenter = c(0, 0), this._pointerState = /* @__PURE__ */ new Map(), this._doubleTapDrag = this.registerOutgoing("double-tap-drag"), this._dragEventSeparator = new t7({ start: (t12, e9) => this._dragStart(t12, e9), update: (t12, e9) => this._dragUpdate(e9), end: (t12, e9) => this._dragEnd(e9) }), this.registerIncoming("drag", (t12) => this._dragEventSeparator.handle(t12)), this.registerIncoming("pointer-down", (t12) => this._handlePointerDown(t12)), this.registerIncoming("pointer-up", () => this._handlePointerUp());
  }
  onUninstall() {
    this._pointerState.forEach((t12) => {
      t12.doubleTapTimeout = o(t12.doubleTapTimeout);
    });
  }
  get hasPendingInputs() {
    return n(this._pointerState, (t12) => null != t12.doubleTapTimeout);
  }
  _clearPointerDown(t12) {
    const e8 = this._pointerState.get(t12);
    e8 && (e8.doubleTapTimeout = o(e8.doubleTapTimeout), this._pointerState.delete(t12), this.refreshHasPendingInputs());
  }
  _createDoubleTapDragData(t12, e8, a14) {
    const { button: i9, buttons: o8, pointer: r9, pointers: s10, pointerType: n6, timestamp: u3 } = a14;
    return { action: t12, delta: e8, button: i9, buttons: o8, pointer: r9, pointers: s10, pointerType: n6, timestamp: u3 };
  }
  _dragStart(t12, e8) {
    if (!this._doubleTapDragReady || 1 !== t12)
      return;
    this._doubleTapDragReady = false, this._doubleTapDragActive = true;
    const { data: a14, modifiers: o8 } = e8, { center: r9 } = a14;
    this._dragStartCenter = r9;
    const s10 = this._createDoubleTapDragData("begin", c(0, 0), a14);
    this._doubleTapDrag.emit(s10, void 0, o8), e8.stopPropagation();
  }
  _dragUpdate(t12) {
    if (!this._doubleTapDragActive)
      return;
    const { data: e8, modifiers: a14 } = t12, { center: o8 } = e8, r9 = c(o8.x - this._dragStartCenter.x, o8.y - this._dragStartCenter.y), s10 = this._createDoubleTapDragData("update", r9, e8);
    this._doubleTapDrag.emit(s10, void 0, a14), t12.stopPropagation();
  }
  _dragEnd(t12) {
    if (!this._doubleTapDragActive)
      return;
    const { data: e8, modifiers: a14 } = t12, { center: o8 } = e8, r9 = c(o8.x - this._dragStartCenter.x, o8.y - this._dragStartCenter.y), s10 = this._createDoubleTapDragData("end", r9, e8);
    this._doubleTapDrag.emit(s10, void 0, a14), this._doubleTapDragActive = false, t12.stopPropagation();
  }
  _handlePointerDown(t12) {
    const { data: e8 } = t12, a14 = c4(e8), i9 = this._pointerState.get(a14), { pointerType: o8 } = e8.native;
    if (i9) {
      const r9 = "touch" === o8 ? this._maximumDoubleTouchDistance : this._maximumDoubleClickDistance;
      this._clearPointerDown(a14), e3(i9.event.data, e8) > r9 ? this._storePointerDown(t12) : this._doubleTapDragReady = true;
    } else
      this._storePointerDown(t12);
  }
  _handlePointerUp() {
    this._doubleTapDragReady = false;
  }
  _storePointerDown(t12) {
    const { data: e8 } = t12, { pointerType: a14 } = e8.native, i9 = c4(e8), o8 = "touch" === a14 ? this._maximumDoubleTouchDelay : this._maximumDoubleClickDelay, r9 = this._clock.setTimeout(() => this._clearPointerDown(i9), o8);
    this._pointerState.set(i9, { event: t12, doubleTapTimeout: r9 }), this.refreshHasPendingInputs();
  }
};

// node_modules/@arcgis/core/views/2d/input/MapViewInputManager.js
var z3 = { counter: "Ctrl", pan: { left: "ArrowLeft", right: "ArrowRight", up: "ArrowUp", down: "ArrowDown" }, zoom: { zoomIn: ["=", "+"], zoomOut: ["-", "_"] }, rotate: { clockwiseOption1: "a", clockwiseOption2: "A", counterClockwiseOption1: "d", counterClockwiseOption2: "D", resetOption1: "n", resetOption2: "N" } };
var k = class extends m {
  constructor() {
    super(...arguments), this._handles = new t2();
  }
  initialize() {
    const e8 = () => {
      var _a;
      return (_a = this.view) == null ? void 0 : _a.ready;
    };
    this._handles.add([f2(() => !e8(), () => this._disconnect()), f2(e8, () => this._connect())]);
  }
  destroy() {
    this._handles = l(this._handles), this._disconnect();
  }
  get latestPointerType() {
    var _a;
    return (_a = this._inputManager) == null ? void 0 : _a.latestPointerType;
  }
  get latestPointerLocation() {
    var _a;
    return (_a = this._inputManager) == null ? void 0 : _a.latestPointerLocation;
  }
  get multiTouchActive() {
    var _a;
    return ((_a = this._inputManager) == null ? void 0 : _a.multiTouchActive) ?? false;
  }
  _disconnect() {
    this.view.viewEvents.disconnect(), this._inputManager = l(this._inputManager);
  }
  _connect() {
    const e8 = this.view.surface, t12 = new c3(e8, this.view.input), o8 = [new m4(), new r5(), new m3(), new s7(this.view.navigation), new p4()], r9 = new d2({ eventSource: t12, recognizers: o8 });
    r9.installHandlers("prevent-context-menu", [new e2()], _.INTERNAL), r9.installHandlers("navigation", [new a12(this.view), new d4(this.view), new o7(this.view), new a11(this.view), new a11(this.view, [z3.counter]), new n5(this.view, "primary"), new i7(this.view, z3.pan), new e6(this.view, z3.zoom), new i8(this.view, z3.rotate), new o6(this.view, "secondary"), new e5(this.view, "touch")], _.INTERNAL), this.view.viewEvents.connect(r9), this._source = t12, this._inputManager = r9, l3(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.navigation) == null ? void 0 : _b.browserTouchPanEnabled;
    }, (e9) => {
      this._source && (this._source.browserTouchPanningEnabled = !e9);
    }, h);
  }
  get test() {
    return { inputManager: this._inputManager };
  }
};
e([y()], k.prototype, "view", void 0), e([y()], k.prototype, "latestPointerType", null), e([y()], k.prototype, "latestPointerLocation", null), e([y()], k.prototype, "multiTouchActive", null), k = e([a2("esri.views.2d.input.MapViewInputManager")], k);
var C2 = k;

// node_modules/@arcgis/core/views/support/createScreenshotPlan.js
function t11(t12, h6, i9, e8, l10, d5, n6, o8) {
  t12.ignorePadding && (e8 = { left: 0, right: 0, top: 0, bottom: 0 });
  let u3 = null;
  null != t12.width && null != t12.height ? u3 = [t12.width, t12.height] : null == t12.width && null != t12.height ? u3 = [t12.height, t12.height] : null != t12.width && null == t12.height ? u3 = [t12.width, t12.width] : null == t12.width && null == t12.height && (u3 = null);
  const r9 = i9[0] - (e8.left + e8.right), a14 = i9[1] - (e8.top + e8.bottom);
  let g, w5, c9 = t12.area || { x: 0, y: 0, width: r9, height: a14 };
  if (u3) {
    const t13 = r9 / a14, h7 = u3[0] / u3[1];
    if (h7 > t13) {
      const t14 = c9.width / h7;
      c9 = { x: c9.x, y: Math.round(c9.y + (c9.height - t14) / 2), width: c9.width, height: Math.round(t14) };
    } else {
      const t14 = c9.height * h7;
      c9 = { x: Math.round(c9.x + (c9.width - t14) / 2), y: c9.y, width: Math.round(t14), height: c9.height };
    }
  } else
    u3 = [c9.width, c9.height];
  u3[0] > c9.width ? (g = Math.min(u3[0] / c9.width, h6), w5 = u3[0] / c9.width / g) : (g = 1, w5 = u3[0] / c9.width);
  return { resolutionScale: g, cropArea: { x: Math.round((c9.x + e8.left) * g), y: Math.round((c9.y + e8.top) * g), width: Math.round(c9.width * g), height: Math.round(c9.height * g) }, outputScale: w5, format: l10, quality: d5, children: n6, rotation: o8 };
}

// node_modules/@arcgis/core/views/ui/2d/DefaultUI2D.js
var e7 = class extends h5 {
  constructor(o8) {
    super(o8), this.components = ["attribution", "zoom"];
  }
};
e([y()], e7.prototype, "components", void 0), e7 = e([a2("esri.views.ui.2d.DefaultUI2D")], e7);
var p5 = e7;

// node_modules/@arcgis/core/webmap/background/ColorBackground.js
var p6;
var a13 = p6 = class extends l2 {
  constructor(o8) {
    super(o8), this.color = new h2([0, 0, 0, 1]);
  }
  clone() {
    return new p6(a({ color: this.color }));
  }
};
e([y({ type: h2, json: { write: true } })], a13.prototype, "color", void 0), a13 = p6 = e([a2("esri.webmap.background.ColorBackground")], a13);
var m7 = a13;

// node_modules/@arcgis/core/views/MapView.js
var X;
var Z2;
var ee;
var te;
var ie;
var re;
async function se() {
  const [, { GraphicsView2D: e8, GraphicContainer: t12, LabelManager: i9, MapViewNavigation: r9, MagnifierView2D: s10, Stage: a14 }] = await Promise.all([import("./webglDeps-6LQKKQHX.js"), import("./mapViewDeps-CDPYMB6A.js")]);
  Z2 = e8, ee = t12, te = i9, ie = r9, re = s10, X = a14;
}
var ae = 160;
var ne = { flipY: true, premultipliedAlpha: true };
var oe = class extends w2(w3(C(z))) {
  constructor(e8) {
    super(e8), this._magnifierView = null, this._stage = null, this._resolveWhenReady = [], this.rootLayerViews = new n2({ getCollections: () => {
      var _a, _b;
      return [(_a = this.basemapView) == null ? void 0 : _a.baseLayerViews, this.layerViews, (_b = this.basemapView) == null ? void 0 : _b.referenceLayerViews];
    }, getChildrenFunction: () => null }), this.featuresTilingScheme = null, this.fullOpacity = 1, this.graphicsView = null, this.stateManager = new z2({ constraints: new f3({ view: this }) }), this.labelManager = null, this.mapViewNavigation = null, this.renderingOptions = { samplingMode: "dynamic", edgeLabelsVisible: true, labelsAnimationTime: 125, labelCollisionsEnabled: true }, this.rendering = false, this.supersampleScreenshotsEnabled = true, this.supportsGround = false, this._stationaryTimer = null, this._gotoTask = null, this.frameTask = new a7(this), this._pePromise = null, this.floors = new V(), this.highlightOptions = new c6(), this.inputManager = new C2({ view: this }), this.map = null, this.spatialReferenceLocked = false, this.timeline = new e4(), this.type = "2d", this.ui = new p5(), this.padding = { top: 0, right: 0, bottom: 0, left: 0 }, this.addHandles([l3(() => this.viewpoint, () => {
      this._lastStationaryEventTimestamp = performance.now(), this._flipStationary(ae);
    }, U), this.on("resize", (e9) => this.stateManager.resize(e9.width, e9.height)), l3(() => {
      var _a;
      return (_a = this.animationManager) == null ? void 0 : _a.animation;
    }, (e9) => {
      this.animation = e9;
    })]), c2();
  }
  destroy() {
    this._set("preconditionsReady", false), this.frameTask = l(this.frameTask), this._gotoTask = null, this.rootLayerViews.destroy(), this.inputManager.destroy(), this._set("inputManager", null);
  }
  get graphicsTileStore() {
    return new d(this.featuresTilingScheme);
  }
  get constraintsInfo() {
    var _a, _b;
    const e8 = (_a = this.defaultsFromMap) == null ? void 0 : _a.tileInfo, t12 = this.spatialReference;
    return { lods: ((_b = e8 == null ? void 0 : e8.spatialReference) == null ? void 0 : _b.equals(t12)) ? e8.lods : null, spatialReference: t12 };
  }
  get state() {
    return this.stateManager.state;
  }
  get initialExtentRequired() {
    var _a;
    if (!this.stateManager)
      return false;
    const { scale: e8, constraints: t12, center: i9, viewpoint: r9, extent: s10 } = this;
    let a14 = this.zoom;
    return !(this.map && "initialViewProperties" in this.map && ((_a = this.map.initialViewProperties) == null ? void 0 : _a.viewpoint)) && (!s10 && ((t12 == null ? void 0 : t12.effectiveLODs) || (a14 = -1), (!i9 || 0 === e8 && -1 === a14) && (!r9 || null == r9.targetGeometry || "extent" !== r9.targetGeometry.type && !r9.scale)));
  }
  get resourceManager() {
    return this._stage.resourceManager;
  }
  get textureManager() {
    return this._stage.painter.textureManager;
  }
  get _defaultsFromMapSettings() {
    return { required: { tileInfo: true, heightModelInfo: false, extent: false }, requiresExtentInSpatialReference: this.spatialReferenceLocked };
  }
  get _projectionEngineLoaded() {
    return !!Y() || (this._pePromise || (this._pePromise = $().finally(() => {
      this._pePromise = null;
    })), false);
  }
  get typeSpecificPreconditionsReady() {
    const e8 = this._getDefaultViewpoint();
    if (!e8)
      return false;
    const t12 = this.spatialReference, i9 = e8.targetGeometry;
    return !!Cn(i9.spatialReference, t12) || this._projectionEngineLoaded;
  }
  set animation(e8) {
    const t12 = this._get("animation");
    if (e8 === t12)
      return;
    if (t12 && t12.stop(), !e8 || e8.isFulfilled())
      return void this._set("animation", null);
    this._set("animation", e8), this.frameTask.animationInProgress = true;
    const i9 = () => {
      var _a;
      e8 === this._get("animation") && (this._set("animation", null), (_a = this.frameTask) == null ? void 0 : _a.requestFrame()), this.frameTask.animationInProgress = false;
    };
    e8.when(i9, i9);
  }
  get background() {
    return ce(this.map) ? this.map.initialViewProperties.background : null;
  }
  set background(e8) {
    this._override("background", e8);
  }
  get center() {
    var _a;
    return ((_a = this.stateManager) == null ? void 0 : _a.center) ?? null;
  }
  set center(e8) {
    this.stateManager.center = e8;
  }
  get constraints() {
    var _a;
    return (_a = this.stateManager) == null ? void 0 : _a.constraints;
  }
  set constraints(e8) {
    e8.view = this;
    const t12 = this.stateManager.constraints;
    this.stateManager.constraints = e8, t12 == null ? void 0 : t12.destroy();
  }
  get extent() {
    var _a;
    return ((_a = this.stateManager) == null ? void 0 : _a.extent) ?? null;
  }
  set extent(e8) {
    this.stateManager.extent = e8;
  }
  get padding() {
    var _a;
    return (_a = this.stateManager) == null ? void 0 : _a.padding;
  }
  set padding(e8) {
    this.stateManager && (this.stateManager.padding = e8);
  }
  get resizeAlign() {
    return this.stateManager.resizeAlign;
  }
  set resizeAlign(e8) {
    this.stateManager.resizeAlign = e8;
  }
  get resolution() {
    return this.stateManager.resolution ?? 0;
  }
  get rotation() {
    return this.stateManager.rotation ?? 0;
  }
  set rotation(e8) {
    this.stateManager.rotation = e8;
  }
  get scale() {
    var _a;
    return ((_a = this.stateManager) == null ? void 0 : _a.scale) ?? 0;
  }
  set scale(e8) {
    this.stateManager && (this.stateManager.scale = e8);
  }
  get stationary() {
    return !(this.animation || this.navigating || this.resizing || this._stationaryTimer);
  }
  get updating() {
    var _a, _b, _c;
    const e8 = !this.destroyed && (!this.layerViewManager || !this.labelManager || !this.graphicsView || true === this.layerViewManager.updating || true === this.labelManager.updating || true === this.graphicsView.updating || this.allLayerViews.some((e9) => !e9.destroyed && !("layerViews" in e9) && true === e9.updating));
    if (has("esri-2d-log-updating")) {
      const t12 = this.allLayerViews.reduce((e9, t13) => ({ ...e9, [t13.layer.id]: !t13.destroyed && !("layerViews" in t13) && t13.updating }), {});
      console.log(`Updating MapView: ${e8}
-> Null LayerViewManager: ${!this.layerViewManager}
-> Null LabelManager: ${!this.labelManager}
-> Null GraphicsView: ${!this.graphicsView}
-> layerViewManager.updating: ${(_a = this.layerViewManager) == null ? void 0 : _a.updating}
-> labelManager.updating: ${(_b = this.labelManager) == null ? void 0 : _b.updating}
-> graphicsView.updating: ${(_c = this.graphicsView) == null ? void 0 : _c.updating}
-> allLayerViews: ${JSON.stringify(t12)}
`);
    }
    return e8;
  }
  get viewpoint() {
    return this.stateManager.viewpoint ?? null;
  }
  set viewpoint(e8) {
    this.stateManager.viewpoint = e8, this.frameTask.requestFrame();
  }
  get zoom() {
    return this.stateManager.zoom ?? -1;
  }
  set zoom(e8) {
    this.stateManager.zoom = e8;
  }
  get navigating() {
    return !(!this.mapViewNavigation || !this.mapViewNavigation.interacting);
  }
  goTo(e8, t12) {
    if (e8)
      return this.animation && (this.animation = null), this._createAnimation(), j2(() => this.ready, t12).then(() => {
        var _a;
        const i9 = { animate: true, ...t12 }, r9 = J(e8, this);
        return (_a = this.animation) == null ? void 0 : _a.update(r9), this._gotoTask = {}, i9.animate ? this._gotoAnimated(r9, i9) : this._gotoImmediate(r9, i9);
      });
    s.getLogger(this).error("#goTo()", "target cannot be null or undefined");
  }
  async hitTest(e8, t12) {
    const i9 = o4(e8) ? r4(this, e8) : e8;
    if (!this.ready || isNaN(i9.x) || isNaN(i9.y))
      return { screenPoint: i9, results: [] };
    let s10 = /* @__PURE__ */ new Set(), a14 = false, n6 = null, o8 = null;
    (t12 == null ? void 0 : t12.include) ? ge(t12.include, he(this, (e9) => s10.add(e9), (e9) => {
      n6 || (n6 = /* @__PURE__ */ new Set()), n6.add(e9);
    }, (e9) => s10.add(e9), () => a14 = true)) : (a14 = true, s10 = new Set(this.allLayerViews)), (t12 == null ? void 0 : t12.exclude) && ge(t12.exclude, he(this, (e9) => s10.delete(e9), (e9) => {
      o8 || (o8 = /* @__PURE__ */ new Set()), o8.add(e9);
    }));
    const l10 = this.allLayerViews.filter((e9) => !e9.suspended && s10.has(e9)).reverse(), p7 = this.toMap(i9);
    let h6 = [...a14 ? this.graphicsView.hitTest(p7).map((e9) => ({ type: "graphic", graphic: e9, layer: null, mapPoint: p7 })) : [], ...await Promise.all(l10.map((e9) => e9.hitTest(p7, i9)).toArray())].filter(R).flat().filter(R);
    return n6 && (h6 = h6.filter((e9) => !("graphic" in e9) || !e9.graphic || (n6 == null ? void 0 : n6.has(pe(e9.graphic))))), o8 && (h6 = h6.filter((e9) => !("graphic" in e9) || !e9.graphic || !(o8 == null ? void 0 : o8.has(pe(e9.graphic))))), { screenPoint: i9, results: h6 };
  }
  async takeScreenshot(e8) {
    const t12 = this._createScreenshotPlan(e8), i9 = await this._stage.takeScreenshot(t12);
    return a6(i9, { format: t12.format, quality: t12.quality, rotation: 0, disableDecorations: false }, ne);
  }
  async _takeScreenshot(e8) {
    const t12 = this._createScreenshotPlan(e8), i9 = await this._stage.takeScreenshot(t12);
    return r6(i9, ne);
  }
  _createScreenshotPlan(e8) {
    e8 = e8 ?? {};
    const t12 = this.supersampleScreenshotsEnabled ? Math.min(4, s8(this.size, Math.min(4096, this._stage.context.parameters.maxTextureSize))) : 1;
    let i9;
    e8.layers ? (i9 = [], e8.layers.forEach((e9) => {
      const t13 = this.allLayerViews.find((t14) => t14.layer.id === e9.id);
      t13 && "container" in t13 && t13.container && i9.push(t13.container);
    })) : i9 = this._stage.children;
    const { format: r9, quality: s10 } = c5(e8.format, e8.quality);
    return t11(e8, t12, this.size, this.padding, r9, s10, i9, e8.rotation);
  }
  get test() {
    return { takeScreenshot: (e8) => this._takeScreenshot(e8) };
  }
  toMap(e8) {
    if (!this.ready)
      return null;
    const t12 = o4(e8) ? r4(this, e8) : e8;
    return this.stateManager.toMap(t12);
  }
  toScreen(e8) {
    return this.stateManager.toScreen(e8);
  }
  on(e8, t12, i9, r9) {
    const s10 = this.inputManager && this.viewEvents.on(e8, t12, i9, r9);
    return s10 || super.on(e8, t12);
  }
  hasEventListener(e8) {
    return super.hasEventListener(e8) || this.viewEvents.hasHandler(e8);
  }
  whenLayerView(e8) {
    return super.whenLayerView(e8);
  }
  graphicChanged(e8) {
    if (this.graphicsView) {
      this.graphicsView.graphicUpdateHandler(e8);
    }
  }
  whenReady() {
    return new Promise((e8) => {
      this.ready ? e8(this) : this._resolveWhenReady.push(e8);
    });
  }
  forceDOMReadyCycle() {
    this.forceReadyCycle();
  }
  getDefaultSpatialReference() {
    var _a, _b, _c;
    return this.map && "initialViewProperties" in this.map && ((_b = (_a = this.map) == null ? void 0 : _a.initialViewProperties) == null ? void 0 : _b.spatialReference) || ((_c = this.defaultsFromMap) == null ? void 0 : _c.spatialReference) || null;
  }
  hasLayerViewModule(e8) {
    return l7.hasLayerViewModule(e8);
  }
  importLayerView(e8) {
    return l7.importLayerView(e8);
  }
  pixelSizeAt() {
    return this.ready ? this.resolution : (s.getLogger(this).error("#pixelSizeAt()", "Map view cannot be used before it is ready"), null);
  }
  popupHitTest(e8) {
    return this.hitTest(e8).then((t12) => ({ ...t12, mapPoint: this.toMap(e8) }));
  }
  requestUpdate() {
    this.ready && this.frameTask.requestUpdate();
  }
  validate() {
    let e8 = i4(this.type);
    return has("safari") && has("safari") < 9 && (e8 = new s2("mapview:browser-not-supported", "This browser is not supported by MapView (Safari < 9)", { type: "safari", requiredVersion: 9, detectedVersion: has("safari") })), null != e8 ? (s.getLogger(this).warn("#validate()", e8.message), Promise.reject(e8)) : se();
  }
  _createAnimation() {
    return this.animation && !this.animation.done || (this.animation = new a4()), this.animation;
  }
  _cancellableGoTo(e8, t12, i9) {
    const r9 = () => e8 === this._gotoTask, s10 = i9.then(() => {
      r9() && (this.animation = null);
    }).catch((e9) => {
      throw r9() && (t12 && !t12.done && (t12.stop(), this.frameTask.animationInProgress = false), this.animation = null), e9;
    }), a14 = new Promise((e9) => e9(s10));
    return t12.when().catch(() => {
      r9() && a14.cancel && a14.cancel();
    }), a14;
  }
  _gotoImmediate(e8, t12) {
    const i9 = this._gotoTask, r9 = this.animation, s10 = e8.then((e9) => {
      if (s3(t12), i9 !== this._gotoTask)
        throw new s2("view:goto-interrupted", "Goto was interrupted");
      this.viewpoint = r9.target = e9, r9.finish();
    });
    return this._cancellableGoTo(i9, r9, s10);
  }
  _flipStationary(e8) {
    return null !== this._stationaryTimer || (this._stationaryTimer = setTimeout(() => {
      this._stationaryTimer = null;
      const e9 = performance.now() - this._lastStationaryEventTimestamp;
      e9 < ae && (this._stationaryTimer = this._flipStationary(e9));
    }, e8)), this._stationaryTimer;
  }
  _getDefaultViewpoint() {
    var _a;
    const { constraints: e8, initialExtent: t12, map: r9, padding: s10, size: a14 } = this;
    if (!e8)
      return null;
    const n6 = r9 && "initialViewProperties" in r9 ? r9.initialViewProperties : void 0, o8 = this.stateManager.getUserStartupOptions(this.size), l10 = n6 == null ? void 0 : n6.viewpoint, p7 = ((_a = l10 == null ? void 0 : l10.targetGeometry) == null ? void 0 : _a.extent) ?? t12, h6 = p7 == null ? void 0 : p7.center, g = (l10 == null ? void 0 : l10.rotation) ?? 0, c9 = (l10 == null ? void 0 : l10.scale) || p7 && D(p7, [a14[0] - s10.left - s10.right, a14[1] - s10.top - s10.bottom]), u3 = o8.center ?? h6, d5 = o8.rotation ?? g, m8 = o8.scale ?? c9;
    return u3 && m8 ? new l4({ targetGeometry: u3, scale: m8, rotation: d5 }) : null;
  }
  _gotoAnimated(e8, t12) {
    const i9 = this._gotoTask, r9 = this.animation;
    if (!r9)
      return Promise.resolve();
    const s10 = e8.then((e9) => {
      if (s3(t12), i9 !== this._gotoTask)
        throw new s2("view:goto-interrupted", "Goto was interrupted");
      return r9.update(e9), this.animationManager.animate(r9, this.viewpoint, t12), r9.when().then(() => {
      }, () => {
      });
    });
    return this._cancellableGoTo(i9, r9, s10);
  }
  _startup() {
    var _a;
    this.timeline.begin("MapView Startup");
    const e8 = this._getDefaultViewpoint();
    this.stateManager.startup(e8, this.size, this.spatialReference, (_a = this.defaultsFromMap.extent) == null ? void 0 : _a.center), this.graphics.owner = this;
    const t12 = new X(this.surface, { canvas: this.renderCanvas, supersampleScreenshots: this.supersampleScreenshotsEnabled, contextOptions: { disabledExtensions: this.deactivatedWebGLExtensions, debugWebGLExtensions: this.debugWebGLExtensions }, renderingOptions: this.renderingOptions, timeline: this.timeline });
    this._stage = t12, this._magnifierView = new re(), this._magnifierView.magnifier = this.magnifier;
    const i9 = new te({ view: this });
    this._set("labelManager", i9);
    const r9 = new l6({ view: this });
    this._set("animationManager", r9);
    const s10 = new ie({ view: this, animationManager: r9 });
    this._set("mapViewNavigation", s10), this._setupSpatialReferenceDependentProperties(), this.handles.add([this.rootLayerViews.on("change", () => this._updateStageChildren()), t12.on("post-render", () => this._set("rendering", t12.renderRequested)), t12.on("will-render", () => this._set("rendering", t12.renderRequested)), t12.on("webgl-error", (e9) => this.fatalError = e9.error), l3(() => this.stationary, (e9) => t12.stationary = e9, w), l3(() => this.background, (e9) => {
      t12.backgroundColor = e9 == null ? void 0 : e9.color, this._magnifierView.backgroundColor = e9 == null ? void 0 : e9.color;
    }, w), l3(() => this.magnifier, (e9) => this._magnifierView.magnifier = e9, w), l3(() => this.renderingOptions, (e9) => t12.renderingOptions = e9, w), l3(() => this.highlightOptions, (e9) => t12.highlightOptions = e9, w), l3(() => this.state.id, () => t12.state = this.state, w)], "map-view"), this._updateStageChildren();
    const a14 = this._resolveWhenReady;
    this._resolveWhenReady = [], a14.forEach((e9) => e9(this)), this.timeline.end("MapView Startup"), this.frameTask.start(), this._set("ready", true);
  }
  _teardown() {
    this._destroySpatialReferenceDependentProperties(), this.handles.remove("map-view"), this.mapViewNavigation.destroy(), this._set("mapViewNavigation", null), this.animationManager.destroy(), this._set("animationManager", null), this.layerViewManager.clear(), this.labelManager.destroy(), this._magnifierView.destroy(), this._stage.destroy(), this._stage = null, this._set("graphicsView", null), this._magnifierView = null, this._set("labelManager", null), this._set("mapViewNavigation", null), this.graphics.owner = null, this.frameTask.stop(), this._stationaryTimer && (clearTimeout(this._stationaryTimer), this._stationaryTimer = null), this._set("ready", false), this.stateManager.teardown(), this.animation = null;
  }
  _updateStageChildren() {
    this._stage.removeAllChildren(), this.rootLayerViews.forEach((e9) => {
      this._stage.addChild(e9.container);
    });
    const e8 = this.graphicsView;
    this._stage.addChild(e8.container), this._stage.addChild(this._magnifierView);
  }
  _setupSpatialReferenceDependentProperties() {
    const e8 = new h3(j3.create({ spatialReference: this.spatialReference, size: 512, numLODs: 36 }));
    this._set("featuresTilingScheme", e8);
    const t12 = new Z2({ view: this, graphics: this.graphics, requestUpdateCallback: () => this.requestUpdate(), container: new ee(e8) });
    this._set("graphicsView", t12);
  }
  _destroySpatialReferenceDependentProperties() {
    const e8 = this.graphicsView;
    this._set("graphicsView", null), e8.destroy(), this._set("featuresTilingScheme", null);
  }
  _spatialReferenceChanged(e8) {
    if (this.ready) {
      this.frameTask.stop();
      for (const e9 of this.allLayerViews)
        e9.processDetach();
      this._destroySpatialReferenceDependentProperties(), this.stateManager.changeSpatialReference(e8), this._stage.state = this.state, this._setupSpatialReferenceDependentProperties();
      for (const e9 of this.allLayerViews)
        e9.processAttach();
      this.frameTask.requestFrame(), this.frameTask.start(), this._updateStageChildren();
    }
  }
};
oe.type = "2d", e([y({ readOnly: true })], oe.prototype, "animationManager", void 0), e([y({ constructOnly: true })], oe.prototype, "deactivatedWebGLExtensions", void 0), e([y({ constructOnly: true })], oe.prototype, "debugWebGLExtensions", void 0), e([y({ readOnly: true })], oe.prototype, "featuresTilingScheme", void 0), e([y({ readOnly: true })], oe.prototype, "fullOpacity", void 0), e([y({ readOnly: true })], oe.prototype, "graphicsTileStore", null), e([y()], oe.prototype, "graphicsView", void 0), e([y()], oe.prototype, "stateManager", void 0), e([y()], oe.prototype, "constraintsInfo", null), e([y({ readOnly: true })], oe.prototype, "state", null), e([y()], oe.prototype, "initialExtentRequired", null), e([y()], oe.prototype, "labelManager", void 0), e([y({ readOnly: true })], oe.prototype, "resourceManager", null), e([y({ readOnly: true })], oe.prototype, "textureManager", null), e([y({ readOnly: true })], oe.prototype, "mapViewNavigation", void 0), e([y({ constructOnly: true })], oe.prototype, "renderCanvas", void 0), e([y()], oe.prototype, "renderingOptions", void 0), e([y({ readOnly: true })], oe.prototype, "rendering", void 0), e([y({ constructOnly: true })], oe.prototype, "supersampleScreenshotsEnabled", void 0), e([y({ readOnly: true })], oe.prototype, "supportsGround", void 0), e([y()], oe.prototype, "_stationaryTimer", void 0), e([y()], oe.prototype, "_defaultsFromMapSettings", null), e([y()], oe.prototype, "_pePromise", void 0), e([y({ readOnly: true })], oe.prototype, "typeSpecificPreconditionsReady", null), e([y()], oe.prototype, "animation", null), e([y({ type: m7 })], oe.prototype, "background", null), e([y()], oe.prototype, "center", null), e([y({ type: f3 })], oe.prototype, "constraints", null), e([y()], oe.prototype, "extent", null), e([y()], oe.prototype, "floors", void 0), e([y({ type: c6 })], oe.prototype, "highlightOptions", void 0), e([y({ readOnly: true })], oe.prototype, "inputManager", void 0), e([y()], oe.prototype, "map", void 0), e([y()], oe.prototype, "padding", null), e([y()], oe.prototype, "resizeAlign", null), e([y({ readOnly: true })], oe.prototype, "resolution", null), e([y()], oe.prototype, "rotation", null), e([y()], oe.prototype, "scale", null), e([y({ constructOnly: true })], oe.prototype, "spatialReferenceLocked", void 0), e([y()], oe.prototype, "stationary", null), e([y({ type: e4, readOnly: true })], oe.prototype, "timeline", void 0), e([y({ readOnly: true })], oe.prototype, "type", void 0), e([y({ readOnly: true })], oe.prototype, "updating", null), e([y()], oe.prototype, "viewpoint", null), e([y()], oe.prototype, "zoom", null), e([y({ readOnly: true })], oe.prototype, "navigating", null), e([y(), s5((e8) => e8 instanceof h5 ? e8 : v(p5, e8))], oe.prototype, "ui", void 0), oe = e([a2("esri.views.MapView")], oe);
var le = oe;
function pe(e8) {
  var _a, _b;
  const t12 = e8.getObjectId();
  return t12 ? `${((_a = e8.layer) == null ? void 0 : _a.uid) ?? ((_b = e8.sourceLayer) == null ? void 0 : _b.uid) ?? "MapView"}/${t12}` : `"MapView/${e8.uid}`;
}
function he(e8, i9, r9, s10, a14) {
  return (n6) => {
    if (n6 instanceof h4) {
      if (n6.layer === e8)
        a14 == null ? void 0 : a14();
      else {
        const t12 = e8.allLayerViews.find((e9) => e9.layer === n6.layer);
        t12 && (s10 == null ? void 0 : s10(t12));
      }
      r9(pe(n6));
    } else {
      const t12 = e8.allLayerViews.find((e9) => e9.layer === n6);
      t12 && i9(t12);
    }
  };
}
function ge(e8, t12) {
  if (e8)
    if (t(e8))
      for (const i9 of e8)
        if (t(i9))
          for (const e9 of i9)
            t12(e9);
        else
          t12(i9);
    else
      t12(e8);
}
function ce(e8) {
  return "esri.WebMap" === (e8 == null ? void 0 : e8.declaredClass);
}
export {
  le as default
};
//# sourceMappingURL=@arcgis_core_views_MapView__js.js.map
