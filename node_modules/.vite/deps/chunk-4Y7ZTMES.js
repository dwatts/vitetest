import {
  i
} from "./chunk-PR2OEILG.js";
import {
  a,
  e as e2,
  t as t2
} from "./chunk-UM64E5NS.js";
import {
  e
} from "./chunk-OX5TJXHM.js";
import {
  t
} from "./chunk-BDWD2ZNU.js";
import {
  h
} from "./chunk-4OR73Y2R.js";

// node_modules/@arcgis/core/geometry/support/triangulationUtils.js
function l(t3) {
  const r = f(t3.rings, t3.hasZ, a2.CCW_IS_HOLE), l2 = new Array();
  let h3 = 0, g2 = 0;
  for (const o of r.polygons) {
    const t4 = o.count, i2 = o.index, c2 = a(r.position, 3 * i2, 3 * t4), f2 = o.holeIndices.map((n) => n - i2), a3 = t(i(c2, f2, 3));
    l2.push({ position: c2, faces: a3 }), h3 += c2.length, g2 += a3.length;
  }
  const u = c(l2, h3, g2), p = Array.isArray(u.position) ? e(u.position, 3, { originalIndices: u.faces }) : e(u.position.buffer, 6, { originalIndices: u.faces });
  return u.position = e2(new Float64Array(p.buffer)), u.faces = p.indices, u;
}
function c(n, t3, e3) {
  if (1 === n.length)
    return n[0];
  const o = t2(t3), i2 = new Array(e3);
  let l2 = 0, c2 = 0, f2 = 0;
  for (const r of n) {
    for (let n2 = 0; n2 < r.position.length; n2++)
      o[l2++] = r.position[n2];
    for (const n2 of r.faces)
      i2[c2++] = n2 + f2;
    f2 = l2 / 3;
  }
  return { position: o, faces: t(i2) };
}
function f(n, t3, e3) {
  const o = n.length, s = new Array(o), i2 = new Array(o), l2 = new Array(o);
  let c2 = 0, f2 = 0, u = 0, p = 0;
  for (let r = 0; r < o; ++r)
    p += n[r].length;
  const d = t2(3 * p);
  let y = 0;
  for (let r = o - 1; r >= 0; r--) {
    const p2 = n[r], m = e3 === a2.CCW_IS_HOLE && g(p2);
    if (m && 1 !== o)
      s[c2++] = p2;
    else {
      let n2 = p2.length;
      for (let t4 = 0; t4 < c2; ++t4)
        n2 += s[t4].length;
      const e4 = { index: y, pathLengths: new Array(c2 + 1), count: n2, holeIndices: new Array(c2) };
      e4.pathLengths[0] = p2.length, p2.length > 0 && (l2[u++] = { index: y, count: p2.length }), y = m ? h2(p2, p2.length - 1, -1, d, y, p2.length, t3) : h2(p2, 0, 1, d, y, p2.length, t3);
      for (let o2 = 0; o2 < c2; ++o2) {
        const n3 = s[o2];
        e4.holeIndices[o2] = y, e4.pathLengths[o2 + 1] = n3.length, n3.length > 0 && (l2[u++] = { index: y, count: n3.length }), y = h2(n3, 0, 1, d, y, n3.length, t3);
      }
      c2 = 0, e4.count > 0 && (i2[f2++] = e4);
    }
  }
  for (let r = 0; r < c2; ++r) {
    const n2 = s[r];
    n2.length > 0 && (l2[u++] = { index: y, count: n2.length }), y = h2(n2, 0, 1, d, y, n2.length, t3);
  }
  return i2.length = f2, l2.length = u, { position: d, polygons: i2, outlines: l2 };
}
function h2(n, t3, e3, o, r, s, i2) {
  r *= 3;
  for (let l2 = 0; l2 < s; ++l2) {
    const s2 = n[t3];
    o[r++] = s2[0], o[r++] = s2[1], o[r++] = i2 ? s2[2] : 0, t3 += e3;
  }
  return r / 3;
}
function g(n) {
  return !h(n, false, false);
}
var a2;
!function(n) {
  n[n.NONE = 0] = "NONE", n[n.CCW_IS_HOLE = 1] = "CCW_IS_HOLE";
}(a2 || (a2 = {}));

export {
  l,
  f,
  a2 as a
};
//# sourceMappingURL=chunk-4Y7ZTMES.js.map
