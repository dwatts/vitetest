import {
  j as j5,
  v as v2
} from "./chunk-VIDC736D.js";
import {
  O,
  R,
  T,
  W,
  h,
  p2 as p,
  z as z2
} from "./chunk-FOEAKQNX.js";
import {
  a as a4,
  f2
} from "./chunk-LEDSC236.js";
import {
  a as a3,
  c,
  f
} from "./chunk-NETCTS4Y.js";
import {
  e as e2,
  n as n3,
  r as r3
} from "./chunk-YGUWDSEH.js";
import {
  A as A2,
  L as L2,
  a as a2,
  j as j4,
  k,
  m as m2,
  o as o2,
  v,
  w
} from "./chunk-NLWV7Q6F.js";
import {
  l
} from "./chunk-RVS5HU2K.js";
import {
  e as e3,
  n as n4,
  r as r4
} from "./chunk-SS3YG6J3.js";
import {
  Cn
} from "./chunk-BNBT4QTW.js";
import {
  j as j3,
  m2 as m
} from "./chunk-4OR73Y2R.js";
import {
  M
} from "./chunk-TEHNQYQD.js";
import {
  A,
  G,
  H,
  P,
  _,
  g,
  j,
  o,
  r as r2,
  u,
  x,
  z
} from "./chunk-TPJLFGOT.js";
import {
  e,
  n,
  r
} from "./chunk-CQX57DED.js";
import {
  E,
  a2 as a,
  j as j2
} from "./chunk-3CQBBMMD.js";
import {
  x2
} from "./chunk-ZEEBL7ZN.js";
import {
  d
} from "./chunk-RTDN6KAT.js";
import {
  n as n2
} from "./chunk-7KH4CLS5.js";
import {
  L,
  s
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/interactive/coordinateHelper.js
var R2;
!function(e6) {
  e6[e6.Z = 0] = "Z", e6[e6.M = 1] = "M";
}(R2 || (R2 = {}));
var x3 = class {
  constructor(e6) {
    this.spatialReference = e6;
  }
  createVector() {
    return this._tag(n4());
  }
  pointToVector(e6) {
    return this._tag(r4(e6.x, e6.y));
  }
  arrayToVector(e6) {
    return this._tag(r4(e6[0], e6[1]));
  }
  vectorToArray(e6) {
    return [e6[0], e6[1]];
  }
  pointToArray(e6) {
    return [e6.x, e6.y];
  }
  vectorToPoint(e6, t6 = new x2()) {
    return t6.x = e6[0], t6.y = e6[1], t6.z = void 0, t6.m = void 0, t6.spatialReference = this.spatialReference, t6;
  }
  arrayToPoint(e6, t6 = new x2()) {
    return t6.x = e6[0], t6.y = e6[1], t6.z = void 0, t6.m = void 0, t6.spatialReference = this.spatialReference, t6;
  }
  vectorToDehydratedPoint(e6, t6 = { x: void 0, y: void 0, z: void 0, m: void 0, hasZ: void 0, hasM: void 0, spatialReference: void 0, type: "point" }) {
    return t6.x = e6[0], t6.y = e6[1], t6.z = void 0, t6.m = void 0, t6.hasZ = false, t6.hasM = false, t6.spatialReference = this.spatialReference, t6;
  }
  lerp(t6, r6, a5, n5) {
    return A2(n5, t6, r6, a5);
  }
  addDelta(e6, t6, r6) {
    e6[0] += t6, e6[1] += r6;
  }
  distance(e6, r6) {
    return m2(e6, r6);
  }
  getZ(e6, t6 = void 0) {
    return t6;
  }
  hasZ() {
    return false;
  }
  getM(e6, t6 = void 0) {
    return t6;
  }
  hasM() {
    return false;
  }
  clone(e6) {
    return this._tag(e3(e6));
  }
  copy(e6, t6) {
    return a2(t6, e6);
  }
  fromXYZ(e6) {
    return this._tag(r4(e6[0], e6[1]));
  }
  toXYZ(e6, t6 = n()) {
    return o(t6, e6[0], e6[1], 0);
  }
  pointToXYZ(e6, t6 = n()) {
    return o(t6, e6.x, e6.y, 0);
  }
  equals(e6, t6) {
    return k(e6, t6);
  }
  _tag(e6) {
    return e6;
  }
};
var M2 = class {
  constructor(e6, t6) {
    this._valueType = e6, this.spatialReference = t6;
  }
  createVector() {
    return this._tag(n());
  }
  pointToVector(e6) {
    return this._tag(r(e6.x, e6.y, this._valueType === R2.Z ? e6.z : e6.m));
  }
  arrayToVector(e6) {
    return this._tag(r(e6[0], e6[1], e6[2] || 0));
  }
  vectorToArray(e6) {
    return [e6[0], e6[1], e6[2]];
  }
  pointToArray(e6) {
    return this._valueType === R2.Z ? [e6.x, e6.y, e6.z] : [e6.x, e6.y, e6.m];
  }
  vectorToPoint(e6, t6 = new x2()) {
    return t6.x = e6[0], t6.y = e6[1], t6.z = this._valueType === R2.Z ? e6[2] : void 0, t6.m = this._valueType === R2.M ? e6[2] : void 0, t6.spatialReference = this.spatialReference, t6;
  }
  arrayToPoint(e6, t6 = new x2()) {
    return t6.x = e6[0], t6.y = e6[1], t6.z = this._valueType === R2.Z ? e6[2] : void 0, t6.m = this._valueType === R2.M ? e6[2] : void 0, t6.spatialReference = this.spatialReference, t6;
  }
  vectorToDehydratedPoint(e6, t6 = { x: void 0, y: void 0, z: void 0, m: void 0, hasZ: void 0, hasM: void 0, spatialReference: void 0, type: "point" }) {
    const r6 = this._valueType === R2.Z, a5 = this._valueType === R2.M;
    return t6.x = e6[0], t6.y = e6[1], t6.z = r6 ? e6[2] : void 0, t6.m = a5 ? e6[2] : void 0, t6.hasZ = r6, t6.hasM = a5, t6.spatialReference = this.spatialReference, t6;
  }
  lerp(e6, t6, r6, a5) {
    return A(a5, e6, t6, r6);
  }
  addDelta(e6, t6, r6, a5) {
    e6[0] += t6, e6[1] += r6, this._valueType === R2.Z && (e6[2] += a5);
  }
  distance(e6, r6) {
    return this._valueType === R2.Z ? x(e6, r6) : m2(e6, r6);
  }
  getZ(e6, t6 = void 0) {
    return this._valueType === R2.Z ? e6[2] : t6;
  }
  hasZ() {
    return this._valueType === R2.Z;
  }
  getM(e6, t6 = void 0) {
    return this._valueType === R2.M ? e6[2] : t6;
  }
  hasM() {
    return this._valueType === R2.M;
  }
  clone(e6) {
    return this._tag(e(e6));
  }
  copy(e6, t6) {
    return r2(t6, e6);
  }
  fromXYZ(e6, t6 = 0, r6 = 0) {
    return this._tag(r(e6[0], e6[1], this._valueType === R2.Z ? e6.length > 2 ? e6[2] : t6 : r6));
  }
  toXYZ(e6, t6 = n()) {
    return o(t6, e6[0], e6[1], this._valueType === R2.Z ? e6[2] : 0);
  }
  pointToXYZ(e6, t6 = n()) {
    return o(t6, e6.x, e6.y, this._valueType === R2.Z ? e6.z ?? 0 : 0);
  }
  equals(e6, t6) {
    return G(e6, t6);
  }
  _tag(e6) {
    return e6;
  }
};
var z3 = class {
  constructor(e6) {
    this.spatialReference = e6;
  }
  createVector() {
    return this._tag(n3());
  }
  pointToVector(e6) {
    return this._tag(r3(e6.x, e6.y, e6.z, e6.m));
  }
  arrayToVector(e6) {
    return this._tag(r3(e6[0], e6[1], e6[2] || 0, e6[3] || 0));
  }
  vectorToArray(e6) {
    return [e6[0], e6[1], e6[2], e6[3]];
  }
  pointToArray(e6) {
    return [e6.x, e6.y, e6.z, e6.m];
  }
  vectorToPoint(e6, t6 = new x2()) {
    return t6.x = e6[0], t6.y = e6[1], t6.z = e6[2], t6.m = e6[3], t6.spatialReference = this.spatialReference, t6;
  }
  arrayToPoint(e6, t6 = new x2()) {
    return t6.x = e6[0], t6.y = e6[1], t6.z = e6[2], t6.m = e6[3], t6.spatialReference = this.spatialReference, t6;
  }
  vectorToDehydratedPoint(e6, t6 = { x: void 0, y: void 0, z: void 0, m: void 0, hasZ: void 0, hasM: void 0, spatialReference: void 0, type: "point" }) {
    return t6.x = e6[0], t6.y = e6[1], t6.z = e6[2], t6.m = e6[3], t6.hasZ = true, t6.hasM = true, t6.spatialReference = this.spatialReference, t6;
  }
  lerp(e6, t6, r6, a5) {
    return j2(a5, e6, t6, r6);
  }
  addDelta(e6, t6, r6, a5) {
    e6[0] += t6, e6[1] += r6, e6[2] += a5;
  }
  distance(e6, t6) {
    return x(e6, t6);
  }
  getZ(e6) {
    return e6[2];
  }
  hasZ() {
    return true;
  }
  getM(e6) {
    return e6[3];
  }
  hasM() {
    return true;
  }
  clone(e6) {
    return this._tag(e2(e6));
  }
  copy(e6, t6) {
    return a(t6, e6);
  }
  fromXYZ(e6, t6 = 0, r6 = 0) {
    return this._tag(r3(e6[0], e6[1], e6.length > 2 ? e6[2] : t6, r6));
  }
  toXYZ(e6, t6 = n()) {
    return o(t6, e6[0], e6[1], e6[2]);
  }
  pointToXYZ(e6, t6 = n()) {
    return o(t6, e6.x, e6.y, e6.z ?? 0);
  }
  equals(e6, t6) {
    return E(e6, t6);
  }
  _tag(e6) {
    return e6;
  }
};
function w2(e6, t6, r6) {
  return e6 && t6 ? new z3(r6) : t6 ? new M2(R2.M, r6) : e6 ? new M2(R2.Z, r6) : new x3(r6);
}

// node_modules/@arcgis/core/views/interactive/editGeometry/unnormalizationHelper.js
function e4(o3, r6) {
  if (!r6.supported)
    return;
  let e6 = 1 / 0, p4 = -1 / 0;
  const n5 = r6.upperBoundX - r6.lowerBoundX;
  o3.forEach((o4) => {
    let u3 = o4.pos[0];
    for (; u3 < r6.lowerBoundX; )
      u3 += n5;
    for (; u3 > r6.upperBoundX; )
      u3 -= n5;
    e6 = Math.min(e6, u3), p4 = Math.max(p4, u3), o4.pos[0] = u3;
  });
  const u2 = p4 - e6;
  n5 - u2 < u2 && o3.forEach((o4) => {
    o4.pos[0] < 0 && (o4.pos[0] += n5);
  });
}
function p2(e6, p4) {
  const n5 = d(e6);
  return p4 === l.Global && n5 ? { supported: true, lowerBoundX: n5.valid[0], upperBoundX: n5.valid[1] } : { supported: false, lowerBoundX: null, upperBoundX: null };
}

// node_modules/@arcgis/core/views/interactive/editGeometry/EditGeometry.js
var h2 = class {
  constructor(e6) {
    this.component = e6, this.leftEdge = null, this.rightEdge = null, this.type = "vertex", this.index = null;
  }
  get pos() {
    return this._pos;
  }
  set pos(e6) {
    this._pos = e6, this.component.unnormalizeVertexPositions();
  }
};
var c2 = class {
  constructor(e6, t6, s3) {
    this.component = e6, this.leftVertex = t6, this.rightVertex = s3, this.type = "edge", t6.rightEdge = this, s3.leftEdge = this;
  }
};
var l2 = class {
  constructor(e6, t6) {
    this._spatialReference = e6, this._viewingMode = t6, this.vertices = [], this.edges = [], this.index = null;
  }
  unnormalizeVertexPositions() {
    this.vertices.length <= 1 || e4(this.vertices, p2(this._spatialReference, this._viewingMode));
  }
  updateVertexIndex(e6, t6) {
    if (0 === this.vertices.length)
      return;
    const s3 = this.vertices[0];
    let i4 = null, r6 = e6, n5 = t6;
    do {
      i4 = r6, i4.index = n5++, r6 = i4.rightEdge ? i4.rightEdge.rightVertex : null;
    } while (null != r6 && r6 !== s3);
    i4.leftEdge && i4 !== this.vertices[this.vertices.length - 1] && this.swapVertices(this.vertices.indexOf(i4), this.vertices.length - 1);
  }
  getFirstVertex() {
    return 0 === this.vertices.length ? null : this.vertices[0];
  }
  getLastVertex() {
    return 0 === this.vertices.length ? null : this.vertices[this.vertices.length - 1];
  }
  isClosed() {
    return this.vertices.length > 2 && null !== this.vertices[0].leftEdge;
  }
  swapVertices(e6, t6) {
    const s3 = this.vertices[e6];
    this.vertices[e6] = this.vertices[t6], this.vertices[t6] = s3;
  }
  iterateVertices(e6) {
    if (0 === this.vertices.length)
      return;
    const t6 = this.vertices[0];
    let s3 = t6;
    do {
      e6(s3, s3.index), s3 = null != s3.rightEdge ? s3.rightEdge.rightVertex : null;
    } while (s3 !== t6 && null != s3);
  }
};
var p3 = class _p extends n2 {
  constructor(e6, t6) {
    super(), this.type = e6, this.coordinateHelper = t6, this._geometry = null, this._dirty = true, this.components = [];
  }
  get geometry() {
    if (this._dirty) {
      switch (this.type) {
        case "point":
          this._geometry = this._toPoint();
          break;
        case "polyline":
          this._geometry = this._toPolyline();
          break;
        case "polygon":
          this._geometry = this._toPolygon();
      }
      this._dirty = false;
    }
    return this._geometry;
  }
  get spatialReference() {
    return this.coordinateHelper.spatialReference;
  }
  notifyChanges(e6) {
    this._dirty = true, this.emit("change", e6);
  }
  _toPoint() {
    return 0 === this.components.length || 0 === this.components[0].vertices.length ? null : this.coordinateHelper.vectorToPoint(this.components[0].vertices[0].pos);
  }
  _toPolyline() {
    const e6 = [], t6 = this.coordinateHelper.vectorToArray;
    for (const s3 of this.components) {
      if (s3.vertices.length < 1)
        continue;
      const i4 = [];
      let r6 = s3.vertices.find((e7) => null == e7.leftEdge);
      const n5 = r6;
      do {
        i4.push(t6(r6.pos)), r6 = r6.rightEdge ? r6.rightEdge.rightVertex : null;
      } while (r6 && r6 !== n5);
      e6.push(i4);
    }
    return new m({ paths: e6, spatialReference: this.spatialReference, hasZ: this.coordinateHelper.hasZ(), hasM: this.coordinateHelper.hasM() });
  }
  _toPolygon() {
    const e6 = [], t6 = this.coordinateHelper.vectorToArray;
    for (const s3 of this.components) {
      if (s3.vertices.length < 1)
        continue;
      const i4 = [], r6 = s3.vertices[0];
      let n5 = r6;
      const o3 = n5;
      do {
        i4.push(t6(n5.pos)), n5 = null != n5.rightEdge ? n5.rightEdge.rightVertex : null;
      } while (n5 && n5 !== o3);
      s3.isClosed() && i4.push(t6(r6.pos)), e6.push(i4);
    }
    return new j3({ rings: e6, spatialReference: this.spatialReference, hasZ: this.coordinateHelper.hasZ(), hasM: this.coordinateHelper.hasM() });
  }
  static fromGeometry(t6, s3) {
    const i4 = t6.spatialReference, n5 = w2(t6.hasZ, t6.hasM, i4), o3 = new _p(t6.type, n5);
    switch (t6.type) {
      case "polygon": {
        const r6 = t6.rings;
        for (let t7 = 0; t7 < r6.length; ++t7) {
          const p4 = r6[t7], g2 = new l2(i4, s3);
          g2.index = t7;
          const a5 = p4.length > 2 && s(p4[0], p4[p4.length - 1]), d2 = a5 ? p4.length - 1 : p4.length;
          for (let e6 = 0; e6 < d2; ++e6) {
            const t8 = n5.arrayToVector(p4[e6]), s4 = new h2(g2);
            g2.vertices.push(s4), s4.pos = t8, s4.index = e6;
          }
          const u2 = g2.vertices.length - 1;
          for (let e6 = 0; e6 < u2; ++e6) {
            const t8 = g2.vertices[e6], s4 = g2.vertices[e6 + 1], i5 = new c2(g2, t8, s4);
            g2.edges.push(i5);
          }
          if (a5) {
            const e6 = new c2(g2, g2.vertices[g2.vertices.length - 1], g2.vertices[0]);
            g2.edges.push(e6);
          }
          o3.components.push(g2);
        }
        break;
      }
      case "polyline": {
        const e6 = t6.paths;
        for (let t7 = 0; t7 < e6.length; ++t7) {
          const r6 = e6[t7], p4 = new l2(i4, s3);
          p4.index = t7;
          const g2 = r6.length;
          for (let e7 = 0; e7 < g2; ++e7) {
            const t8 = n5.arrayToVector(r6[e7]), s4 = new h2(p4);
            p4.vertices.push(s4), s4.pos = t8, s4.index = e7;
          }
          const a5 = p4.vertices.length - 1;
          for (let e7 = 0; e7 < a5; ++e7) {
            const t8 = p4.vertices[e7], s4 = p4.vertices[e7 + 1], i5 = new c2(p4, t8, s4);
            p4.edges.push(i5);
          }
          o3.components.push(p4);
        }
        break;
      }
      case "point": {
        const e6 = new l2(i4, s3);
        e6.index = 0;
        const r6 = new h2(e6);
        r6.index = 0, r6.pos = n5.pointToVector(t6), e6.vertices.push(r6), o3.components.push(e6);
        break;
      }
    }
    return o3;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/interfaces.js
var E2;
!function(E3) {
  E3[E3.NEW_STEP = 0] = "NEW_STEP", E3[E3.ACCUMULATE_STEPS = 1] = "ACCUMULATE_STEPS";
}(E2 || (E2 = {}));

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/AppendVertex.js
var i = class {
  constructor(e6, t6, i4) {
    this._editGeometry = e6, this._component = t6, this._pos = i4, this._addedVertex = null, this._originalEdge = null, this._left = null, this._right = null;
  }
  apply() {
    let i4 = "redo";
    null == this._addedVertex && (i4 = "apply", this._addedVertex = new h2(this._component));
    const s3 = this._component.getLastVertex();
    if (null == s3)
      this._component.vertices.push(this._addedVertex), this._addedVertex.pos = this._pos, this._addedVertex.index = 0;
    else {
      let e6 = null;
      s3.rightEdge && (this._originalEdge = s3.rightEdge, e6 = this._originalEdge.rightVertex, this._component.edges.splice(this._component.edges.indexOf(this._originalEdge), 1)), this._component.vertices.push(this._addedVertex), this._addedVertex.pos = this._pos, null == this._left && (this._left = new c2(this._component, s3, this._addedVertex)), this._component.edges.push(this._left), s3.rightEdge = this._left, null != this._originalEdge && null != e6 && (null == this._right && (this._right = new c2(this._component, this._addedVertex, e6)), this._component.edges.push(this._right), e6.leftEdge = this._right), this._component.updateVertexIndex(this._addedVertex, s3.index + 1);
    }
    this._editGeometry.notifyChanges({ operation: i4, addedVertices: [this._addedVertex] });
  }
  undo() {
    null != this._addedVertex && (this._component.vertices.splice(this._component.vertices.indexOf(this._addedVertex), 1), null != this._left && (this._component.edges.splice(this._component.edges.indexOf(this._left), 1), this._left.leftVertex.rightEdge = null), null != this._right && (this._component.edges.splice(this._component.edges.indexOf(this._right), 1), this._right.rightVertex.leftEdge = null), null != this._originalEdge && (this._component.edges.push(this._originalEdge), this._originalEdge.leftVertex.rightEdge = this._originalEdge, this._originalEdge.rightVertex.leftEdge = this._originalEdge), null != this._left ? this._component.updateVertexIndex(this._left.leftVertex, this._left.leftVertex.index) : this._component.updateVertexIndex(this._addedVertex, 0), this._editGeometry.notifyChanges({ operation: "undo", removedVertices: [this._addedVertex] }));
  }
  accumulate() {
    return false;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/UpdateVertices.js
var t = class _t {
  constructor(t6, e6, i4) {
    this._editGeometry = t6, this._vertices = e6, this.operation = i4, this._undone = false;
  }
  apply() {
    this._vertices.forEach((t6) => this.operation.apply(t6)), this._editGeometry.components.forEach((t6) => t6.unnormalizeVertexPositions()), this._editGeometry.notifyChanges({ operation: this._undone ? "redo" : "apply", updatedVertices: this._vertices });
  }
  undo() {
    this._vertices.forEach((t6) => this.operation.undo(t6)), this._editGeometry.notifyChanges({ operation: "undo", updatedVertices: this._vertices }), this._undone = true;
  }
  canAccumulate(t6) {
    if (this._undone || t6._vertices.length !== this._vertices.length)
      return false;
    for (let e6 = 0; e6 < t6._vertices.length; ++e6)
      if (t6._vertices[e6] !== this._vertices[e6])
        return false;
    return this.operation.canAccumulate(t6.operation);
  }
  accumulate(e6) {
    return !!(e6 instanceof _t && this.canAccumulate(e6)) && (this._vertices.forEach((t6) => this.operation.accumulate(t6, e6.operation)), this.operation.accumulateParams(e6.operation), this._editGeometry.components.forEach((t6) => t6.unnormalizeVertexPositions()), this._editGeometry.notifyChanges({ operation: "apply", updatedVertices: this._vertices }), true);
  }
};
var e5;
!function(t6) {
  t6[t6.CUMULATIVE = 0] = "CUMULATIVE", t6[t6.REPLACE = 1] = "REPLACE";
}(e5 || (e5 = {}));

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/RemoveVertices.js
var t2 = class {
  constructor(e6, t6, r6 = 0) {
    this._editGeometry = e6, this._vertices = t6, this._minNumberOfVertices = r6, this.removedVertices = null;
  }
  apply() {
    let e6 = "redo";
    if (null == this.removedVertices) {
      const t6 = this.removedVertices = [];
      this._vertices.forEach((e7) => {
        const r6 = this._removeVertex(e7);
        null != r6 && t6.push(r6);
      }), e6 = "apply";
    } else
      this.removedVertices.forEach((e7) => {
        this._removeVertex(e7.removedVertex);
      });
    this._editGeometry.notifyChanges({ operation: e6, removedVertices: this._vertices });
  }
  undo() {
    var _a;
    (_a = this.removedVertices) == null ? void 0 : _a.forEach((e6) => {
      this._undoRemoveVertex(e6);
    }), this._editGeometry.notifyChanges({ operation: "undo", addedVertices: this._vertices });
  }
  accumulate() {
    return false;
  }
  _removeVertex(t6) {
    const r6 = t6.component;
    if (r6.vertices.length <= this._minNumberOfVertices)
      return null;
    const i4 = { removedVertex: t6, createdEdge: null }, s3 = t6.leftEdge, d2 = t6.rightEdge;
    return r6.vertices.splice(r6.vertices.indexOf(t6), 1), s3 && (r6.edges.splice(r6.edges.indexOf(s3), 1), s3.leftVertex.rightEdge = null), d2 && (r6.edges.splice(r6.edges.indexOf(d2), 1), d2.rightVertex.leftEdge = null), 0 === t6.index && d2 && this._vertices.length > 0 && r6.swapVertices(r6.vertices.indexOf(d2.rightVertex), 0), s3 && d2 && (i4.createdEdge = new c2(r6, s3.leftVertex, d2.rightVertex), r6.edges.push(i4.createdEdge)), d2 && r6.updateVertexIndex(d2.rightVertex, d2.rightVertex.index - 1), i4;
  }
  _undoRemoveVertex(e6) {
    const t6 = e6.removedVertex, r6 = e6.removedVertex.component, i4 = t6.leftEdge, s3 = t6.rightEdge;
    e6.createdEdge && r6.edges.splice(r6.edges.indexOf(e6.createdEdge), 1), r6.vertices.push(t6), i4 && (r6.edges.push(i4), i4.leftVertex.rightEdge = i4), s3 && (r6.edges.push(s3), s3.rightVertex.leftEdge = s3), r6.updateVertexIndex(t6, t6.index);
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/SplitEdge.js
var i2 = class {
  constructor(e6, t6, i4) {
    this._editGeometry = e6, this._edge = t6, this._t = i4, this.createdVertex = null, this._left = null, this._right = null;
  }
  apply() {
    let i4 = "redo";
    const r6 = this._edge, s3 = r6.component, d2 = r6.leftVertex, h3 = r6.rightVertex;
    s3.edges.splice(s3.edges.indexOf(r6), 1), null == this.createdVertex && (i4 = "apply", this.createdVertex = new h2(r6.component)), s3.vertices.push(this.createdVertex), this.createdVertex.pos = this._editGeometry.coordinateHelper.lerp(r6.leftVertex.pos, r6.rightVertex.pos, this._t, this._editGeometry.coordinateHelper.createVector()), null == this._left && (this._left = new c2(s3, d2, this.createdVertex)), this._left.leftVertex.leftEdge ? s3.edges.push(this._left) : s3.edges.unshift(this._left), d2.rightEdge = this._left, null == this._right && (this._right = new c2(s3, this.createdVertex, h3)), s3.edges.push(this._right), h3.leftEdge = this._right, s3.updateVertexIndex(this.createdVertex, d2.index + 1), this._editGeometry.notifyChanges({ operation: i4, addedVertices: [this.createdVertex] });
  }
  undo() {
    if (null == this.createdVertex || null == this._left || null == this._right)
      return null;
    const e6 = this._edge, t6 = e6.component, i4 = this.createdVertex.leftEdge, r6 = this.createdVertex.rightEdge, s3 = i4 == null ? void 0 : i4.leftVertex, d2 = r6 == null ? void 0 : r6.rightVertex;
    t6.vertices.splice(t6.vertices.indexOf(this.createdVertex), 1), t6.edges.splice(t6.edges.indexOf(this._left), 1), t6.edges.splice(t6.edges.indexOf(this._right), 1), this._edge.leftVertex.leftEdge ? t6.edges.push(this._edge) : t6.edges.unshift(this._edge), s3 && (s3.rightEdge = e6), d2 && (d2.leftEdge = e6), s3 && t6.updateVertexIndex(s3, s3.index), this._editGeometry.notifyChanges({ operation: "undo", removedVertices: [this.createdVertex] });
  }
  accumulate() {
    return false;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/SetVertexPosition.js
var t3 = class _t {
  constructor(t6, e6, i4) {
    this._editGeometry = t6, this._vertex = e6, this._pos = i4;
  }
  apply() {
    const t6 = null == this._originalPosition;
    t6 && (this._originalPosition = this._vertex.pos), this._apply(t6 ? "apply" : "redo");
  }
  undo() {
    this._vertex.pos = this._originalPosition, this._editGeometry.notifyChanges({ operation: "undo", updatedVertices: [this._vertex] });
  }
  accumulate(e6) {
    return e6 instanceof _t && e6._vertex === this._vertex && (this._pos = e6._pos, this._apply("apply"), true);
  }
  _apply(t6) {
    this._vertex.pos = this._pos, this._editGeometry.components.forEach((t7) => t7.unnormalizeVertexPositions()), this._editGeometry.notifyChanges({ operation: t6, updatedVertices: [this._vertex] });
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/CloseComponent.js
var r5 = class {
  constructor(e6, t6) {
    this._editGeometry = e6, this._component = t6, this._createdEdge = null;
  }
  apply() {
    let e6 = "redo";
    if (null == this._createdEdge) {
      e6 = "apply";
      const r6 = this._component.getFirstVertex(), i4 = this._component.getLastVertex();
      if (this._component.isClosed() || this._component.vertices.length < 3 || null == r6 || null == i4)
        return;
      this._createdEdge = new c2(this._component, i4, r6);
    }
    this._createdEdge.leftVertex.rightEdge = this._createdEdge, this._createdEdge.rightVertex.leftEdge = this._createdEdge, this._component.edges.push(this._createdEdge), this._editGeometry.notifyChanges({ operation: e6 });
  }
  undo() {
    null != this._createdEdge && (L(this._component.edges, this._createdEdge), this._createdEdge.leftVertex.rightEdge = null, this._createdEdge.rightVertex.leftEdge = null, this._editGeometry.notifyChanges({ operation: "undo" }));
  }
  accumulate() {
    return false;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/MoveVertex.js
var t4 = class _t {
  constructor(t6, s3, d2, h3) {
    this._helper = t6, this.dx = s3, this.dy = d2, this.dz = h3;
  }
  _move(t6, s3, d2, h3) {
    this._helper.addDelta(t6.pos, s3, d2, h3);
  }
  apply(t6) {
    this._move(t6, this.dx, this.dy, this.dz);
  }
  undo(t6) {
    this._move(t6, -this.dx, -this.dy, -this.dz);
  }
  canAccumulate(s3) {
    return s3 instanceof _t;
  }
  accumulate(t6, s3) {
    this._move(t6, s3.dx, s3.dy, s3.dz);
  }
  accumulateParams(t6) {
    this.dx += t6.dx, this.dy += t6.dy, this.dz += t6.dz;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/OffsetEdgeVertex.js
var N = class _N {
  get plane() {
    return this._plane;
  }
  get requiresSplitEdgeLeft() {
    return !this._left.isOriginalDirection;
  }
  get requiresSplitEdgeRight() {
    return !this._right.isOriginalDirection;
  }
  get edgeDirection() {
    return this._edgeDirection;
  }
  constructor(t6, i4, e6, s3 = 0, n5 = Z.IMMEDIATE) {
    this._helper = t6, this._planeType = i4, this._edge = e6, this.distance = s3, this._plane = h(), this._offsetPlane = h(), this._minDistance = -1 / 0, this._maxDistance = 1 / 0, this._selectedArrow = 1, n5 === Z.IMMEDIATE && this._initialize();
  }
  _initialize() {
    this._initializeNeighbors(), this._initializePlane(), this._initializeDistanceConstraints();
  }
  _initializeNeighbors() {
    var _a, _b, _c, _d;
    const t6 = this._toXYZ(this._edge.leftVertex.pos), i4 = this._toXYZ((_b = (_a = this._edge.leftVertex.leftEdge) == null ? void 0 : _a.leftVertex) == null ? void 0 : _b.pos), e6 = this._toXYZ(this._edge.rightVertex.pos), s3 = this._toXYZ((_d = (_c = this._edge.rightVertex.rightEdge) == null ? void 0 : _c.rightVertex) == null ? void 0 : _d.pos);
    this._edgeDirection = H(n(), t6, e6), this._left = this._computeNeighbor(t6, i4, this._edgeDirection), this._right = this._computeNeighbor(e6, s3, this._edgeDirection);
  }
  _toXYZ(t6) {
    return null != t6 ? this._helper.toXYZ(t6) : null;
  }
  _pointToXYZ(t6) {
    return this._toXYZ(this._helper.pointToVector(t6));
  }
  _computeNeighbor(t6, i4, e6) {
    if (null == i4)
      return { start: t6, end: i4, direction: r(-e6[1], e6[0], 0), isOriginalDirection: true };
    const s3 = H(n(), t6, i4), n5 = !this._passesBisectingAngleThreshold(s3, e6);
    return { start: t6, end: i4, direction: n5 ? this._bisectVectorsPerpendicular(e6, s3) : s3, isOriginalDirection: !n5 };
  }
  _passesBisectingAngleThreshold(t6, i4) {
    const e6 = Math.abs(a4(i4, t6));
    return e6 >= P2 && e6 <= Math.PI - P2;
  }
  _bisectVectorsPerpendicular(t6, i4) {
    const e6 = P(t6, i4) < 0 ? t6 : j(n(), t6), s3 = Math.abs(P(e6, i4));
    if (!(s3 < T2 || s3 > 1 - T2))
      return this._bisectDirection(e6, i4);
    const n5 = _(n(), e6, [0, 0, 1]);
    return z(n5, n5);
  }
  _bisectDirection(t6, i4) {
    const e6 = u(n(), t6, i4);
    return z(e6, e6);
  }
  _initializePlane() {
    const t6 = this._computeNormalDirection(this._left), i4 = this._computeNormalDirection(this._right);
    P(t6, i4) < 0 && j(i4, i4), T(this._left.start, this._bisectDirection(t6, i4), this._plane);
  }
  _computeNormalDirection(t6) {
    const i4 = _(n(), t6.direction, this._edgeDirection);
    z(i4, i4);
    const e6 = _(n(), this._edgeDirection, i4);
    return this._planeType === y.XY && (e6[2] = 0), z(e6, e6);
  }
  _initializeDistanceConstraints() {
    null == this._left.end || this.requiresSplitEdgeLeft || this._updateDistanceConstraint(R(this._plane, this._left.end)), null == this._right.end || this.requiresSplitEdgeRight || this._updateDistanceConstraint(R(this._plane, this._right.end)), this._updateIntersectDistanceConstraint(this._plane);
  }
  _updateDistanceConstraint(t6) {
    t6 <= 0 && (this._minDistance = Math.max(this._minDistance, t6)), t6 >= 0 && (this._maxDistance = Math.min(this._maxDistance, t6));
  }
  _updateIntersectDistanceConstraint(t6) {
    const r6 = W(t6), h3 = this._edgeDirection, o3 = u(n(), this._left.start, this._left.direction), a5 = u(n(), this._right.start, this._right.direction), _3 = this._pointInBasis2D(n4(), r6, h3, this._left.start), p4 = this._pointInBasis2D(n4(), r6, h3, o3), d2 = this._pointInBasis2D(n4(), r6, h3, this._right.start), u2 = this._pointInBasis2D(n4(), r6, h3, a5), [f3] = j5({ start: p4, end: _3, type: v2.LINE }, { start: u2, end: d2, type: v2.LINE });
    if (!f3)
      return;
    const m3 = o2(n4(), _3, p4);
    v(m3, m3);
    const E3 = o2(n4(), f3, p4), x4 = j4(m3, E3), I = u(n(), o3, g(n(), this._left.direction, -x4)), V = R(t6, I);
    this._updateDistanceConstraint(V);
  }
  _pointInBasis2D(t6, i4, e6, s3) {
    return t6[0] = f2(i4, s3), t6[1] = f2(e6, s3), t6;
  }
  _offset(t6, i4) {
    Number.isFinite(this._minDistance) && (i4 = Math.max(this._minDistance, i4)), Number.isFinite(this._maxDistance) && (i4 = Math.min(this._maxDistance, i4)), p(this._offsetPlane, this._plane), this._offsetPlane[3] -= i4;
    const e6 = (t7, i5, e7) => null != i5 && O(this._offsetPlane, t7, u(n(), t7, i5), e7), s3 = n();
    (t6 === this._edge.leftVertex ? e6(this._left.start, this._left.direction, s3) : e6(this._right.start, this._right.direction, s3)) && this._helper.copy(this._helper.fromXYZ(s3, void 0, this._helper.getM(t6.pos)), t6.pos);
  }
  selectArrowFromStartPoint(t6) {
    this._selectedArrow = z2(this.plane, this._pointToXYZ(t6)) ? 1 : -1;
  }
  get selectedArrow() {
    return this._selectedArrow;
  }
  signedDistanceToPoint(t6) {
    return R(this.plane, this._pointToXYZ(t6));
  }
  apply(t6) {
    this._offset(t6, this.distance);
  }
  undo(t6) {
    this._offset(t6, 0);
  }
  canAccumulate(t6) {
    return t6 instanceof _N && this._edge.leftVertex.index === t6._edge.leftVertex.index && this._edge.rightVertex.index === t6._edge.rightVertex.index && this._edge.component === t6._edge.component && this._maybeEqualsVec3(this._left.direction, t6._left.direction) && this._maybeEqualsVec3(this._right.direction, t6._right.direction) && G(W(this._plane), W(t6._plane));
  }
  accumulate(t6, i4) {
    const e6 = this._plane[3] - i4._plane[3] + i4.distance;
    this._offset(t6, e6);
  }
  accumulateParams(t6) {
    const i4 = t6.distance - t6._plane[3];
    this.distance = i4 + this._plane[3];
  }
  clone() {
    const t6 = new _N(this._helper, this._planeType, this._edge, this.distance, Z.DEFERRED);
    return p(t6._plane, this._plane), p(t6._offsetPlane, this._offsetPlane), t6._maxDistance = this._maxDistance, t6._minDistance = this._minDistance, t6._left = this._cloneNeighbor(this._left), t6._right = this._cloneNeighbor(this._right), t6._edgeDirection = r2(n(), this._edgeDirection), t6;
  }
  _maybeEqualsVec3(t6, i4) {
    return null == t6 && null == i4 || null != t6 && null != i4 && G(t6, i4);
  }
  _cloneNeighbor({ start: t6, end: i4, direction: e6, isOriginalDirection: s3 }) {
    return { start: r2(n(), t6), end: null != i4 ? r2(n(), i4) : null, direction: r2(n(), e6), isOriginalDirection: s3 };
  }
};
var P2 = M(15);
var T2 = 1e-3;
var y;
var Z;
!function(t6) {
  t6[t6.XYZ = 0] = "XYZ", t6[t6.XY = 1] = "XY";
}(y || (y = {})), function(t6) {
  t6[t6.IMMEDIATE = 0] = "IMMEDIATE", t6[t6.DEFERRED = 1] = "DEFERRED";
}(Z || (Z = {}));

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/RotateVertex.js
var s2 = class _s {
  constructor(t6, a5, s3 = e5.CUMULATIVE) {
    this.origin = t6, this.angle = a5, this._accumulationType = s3;
  }
  _rotate(t6, i4) {
    L2(t6.pos, t6.pos, this.origin, i4);
  }
  apply(t6) {
    this._rotate(t6, this.angle);
  }
  undo(t6) {
    this._rotate(t6, -this.angle);
  }
  canAccumulate(a5) {
    return a5 instanceof _s && s(this.origin, a5.origin);
  }
  accumulate(t6, a5) {
    const s3 = a5._accumulationType === e5.REPLACE;
    this._rotate(t6, s3 ? a5.angle - this.angle : a5.angle);
  }
  accumulateParams(t6) {
    const a5 = t6._accumulationType === e5.REPLACE;
    this.angle = a5 ? t6.angle : this.angle + t6.angle;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/ScaleVertex.js
var c3 = class _c {
  constructor(t6, a5, c4, o3, r6 = e5.CUMULATIVE) {
    this.origin = t6, this.axis1 = a5, this.factor1 = c4, this.factor2 = o3, this._accumulationType = r6, this.axis2 = r4(a5[1], -a5[0]);
  }
  _scale(t6, s3, i4) {
    w(t6.pos, t6.pos, this.origin, this.axis1, s3), w(t6.pos, t6.pos, this.origin, this.axis2, i4);
  }
  apply(t6) {
    this._scale(t6, this.factor1, this.factor2);
  }
  undo(t6) {
    this._scale(t6, 1 / this.factor1, 1 / this.factor2);
  }
  canAccumulate(s3) {
    return s3 instanceof _c && s(this.origin, s3.origin) && s(this.axis1, s3.axis1);
  }
  accumulate(t6, s3) {
    s3._accumulationType === e5.REPLACE ? this._scale(t6, s3.factor1 / this.factor1, s3.factor2 / this.factor2) : this._scale(t6, s3.factor1, s3.factor2);
  }
  accumulateParams(t6) {
    const s3 = t6._accumulationType === e5.REPLACE;
    this.factor1 = s3 ? t6.factor1 : this.factor1 * t6.factor1, this.factor2 = s3 ? t6.factor2 : this.factor2 * t6.factor2;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/UndoGroup.js
var t5 = class {
  constructor() {
    this._operations = [], this._closed = false;
  }
  close() {
    this._closed = true;
  }
  apply() {
    for (const t6 of this._operations)
      t6.apply();
  }
  undo() {
    for (let t6 = this._operations.length - 1; t6 >= 0; t6--)
      this._operations[t6].undo();
  }
  accumulate(t6) {
    if (this._closed)
      return false;
    const o3 = this._operations.length ? this._operations[this._operations.length - 1] : null;
    return o3 && o3.accumulate(t6) || (this._operations.push(t6), t6.apply()), true;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/EditGeometryOperations.js
var _2 = class __ extends n2 {
  constructor(e6) {
    super(), this.data = e6, this._undoStack = [], this._redoStack = [], this._listener = this.data.on("change", (e7) => {
      e7.addedVertices && this.emit("vertex-add", { type: "vertex-add", vertices: e7.addedVertices, operation: e7.operation }), e7.removedVertices && this.emit("vertex-remove", { type: "vertex-remove", vertices: e7.removedVertices, operation: e7.operation }), e7.updatedVertices && this.emit("vertex-update", { type: "vertex-update", vertices: e7.updatedVertices, operation: e7.operation });
    });
  }
  destroy() {
    this._listener.remove();
  }
  splitEdge(e6, t6) {
    return this._apply(new i2(this.data, e6, t6));
  }
  updateVertices(e6, t6, o3 = E2.ACCUMULATE_STEPS) {
    return this._apply(new t(this.data, e6, t6), o3);
  }
  moveVertices(e6, t6, o3, s3, i4 = E2.ACCUMULATE_STEPS) {
    return this.updateVertices(e6, new t4(this.data.coordinateHelper, t6, o3, s3), i4);
  }
  scaleVertices(e6, t6, o3, s3, n5, a5 = E2.ACCUMULATE_STEPS, p4 = e5.CUMULATIVE) {
    return this.updateVertices(e6, new c3(t6, o3, s3, n5, p4), a5);
  }
  rotateVertices(e6, t6, o3, s3 = E2.ACCUMULATE_STEPS, n5 = e5.CUMULATIVE) {
    return this.updateVertices(e6, new s2(t6, o3, n5), s3);
  }
  removeVertices(e6) {
    return this._apply(new t2(this.data, e6, this._minNumVerticesPerType));
  }
  appendVertex(e6) {
    return 0 === this.data.components.length ? null : this._apply(new i(this.data, this.data.components[0], e6));
  }
  setVertexPosition(e6, t6) {
    return this._apply(new t3(this.data, e6, t6));
  }
  offsetEdge(e6, t6, o3, s3 = E2.ACCUMULATE_STEPS) {
    return this.updateVertices([t6.leftVertex, t6.rightVertex], new N(this.data.coordinateHelper, e6, t6, o3), s3);
  }
  closeComponent(e6) {
    return this.data.components.includes(e6) ? this._apply(new r5(this.data, e6)) : null;
  }
  canRemoveVertex() {
    return this.data.components[0].vertices.length > this._minNumVerticesPerType;
  }
  createUndoGroup() {
    const e6 = new t5();
    return this._apply(e6), { remove: () => e6.close() };
  }
  undo() {
    if (this._undoStack.length > 0) {
      const e6 = this._undoStack.pop();
      return e6.undo(), this._redoStack.push(e6), e6;
    }
    return null;
  }
  redo() {
    if (this._redoStack.length > 0) {
      const e6 = this._redoStack.pop();
      return e6.apply(), this._undoStack.push(e6), e6;
    }
    return null;
  }
  get canUndo() {
    return this._undoStack.length > 0;
  }
  get canRedo() {
    return this._redoStack.length > 0;
  }
  get lastOperation() {
    return this._undoStack.length > 0 ? this._undoStack[this._undoStack.length - 1] : null;
  }
  get _minNumVerticesPerType() {
    switch (this.data.type) {
      case "point":
        return 1;
      case "polyline":
        return 2;
      case "polygon":
        return 3;
      default:
        return 0;
    }
  }
  _apply(e6, t6 = E2.ACCUMULATE_STEPS) {
    return t6 !== E2.NEW_STEP && null != this.lastOperation && this.lastOperation.accumulate(e6) || (e6.apply(), this._undoStack.push(e6), this._redoStack = []), e6;
  }
  static fromGeometry(e6, r6) {
    return new __(p3.fromGeometry(e6, r6));
  }
};

// node_modules/@arcgis/core/views/support/measurementUtils.js
function i3(i4) {
  const m3 = c(i4), n5 = m3 === f ? a3 : m3;
  return Cn(i4, n5) ? n5 : i4;
}

export {
  i3 as i,
  w2 as w,
  l2 as l,
  p3 as p,
  _2 as _
};
//# sourceMappingURL=chunk-EKZRSO4Y.js.map
