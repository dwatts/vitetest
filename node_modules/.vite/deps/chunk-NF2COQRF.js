import {
  C,
  y
} from "./chunk-DEKAIZFC.js";
import {
  t as t5
} from "./chunk-ZAPLLPYK.js";
import {
  r
} from "./chunk-IRBH32SX.js";
import {
  t
} from "./chunk-XUU35WPC.js";
import {
  h as h2,
  p as p2,
  t as t3,
  u as u2
} from "./chunk-6QR5R4JX.js";
import {
  o as o8
} from "./chunk-LGDKASPG.js";
import {
  u as u3,
  v
} from "./chunk-4YXJLES6.js";
import {
  c
} from "./chunk-EHQZFPMP.js";
import {
  o as o3
} from "./chunk-VC3BY3DV.js";
import {
  a,
  t as t4
} from "./chunk-WH76OAIT.js";
import {
  g
} from "./chunk-JHDKOKT6.js";
import {
  o as o5
} from "./chunk-CG3URTR2.js";
import {
  d,
  i as i3,
  o as o4,
  t as t2
} from "./chunk-LIO6VZRI.js";
import {
  h
} from "./chunk-73PNWDTS.js";
import {
  P
} from "./chunk-N3RXOITN.js";
import {
  f,
  p,
  u
} from "./chunk-DOR4M5EA.js";
import {
  n as n2
} from "./chunk-3ROGWJVH.js";
import {
  O
} from "./chunk-BUCIQGFS.js";
import {
  o as o7
} from "./chunk-CR5XNTAP.js";
import {
  e as e2
} from "./chunk-YVVROPAO.js";
import {
  o as o6
} from "./chunk-UUW6REOV.js";
import {
  s
} from "./chunk-Z3NHJA5D.js";
import {
  i as i2,
  i2 as i4
} from "./chunk-BO2REVMA.js";
import {
  o as o2
} from "./chunk-V66LHQVK.js";
import {
  e
} from "./chunk-CW7LIPBH.js";
import {
  i
} from "./chunk-7EG7BYWF.js";
import {
  o,
  z
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTangent.glsl.js
function e3(e4, t6) {
  e4.varyings.add("tbnTangent", "vec3"), e4.varyings.add("tbnBiTangent", "vec3"), t6.spherical ? e4.vertex.code.add(o2`void forwardVertexTangent(vec3 n) {
tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), n));
tbnBiTangent = normalize(cross(n, tbnTangent));
}`) : e4.vertex.code.add(o2`void forwardVertexTangent(vec3 n) {
tbnTangent = vec3(1.0, 0.0, 0.0);
tbnBiTangent = normalize(cross(n, tbnTangent));
}`), e4.fragment.code.add(o2`mat3 getTBNMatrix(vec3 n) {
return mat3(tbnTangent, tbnBiTangent, n);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/terrain/TileBlendInput.js
var o9;
!function(o10) {
  o10[o10.LayerOnly = 0] = "LayerOnly", o10[o10.ColorComposite = 1] = "ColorComposite", o10[o10.GridComposite = 2] = "GridComposite", o10[o10.COUNT = 3] = "COUNT";
}(o9 || (o9 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/terrain/TerrainTexture.glsl.js
var l = class extends v {
  constructor() {
    super(...arguments), this.overlayOpacity = 1, this.overlaySource = n2.None;
  }
};
function u4(r2, o10) {
  r2.vertex.uniforms.add(new m("overlayTexOffset"), new m("overlayTexScale")), r2.fragment.uniforms.add(new o6("overlayOpacity", (e4) => e4.overlayOpacity), new s("ovColorTex", (r3, o11) => 0 === o11.overlays.length ? null : o11.overlays[O.INNER].getColorTexture(r3.overlaySource))), C(r2, o10);
}
function f2(e4, r2) {
  const { vertex: o10, fragment: s2, varyings: c2 } = e4;
  c2.add("vtc", "vec2"), o10.uniforms.add(new m("texOffsetAndScale")), s2.uniforms.add(new p3("tex")), s2.uniforms.add(new v2("textureOpacities"));
  const i5 = r2.textureFadingEnabled && !r2.renderOccluded;
  i5 && (o10.uniforms.add(new m("nextTexOffsetAndScale")), c2.add("nvtc", "vec2"), s2.uniforms.add(new p3("texNext")), s2.uniforms.add(new v2("nextTexOpacities")), s2.uniforms.add(new x("fadeFactor")));
  const d2 = r2.tileBlendInput === o9.ColorComposite, l2 = r2.tileBlendInput === o9.GridComposite;
  l2 && s2.include(t5), d2 && s2.uniforms.add(new v2("backgroundColor")), o10.code.add(o2`
  void forwardTextureCoordinatesWithTransform(in vec2 uv) {
    vtc = uv * texOffsetAndScale.zw + texOffsetAndScale.xy;
    ${i5 ? o2`nvtc = uv * nextTexOffsetAndScale.zw + nextTexOffsetAndScale.xy;` : o2``}
  }`), s2.code.add(o2`
    vec4 getColor(vec4 color, vec2 uv, vec3 opacities) {
      ${l2 || d2 ? o2`
              if (opacities.y <= 0.0) {
                return color * opacities.z * opacities.x;
              }
              vec4 bg = vec4(${d2 ? o2`backgroundColor` : o2`gridColor(uv)`} * opacities.y, opacities.y);
              vec4 layer = color * opacities.z;
              return (bg * (1.0 - layer.a) + layer) * opacities.x;` : o2`return color;`}
    }`), i5 ? s2.code.add(o2`vec4 getTileColor() {
vec4 color = getColor(texture(tex, vtc), vtc, textureOpacities);
if (fadeFactor >= 1.0) {
return color;
}
vec4 nextColor = getColor(texture(texNext, nvtc), nvtc, nextTexOpacities);
return mix(nextColor, color, fadeFactor);
}`) : s2.code.add(o2`vec4 getTileColor() {
return getColor(texture(tex, vtc), vtc, textureOpacities);
}`);
}
var x = class extends i2 {
  constructor(e4) {
    super(e4, "float");
  }
};
var v2 = class extends i2 {
  constructor(e4) {
    super(e4, "vec3");
  }
};
var m = class extends i2 {
  constructor(e4) {
    super(e4, "vec4");
  }
};
var p3 = class extends i2 {
  constructor(e4) {
    super(e4, "sampler2D");
  }
};

// node_modules/@arcgis/core/chunks/Terrain.glsl.js
var _ = class extends l {
};
function k(r2) {
  const a2 = new i4(), { vertex: T, fragment: _2, varyings: k2 } = a2;
  a2.include(o4), a2.include(t, r2), a2.include(o3, r2);
  const H2 = () => {
    a2.include(r, r2), T.code.add(o2`vec3 getNormal() {
float z = 1.0 - abs(normalCompressed.x) - abs(normalCompressed.y);
vec3 n = vec3(normalCompressed + vec2(normalCompressed.x >= 0.0 ? 1.0 : -1.0,
normalCompressed.y >= 0.0 ? 1.0 : -1.0) * min(z, 0.0), z);
return normalize(n);
}`);
  };
  p(T, r2), a2.include(o5, r2);
  const I = r2.overlayMode !== y.Disabled, q = I && r2.invisible;
  switch (r2.output) {
    case h.Color:
      {
        a2.include(f2, r2), a2.include(p2, r2), I && a2.include(u4, { ...r2, pbrMode: r2.pbrMode === c.Terrain ? c.TerrainWithWater : c.Water });
        const t6 = r2.overlayMode === y.EnabledWithWater;
        t6 && a2.include(e3, r2), k2.add("vnormal", "vec3"), k2.add("vpos", "vec3"), k2.add("vup", "vec3"), H2(), r2.screenSizePerspective && u(T);
        const n3 = r2.receiveShadows && !r2.renderOccluded;
        n3 && a2.include(d, r2), r2.screenSizePerspective && (k2.add("screenSizeDistanceToCamera", "float"), k2.add("screenSizeCosAngle", "float")), T.code.add(o2`
        void main(void) {
          //Position
          vpos = position;
          vec3 positionWorld = position + localOrigin;
          gl_Position = transformPosition(proj, view, vpos);

          //Normal
          vnormal = getNormal();

          //Up
          vup = getLocalUp(position, localOrigin);

          ${t6 ? o2`forwardVertexTangent(vnormal);` : o2``}

          //Texture UV
          vec2 uv = getUV0();
          forwardTextureCoordinatesWithTransform(uv);
          ${I ? o2`setOverlayVTC(uv);` : ""}
          ${r2.tileBorders ? o2`forwardTextureCoordinates();` : ""}

          ${r2.screenSizePerspective ? o2`
          vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;
          screenSizeDistanceToCamera = length(viewPos);
          vec3 viewSpaceNormal = (viewNormal * vec4(normalize(positionWorld), 1.0)).xyz;
          screenSizeCosAngle = abs(viewSpaceNormal.z);` : ""}

          ${n3 ? o2`forwardLinearDepth();` : ""}

        }
      `), a2.include(P, r2), a2.include(p2, r2), a2.include(t3, r2), a2.include(u3, r2), f(_2, r2), h2(_2), u2(_2), _2.uniforms.add(T.uniforms.get("localOrigin"), new e2("viewDirection", (e4, r3) => z(E, o(E, r3.camera.viewMatrix[12], r3.camera.viewMatrix[13], r3.camera.viewMatrix[14])))), t6 && _2.uniforms.add(new s("ovWaterTex", (e4, r3) => 0 === r3.overlays.length ? null : r3.overlays[O.INNER].getNormalTexture(e4.overlaySource)), new o7("view", (r3, o10) => i(B, o10.camera.viewMatrix, r3.origin))), _2.code.add(o2`const float sliceOpacity = 0.2;
float lum(vec3 c) {
return (min(min(c.r, c.g), c.b) + max(max(c.r, c.g), c.b)) * 0.5;
}`), t4(_2), a(_2), _2.code.add(o2`
        void main() {
          vec3 normal = normalize(vnormal);
          float vndl = dot(normal, mainLightDirection);

          float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));
          float shadow = ${r2.receiveShadows && !r2.renderOccluded ? "readShadowMap(vpos, linearDepth)" : r2.spherical ? "lightingGlobalFactor * (1.0 - additionalAmbientScale)" : "0.0"};

          float ssao = evaluateAmbientOcclusionInverse();
          vec4 tileColor = getTileColor();

          ${I ? o2`
              vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);
              vec4 overlayColor = overlayOpacity * overlayColorOpaque;
              ${r2.invisible ? o2`if (overlayColor.a == 0.0) { discard; }` : ""}
              vec4 groundColor = tileColor;
              tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;` : ""}

          // If combined alpha is 0 we can discard pixel. The performance impact by having a discard here
          // is neglectable because terrain typically renders first into the framebuffer.
          if(tileColor.a <= 0.0) {
            discard;
          }

          bool sliced = rejectBySlice(vpos);
          if (sliced) {
            tileColor *= sliceOpacity;
          }

          vec3 albedo = tileColor.rgb;

          // heuristic shading function used in the old terrain, now used to add ambient lighting

          vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;

          ${r2.pbrMode === c.Terrain || r2.pbrMode === c.TerrainWithWater ? o2`fragColor = vec4(evaluateTerrainLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight, normalize(vpos - cameraPosition), vup), tileColor.a);` : o2`fragColor = vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);`}
          ${t6 ? o2`
              vec4 overlayWaterMask = getOverlayColor(ovWaterTex, vtcOverlay);
              float waterNormalLength = length(overlayWaterMask);
              if (waterNormalLength > 0.95) {
                mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);
                vec4 waterOverlayColor = vec4(overlayColor.w > 0.0 ? overlayColorOpaque.xyz/overlayColor.w : vec3(1.0), overlayColor.w);
                vec4 viewPosition = view*vec4(vpos, 1.0);
                vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vpos - cameraPosition), shadow, vnormal, tbnMatrix, viewPosition.xyz,  vpos + localOrigin);
                vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
                float opacity = sliced ? sliceOpacity : 1.0;
                // un-gamma the ground color to mix in linear space
                fragColor = mix(groundColor, waterColorNonLinear, waterColorLinear.w) * opacity;
              }` : ""}
          ${r2.screenSizePerspective ? o2`
            float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, vec4(0.0, 0.0, 0.0, 0.0));
            if (perspectiveScale <= 0.25) {
              fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);
            }
            else if (perspectiveScale <= 0.5) {
              fragColor = mix(fragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);
            }
            else if (perspectiveScale >= 0.99) {
              fragColor = mix(fragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);
            }
            else {
              fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);
            }` : ""}
          ${r2.visualizeNormals ? r2.spherical ? o2`
                  vec3 localUp = normalize(vpos + localOrigin);
                  vec3 right = normalize(cross(vec3(0.0, 0.0, 1.0), localUp));
                  vec3 forward = normalize(cross(localUp, right));
                  mat3 tbn = mat3(right, forward, localUp);
                  vec3 tNormal = normalize(normal * tbn);
                  fragColor = vec4(vec3(0.5) + 0.5 * tNormal, 0.0);
              ` : o2`
                  vec3 tNormal = normalize(normal);
                  fragColor = vec4(vec3(0.5) + 0.5 * tNormal, 0.0);
              ` : ""}
          ${r2.tileBorders ? o2`
              vec2 dVuv = fwidth(vuv0);
              vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv0, 1.0 - vuv0));
              float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);
              fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);` : ""}
          fragColor = highlightSlice(fragColor, vpos);
        }
      `);
      }
      break;
    case h.Depth:
      q && a2.include(u4, r2), a2.include(o8, r2), t2(a2), i3(a2), T.code.add(o2`
              void main(void) {
                ${q ? o2`setOverlayVTC(getUV0());` : ""}
                gl_Position = transformPositionWithDepth(proj, view, position, nearFar, linearDepth);
              }
          `), _2.code.add(o2`
              void main() {
                ${q ? o2`if (getCombinedOverlayColor().a == 0.0) { discard; }` : ""}
                outputDepth(linearDepth);
              }
          `);
      break;
    case h.Shadow:
    case h.ShadowHighlight:
    case h.ShadowExcludeHighlight:
      a2.include(o8, r2), t2(a2), i3(a2), T.code.add(o2`void main(void) {
gl_Position = transformPositionWithDepth(proj, view, position, nearFar, linearDepth);
}`), _2.code.add(o2`void main() {
outputDepth(linearDepth);
}`);
      break;
    case h.Normal:
      q && a2.include(u4, r2), k2.add("vnormal", "vec3"), u(T), H2(), T.code.add(o2`
            void main(void) {
              ${q ? o2`setOverlayVTC(getUV0());` : ""}
              gl_Position = transformPosition(proj, view, position);
              vnormal = normalize((viewNormal * vec4(getNormal(), 1.0)).xyz);
            }
        `), _2.code.add(o2`
            void main() {
              ${q ? o2`if (getCombinedOverlayColor().a == 0.0) { discard; }` : ""}
              vec3 normal = normalize(vnormal);
              if (gl_FrontFacing == false) {
                normal = -normal;
              }
              fragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);
            }
        `);
      break;
    case h.Highlight:
      I && a2.include(u4, r2), T.code.add(o2`
          void main() {
            ${I ? o2`setOverlayVTC(getUV0());` : ""}
            gl_Position = transformPosition(proj, view, position);
          }
        `), a2.include(g, r2), _2.code.add(o2`
          void main() {
            ${I ? o2`if (getCombinedOverlayColor().a == 0.0) { discard; }` : ""}
            outputHighlight();
          }
        `);
  }
  return r2.output === h.ObjectAndLayerIdColor && (a2.include(u4, { ...r2, pbrMode: c.Disabled }), T.code.add(o2`void main(void) {
gl_Position = transformPosition(proj, view, position);
setOverlayVTC(getUV0());
}`), _2.code.add(o2`void main() {
fragColor = getOverlayColorTexel(vtcOverlay);
}`)), a2;
}
var B = e();
var E = n();
var H = Object.freeze(Object.defineProperty({ __proto__: null, TerrainPassParameters: _, build: k }, Symbol.toStringTag, { value: "Module" }));

export {
  o9 as o,
  _,
  k,
  H
};
//# sourceMappingURL=chunk-NF2COQRF.js.map
