import {
  h as h2
} from "./chunk-ZW3OKQGC.js";
import {
  c as c2
} from "./chunk-BSSEIP2H.js";
import {
  G,
  Q,
  V,
  et,
  ie,
  ne,
  r
} from "./chunk-VF625TQS.js";
import {
  m
} from "./chunk-DNEN337Y.js";
import {
  O,
  c,
  r as r2,
  t
} from "./chunk-ZL3HOHNK.js";
import {
  p3 as p
} from "./chunk-JNDFAMXY.js";
import {
  u as u2
} from "./chunk-DOQ3SAAR.js";
import {
  h
} from "./chunk-RRJGZKNX.js";
import {
  j
} from "./chunk-43LWRDQS.js";
import {
  s
} from "./chunk-7I33FAWS.js";
import {
  u
} from "./chunk-DWOEYHKS.js";

// node_modules/@arcgis/core/symbols/cim/CIMSymbolRasterizer.js
var M;
!function(e) {
  e.Legend = "legend", e.Preview = "preview";
}(M || (M = {}));
var _ = (e) => e && e.scaleFactor ? e.scaleFactor : 1;
var b = 96 / 72;
var z = class {
  constructor(e, t2) {
    this._spatialReference = e, this._avoidSDF = t2, this._resourceCache = /* @__PURE__ */ new Map(), this._imageDataCanvas = null, this._pictureMarkerCache = /* @__PURE__ */ new Map(), this._textRasterizer = new r(), this._cimResourceManager = new h2(), this._rasterizer = new c2(this._cimResourceManager);
  }
  get resourceManager() {
    return this._cimResourceManager;
  }
  async rasterizeCIMSymbolAsync(e, t2, a, i, r3, o, s2, n) {
    if (!e)
      return null;
    const { data: g } = e;
    if (!g || "CIMSymbolReference" !== g.type || !g.symbol)
      return null;
    const { symbol: u3 } = g;
    o || (o = O(u3));
    const d = await ne.resolveSymbolOverrides(g, t2, this._spatialReference, r3, o, s2, n);
    this._imageDataCanvas || (this._imageDataCanvas = document.createElement("canvas"));
    const y = this._imageDataCanvas, p2 = this._cimResourceManager, w = [];
    ie.fetchResources(d, p2, w), ie.fetchFonts(d, p2, w), w.length > 0 && await Promise.all(w);
    const { width: C, height: M2 } = a, _2 = v(o, C, M2, i), z2 = ie.getEnvelope(d, _2, p2);
    if (!z2)
      return null;
    const I2 = (window.devicePixelRatio || 1) * b;
    let x = 1, R = 0, P = 0;
    switch (u3.type) {
      case "CIMPointSymbol":
      case "CIMTextSymbol":
        {
          let e2 = 1;
          z2.width > C && (e2 = C / z2.width);
          let t3 = 1;
          z2.height > M2 && (t3 = M2 / z2.height), "preview" === i && (z2.width < C && (e2 = C / z2.width), z2.height < M2 && (t3 = M2 / z2.height)), x = Math.min(e2, t3), R = z2.x + z2.width / 2, P = z2.y + z2.height / 2;
        }
        break;
      case "CIMLineSymbol":
        {
          let e2 = 1;
          z2.height > M2 && (e2 = M2 / z2.height), x = e2, P = z2.y + z2.height / 2;
          const t3 = z2.x * x + C / 2, a2 = (z2.x + z2.width) * x + C / 2;
          if (t3 < 0) {
            const { paths: e3 } = _2;
            e3[0][0][0] -= t3;
          }
          if (a2 > C) {
            const { paths: e3 } = _2;
            e3[0][2][0] -= a2 - C;
          }
        }
        break;
      case "CIMPolygonSymbol": {
        R = z2.x + z2.width / 2, P = z2.y + z2.height / 2;
        const e2 = z2.x * x + C / 2, t3 = (z2.x + z2.width) * x + C / 2, a2 = z2.y * x + M2 / 2, i2 = (z2.y + z2.height) * x + M2 / 2, { rings: r4 } = _2;
        e2 < 0 && (r4[0][0][0] -= e2, r4[0][3][0] -= e2, r4[0][4][0] -= e2), a2 < 0 && (r4[0][0][1] += a2, r4[0][1][1] += a2, r4[0][4][1] += a2), t3 > C && (r4[0][1][0] -= t3 - C, r4[0][2][0] -= t3 - C), i2 > M2 && (r4[0][2][1] += i2 - M2, r4[0][3][1] += i2 - M2);
      }
    }
    y.width = C * I2, y.height = M2 * I2;
    const D = 1;
    y.width += 2 * D, y.height += 2 * D;
    const S = y.getContext("2d"), k = Q.createIdentity();
    k.translate(-R, -P), k.scale(x * I2, -x * I2), k.translate(C * I2 / 2 + D, M2 * I2 / 2 + D), S.clearRect(0, 0, y.width, y.height);
    return new et(S, p2, k, true).drawSymbol(d, _2), S.getImageData(0, 0, y.width, y.height);
  }
  async analyzeCIMSymbol3D(e, t2, a, r3, s2) {
    const n = [], c3 = t2 ? { geometryType: r3, spatialReference: this._spatialReference, fields: t2 } : null, l = [];
    ie.fetchFonts(e.data.symbol, this._cimResourceManager, l), await Promise.all(l);
    const h3 = new G(this._cimResourceManager, c3);
    let g;
    await h3.analyzeSymbolReference(e.data, this._avoidSDF, n), s(s2);
    for (const i of n)
      "CIMPictureMarker" !== i.cim.type && "CIMPictureFill" !== i.cim.type && "CIMPictureStroke" !== i.cim.type || (g || (g = []), g.push(this._fetchPictureMarkerResource(i, s2))), a && "text" === i.type && "string" == typeof i.text && i.text.includes("[") && (i.text = c(a, i.text, i.cim.textCase));
    return g && await Promise.all(g), n;
  }
  rasterizeCIMSymbol3D(e, t2, a, i, r3, o) {
    const s2 = [];
    for (const n of e) {
      i && "function" == typeof i.scaleFactor && (i.scaleFactor = i.scaleFactor(t2, r3, o));
      const e2 = this._getRasterizedResource(n, t2, a, i, r3, o);
      if (!e2)
        continue;
      let c3 = 0, l = e2.anchorX || 0, h3 = e2.anchorY || 0, m2 = false, g = 0, u3 = 0;
      if ("esriGeometryPoint" === a) {
        const e3 = _(i);
        if (g = t(n.offsetX, t2, r3, o) * e3 || 0, u3 = t(n.offsetY, t2, r3, o) * e3 || 0, "marker" === n.type)
          c3 = t(n.rotation, t2, r3, o) || 0, m2 = n.rotateClockwise ?? false;
        else if ("text" === n.type) {
          if (c3 = t(n.angle, t2, r3, o) || 0, void 0 !== n.horizontalAlignment)
            switch (n.horizontalAlignment) {
              case "left":
                l = -0.5;
                break;
              case "right":
                l = 0.5;
                break;
              default:
                l = 0;
            }
          if (void 0 !== n.verticalAlignment)
            switch (n.verticalAlignment) {
              case "top":
                h3 = 0.5;
                break;
              case "bottom":
                h3 = -0.5;
                break;
              case "baseline":
                h3 = -0.25;
                break;
              default:
                h3 = 0;
            }
        }
      }
      null != e2 && s2.push({ angle: c3, rotateClockWise: m2, anchorX: l, anchorY: h3, offsetX: g, offsetY: u3, rasterizedResource: e2 });
    }
    return this.getSymbolImage(s2);
  }
  getSymbolImage(e) {
    const t2 = document.createElement("canvas"), i = u(t2.getContext("2d"));
    let o = 0, s2 = 0, n = 0, c3 = 0;
    const l = [];
    for (let a = 0; a < e.length; a++) {
      const t3 = e[a], h4 = t3.rasterizedResource;
      if (!h4)
        continue;
      const m3 = h4.size, g2 = t3.offsetX, u3 = t3.offsetY, f = t3.anchorX, d = t3.anchorY, y = t3.rotateClockWise || false;
      let p2 = t3.angle, w = u2(g2) - m3[0] * (0.5 + f), C = u2(u3) - m3[1] * (0.5 + d), M2 = w + m3[0], _2 = C + m3[1];
      if (p2) {
        y && (p2 = -p2);
        const e2 = Math.sin(p2 * Math.PI / 180), t4 = Math.cos(p2 * Math.PI / 180), a2 = w * t4 - C * e2, i2 = w * e2 + C * t4, r3 = w * t4 - _2 * e2, o2 = w * e2 + _2 * t4, s3 = M2 * t4 - _2 * e2, n2 = M2 * e2 + _2 * t4, c4 = M2 * t4 - C * e2, l2 = M2 * e2 + C * t4;
        w = Math.min(a2, r3, s3, c4), C = Math.min(i2, o2, n2, l2), M2 = Math.max(a2, r3, s3, c4), _2 = Math.max(i2, o2, n2, l2);
      }
      o = w < o ? w : o, s2 = C < s2 ? C : s2, n = M2 > n ? M2 : n, c3 = _2 > c3 ? _2 : c3;
      const b2 = i.createImageData(h4.size[0], h4.size[1]);
      b2.data.set(new Uint8ClampedArray(h4.image.buffer));
      const z2 = { offsetX: g2, offsetY: u3, rotateClockwise: y, angle: p2, rasterizedImage: b2, anchorX: f, anchorY: d };
      l.push(z2);
    }
    t2.width = n - o, t2.height = c3 - s2;
    const h3 = -o, m2 = c3;
    for (let a = 0; a < l.length; a++) {
      const e2 = l[a], t3 = this._imageDataToCanvas(e2.rasterizedImage), o2 = e2.rasterizedImage.width, s3 = e2.rasterizedImage.height, n2 = h3 - o2 * (0.5 + e2.anchorX), c4 = m2 - s3 * (0.5 - e2.anchorY);
      if (e2.angle) {
        const a2 = (360 - e2.angle) * Math.PI / 180;
        i.save(), i.translate(u2(e2.offsetX), -u2(e2.offsetY)), i.translate(h3, m2), i.rotate(a2), i.translate(-h3, -m2), i.drawImage(t3, n2, c4), i.restore();
      } else
        i.drawImage(t3, n2 + u2(e2.offsetX), c4 - u2(e2.offsetY));
    }
    const g = new p({ x: h3 / t2.width - 0.5, y: m2 / t2.height - 0.5 });
    return { imageData: 0 !== t2.width && 0 !== t2.height ? i.getImageData(0, 0, t2.width, t2.height) : i.createImageData(1, 1), anchorPosition: g };
  }
  async _fetchPictureMarkerResource(e, a) {
    const i = e.materialHash;
    if (!this._pictureMarkerCache.get(i)) {
      const r3 = (await j(e.cim.url, { responseType: "image", signal: a && a.signal })).data;
      this._pictureMarkerCache.set(i, r3);
    }
  }
  _imageDataToCanvas(e) {
    this._imageDataCanvas || (this._imageDataCanvas = document.createElement("canvas"));
    const t2 = this._imageDataCanvas, i = u(t2.getContext("2d"));
    return t2.width = e.width, t2.height = e.height, i.putImageData(e, 0, 0), t2;
  }
  _imageTo32Array(t2, i, r3, o) {
    this._imageDataCanvas || (this._imageDataCanvas = document.createElement("canvas"));
    const s2 = this._imageDataCanvas, n = u(s2.getContext("2d"));
    if (s2.width = i, s2.height = r3, n.drawImage(t2, 0, 0, i, r3), o) {
      n.save();
      const a = new h(o);
      n.fillStyle = a.toHex(), n.globalCompositeOperation = "multiply", n.fillRect(0, 0, i, r3), n.globalCompositeOperation = "destination-atop", n.drawImage(t2, 0, 0, i, r3), n.restore();
    }
    return new Uint32Array(n.getImageData(0, 0, i, r3).data.buffer);
  }
  _getRasterizedResource(e, t2, i, r3, o, s2) {
    let n, c3, l;
    const h3 = null, m2 = null;
    if ("text" === e.type)
      return this._rasterizeTextResource(e, t2, r3, o, s2);
    ({ analyzedCIM: n, hash: c3 } = I(e, t2, o, s2));
    const g = _(r3);
    if ("CIMPictureMarker" === e.cim.type) {
      const i2 = t(e.size, t2, o, s2) * g, { image: r4, width: n2, height: c4 } = u(this._getPictureResource(e, i2, t(e.color, t2, o, s2)));
      return l = { image: r4, size: [n2, c4], sdf: false, simplePattern: false, anchorX: e.anchorPoint ? e.anchorPoint.x : 0, anchorY: e.anchorPoint ? e.anchorPoint.y : 0 }, l;
    }
    m(n, g, { preserveOutlineWidth: false });
    const u3 = n;
    c3 += i, r3 && (c3 += JSON.stringify(r3));
    const f = this._resourceCache;
    return f.has(c3) ? f.get(c3) : (l = this._rasterizer.rasterizeJSONResource({ cim: u3, type: e.type, url: e.url, mosaicHash: c3, size: h3, path: m2 }, window.devicePixelRatio || 1, this._avoidSDF), f.set(c3, l), l);
  }
  _rasterizeTextResource(e, t2, a, i, r3) {
    var _a, _b, _c;
    const o = _(a), s2 = t(e.text, t2, i, r3);
    if (!s2 || 0 === s2.length)
      return null;
    const n = e.cim, c3 = t((n == null ? void 0 : n.fontFamilyName) || e.fontName, t2, i, r3), l = t(((_a = n == null ? void 0 : n.font) == null ? void 0 : _a.style) || e.style, t2, i, r3), h3 = t(((_b = n == null ? void 0 : n.font) == null ? void 0 : _b.weight) || e.weight, t2, i, r3), m2 = t(((_c = n == null ? void 0 : n.font) == null ? void 0 : _c.decoration) || e.decoration, t2, i, r3), g = t(e.size, t2, i, r3) * o, u3 = t(e.horizontalAlignment, t2, i, r3), f = t(e.verticalAlignment, t2, i, r3), d = r2(t(e.color, t2, i, r3)), w = r2(t(e.outlineColor, t2, i, r3)), C = t(e.outlineSize, t2, i, r3), M2 = null != e.backgroundColor ? r2(e.backgroundColor) : null, b2 = null != e.borderLineColor ? r2(e.borderLineColor) : null, z2 = null != e.borderLineWidth ? e.borderLineWidth : null, v2 = { color: d, size: g, horizontalAlignment: u3, verticalAlignment: f, font: { family: c3, style: l, weight: h3, decoration: m2 }, halo: { size: C || 0, color: w, style: l }, backgroundColor: M2, borderLine: null != b2 && null != z2 ? { color: b2, size: z2 } : null, pixelRatio: 1, premultiplyColors: !this._avoidSDF };
    return this._textRasterizer.rasterizeText(s2, v2);
  }
  _getPictureResource(e, t2, a) {
    const i = this._pictureMarkerCache.get(e.materialHash);
    if (!i)
      return null;
    const o = i.height / i.width, s2 = t2 ? o > 1 ? u2(t2) : u2(t2) / o : i.width, n = t2 ? o > 1 ? u2(t2) * o : u2(t2) : i.height;
    return { image: this._imageTo32Array(i, s2, n, a), width: s2, height: n };
  }
};
function v(e, t2, a, i) {
  const r3 = 1, o = -t2 / 2 + r3, s2 = t2 / 2 - r3, n = a / 2 - r3, c3 = -a / 2 + r3;
  switch (e) {
    case "esriGeometryPoint":
      return { x: 0, y: 0 };
    case "esriGeometryPolyline":
      return { paths: [[[o, 0], [0, 0], [s2, 0]]] };
    default:
      return "legend" === i ? { rings: [[[o, n], [s2, 0], [s2, c3], [o, c3], [o, n]]] } : { rings: [[[o, n], [s2, n], [s2, c3], [o, c3], [o, n]]] };
  }
}
function I(e, t2, a, i) {
  let r3, o;
  if ("function" == typeof e.materialHash) {
    r3 = (0, e.materialHash)(t2, a, i), o = V(e.cim, e.materialOverrides);
  } else
    r3 = e.materialHash, o = e.cim;
  return { analyzedCIM: o, hash: r3 };
}

export {
  M,
  z
};
//# sourceMappingURL=chunk-5HISUHXO.js.map
