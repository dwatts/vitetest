import {
  u
} from "./chunk-WTPQKRQM.js";
import {
  A,
  C,
  F,
  V
} from "./chunk-BCDDCNQ2.js";
import {
  n
} from "./chunk-63ERNIOV.js";
import {
  i
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import {
  a2 as a,
  c2 as c,
  d
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/webgl/BufferObject.js
var h = s.getLogger("esri.views.webgl.BufferObject");
var c2 = class _c {
  static createIndex(e, t, r) {
    return new _c(e, A.ELEMENT_ARRAY_BUFFER, t, r);
  }
  static createVertex(e, t, r) {
    return new _c(e, A.ARRAY_BUFFER, t, r);
  }
  static createUniform(e, t, r) {
    if (e.type !== n.WEBGL2)
      throw new Error("Uniform buffers are supported in WebGL2 only!");
    return new _c(e, A.UNIFORM_BUFFER, t, r);
  }
  static createPixelPack(e, t = F.STREAM_READ, r) {
    if (e.type !== n.WEBGL2)
      throw new Error("Pixel pack buffers are supported in WebGL2 only!");
    const i2 = new _c(e, A.PIXEL_PACK_BUFFER, t);
    return r && i2.setSize(r), i2;
  }
  static createPixelUnpack(e, t = F.STREAM_DRAW, r) {
    if (e.type !== n.WEBGL2)
      throw new Error("Pixel unpack buffers are supported in WebGL2 only!");
    return new _c(e, A.PIXEL_UNPACK_BUFFER, t, r);
  }
  constructor(e, t, r, i2) {
    this._context = e, this.bufferType = t, this.usage = r, this._glName = null, this._size = -1, this._indexType = void 0, e.instanceCounter.increment(V.BufferObject, this), this._glName = this._context.gl.createBuffer(), u(this._context.gl), i2 && this.setData(i2);
  }
  get glName() {
    return this._glName;
  }
  get size() {
    return this._size;
  }
  get indexType() {
    return this._indexType;
  }
  get byteLength() {
    return this.bufferType === A.ELEMENT_ARRAY_BUFFER ? this._indexType === C.UNSIGNED_INT ? 4 * this._size : 2 * this._size : this._size;
  }
  get _isVAOAware() {
    return this.bufferType === A.ELEMENT_ARRAY_BUFFER || this.bufferType === A.ARRAY_BUFFER;
  }
  dispose() {
    var _a;
    if ((_a = this._context) == null ? void 0 : _a.gl) {
      if (this._glName) {
        this._context.gl.deleteBuffer(this._glName), this._glName = null;
      }
      this._context.instanceCounter.decrement(V.BufferObject, this), this._context = i(this._context);
    } else
      this._glName && h.warn("Leaked WebGL buffer object");
  }
  setSize(e, t = null) {
    if (e <= 0 && h.error("Buffer size needs to be positive!"), this.bufferType === A.ELEMENT_ARRAY_BUFFER && null != t)
      switch (this._indexType = t, t) {
        case C.UNSIGNED_SHORT:
          e *= 2;
          break;
        case C.UNSIGNED_INT:
          e *= 4;
      }
    this._setBufferData(e);
  }
  setData(e) {
    if (!e)
      return;
    let t = e.byteLength;
    this.bufferType === A.ELEMENT_ARRAY_BUFFER && (c(e) && (t /= 2, this._indexType = C.UNSIGNED_SHORT), a(e) && (t /= 4, this._indexType = C.UNSIGNED_INT)), this._setBufferData(t, e);
  }
  _setBufferData(e, t = null) {
    this._size = e;
    const r = this._context.getBoundVAO();
    this._isVAOAware && this._context.bindVAO(null), this._context.bindBuffer(this);
    const i2 = this._context.gl;
    null != t ? i2.bufferData(this.bufferType, t, this.usage) : i2.bufferData(this.bufferType, e, this.usage), u(i2), this._isVAOAware && this._context.bindVAO(r);
  }
  setSubData(e, t, r, i2) {
    if (!e)
      return;
    (t < 0 || t * e.BYTES_PER_ELEMENT >= this.byteLength) && h.error("offset is out of range!"), r >= i2 && h.error("end must be bigger than start!"), (t + (i2 - r)) * e.BYTES_PER_ELEMENT > this.byteLength && h.error("An attempt to write beyond the end of the buffer!");
    const s2 = this._context.getBoundVAO();
    this._isVAOAware && this._context.bindVAO(null), this._context.bindBuffer(this);
    const a2 = this._context.gl;
    if (this._context.type === n.WEBGL2)
      a2.bufferSubData(this.bufferType, t * e.BYTES_PER_ELEMENT, e, r, i2 - r);
    else {
      const s3 = 0 === r && i2 === e.length ? e : e.subarray(r, i2);
      a2.bufferSubData(this.bufferType, t * e.BYTES_PER_ELEMENT, s3);
    }
    u(a2), this._isVAOAware && this._context.bindVAO(s2);
  }
  getSubData(e, t = 0, r, i2) {
    if (this._context.type !== n.WEBGL2)
      return void h.error("Get buffer subdata is supported in WebGL2 only!");
    if (r < 0 || i2 < 0)
      return void h.error("Problem getting subdata: offset and length were less than zero!");
    const s2 = E(e) ? e.BYTES_PER_ELEMENT : 1;
    if (s2 * ((r ?? 0) + (i2 ?? 0)) > e.byteLength)
      return void h.error("Problem getting subdata: offset and length exceeded destination size!");
    t + s2 * (i2 ?? 0) > this.byteLength && h.warn("Potential problem getting subdata: requested data exceeds buffer size!");
    const n2 = this._context.gl;
    this._context.bindBuffer(this, A.COPY_READ_BUFFER), n2.getBufferSubData(A.COPY_READ_BUFFER, t, e, r, i2), this._context.unbindBuffer(A.COPY_READ_BUFFER);
  }
  async getSubDataAsync(e, t = 0, r, i2) {
    this._context.type === n.WEBGL2 ? (await this._context.clientWaitAsync(), this.getSubData(e, t, r, i2)) : h.error("Get buffer subdata is supported in WebGL2 only!");
  }
};
function E(t) {
  return d(t);
}

export {
  c2 as c
};
//# sourceMappingURL=chunk-FB6EWBGE.js.map
