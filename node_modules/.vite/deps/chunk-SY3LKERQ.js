import {
  e
} from "./chunk-KF45Y73U.js";
import {
  o as o2,
  v
} from "./chunk-NLWV7Q6F.js";
import {
  d,
  i,
  t
} from "./chunk-BNBT4QTW.js";
import {
  x
} from "./chunk-DOQ3SAAR.js";
import {
  g,
  o,
  u
} from "./chunk-TPJLFGOT.js";
import {
  f
} from "./chunk-ZEEBL7ZN.js";
import {
  E,
  H,
  j
} from "./chunk-RTDN6KAT.js";
import {
  s3 as s
} from "./chunk-HMVAPW5X.js";

// node_modules/@arcgis/core/properties/defaultUnit.js
var e2 = { readOnly: true, get() {
  return e(this.view);
} };

// node_modules/@arcgis/core/views/3d/analysis/interfaces.js
var e3;
!function(e4) {
  e4[e4.Auto = 0] = "Auto", e4[e4.Euclidean = 1] = "Euclidean", e4[e4.Geodesic = 2] = "Geodesic";
}(e3 || (e3 = {}));

// node_modules/@arcgis/core/geometry/support/geodesicUtils.js
function f2(e4) {
  if (!e4)
    return null;
  if (E(e4) && e4.wkid) {
    const t4 = d[e4.wkid];
    if (t4)
      return t4;
  }
  if (e4.wkt) {
    const t4 = p(e4.wkt);
    if (t4)
      return t4;
  }
  return null;
}
function p(e4) {
  const t4 = t.exec(e4);
  if (!t4 || 2 !== t4.length)
    return null;
  const n = t4[1].split(",");
  if (!n || n.length < 3)
    return null;
  const i3 = parseFloat(n[1]), r = parseFloat(n[2]);
  if (isNaN(i3) || isNaN(r))
    return null;
  return { a: i3, f: 0 === r ? 0 : 1 / r };
}
function u2(e4) {
  const t4 = f2(e4 ?? f.WGS84);
  if (d2(t4))
    return t4;
  const n = t4.a * (1 - t4.f);
  return Object.assign(t4, { b: n, eSq: 1 - (n / t4.a) ** 2, radius: (2 * t4.a + n) / 3, densificationRatio: 1e4 / ((2 * t4.a + n) / 3) });
}
function d2(e4) {
  return null != e4 && "b" in e4 && "eSq" in e4 && "radius" in e4;
}
function M(e4) {
  return null !== f2(e4);
}
function y(n, i3 = "meters") {
  if (!n)
    throw new s("geodesic-lengths:invalid-geometries", "the input geometries type is not supported");
  if (n.some((e4) => !M(e4.spatialReference)))
    throw new s("geodesic-lengths:invalid-spatial-reference", "the input geometries spatial reference is not supported");
  const s2 = [];
  for (let e4 = 0; e4 < n.length; e4++) {
    const r = n[e4], { spatialReference: a2 } = r, o3 = "polyline" === r.type ? r.paths : r.rings;
    let c = 0;
    for (let e5 = 0; e5 < o3.length; e5++) {
      const t4 = o3[e5];
      let n2 = 0;
      for (let e6 = 1; e6 < t4.length; e6++) {
        const i4 = t4[e6 - 1][0], s3 = t4[e6][0], r2 = t4[e6 - 1][1], o4 = t4[e6][1];
        if (r2 !== o4 || i4 !== s3) {
          const e7 = new R();
          b(e7, [i4, r2], [s3, o4], a2), n2 += e7.distance;
        }
      }
      c += n2;
    }
    c = j(c, "meters", i3), s2.push(c);
  }
  return s2;
}
var R = class {
  constructor(e4 = 0, t4 = void 0, n = void 0) {
    this.distance = e4, this.azimuth = t4, this.reverseAzimuth = n;
  }
};
function b(e4, t4, i3, s2) {
  const r = t4[0] * i, a2 = t4[1] * i, o3 = i3[0] * i, c = i3[1] * i, { a: h, b: l, f: f4, radius: p3 } = u2(s2), d3 = o3 - r, m3 = Math.atan((1 - f4) * Math.tan(a2)), g2 = Math.atan((1 - f4) * Math.tan(c)), M2 = Math.sin(m3), w = Math.cos(m3), y2 = Math.sin(g2), v2 = Math.cos(g2);
  let R2, z, b2, j3, q, x3, A, N, S2, k, P = 1e3, F = d3;
  do {
    if (A = Math.sin(F), N = Math.cos(F), b2 = Math.sqrt(v2 * A * (v2 * A) + (w * y2 - M2 * v2 * N) * (w * y2 - M2 * v2 * N)), 0 === b2)
      return e4.distance = 0, e4.azimuth = void 0, e4.reverseAzimuth = void 0, e4;
    q = M2 * y2 + w * v2 * N, x3 = Math.atan2(b2, q), S2 = w * v2 * A / b2, z = 1 - S2 * S2, j3 = q - 2 * M2 * y2 / z, isNaN(j3) && (j3 = 0), k = f4 / 16 * z * (4 + f4 * (4 - 3 * z)), R2 = F, F = d3 + (1 - k) * f4 * S2 * (x3 + k * b2 * (j3 + k * q * (2 * j3 * j3 - 1)));
  } while (Math.abs(F - R2) > 1e-12 && --P > 0);
  if (0 === P) {
    const t5 = p3, i4 = Math.acos(Math.sin(a2) * Math.sin(c) + Math.cos(a2) * Math.cos(c) * Math.cos(o3 - r)) * t5, s3 = o3 - r, h2 = Math.sin(s3) * Math.cos(c), l2 = Math.cos(a2) * Math.sin(c) - Math.sin(a2) * Math.cos(c) * Math.cos(s3), f5 = Math.atan2(h2, l2);
    return e4.azimuth = f5 / i, e4.distance = i4, e4.reverseAzimuth = void 0, e4;
  }
  const U = z * (h * h - l * l) / (l * l), C = U / 1024 * (256 + U * (U * (74 - 47 * U) - 128)), E2 = l * (1 + U / 16384 * (4096 + U * (U * (320 - 175 * U) - 768))) * (x3 - C * b2 * (j3 + C / 4 * (q * (2 * j3 * j3 - 1) - C / 6 * j3 * (4 * b2 * b2 - 3) * (4 * j3 * j3 - 3)))), G = Math.atan2(v2 * Math.sin(F), w * y2 - M2 * v2 * Math.cos(F)), I = Math.atan2(w * Math.sin(F), w * y2 * Math.cos(F) - M2 * v2);
  return e4.azimuth = G / i, e4.distance = E2, e4.reverseAzimuth = I / i, e4;
}

// node_modules/@arcgis/core/views/3d/analysis/support/viewUtils.js
function t2(e4, o3) {
  if (o(o3, 0, 0, 0), e4.length > 0) {
    for (let r = 0; r < e4.length; ++r)
      u(o3, o3, e4[r]);
    g(o3, o3, 1 / e4.length);
  }
}
function f3(e4, n, c, s2) {
  s2.projectToRenderScreen(e4, i2), s2.projectToRenderScreen(n, m2), o2(c, p2, a), v(c, c);
}
var i2 = x();
var a = i2;
var m2 = x();
var p2 = m2;

// node_modules/@arcgis/core/views/3d/analysis/support/UnitNormalizer.js
var t3 = class {
  constructor(e4 = null) {
    this.spatialReference = e4;
  }
  get spatialReference() {
    return this._spatialReference;
  }
  set spatialReference(e4) {
    e4 !== this._spatialReference && (this._spatialReference = e4, this._updateNormalizationFactors());
  }
  normalizeDistance(e4) {
    return e4 * this._metersPerDistanceUnit;
  }
  normalizeElevation(e4) {
    return e4 * this._metersPerElevationUnit;
  }
  normalizeArea(e4) {
    return e4 * this._squareMetersPerAreaUnit;
  }
  _updateNormalizationFactors() {
    this._metersPerDistanceUnit = H(this._spatialReference, 1), this._metersPerElevationUnit = H(this._spatialReference, 1), this._squareMetersPerAreaUnit = this._metersPerDistanceUnit * this._metersPerDistanceUnit;
  }
};

export {
  e2 as e,
  e3 as e2,
  M,
  y,
  R,
  b,
  t2 as t,
  f3 as f,
  t3 as t2
};
//# sourceMappingURL=chunk-SY3LKERQ.js.map
