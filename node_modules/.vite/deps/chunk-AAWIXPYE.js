import {
  _,
  i
} from "./chunk-7JB7RSO7.js";
import {
  c
} from "./chunk-DOQ3SAAR.js";
import {
  m
} from "./chunk-TEHNQYQD.js";

// node_modules/@arcgis/core/views/input/IViewEvents.js
var t;
!function(t2) {
  t2[t2.Left = 0] = "Left", t2[t2.Middle = 1] = "Middle", t2[t2.Right = 2] = "Right";
}(t || (t = {}));

// node_modules/@arcgis/core/views/input/ViewEvents.js
var r = ["click", "double-click", "immediate-click", "immediate-double-click", "hold", "drag", "key-down", "key-up", "pointer-down", "pointer-move", "pointer-up", "pointer-drag", "mouse-wheel", "pointer-enter", "pointer-leave", "gamepad", "focus", "blur"];
var i2 = {};
function o(t2) {
  return !!i2[t2];
}
function s(t2) {
  for (const e of t2)
    if (!o(e))
      return false;
  return true;
}
r.forEach((t2) => {
  i2[t2] = true;
});
var p = class {
  constructor(t2) {
    this._handlers = /* @__PURE__ */ new Map(), this._counter = 0, this._handlerCounts = /* @__PURE__ */ new Map(), this.view = t2, this.inputManager = null;
  }
  connect(t2) {
    t2 && this.disconnect(), this.inputManager = t2, this._handlers.forEach(({ handler: t3, priority: e }, a) => {
      var _a;
      return (_a = this.inputManager) == null ? void 0 : _a.installHandlers(a, [t3], e);
    });
  }
  disconnect() {
    this.inputManager && this._handlers.forEach((t2, e) => {
      var _a;
      return (_a = this.inputManager) == null ? void 0 : _a.uninstallHandlers(e);
    }), this.inputManager = null;
  }
  destroy() {
    this.disconnect(), this._handlers.clear(), this.view = null;
  }
  on(t2, e, a, r2) {
    const i3 = Array.isArray(t2) ? t2 : t2.split(",");
    if (!s(i3))
      return i3.some(o) && console.error("Error: registering input events and other events on the view at the same time is not supported."), null;
    let p2, l;
    Array.isArray(e) ? l = e : (p2 = e, l = []), "function" == typeof a ? p2 = a : r2 = a, r2 = null != r2 ? r2 : _.DEFAULT;
    const u = this._createUniqueGroupName(), m2 = new c2(this.view, i3, l, p2);
    this._handlers.set(u, { handler: m2, priority: r2 });
    for (const n of i3) {
      const t3 = this._handlerCounts.get(n) || 0;
      this._handlerCounts.set(n, t3 + 1);
    }
    return this.inputManager && this.inputManager.installHandlers(u, [m2], r2), { remove: () => this._removeHandler(u, i3) };
  }
  hasHandler(t2) {
    return !!this._handlerCounts.get(t2);
  }
  _removeHandler(t2, e) {
    if (this._handlers.has(t2)) {
      this._handlers.delete(t2);
      for (const t3 of e) {
        const e2 = this._handlerCounts.get(t3);
        void 0 === e2 ? console.error("Trying to remove handler for event that has no handlers registered: ", t3) : 1 === e2 ? this._handlerCounts.delete(t3) : this._handlerCounts.set(t3, e2 - 1);
      }
    }
    this.inputManager && this.inputManager.uninstallHandlers(t2);
  }
  _createUniqueGroupName() {
    return this._counter += 1, `viewEvents_${this._counter}`;
  }
};
var c2 = class extends i {
  constructor(t2, e, a, n) {
    super(true), this._latestDragStart = void 0, this.view = t2;
    for (const r2 of e)
      switch (r2) {
        case "click":
          this.registerIncoming("click", a, (t3) => n(this._wrapClick(t3)));
          break;
        case "double-click":
          this.registerIncoming("double-click", a, (t3) => n(this._wrapDoubleClick(t3)));
          break;
        case "immediate-click":
          this.registerIncoming("immediate-click", a, (t3) => n(this._wrapImmediateClick(t3)));
          break;
        case "immediate-double-click":
          this.registerIncoming("immediate-double-click", a, (t3) => n(this._wrapImmediateDoubleClick(t3)));
          break;
        case "hold":
          this.registerIncoming("hold", a, (t3) => n(this._wrapHold(t3)));
          break;
        case "drag":
          this.registerIncoming("drag", a, (t3) => {
            const e2 = this._wrapDrag(t3);
            e2 && n(e2);
          });
          break;
        case "key-down":
          this.registerIncoming("key-down", a, (t3) => n(this._wrapKeyDown(t3)));
          break;
        case "key-up":
          this.registerIncoming("key-up", a, (t3) => n(this._wrapKeyUp(t3)));
          break;
        case "pointer-down":
          this.registerIncoming("pointer-down", a, (t3) => n(this._wrapPointer(t3, "pointer-down")));
          break;
        case "pointer-move":
          this.registerIncoming("pointer-move", a, (t3) => n(this._wrapPointer(t3, "pointer-move")));
          break;
        case "pointer-up":
          this.registerIncoming("pointer-up", a, (t3) => n(this._wrapPointer(t3, "pointer-up")));
          break;
        case "pointer-drag":
          this.registerIncoming("pointer-drag", a, (t3) => n(this._wrapPointerDrag(t3)));
          break;
        case "mouse-wheel":
          this.registerIncoming("mouse-wheel", a, (t3) => n(this._wrapMouseWheel(t3)));
          break;
        case "pointer-enter":
          this.registerIncoming("pointer-enter", a, (t3) => n(this._wrapPointer(t3, "pointer-enter")));
          break;
        case "pointer-leave":
          this.registerIncoming("pointer-leave", a, (t3) => n(this._wrapPointer(t3, "pointer-leave")));
          break;
        case "gamepad":
          this.registerIncoming("gamepad", a, (t3) => {
            n(this._wrapGamepad(t3));
          });
          break;
        case "focus":
          this.registerIncoming("focus", a, (t3) => {
            n(this._wrapFocus(t3));
          });
          break;
        case "blur":
          this.registerIncoming("blur", a, (t3) => {
            n(this._wrapBlur(t3));
          });
      }
  }
  _wrapFocus(t2) {
    return { type: "focus", timestamp: t2.timestamp, native: t2.data.native, cancelable: t2.cancelable, stopPropagation: () => t2.stopPropagation(), async: (e) => t2.async(e), preventDefault: () => t2.preventDefault() };
  }
  _wrapBlur(t2) {
    return { type: "blur", timestamp: t2.timestamp, native: t2.data.native, cancelable: t2.cancelable, stopPropagation: () => t2.stopPropagation(), async: (e) => t2.async(e), preventDefault: () => t2.preventDefault() };
  }
  _wrapClick(t2) {
    const { pointerType: a, button: n, buttons: r2, x: i3, y: o2, native: s2, eventId: p2 } = t2.data, { cancelable: c3, timestamp: l } = t2;
    return { type: "click", pointerType: a, button: n, buttons: r2, x: i3, y: o2, native: s2, timestamp: l, screenPoint: c(i3, o2), mapPoint: this._getMapPoint(i3, o2), eventId: p2, cancelable: c3, stopPropagation: () => t2.stopPropagation(), async: (e) => t2.async(e), preventDefault: () => t2.preventDefault() };
  }
  _wrapDoubleClick(t2) {
    const { pointerType: e, button: a, buttons: n, x: r2, y: i3, native: o2, eventId: s2 } = t2.data, { cancelable: p2, timestamp: c3 } = t2;
    return { type: "double-click", pointerType: e, button: a, buttons: n, x: r2, y: i3, native: o2, timestamp: c3, mapPoint: this._getMapPoint(r2, i3), eventId: s2, cancelable: p2, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
  _wrapImmediateClick(t2) {
    const { pointerType: e, button: a, buttons: n, x: r2, y: i3, native: o2, eventId: s2 } = t2.data, p2 = o2.pointerId, { cancelable: c3, timestamp: l } = t2;
    return { type: "immediate-click", pointerId: p2, pointerType: e, button: a, buttons: n, x: r2, y: i3, native: o2, timestamp: l, mapPoint: this._getMapPoint(r2, i3), eventId: s2, cancelable: c3, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
  _wrapImmediateDoubleClick(t2) {
    const { pointerType: e, button: a, buttons: n, x: r2, y: i3, native: o2, eventId: s2 } = t2.data, p2 = o2.pointerId, { cancelable: c3, timestamp: l } = t2;
    return { type: "immediate-double-click", pointerId: p2, pointerType: e, button: a, buttons: n, x: r2, y: i3, native: o2, timestamp: l, mapPoint: this._getMapPoint(r2, i3), eventId: s2, cancelable: c3, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
  _wrapHold(t2) {
    const { pointerType: e, button: a, buttons: n, x: r2, y: i3, native: o2 } = t2.data, { cancelable: s2, timestamp: p2 } = t2;
    return { type: "hold", pointerType: e, button: a, buttons: n, x: r2, y: i3, native: o2, timestamp: p2, mapPoint: this._getMapPoint(r2, i3), cancelable: s2, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
  _getMapPoint(t2, a) {
    return this.view.toMap(c(t2, a), { exclude: [] });
  }
  _wrapDrag(e) {
    const a = e.data, { x: n, y: r2 } = a.center, { action: i3, pointerType: o2, button: s2 } = a;
    if ("start" === i3 && (this._latestDragStart = a), !this._latestDragStart)
      return;
    const p2 = a.pointer.native, c3 = a.buttons, { cancelable: l, timestamp: u } = e, m2 = { x: this._latestDragStart.center.x, y: this._latestDragStart.center.y };
    return "end" === i3 && (this._latestDragStart = void 0), { type: "drag", action: i3, x: n, y: r2, origin: m2, pointerType: o2, button: s2, buttons: c3, radius: a.radius, angle: m(a.angle), native: p2, timestamp: u, cancelable: l, stopPropagation: () => e.stopPropagation(), async: (t2) => e.async(t2), preventDefault: () => e.preventDefault() };
  }
  _wrapKeyDown(t2) {
    const { key: e, repeat: a, native: n } = t2.data, { cancelable: r2, timestamp: i3 } = t2;
    return { type: "key-down", key: e, repeat: a, native: n, timestamp: i3, cancelable: r2, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
  _wrapKeyUp(t2) {
    const { key: e, native: a } = t2.data, { cancelable: n, timestamp: r2 } = t2;
    return { type: "key-up", key: e, native: a, timestamp: r2, cancelable: n, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
  _wrapPointer(t2, e) {
    const { x: a, y: n, button: r2, buttons: i3, native: o2, eventId: s2 } = t2.data, p2 = o2.pointerId, c3 = o2.pointerType, { cancelable: l, timestamp: u } = t2;
    return { type: e, x: a, y: n, pointerId: p2, pointerType: c3, button: r2, buttons: i3, native: o2, timestamp: u, eventId: s2, cancelable: l, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
  _wrapPointerDrag(t2) {
    const { x: e, y: a, buttons: n, native: r2, eventId: i3 } = t2.data.currentEvent, { button: o2 } = t2.data.startEvent, s2 = t2.data.startEvent.native.pointerId, p2 = t2.data.startEvent.native.pointerType, c3 = t2.data.action, l = { x: t2.data.startEvent.x, y: t2.data.startEvent.y }, { cancelable: u, timestamp: m2 } = t2;
    return { type: "pointer-drag", x: e, y: a, pointerId: s2, pointerType: p2, button: o2, buttons: n, action: c3, origin: l, native: r2, timestamp: m2, eventId: i3, cancelable: u, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
  _wrapMouseWheel(t2) {
    const { cancelable: e, data: a, timestamp: n } = t2, { x: r2, y: i3, deltaY: o2, native: s2 } = a;
    return { type: "mouse-wheel", x: r2, y: i3, deltaY: o2, native: s2, timestamp: n, cancelable: e, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
  _wrapGamepad(t2) {
    const { action: e, state: a, device: n } = t2.data, { cancelable: r2, timestamp: i3 } = t2, { buttons: o2, axes: s2 } = a;
    return { type: "gamepad", device: n, timestamp: i3, action: e, buttons: o2, axes: s2, cancelable: r2, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
};

export {
  t,
  r,
  p
};
//# sourceMappingURL=chunk-AAWIXPYE.js.map
