import {
  c as c3
} from "./chunk-BTHQ4EZE.js";
import {
  l
} from "./chunk-F6PJCZPH.js";
import {
  a as a4
} from "./chunk-32IFRFHL.js";
import {
  n
} from "./chunk-XGIDQJNQ.js";
import {
  d as d2
} from "./chunk-TYEEWKIN.js";
import {
  ht
} from "./chunk-WRC5WFEM.js";
import {
  E,
  a2 as a5,
  e as e5
} from "./chunk-UYTAZUBJ.js";
import {
  C
} from "./chunk-2EO2WRP7.js";
import {
  c as c2
} from "./chunk-VYGC2LVC.js";
import {
  t as t2
} from "./chunk-N4JKQR77.js";
import {
  b
} from "./chunk-BDX5TRUE.js";
import {
  w as w2
} from "./chunk-NIZWDAMQ.js";
import {
  t as t3
} from "./chunk-SMDDCTGQ.js";
import {
  O as O2
} from "./chunk-BUCIQGFS.js";
import {
  t
} from "./chunk-UM64E5NS.js";
import {
  D
} from "./chunk-BCDDCNQ2.js";
import {
  s as s4
} from "./chunk-6S2FCH6S.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  _,
  a as a3
} from "./chunk-SVCGLUNW.js";
import {
  H,
  M as M2,
  R,
  e as e4,
  i,
  q,
  s as s3
} from "./chunk-EKJ2DJIR.js";
import {
  M
} from "./chunk-3VUFACNT.js";
import {
  j as j2
} from "./chunk-H7RDAEPY.js";
import {
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2,
  e as e3
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  a,
  c,
  d,
  j,
  k,
  s as s2,
  w
} from "./chunk-7I33FAWS.js";
import {
  e as e2
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";

// node_modules/@arcgis/core/views/3d/layers/support/overlayImageUtils.js
function u(r, o, n2) {
  const i2 = M2(r) / s3(r), m = { width: n2, height: n2 };
  return i2 > 1.0001 ? m.height = n2 / i2 : i2 < 0.9999 && (m.width = n2 * i2), m.width = Math.round(m.width / (M2(r) / M2(o))), m.height = Math.round(m.height / (s3(r) / s3(o))), m;
}
function l2(t4, e6) {
  return ht(t4, [[e6[0], e6[1], -1], [e6[2], e6[1], -1], [e6[2], e6[3], -1], [e6[0], e6[3], -1]]);
}
function s5(t4, e6, h) {
  if (!q(e6, h))
    return l2(t4, h);
  const u2 = [e6[1] - h[1], Math.min(e6[3], h[3]) - Math.max(e6[1], h[1]), h[3] - e6[3], 123456], s6 = [e6[0] - h[0], Math.min(e6[2], h[2]) - Math.max(e6[0], h[0]), h[2] - e6[2], 123456], f = h[2] - h[0], p = h[3] - h[1], w3 = s6[0] > 0 && s6[2] > 0 ? 3 : 2, b2 = u2[0] > 0 && u2[2] > 0 ? 3 : 2, c4 = (b2 + 1) * (w3 + 1), y2 = t(3 * c4), A = t2(2 * c4), M3 = new Array(6 * (b2 * w3 - 1));
  let d3 = 0, j3 = 0, O3 = 0, x = 0, I = 0;
  for (let r = 0; r < 4; r++) {
    const t5 = u2[r];
    if (t5 <= 0)
      continue;
    let e7 = 0;
    for (let o = 0; o < 4; o++) {
      const t6 = s6[o];
      t6 <= 0 || (y2[j3++] = h[0] + e7, y2[j3++] = h[1] + d3, y2[j3++] = -1, A[O3++] = e7 / f, A[O3++] = d3 / p, o < 3 && r < 3 && (1 !== o || 1 !== r) && (M3[I++] = x, M3[I++] = x + 1, M3[I++] = x + w3 + 1, M3[I++] = x + 1, M3[I++] = x + w3 + 2, M3[I++] = x + w3 + 1), x++, e7 += t6);
    }
    d3 += t5;
  }
  const N = new Array(M3.length);
  return new b(t4, [[O.POSITION, new s4(y2, 3, true)], [O.NORMAL, new s4(a6, 3, true)], [O.UV0, new s4(A, 2, true)]], [[O.POSITION, M3], [O.NORMAL, N], [O.UV0, M3]]);
}
var a6 = [0, 0, 1];

// node_modules/@arcgis/core/views/3d/layers/DynamicLayerView3D.js
var V = class extends a4(n(d2)) {
  constructor() {
    super(...arguments), this.drapeSourceType = e5.RasterImage, this.updatePolicy = C.SYNC, this.fullExtentInLocalViewSpatialReference = null, this.maximumDataResolution = null, this._images = new Array(), this._extents = new Array(), this._overlays = new Array(), this.updateWhenStationary = true, this._drapeSourceRenderer = null, this.refreshDebounced = k(async (e6) => {
      this.destroyed || await this._doRefresh(e6).catch((e7) => {
        d(e7) || s.getLogger(this).error(e7);
      });
    }, 2e3);
  }
  initialize() {
    this._drapeSourceRenderer = this.view.basemapTerrain.overlayManager.registerGeometryDrapeSource(this), this.handles.add(e3(() => this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this))), this.addResolvingPromise(l(this).then((e6) => this._set("fullExtentInLocalViewSpatialReference", e6))), this.updatingHandles.add(() => this.suspended, () => this._suspendedChangeHandler()), this.handles.add(this.view.resourceController.scheduler.registerIdleStateCallbacks(() => {
      this._isScaleRangeActive() && this.notifyChange("suspended");
    }, () => {
    })), this._isScaleRangeLayer() && this.updatingHandles.add(() => this.layer.effectiveScaleRange, () => this.notifyChange("suspended"));
  }
  destroy() {
    this.clear();
  }
  setDrapingExtent(e6, t4) {
    this._spatialReference = t4, e6.forEach((e7) => {
      this._overlays[e7.index] = e7, this._updateImageExtent(e7);
    });
  }
  _updateImageExtent(e6) {
    const t4 = this._clippedExtent(e6.extent, F);
    if (null == t4)
      return;
    const i2 = u(e6.extent, t4, e6.resolution);
    let r = e6.pixelRatio * this.view.state.pixelRatio;
    const { layer: s6 } = this;
    if ("imageMaxWidth" in s6 && null != s6.imageMaxWidth || "imageMaxHeight" in s6 && null != s6.imageMaxHeight) {
      const e7 = s6.imageMaxWidth, t5 = s6.imageMaxHeight;
      if (i2.width > e7) {
        const t6 = e7 / i2.width;
        i2.height = Math.floor(i2.height * t6), i2.width = e7, r *= t6;
      }
      if (i2.height > t5) {
        const e8 = t5 / i2.height;
        i2.width = Math.floor(i2.width * e8), i2.height = t5, r *= e8;
      }
    }
    const n2 = this._extents[e6.index];
    n2 && H(n2.extent, t4) && this._imageSizeEquals(t4, n2.imageSize, i2) || (this._extents[e6.index] = { extent: i(t4), imageSize: i2, pixelRatio: r }, this.suspended || this._fetch(e6.index).catch((e7) => {
      d(e7) || s.getLogger(this).error(e7);
    }));
  }
  clear() {
    for (let e6 = 0; e6 < this._images.length; e6++)
      this._clearImage(e6);
  }
  async doRefresh() {
    return this._doRefresh();
  }
  async _doRefresh(e6) {
    if (this.suspended)
      return;
    const t4 = [];
    for (let i2 = 0; i2 < this._extents.length; i2++)
      this._extents[i2] && t4.push(this._fetch(i2, e6));
    await j(t4);
  }
  canResume() {
    if (!super.canResume())
      return false;
    const e6 = this.layer;
    if (this._isScaleRangeActive()) {
      const { minScale: t4, maxScale: i2 } = e6.effectiveScaleRange, r = this.view.scale;
      if (r < i2 || t4 > 0 && r > t4)
        return false;
    }
    return true;
  }
  isUpdating() {
    return this._images.some((e6) => !!e6.loadingPromise);
  }
  async processResult(e6, t4, i2) {
    (t4 instanceof HTMLImageElement || t4 instanceof HTMLCanvasElement) && (e6.image = t4);
  }
  findExtentInfoAt(e6) {
    for (const t4 of this._extents) {
      const i2 = t4.extent;
      if (new M(i2[0], i2[1], i2[2], i2[3], this._spatialReference).contains(e6))
        return t4;
    }
    return null;
  }
  getFetchOptions() {
  }
  async redraw(e6, i2) {
    await a3(this._images, async (t4, r) => {
      t4 && (await e6(t4, i2), await this._createStageObjects(r, t4.image, i2));
    });
  }
  _imageSizeEquals(e6, t4, i2) {
    if (!this.maximumDataResolution)
      return false;
    const r = M2(e6) / this.maximumDataResolution.x, a7 = s3(e6) / this.maximumDataResolution.y, s6 = r / t4.width, n2 = a7 / t4.height, o = r / i2.width, l3 = a7 / i2.height, h = Math.abs(s6 - o), m = Math.abs(n2 - l3), d3 = t3.TESTS_DISABLE_OPTIMIZATIONS ? 0 : 1.5;
    return h <= d3 && m <= d3;
  }
  async _fetch(e6, t4) {
    if (this.suspended)
      return;
    const i2 = this._extents[e6], r = i2.extent;
    this._images[e6] || (this._images[e6] = { texture: null, material: null, renderGeometry: null, loadingPromise: null, loadingAbortController: null, image: null, pixelData: null, renderExtent: i(r) });
    const n2 = this._images[e6];
    n2.loadingAbortController = e2(n2.loadingAbortController);
    const l3 = new M(r[0], r[1], r[2], r[3], this._spatialReference);
    if (0 === l3.width || 0 === l3.height)
      return void this._clearImage(e6);
    const c4 = new AbortController();
    n2.loadingAbortController = c4, w(t4, () => c4.abort());
    const g = c4.signal, u2 = this._waitFetchReady(g).then(async () => {
      const t5 = { requestAsImageElement: true, pixelRatio: this._overlays[e6].pixelRatio, ...this.getFetchOptions(), signal: g }, { height: r2, width: a7 } = i2.imageSize;
      return this.layer.fetchImage(l3, a7, r2, t5);
    }).then((e7) => {
      if (a(g))
        throw s.getLogger(this).warnOnce("A call to fetchImage resolved even though the request was aborted. fetchImage should not resolve if options.signal.aborted is true."), c();
      return this.processResult(n2, e7);
    }).then(() => {
      e4(n2.renderExtent, r);
    }).finally(() => {
      u2 === n2.loadingPromise && (n2.loadingPromise = null, n2.loadingAbortController = null);
    });
    n2.loadingPromise = u2, this.notifyChange("updating"), await u2.then(async () => {
      if (g.aborted)
        throw c();
      await this._createStageObjects(e6, n2.image, g), this.notifyChange("updating");
    }).catch((e7) => {
      throw e7 && !d(e7) && s.getLogger(this).error(e7), this.notifyChange("updating"), e7;
    });
  }
  _clearImage(e6) {
    const t4 = this._images[e6];
    if (t4) {
      null != t4.renderGeometry && (this._drapeSourceRenderer.removeGeometries([t4.renderGeometry], E.UPDATE), t4.renderGeometry = null);
      const e7 = this.view._stage;
      e7.remove(t4.texture), t4.texture = null, e7.remove(t4.material), t4.material = null, t4.loadingAbortController = e2(t4.loadingAbortController), t4.loadingPromise = null, t4.image = null, t4.pixelData = null;
    }
  }
  async _createStageObjects(e6, t4, r) {
    const a7 = this.view._stage, s6 = this._images[e6], n2 = () => {
      a7.remove(s6.texture), s6.texture = null, null != s6.renderGeometry && (this._drapeSourceRenderer.removeGeometries([s6.renderGeometry], E.UPDATE), s6.renderGeometry = null);
    };
    if (t4) {
      const o = new w2(t4, { width: t4.width, height: t4.height, preMultiplyAlpha: true, wrap: { s: D.CLAMP_TO_EDGE, t: D.CLAMP_TO_EDGE } });
      let l3;
      if (await _(this._images[e6 === O2.INNER ? O2.OUTER : O2.INNER].loadingPromise), s2(r), n2(), a7.add(o), await a7.loadImmediate(o), s6.texture = o, null == s6.material ? (s6.material = new c3({ transparent: true, textureId: o.id }), a7.add(s6.material)) : s6.material.setParameters({ textureId: o.id }), e6 === O2.INNER)
        l3 = l2(s6.material, s6.renderExtent);
      else {
        const e7 = this._images[0].renderExtent;
        if (!e7)
          return void n2();
        l3 = s5(s6.material, e7, s6.renderExtent);
      }
      s6.renderGeometry = new a5(l3), s6.renderGeometry.localOrigin = this._overlays[e6].renderLocalOrigin, this._drapeSourceRenderer.addGeometries([s6.renderGeometry], E.UPDATE);
    } else
      n2(), a7.remove(s6.material), s6.material = null;
  }
  _isScaleRangeLayer() {
    return "effectiveScaleRange" in this.layer;
  }
  _isScaleRangeActive() {
    const e6 = this.layer;
    if (!this._isScaleRangeLayer())
      return false;
    const { minScale: t4, maxScale: i2 } = e6.effectiveScaleRange;
    return c2(t4, i2);
  }
  _clippedExtent(e6, t4) {
    if ("local" !== this.view.viewingMode)
      return e4(t4, e6);
    const i2 = this.view.basemapTerrain;
    return i2.ready ? R(e6, i2.extent, t4) : e4(t4, e6);
  }
  _suspendedChangeHandler() {
    this.suspended ? this.clear() : this.refreshDebounced();
  }
  async _waitFetchReady(e6) {
    await j2(() => this.view.stationary, e6), s2(e6);
  }
};
e([y()], V.prototype, "layer", void 0), e([y()], V.prototype, "suspended", void 0), e([y({ readOnly: true })], V.prototype, "fullExtentInLocalViewSpatialReference", void 0), e([y()], V.prototype, "updating", void 0), V = e([a2("esri.views.3d.layers.DynamicLayerView3D")], V);
var z = V;
var F = i();

export {
  z
};
//# sourceMappingURL=chunk-QE3IPVAC.js.map
