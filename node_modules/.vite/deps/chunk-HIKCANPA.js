import {
  d
} from "./chunk-HUWHMZKL.js";
import {
  e as e2
} from "./chunk-YVVROPAO.js";
import {
  e as e4
} from "./chunk-QS45OHBM.js";
import {
  e as e3
} from "./chunk-WRFNQB7U.js";
import {
  o as o2
} from "./chunk-UUW6REOV.js";
import {
  o as o3
} from "./chunk-2US5EKDI.js";
import {
  i2 as i
} from "./chunk-BO2REVMA.js";
import {
  o
} from "./chunk-V66LHQVK.js";
import {
  l
} from "./chunk-4SIKLJSS.js";
import {
  T,
  h
} from "./chunk-FOEAKQNX.js";
import {
  _ as _2
} from "./chunk-LEDSC236.js";
import {
  n as n2
} from "./chunk-YGUWDSEH.js";
import {
  r as r2
} from "./chunk-NLWV7Q6F.js";
import {
  n as n3
} from "./chunk-SS3YG6J3.js";
import {
  M
} from "./chunk-TEHNQYQD.js";
import {
  O,
  _,
  e,
  r,
  s,
  u,
  x,
  z
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import {
  w
} from "./chunk-3CQBBMMD.js";

// node_modules/@arcgis/core/chunks/Laserlines.glsl.js
var C = M(6);
function A(e5) {
  const i2 = new i();
  i2.include(o3), i2.include(d, e5);
  const t = i2.fragment;
  if (e5.lineVerticalPlaneEnabled || e5.heightManifoldEnabled)
    if (t.uniforms.add(new o2("maxPixelDistance", (i3, t2) => e5.heightManifoldEnabled ? 2 * t2.camera.computeScreenPixelSizeAt(i3.heightManifoldTarget) : 2 * t2.camera.computeScreenPixelSizeAt(i3.lineVerticalPlaneSegment.origin))), t.code.add(o`float planeDistancePixels(vec4 plane, vec3 pos) {
float dist = dot(plane.xyz, pos) + plane.w;
float width = fwidth(dist);
dist /= min(width, maxPixelDistance);
return abs(dist);
}`), e5.spherical) {
      const e6 = (e7, i4, t2) => O(e7, i4.heightManifoldTarget, t2.camera.viewMatrix), i3 = (e7, i4) => O(e7, [0, 0, 0], i4.camera.viewMatrix);
      t.uniforms.add(new e4("heightManifoldOrigin", (t2, r3) => (e6(T2, t2, r3), i3(U, r3), e(U, U, T2), z(R, U), R[3] = s(U), R)), new e2("globalOrigin", (e7, t2) => i3(T2, t2)), new o2("cosSphericalAngleThreshold", (e7, i4) => 1 - Math.max(2, x(i4.camera.eye, e7.heightManifoldTarget) * i4.camera.perRenderPixelRatio) / s(e7.heightManifoldTarget))), t.code.add(o`float globeDistancePixels(float posInGlobalOriginLength) {
float dist = abs(posInGlobalOriginLength - heightManifoldOrigin.w);
float width = fwidth(dist);
dist /= min(width, maxPixelDistance);
return abs(dist);
}
float heightManifoldDistancePixels(vec4 heightPlane, vec3 pos) {
vec3 posInGlobalOriginNorm = normalize(globalOrigin - pos);
float cosAngle = dot(posInGlobalOriginNorm, heightManifoldOrigin.xyz);
vec3 posInGlobalOrigin = globalOrigin - pos;
float posInGlobalOriginLength = length(posInGlobalOrigin);
float sphericalDistance = globeDistancePixels(posInGlobalOriginLength);
float planarDistance = planeDistancePixels(heightPlane, pos);
return cosAngle < cosSphericalAngleThreshold ? sphericalDistance : planarDistance;
}`);
    } else
      t.code.add(o`float heightManifoldDistancePixels(vec4 heightPlane, vec3 pos) {
return planeDistancePixels(heightPlane, pos);
}`);
  if (e5.pointDistanceEnabled && (t.uniforms.add(new o2("maxPixelDistance", (e6, i3) => 2 * i3.camera.computeScreenPixelSizeAt(e6.pointDistanceTarget))), t.code.add(o`float sphereDistancePixels(vec4 sphere, vec3 pos) {
float dist = distance(sphere.xyz, pos) - sphere.w;
float width = fwidth(dist);
dist /= min(width, maxPixelDistance);
return abs(dist);
}`)), e5.intersectsLineEnabled && (t.uniforms.add(new o2("perScreenPixelRatio", (e6, i3) => i3.camera.perScreenPixelRatio)), t.code.add(o`float lineDistancePixels(vec3 start, vec3 dir, float radius, vec3 pos) {
float dist = length(cross(dir, pos - start)) / (length(pos) * perScreenPixelRatio);
return abs(dist) - radius;
}`)), (e5.lineVerticalPlaneEnabled || e5.intersectsLineEnabled) && t.code.add(o`bool pointIsWithinLine(vec3 pos, vec3 start, vec3 end) {
vec3 dir = end - start;
float t2 = dot(dir, pos - start);
float l2 = dot(dir, dir);
return t2 >= 0.0 && t2 <= l2;
}`), t.code.add(o`void main() {
vec3 pos;
vec3 normal;
float depthDiscontinuityAlpha;
if (!laserlineReconstructFromDepth(pos, normal, depthDiscontinuityAlpha)) {
discard;
}
vec4 color = vec4(0, 0, 0, 0);`), e5.heightManifoldEnabled) {
    t.uniforms.add(new e3("angleCutoff", (e6) => V(e6)), new e4("heightPlane", (e6, i4) => z2(e6.heightManifoldTarget, e6.renderCoordsHelper.worldUpAtPosition(e6.heightManifoldTarget, T2), i4.camera.viewMatrix)));
    const i3 = e5.spherical ? o`normalize(globalOrigin - pos)` : o`heightPlane.xyz`;
    t.code.add(o`
    {
      float heightManifoldAlpha = 1.0 - smoothstep(angleCutoff.x, angleCutoff.y, abs(dot(normal, ${i3})));
      vec4 heightManifoldColor = laserlineProfile(heightManifoldDistancePixels(heightPlane, pos));
      color = max(color, heightManifoldColor * heightManifoldAlpha);
    }
    `);
  }
  return e5.pointDistanceEnabled && (t.uniforms.add(new e3("angleCutoff", (e6) => V(e6)), new e4("pointDistanceSphere", (e6, i3) => j(e6, i3))), t.code.add(o`{
float pointDistanceSphereDistance = sphereDistancePixels(pointDistanceSphere, pos);
vec4 pointDistanceSphereColor = laserlineProfile(pointDistanceSphereDistance);
float pointDistanceSphereAlpha = 1.0 - smoothstep(angleCutoff.x, angleCutoff.y, abs(dot(normal, normalize(pos - pointDistanceSphere.xyz))));
color = max(color, pointDistanceSphereColor * pointDistanceSphereAlpha);
}`)), e5.lineVerticalPlaneEnabled && (t.uniforms.add(new e3("angleCutoff", (e6) => V(e6)), new e4("lineVerticalPlane", (e6, i3) => y(e6, i3)), new e2("lineVerticalStart", (e6, i3) => O2(e6, i3)), new e2("lineVerticalEnd", (e6, i3) => E(e6, i3))), t.code.add(o`{
if (pointIsWithinLine(pos, lineVerticalStart, lineVerticalEnd)) {
float lineVerticalDistance = planeDistancePixels(lineVerticalPlane, pos);
vec4 lineVerticalColor = laserlineProfile(lineVerticalDistance);
float lineVerticalAlpha = 1.0 - smoothstep(angleCutoff.x, angleCutoff.y, abs(dot(normal, lineVerticalPlane.xyz)));
color = max(color, lineVerticalColor * lineVerticalAlpha);
}
}`)), e5.intersectsLineEnabled && (t.uniforms.add(new e3("angleCutoff", (e6) => V(e6)), new e2("intersectsLineStart", (e6, i3) => O(T2, e6.lineStartWorld, i3.camera.viewMatrix)), new e2("intersectsLineEnd", (e6, i3) => O(T2, e6.lineEndWorld, i3.camera.viewMatrix)), new e2("intersectsLineDirection", (e6, i3) => (r(R, e6.intersectsLineSegment.vector), R[3] = 0, z(T2, w(R, R, i3.camera.viewMatrix)))), new o2("intersectsLineRadius", (e6) => e6.intersectsLineRadius)), t.code.add(o`{
if (pointIsWithinLine(pos, intersectsLineStart, intersectsLineEnd)) {
float intersectsLineDistance = lineDistancePixels(intersectsLineStart, intersectsLineDirection, intersectsLineRadius, pos);
vec4 intersectsLineColor = laserlineProfile(intersectsLineDistance);
float intersectsLineAlpha = 1.0 - smoothstep(angleCutoff.x, angleCutoff.y, 1.0 - abs(dot(normal, intersectsLineDirection)));
color = max(color, intersectsLineColor * intersectsLineAlpha);
}
}`)), t.code.add(o`fragColor = laserlineOutput(color * depthDiscontinuityAlpha);
}`), i2;
}
function V(t) {
  return r2(I, Math.cos(t.angleCutoff), Math.cos(Math.max(0, t.angleCutoff - M(2))));
}
function j(e5, i2) {
  return O(H, e5.pointDistanceOrigin, i2.camera.viewMatrix), H[3] = x(e5.pointDistanceOrigin, e5.pointDistanceTarget), H;
}
function y(e5, i2) {
  const t = l(e5.lineVerticalPlaneSegment, 0.5, T2), n4 = e5.renderCoordsHelper.worldUpAtPosition(t, G), o4 = z(U, e5.lineVerticalPlaneSegment.vector), r3 = _(R, n4, o4);
  return z(r3, r3), z2(e5.lineVerticalPlaneSegment.origin, r3, i2.camera.viewMatrix);
}
function O2(e5, i2) {
  const t = r(T2, e5.lineVerticalPlaneSegment.origin);
  return e5.renderCoordsHelper.setAltitude(t, 0), O(t, t, i2.camera.viewMatrix);
}
function E(e5, i2) {
  const t = u(T2, e5.lineVerticalPlaneSegment.origin, e5.lineVerticalPlaneSegment.vector);
  return e5.renderCoordsHelper.setAltitude(t, 0), O(t, t, i2.camera.viewMatrix);
}
function z2(e5, i2, t) {
  return O(F, e5, t), r(R, i2), R[3] = 0, w(R, R, t), T(F, R, W);
}
var I = n3();
var T2 = n();
var R = n2();
var G = n();
var U = n();
var F = n();
var W = h();
var H = _2();
var _3 = Object.freeze(Object.defineProperty({ __proto__: null, build: A, defaultAngleCutoff: C }, Symbol.toStringTag, { value: "Module" }));

export {
  C,
  A,
  _3 as _
};
//# sourceMappingURL=chunk-HIKCANPA.js.map
