import {
  t as t6
} from "./chunk-XKYCNHCM.js";
import {
  S as S3
} from "./chunk-YEDW7SLL.js";
import {
  t as t4
} from "./chunk-N4JKQR77.js";
import {
  b,
  r2 as r7
} from "./chunk-BDX5TRUE.js";
import {
  A as A2,
  S as S2,
  a as a4,
  c as c4,
  l as l3
} from "./chunk-LIXBKTBN.js";
import {
  e as e10,
  f as f5,
  o as o7
} from "./chunk-VDSNHCMM.js";
import {
  E as E3
} from "./chunk-6LC2JTLC.js";
import {
  s as s5
} from "./chunk-XM3YSFN6.js";
import {
  w
} from "./chunk-NIZWDAMQ.js";
import {
  t as t7
} from "./chunk-DU3C7D26.js";
import {
  Z
} from "./chunk-YQALOTSV.js";
import {
  i as i6
} from "./chunk-UPDSQXLR.js";
import {
  R
} from "./chunk-NOWEY45I.js";
import {
  a as a2,
  f as f4,
  v
} from "./chunk-XUU35WPC.js";
import {
  e as e9,
  i as i7,
  t as t8
} from "./chunk-V6CD66ZZ.js";
import {
  W,
  _ as _2,
  a as a3,
  h as h5
} from "./chunk-6FHMQNMS.js";
import {
  r as r8
} from "./chunk-KFDARCTS.js";
import {
  V,
  d2,
  h as h4,
  o2 as o4
} from "./chunk-SMDDCTGQ.js";
import {
  E as E2
} from "./chunk-NU4UASX6.js";
import {
  c as c3
} from "./chunk-EHQZFPMP.js";
import {
  d
} from "./chunk-VC3BY3DV.js";
import {
  r as r6
} from "./chunk-YLTVH2K4.js";
import {
  o as o5
} from "./chunk-SADO52IH.js";
import {
  h as h3
} from "./chunk-73PNWDTS.js";
import {
  o as o6
} from "./chunk-PKS3ZVLN.js";
import {
  f as f3,
  l2 as l,
  n2 as n3,
  n3 as n4,
  o3 as o2,
  o4 as o3,
  t,
  t2,
  u as u2
} from "./chunk-UAIJDJWO.js";
import {
  t as t3
} from "./chunk-2CKXYQCA.js";
import {
  e as e7,
  i as i5,
  n as n5
} from "./chunk-JP7O2ZWE.js";
import {
  n as n2,
  r as r5,
  u
} from "./chunk-2SZNVP5H.js";
import {
  e as e6
} from "./chunk-G4LSNP77.js";
import {
  H
} from "./chunk-Z7LZRT7C.js";
import {
  D,
  I
} from "./chunk-BCDDCNQ2.js";
import {
  E,
  L,
  O as O2,
  c,
  i as i2,
  x
} from "./chunk-FIBWCATC.js";
import {
  a
} from "./chunk-QOWAKGE4.js";
import {
  s as s4
} from "./chunk-6S2FCH6S.js";
import {
  e as e5
} from "./chunk-CW7LIPBH.js";
import {
  e as e4
} from "./chunk-VN2IXVGV.js";
import {
  O as O3
} from "./chunk-BN6X2OXK.js";
import {
  r as r3
} from "./chunk-QZ6WR57P.js";
import {
  r as r4
} from "./chunk-YGUWDSEH.js";
import {
  e as e8,
  t as t5
} from "./chunk-D5NSNTGJ.js";
import {
  c as c2,
  i as i4
} from "./chunk-5KLICR5E.js";
import {
  l as l2
} from "./chunk-RVS5HU2K.js";
import {
  g as g2,
  i as i3
} from "./chunk-JB7FDW5N.js";
import {
  h as h2
} from "./chunk-7EG7BYWF.js";
import {
  P as P2,
  h
} from "./chunk-AQ7R6V4L.js";
import {
  _
} from "./chunk-SVCGLUNW.js";
import {
  A,
  F,
  O,
  P,
  S,
  e as e3,
  g,
  i,
  o,
  r as r2,
  s as s3,
  z
} from "./chunk-TPJLFGOT.js";
import {
  e as e2,
  f as f2,
  n,
  r
} from "./chunk-CQX57DED.js";
import {
  j
} from "./chunk-43LWRDQS.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  f
} from "./chunk-7I33FAWS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import {
  has
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/glTF/internal/TextureTransformUtils.js
function r9(r11) {
  if (null == r11)
    return null;
  const f6 = null != r11.offset ? r11.offset : c2, l4 = null != r11.rotation ? r11.rotation : 0, c6 = null != r11.scale ? r11.scale : i4, u4 = t5(1, 0, 0, 0, 1, 0, f6[0], f6[1], 1), i8 = t5(Math.cos(l4), -Math.sin(l4), 0, Math.sin(l4), Math.cos(l4), 0, 0, 0, 1), m = t5(c6[0], 0, 0, 0, c6[1], 0, 0, 0, 1), e11 = e8();
  return i3(e11, i8, m), i3(e11, u4, e11), e11;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/ProcessedObjectResource.js
var s6 = class {
  constructor() {
    this.geometries = new Array(), this.materials = new Array(), this.textures = new Array();
  }
};
var t9 = class {
  constructor(t11, e11, r11) {
    this.name = t11, this.lodThreshold = e11, this.pivotOffset = r11, this.stageResources = new s6(), this.numberOfVertices = 0;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/pbrUtils.js
function u3({ normalTexture: u4, metallicRoughnessTexture: n7, metallicFactor: r11, roughnessFactor: s8, emissiveTexture: o8, emissiveFactor: t11, occlusionTexture: c6 }) {
  return null == u4 && null == n7 && null == o8 && (null == t11 || F(t11, f2)) && null == c6 && (null == s8 || 1 === s8) && (null == r11 || 1 === r11 || 0 === r11);
}
var n6 = [1, 1, 0.5];
var r10 = [0, 0.6, 0.2];
var s7 = [0, 1, 0.2];

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/DefaultMaterialTechnique.js
var k = class extends f4 {
  constructor() {
    super(...arguments), this.isSchematic = false, this.usePBR = false, this.mrrFactors = e2(n6), this.hasVertexColors = false, this.hasSymbolColors = false, this.doubleSided = false, this.doubleSidedType = "normal", this.cullFace = n5.Back, this.isInstanced = false, this.hasInstancedColor = false, this.emissiveFactor = r(0, 0, 0), this.instancedDoublePrecision = false, this.normalType = a2.Attribute, this.receiveSSAO = true, this.receiveShadows = true, this.castShadows = true, this.shadowMappingEnabled = false, this.ambient = r(0.2, 0.2, 0.2), this.diffuse = r(0.8, 0.8, 0.8), this.externalColor = r4(1, 1, 1, 1), this.colorMixMode = "multiply", this.opacity = 1, this.layerOpacity = 1, this.origin = n(), this.hasSlicePlane = false, this.hasSliceHighlight = true, this.offsetTransparentBackfaces = false, this.vvSize = null, this.vvColor = null, this.vvOpacity = null, this.vvSymbolAnchor = null, this.vvSymbolRotationMatrix = null, this.modelTransformation = null, this.transparent = false, this.writeDepth = true, this.customDepthTest = e7.Less, this.textureAlphaMode = i5.Blend, this.textureAlphaCutoff = o6, this.textureAlphaPremultiplied = false, this.hasOccludees = false, this.renderOccluded = o4.Occlude;
  }
};
var N = class extends v {
  constructor() {
    super(...arguments), this.origin = n(), this.slicePlaneLocalOrigin = this.origin;
  }
};
var q = class _q extends e9 {
  initializeConfiguration(e11, t11) {
    t11.spherical = e11.viewingMode === l2.Global, t11.doublePrecisionRequiresObfuscation = e11.rctx.driverTest.doublePrecisionRequiresObfuscation.result, t11.textureCoordinateType = t11.hasColorTexture || t11.hasMetallicRoughnessTexture || t11.hasEmissionTexture || t11.hasOcclusionTexture || t11.hasNormalTexture ? d.Default : d.None, t11.objectAndLayerIdColorInstanced = t11.instanced;
  }
  initializeProgram(e11) {
    return this._initializeProgram(e11, _q.shader);
  }
  _initializeProgram(e11, t11) {
    return new i7(e11.rctx, t11.get().build(this.configuration), E2);
  }
  _convertDepthTestFunction(e11) {
    return e11 === e7.Lequal ? I.LEQUAL : I.LESS;
  }
  _makePipeline(e11, t11) {
    const i8 = this.configuration, r11 = e11 === o5.NONE, s8 = e11 === o5.FrontFace;
    return W({ blending: i8.output !== h3.Color && i8.output !== h3.Alpha || !i8.transparent ? null : r11 ? c4 : A2(e11), culling: z2(i8) ? h5(i8.cullFace) : null, depthTest: { func: l3(e11, this._convertDepthTestFunction(i8.customDepthTest)) }, depthWrite: (r11 || s8) && i8.writeDepth ? a3 : null, colorWrite: _2, stencilWrite: i8.hasOccludees ? e10 : null, stencilTest: i8.hasOccludees ? t11 ? o7 : f5 : null, polygonOffset: r11 || s8 ? null : a4(i8.enableOffset) });
  }
  initializePipeline() {
    return this._occludeePipelineState = this._makePipeline(this.configuration.transparencyPassType, true), this._makePipeline(this.configuration.transparencyPassType, false);
  }
  getPipelineState(e11, t11) {
    return t11 ? this._occludeePipelineState : super.getPipelineState(e11, t11);
  }
};
function z2(e11) {
  return e11.cullFace !== n5.None || !e11.hasSlicePlane && (!e11.transparent && !e11.doubleSidedMode);
}
q.shader = new t8(Z, () => import("./DefaultMaterial.glsl-E5T5CT2K.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/DefaultMaterialTechniqueConfiguration.js
var c5 = class extends s5 {
  constructor() {
    super(...arguments), this.output = h3.Color, this.alphaDiscardMode = i5.Opaque, this.doubleSidedMode = i6.None, this.pbrMode = c3.Disabled, this.cullFace = n5.None, this.transparencyPassType = o5.NONE, this.normalType = a2.Attribute, this.textureCoordinateType = d.None, this.customDepthTest = e7.Less, this.spherical = false, this.hasVertexColors = false, this.hasSymbolColors = false, this.hasVerticalOffset = false, this.hasSlicePlane = false, this.hasSliceHighlight = true, this.hasColorTexture = false, this.hasMetallicRoughnessTexture = false, this.hasEmissionTexture = false, this.hasOcclusionTexture = false, this.hasNormalTexture = false, this.hasScreenSizePerspective = false, this.hasVertexTangents = false, this.hasOccludees = false, this.hasMultipassTerrain = false, this.hasModelTransformation = false, this.offsetBackfaces = false, this.vvSize = false, this.vvColor = false, this.receiveShadows = false, this.receiveAmbientOcclusion = false, this.textureAlphaPremultiplied = false, this.instanced = false, this.instancedColor = false, this.objectAndLayerIdColorInstanced = false, this.instancedDoublePrecision = false, this.doublePrecisionRequiresObfuscation = false, this.writeDepth = true, this.transparent = false, this.enableOffset = true, this.cullAboveGround = false, this.snowCover = false, this.hasColorTextureTransform = false, this.hasEmissionTextureTransform = false, this.hasNormalTextureTransform = false, this.hasOcclusionTextureTransform = false, this.hasMetallicRoughnessTextureTransform = false;
  }
};
e([r8({ count: h3.COUNT })], c5.prototype, "output", void 0), e([r8({ count: i5.COUNT })], c5.prototype, "alphaDiscardMode", void 0), e([r8({ count: i6.COUNT })], c5.prototype, "doubleSidedMode", void 0), e([r8({ count: c3.COUNT })], c5.prototype, "pbrMode", void 0), e([r8({ count: n5.COUNT })], c5.prototype, "cullFace", void 0), e([r8({ count: o5.COUNT })], c5.prototype, "transparencyPassType", void 0), e([r8({ count: a2.COUNT })], c5.prototype, "normalType", void 0), e([r8({ count: d.COUNT })], c5.prototype, "textureCoordinateType", void 0), e([r8({ count: e7.COUNT })], c5.prototype, "customDepthTest", void 0), e([r8()], c5.prototype, "spherical", void 0), e([r8()], c5.prototype, "hasVertexColors", void 0), e([r8()], c5.prototype, "hasSymbolColors", void 0), e([r8()], c5.prototype, "hasVerticalOffset", void 0), e([r8()], c5.prototype, "hasSlicePlane", void 0), e([r8()], c5.prototype, "hasSliceHighlight", void 0), e([r8()], c5.prototype, "hasColorTexture", void 0), e([r8()], c5.prototype, "hasMetallicRoughnessTexture", void 0), e([r8()], c5.prototype, "hasEmissionTexture", void 0), e([r8()], c5.prototype, "hasOcclusionTexture", void 0), e([r8()], c5.prototype, "hasNormalTexture", void 0), e([r8()], c5.prototype, "hasScreenSizePerspective", void 0), e([r8()], c5.prototype, "hasVertexTangents", void 0), e([r8()], c5.prototype, "hasOccludees", void 0), e([r8()], c5.prototype, "hasMultipassTerrain", void 0), e([r8()], c5.prototype, "hasModelTransformation", void 0), e([r8()], c5.prototype, "offsetBackfaces", void 0), e([r8()], c5.prototype, "vvSize", void 0), e([r8()], c5.prototype, "vvColor", void 0), e([r8()], c5.prototype, "receiveShadows", void 0), e([r8()], c5.prototype, "receiveAmbientOcclusion", void 0), e([r8()], c5.prototype, "textureAlphaPremultiplied", void 0), e([r8()], c5.prototype, "instanced", void 0), e([r8()], c5.prototype, "instancedColor", void 0), e([r8()], c5.prototype, "objectAndLayerIdColorInstanced", void 0), e([r8()], c5.prototype, "instancedDoublePrecision", void 0), e([r8()], c5.prototype, "doublePrecisionRequiresObfuscation", void 0), e([r8()], c5.prototype, "writeDepth", void 0), e([r8()], c5.prototype, "transparent", void 0), e([r8()], c5.prototype, "enableOffset", void 0), e([r8()], c5.prototype, "cullAboveGround", void 0), e([r8()], c5.prototype, "snowCover", void 0), e([r8()], c5.prototype, "hasColorTextureTransform", void 0), e([r8()], c5.prototype, "hasEmissionTextureTransform", void 0), e([r8()], c5.prototype, "hasNormalTextureTransform", void 0), e([r8()], c5.prototype, "hasOcclusionTextureTransform", void 0), e([r8()], c5.prototype, "hasMetallicRoughnessTextureTransform", void 0), e([r8({ constValue: true })], c5.prototype, "hasVvInstancing", void 0), e([r8({ constValue: false })], c5.prototype, "useCustomDTRExponentForWater", void 0), e([r8({ constValue: false })], c5.prototype, "supportsTextureAtlas", void 0), e([r8({ constValue: true })], c5.prototype, "useFillLights", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/RealisticTreeTechnique.js
var t10 = class _t extends q {
  initializeConfiguration(i8, a5) {
    super.initializeConfiguration(i8, a5), a5.hasMetallicRoughnessTexture = false, a5.hasEmissionTexture = false, a5.hasOcclusionTexture = false, a5.hasNormalTexture = false, a5.hasModelTransformation = false, a5.normalType = a2.Attribute, a5.doubleSidedMode = i6.WindingOrder, a5.hasVertexTangents = false;
  }
  initializeProgram(e11) {
    return this._initializeProgram(e11, _t.shader);
  }
};
t10.shader = new t8(R, () => import("./RealisticTree.glsl-S6EUHYBU.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultMaterial.js
var I2 = class extends d2 {
  constructor(e11) {
    super(e11, L2), this.supportsEdges = true, this._configuration = new c5(), this._vertexBufferLayout = j2(this.parameters);
  }
  isVisibleForOutput(e11) {
    return e11 !== h3.Shadow && e11 !== h3.ShadowExcludeHighlight && e11 !== h3.ShadowHighlight || this.parameters.castShadows;
  }
  isVisible() {
    const e11 = this.parameters;
    if (!super.isVisible() || 0 === e11.layerOpacity)
      return false;
    const { hasInstancedColor: t11, hasVertexColors: r11, hasSymbolColors: s8, vvColor: a5 } = e11, i8 = "replace" === e11.colorMixMode, o8 = e11.opacity > 0, n7 = e11.externalColor && e11.externalColor[3] > 0, h7 = t11 || a5 || s8;
    return r11 && h7 ? i8 || o8 : r11 ? i8 ? n7 : o8 : h7 ? i8 || o8 : i8 ? n7 : o8;
  }
  getConfiguration(e11, t11) {
    return this._configuration.output = e11, this._configuration.hasNormalTexture = !!this.parameters.normalTextureId, this._configuration.hasColorTexture = !!this.parameters.textureId, this._configuration.hasVertexTangents = this.parameters.hasVertexTangents, this._configuration.instanced = this.parameters.isInstanced, this._configuration.instancedDoublePrecision = this.parameters.instancedDoublePrecision, this._configuration.vvSize = !!this.parameters.vvSize, this._configuration.hasVerticalOffset = null != this.parameters.verticalOffset, this._configuration.hasScreenSizePerspective = null != this.parameters.screenSizePerspective, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.hasSliceHighlight = this.parameters.hasSliceHighlight, this._configuration.alphaDiscardMode = this.parameters.textureAlphaMode, this._configuration.normalType = this.parameters.normalType, this._configuration.transparent = this.parameters.transparent, this._configuration.writeDepth = this.parameters.writeDepth, null != this.parameters.customDepthTest && (this._configuration.customDepthTest = this.parameters.customDepthTest), this._configuration.hasOccludees = this.parameters.hasOccludees, this._configuration.cullFace = this.parameters.hasSlicePlane ? n5.None : this.parameters.cullFace, this._configuration.hasMultipassTerrain = t11.multipassTerrain.enabled, this._configuration.cullAboveGround = t11.multipassTerrain.cullAboveGround, this._configuration.hasModelTransformation = null != this.parameters.modelTransformation, e11 !== h3.Color && e11 !== h3.Alpha || (this._configuration.hasVertexColors = this.parameters.hasVertexColors, this._configuration.hasSymbolColors = this.parameters.hasSymbolColors, this.parameters.treeRendering ? this._configuration.doubleSidedMode = i6.WindingOrder : this._configuration.doubleSidedMode = this.parameters.doubleSided && "normal" === this.parameters.doubleSidedType ? i6.View : this.parameters.doubleSided && "winding-order" === this.parameters.doubleSidedType ? i6.WindingOrder : i6.None, this._configuration.instancedColor = this.parameters.hasInstancedColor, this._configuration.receiveShadows = this.parameters.receiveShadows && this.parameters.shadowMappingEnabled, this._configuration.receiveAmbientOcclusion = !!t11.ssaoHelper.active && this.parameters.receiveSSAO, this._configuration.vvColor = !!this.parameters.vvColor, this._configuration.textureAlphaPremultiplied = !!this.parameters.textureAlphaPremultiplied, this._configuration.pbrMode = this.parameters.usePBR ? this.parameters.isSchematic ? c3.Schematic : c3.Normal : c3.Disabled, this._configuration.hasMetallicRoughnessTexture = !!this.parameters.metallicRoughnessTextureId, this._configuration.hasEmissionTexture = !!this.parameters.emissiveTextureId, this._configuration.hasOcclusionTexture = !!this.parameters.occlusionTextureId, this._configuration.offsetBackfaces = !(!this.parameters.transparent || !this.parameters.offsetTransparentBackfaces), this._configuration.transparencyPassType = t11.transparencyPassType, this._configuration.enableOffset = t11.camera.relativeElevation < S2, this._configuration.snowCover = this.hasSnowCover(t11), this._configuration.hasColorTextureTransform = !!this.parameters.colorTextureTransformMatrix, this._configuration.hasNormalTextureTransform = !!this.parameters.normalTextureTransformMatrix, this._configuration.hasEmissionTextureTransform = !!this.parameters.emissiveTextureTransformMatrix, this._configuration.hasOcclusionTextureTransform = !!this.parameters.occlusionTextureTransformMatrix, this._configuration.hasMetallicRoughnessTextureTransform = !!this.parameters.metallicRoughnessTextureTransformMatrix), this._configuration;
  }
  hasSnowCover(e11) {
    return null != e11.weather && e11.weatherVisible && "snowy" === e11.weather.type && "enabled" === e11.weather.snowCover;
  }
  intersect(h7, l4, u4, m, p, d3) {
    if (null != this.parameters.verticalOffset) {
      const h8 = u4.camera;
      o(z3, l4[12], l4[13], l4[14]);
      let d4 = null;
      switch (u4.viewingMode) {
        case l2.Global:
          d4 = z(B, z3);
          break;
        case l2.Local:
          d4 = r2(B, V2);
      }
      let f6 = 0;
      const g3 = e3(G, z3, h8.eye), T2 = s3(g3), _3 = g(g3, g3, 1 / T2);
      let x2 = null;
      this.parameters.screenSizePerspective && (x2 = P(d4, _3)), f6 += V(h8, T2, this.parameters.verticalOffset, x2 ?? 0, this.parameters.screenSizePerspective), g(d4, d4, f6), S(H2, d4, u4.transform.inverseRotation), m = e3(D2, m, H2), p = e3(N2, p, H2);
    }
    h4(h7, u4, m, p, S3(u4.verticalOffset), d3);
  }
  requiresSlot(e11, t11) {
    if (t11 === h3.Color || t11 === h3.Alpha || t11 === h3.Depth || t11 === h3.Normal || t11 === h3.Shadow || t11 === h3.ShadowHighlight || t11 === h3.ShadowExcludeHighlight || t11 === h3.Highlight || t11 === h3.ObjectAndLayerIdColor) {
      return e11 === (this.parameters.transparent ? this.parameters.writeDepth ? E3.TRANSPARENT_MATERIAL : E3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL : E3.OPAQUE_MATERIAL) || e11 === E3.DRAPED_MATERIAL;
    }
    return false;
  }
  createGLMaterial(e11) {
    return new P3(e11);
  }
  createBufferWriter() {
    return new r7(this._vertexBufferLayout);
  }
};
var P3 = class extends r6 {
  constructor(e11) {
    super({ ...e11, ...e11.material.parameters });
  }
  _updateShadowState(e11) {
    e11.shadowMap.enabled !== this._material.parameters.shadowMappingEnabled && this._material.setParameters({ shadowMappingEnabled: e11.shadowMap.enabled });
  }
  _updateOccludeeState(e11) {
    e11.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e11.hasOccludees });
  }
  beginSlot(t11) {
    this._output !== h3.Color && this._output !== h3.Alpha || (this._updateShadowState(t11), this._updateOccludeeState(t11));
    const r11 = this._material.parameters;
    this.updateTexture(r11.textureId);
    const s8 = t11.camera.viewInverseTransposeMatrix;
    return o(r11.origin, s8[3], s8[7], s8[11]), this._material.setParameters(this.textureBindParameters), this.ensureTechnique(r11.treeRendering ? t10 : q, t11);
  }
};
var E4 = class extends k {
  constructor() {
    super(...arguments), this.initTextureTransparent = false, this.treeRendering = false, this.hasVertexTangents = false;
  }
};
var L2 = new E4();
function j2(e11) {
  const t11 = H().vec3f(O3.POSITION);
  e11.normalType === a2.Compressed ? t11.vec2i16(O3.NORMALCOMPRESSED, { glNormalized: true }) : t11.vec3f(O3.NORMAL), e11.hasVertexTangents && t11.vec4f(O3.TANGENT);
  return (e11.textureId || e11.normalTextureId || e11.metallicRoughnessTextureId || e11.emissiveTextureId || e11.occlusionTextureId) && t11.vec2f(O3.UV0), e11.hasVertexColors && t11.vec4u8(O3.COLOR), e11.hasSymbolColors && t11.vec4u8(O3.SYMBOLCOLOR), has("enable-feature:objectAndLayerId-rendering") && t11.vec4u8(O3.OBJECTANDLAYERIDCOLOR), t11;
}
var D2 = n();
var N2 = n();
var V2 = r(0, 0, 1);
var B = n();
var H2 = n();
var z3 = n();
var G = n();

// node_modules/@arcgis/core/views/3d/layers/graphics/wosrLoader.js
var h6 = s.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");
async function v2(e11, t11) {
  const n7 = await A3(e11, t11), s8 = await T(n7.textureDefinitions ?? {}, t11);
  let a5 = 0;
  for (const r11 in s8)
    if (s8.hasOwnProperty(r11)) {
      const e12 = s8[r11];
      a5 += (e12 == null ? void 0 : e12.image) ? e12.image.width * e12.image.height * 4 : 0;
    }
  return { resource: n7, textures: s8, size: a5 + e6(n7) };
}
async function A3(r11, n7) {
  const s8 = null != n7 && n7.streamDataRequester;
  if (s8)
    return j3(r11, s8, n7);
  const a5 = await _(j(r11, n7));
  if (true === a5.ok)
    return a5.value.data;
  f(a5.error), M(a5.error);
}
async function j3(e11, r11, n7) {
  const s8 = await _(r11.request(e11, "json", n7));
  if (true === s8.ok)
    return s8.value;
  f(s8.error), M(s8.error.details.url);
}
function M(e11) {
  throw new s2("", `Request for object resource failed: ${e11}`);
}
function P4(e11) {
  const t11 = e11.params, r11 = t11.topology;
  let n7 = true;
  switch (t11.vertexAttributes || (h6.warn("Geometry must specify vertex attributes"), n7 = false), t11.topology) {
    case "PerAttributeArray":
      break;
    case "Indexed":
    case null:
    case void 0: {
      const e12 = t11.faces;
      if (e12) {
        if (t11.vertexAttributes)
          for (const r12 in t11.vertexAttributes) {
            const t12 = e12[r12];
            t12 && t12.values ? (null != t12.valueType && "UInt32" !== t12.valueType && (h6.warn(`Unsupported indexed geometry indices type '${t12.valueType}', only UInt32 is currently supported`), n7 = false), null != t12.valuesPerElement && 1 !== t12.valuesPerElement && (h6.warn(`Unsupported indexed geometry values per element '${t12.valuesPerElement}', only 1 is currently supported`), n7 = false)) : (h6.warn(`Indexed geometry does not specify face indices for '${r12}' attribute`), n7 = false);
          }
      } else
        h6.warn("Indexed geometries must specify faces"), n7 = false;
      break;
    }
    default:
      h6.warn(`Unsupported topology '${r11}'`), n7 = false;
  }
  e11.params.material || (h6.warn("Geometry requires material"), n7 = false);
  const s8 = e11.params.vertexAttributes;
  for (const a5 in s8) {
    s8[a5].values || (h6.warn("Geometries with externally defined attributes are not yet supported"), n7 = false);
  }
  return n7;
}
function I3(e11, t11) {
  var _a;
  const r11 = new Array(), n7 = new Array(), s8 = new Array(), o8 = new t6(), u4 = e11.resource, c6 = r3.parse(u4.version || "1.0", "wosr");
  O4.validate(c6);
  const p = u4.model.name, d3 = u4.model.geometries, x2 = u4.materialDefinitions ?? {}, h7 = e11.textures;
  let v3 = 0;
  const A4 = /* @__PURE__ */ new Map();
  for (let a5 = 0; a5 < d3.length; a5++) {
    const e12 = d3[a5];
    if (!P4(e12))
      continue;
    const i8 = k2(e12), u5 = e12.params.vertexAttributes, c7 = [];
    for (const t12 in u5) {
      const e13 = u5[t12], r12 = e13.values;
      c7.push([t12, new s4(r12, e13.valuesPerElement, true)]);
    }
    const p2 = [];
    if ("PerAttributeArray" !== e12.params.topology) {
      const t12 = e12.params.faces;
      for (const e13 in t12)
        p2.push([e13, t12[e13].values]);
    }
    const j4 = i8.texture, M2 = h7 && h7[j4];
    if (M2 && !A4.has(j4)) {
      const { image: e13, parameters: t12 } = M2, r12 = new w(e13, t12);
      n7.push(r12), A4.set(j4, r12);
    }
    const I4 = A4.get(j4), U2 = I4 ? I4.id : void 0, T2 = i8.material;
    let O5 = o8.get(T2, j4);
    if (null == O5) {
      const e13 = x2[T2.substring(T2.lastIndexOf("/") + 1)].params;
      1 === e13.transparency && (e13.transparency = 0);
      const r12 = M2 && M2.alphaChannelUsage, n8 = e13.transparency > 0 || "transparency" === r12 || "maskAndTransparency" === r12, s9 = M2 ? E5(M2.alphaChannelUsage) : void 0, a6 = { ambient: e2(e13.diffuse), diffuse: e2(e13.diffuse), opacity: 1 - (e13.transparency || 0), transparent: n8, textureAlphaMode: s9, textureAlphaCutoff: 0.33, textureId: U2, initTextureTransparent: true, doubleSided: true, cullFace: n5.None, colorMixMode: e13.externalColorMixMode || "tint", textureAlphaPremultiplied: (M2 == null ? void 0 : M2.parameters.preMultiplyAlpha) ?? false };
      null != t11 && t11.materialParamsMixin && Object.assign(a6, t11.materialParamsMixin), O5 = new I2(a6), o8.set(T2, j4, O5);
    }
    s8.push(O5);
    const q2 = new b(O5, c7, p2);
    v3 += ((_a = p2.find((e13) => e13[0] === O3.POSITION)) == null ? void 0 : _a[1].length) ?? 0, r11.push(q2);
  }
  return { engineResources: [{ name: p, stageResources: { textures: n7, materials: s8, geometries: r11 }, pivotOffset: u4.model.pivotOffset, numberOfVertices: v3, lodThreshold: null }], referenceBoundingBox: U(r11) };
}
function U(e11) {
  const t11 = P2();
  return e11.forEach((e12) => {
    const r11 = e12.boundingInfo;
    null != r11 && (h(t11, r11.bbMin), h(t11, r11.bbMax));
  }), t11;
}
async function T(e11, t11) {
  const r11 = new Array();
  for (const a5 in e11) {
    const n8 = e11[a5], s9 = n8.images[0].data;
    if (!s9) {
      h6.warn("Externally referenced texture data is not yet supported");
      continue;
    }
    const o8 = n8.encoding + ";base64," + s9, i8 = "/textureDefinitions/" + a5, l4 = "rgba" === n8.channels ? n8.alphaChannelUsage || "transparency" : "none", u4 = { noUnpackFlip: true, wrap: { s: D.REPEAT, t: D.REPEAT }, preMultiplyAlpha: E5(l4) !== i5.Opaque }, c6 = null != t11 && t11.disableTextures ? Promise.resolve(null) : t7(o8, t11);
    r11.push(c6.then((e12) => ({ refId: i8, image: e12, parameters: u4, alphaChannelUsage: l4 })));
  }
  const n7 = await Promise.all(r11), s8 = {};
  for (const a5 of n7)
    s8[a5.refId] = a5;
  return s8;
}
function E5(e11) {
  switch (e11) {
    case "mask":
      return i5.Mask;
    case "maskAndTransparency":
      return i5.MaskBlend;
    case "none":
      return i5.Opaque;
    default:
      return i5.Blend;
  }
}
function k2(e11) {
  const t11 = e11.params;
  return { id: 1, material: t11.material, texture: t11.texture, region: t11.texture };
}
var O4 = new r3(1, 2, "wosr");

// node_modules/@arcgis/core/views/3d/layers/graphics/objectResourceUtils.js
async function X(t11, r11) {
  var _a;
  const o8 = Y(a(t11));
  if ("wosr" === o8.fileType) {
    const e11 = await (r11.cache ? r11.cache.loadWOSR(o8.url, r11) : v2(o8.url, r11)), { engineResources: t12, referenceBoundingBox: s9 } = I3(e11, r11);
    return { lods: t12, referenceBoundingBox: s9, isEsriSymbolResource: false, isWosr: true };
  }
  const s8 = await (r11.cache ? r11.cache.loadGLTF(o8.url, r11, !!r11.usePBR) : l(new n4(r11.streamDataRequester), o8.url, r11, r11.usePBR)), i8 = (_a = s8.model.meta) == null ? void 0 : _a.ESRI_proxyEllipsoid, n7 = s8.meta.isEsriSymbolResource && null != i8 && s8.meta.uri.includes("/RealisticTrees/");
  n7 && !s8.customMeta.esriTreeRendering && (s8.customMeta.esriTreeRendering = true, se(s8, i8));
  const l4 = !!r11.usePBR, u4 = s8.meta.isEsriSymbolResource ? { usePBR: l4, isSchematic: false, treeRendering: n7, mrrFactors: [...s7] } : { usePBR: l4, isSchematic: false, treeRendering: false, mrrFactors: [...n6] }, a5 = { ...r11.materialParamsMixin, treeRendering: n7 }, { engineResources: c6, referenceBoundingBox: m } = Z2(s8, u4, a5, r11.skipHighLods && null == o8.specifiedLodIndex ? { skipHighLods: true } : { skipHighLods: false, singleLodIndex: o8.specifiedLodIndex });
  return { lods: c6, referenceBoundingBox: m, isEsriSymbolResource: s8.meta.isEsriSymbolResource, isWosr: false };
}
function Y(e11) {
  const t11 = e11.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/);
  if (t11)
    return { fileType: "gltf", url: t11[1], specifiedLodIndex: null != t11[4] ? Number(t11[4]) : null };
  return e11.match(/(.*\.(json|json\.gz))$/) ? { fileType: "wosr", url: e11, specifiedLodIndex: null } : { fileType: "unknown", url: e11, specifiedLodIndex: null };
}
function Z2(e11, t11, r11, o8) {
  const s8 = e11.model, i8 = new Array(), n7 = /* @__PURE__ */ new Map(), l4 = /* @__PURE__ */ new Map(), u4 = s8.lods.length, a5 = P2();
  return s8.lods.forEach((e12, c6) => {
    const m = true === o8.skipHighLods && (u4 > 1 && 0 === c6 || u4 > 3 && 1 === c6) || false === o8.skipHighLods && null != o8.singleLodIndex && c6 !== o8.singleLodIndex;
    if (m && 0 !== c6)
      return;
    const f6 = new t9(e12.name, e12.lodThreshold, [0, 0, 0]);
    e12.parts.forEach((e13) => {
      const o9 = m ? new I2({}) : ee(s8, e13, f6, t11, r11, n7, l4), { geometry: i9, vertexCount: u5 } = te(e13, null != o9 ? o9 : new I2({})), p = i9.boundingInfo;
      null != p && 0 === c6 && (h(a5, p.bbMin), h(a5, p.bbMax)), null != o9 && (f6.stageResources.geometries.push(i9), f6.numberOfVertices += u5);
    }), m || i8.push(f6);
  }), { engineResources: i8, referenceBoundingBox: a5 };
}
function ee(e11, t11, r11, o8, s8, i8, n7) {
  const l4 = t11.material + (t11.attributes.normal ? "_normal" : "") + (t11.attributes.color ? "_color" : "") + (t11.attributes.texCoord0 ? "_texCoord0" : "") + (t11.attributes.tangent ? "_tangent" : ""), u4 = e11.materials.get(t11.material), a5 = null != t11.attributes.texCoord0, c6 = null != t11.attributes.normal;
  if (null == u4)
    return null;
  const m = oe(u4.alphaMode);
  if (!i8.has(l4)) {
    if (a5) {
      const t12 = (t13, r13 = false) => {
        if (null != t13 && !n7.has(t13)) {
          const o9 = e11.textures.get(t13);
          if (null != o9) {
            const e12 = o9.data;
            n7.set(t13, new w(t3(e12) ? e12.data : e12, { ...o9.parameters, preMultiplyAlpha: !t3(e12) && r13, encoding: t3(e12) && null != e12.encoding ? e12.encoding : void 0 }));
          }
        }
      };
      t12(u4.textureColor, m !== i5.Opaque), t12(u4.textureNormal), t12(u4.textureOcclusion), t12(u4.textureEmissive), t12(u4.textureMetallicRoughness);
    }
    const r12 = u4.color[0] ** (1 / o3), f7 = u4.color[1] ** (1 / o3), d3 = u4.color[2] ** (1 / o3), p = u4.emissiveFactor[0] ** (1 / o3), g3 = u4.emissiveFactor[1] ** (1 / o3), x2 = u4.emissiveFactor[2] ** (1 / o3), b2 = null != u4.textureColor && a5 ? n7.get(u4.textureColor) : null, h7 = u3({ normalTexture: u4.textureNormal, metallicRoughnessTexture: u4.textureMetallicRoughness, metallicFactor: u4.metallicFactor, roughnessFactor: u4.roughnessFactor, emissiveTexture: u4.textureEmissive, emissiveFactor: u4.emissiveFactor, occlusionTexture: u4.textureOcclusion });
    i8.set(l4, new I2({ ...o8, transparent: m === i5.Blend, customDepthTest: e7.Lequal, textureAlphaMode: m, textureAlphaCutoff: u4.alphaCutoff, diffuse: [r12, f7, d3], ambient: [r12, f7, d3], opacity: u4.opacity, doubleSided: u4.doubleSided, doubleSidedType: "winding-order", cullFace: u4.doubleSided ? n5.None : n5.Back, hasVertexColors: !!t11.attributes.color, hasVertexTangents: !!t11.attributes.tangent, normalType: c6 ? a2.Attribute : a2.ScreenDerivative, castShadows: true, receiveSSAO: true, textureId: null != b2 ? b2.id : void 0, colorMixMode: u4.colorMixMode, normalTextureId: null != u4.textureNormal && a5 ? n7.get(u4.textureNormal).id : void 0, textureAlphaPremultiplied: null != b2 && !!b2.parameters.preMultiplyAlpha, occlusionTextureId: null != u4.textureOcclusion && a5 ? n7.get(u4.textureOcclusion).id : void 0, emissiveTextureId: null != u4.textureEmissive && a5 ? n7.get(u4.textureEmissive).id : void 0, metallicRoughnessTextureId: null != u4.textureMetallicRoughness && a5 ? n7.get(u4.textureMetallicRoughness).id : void 0, emissiveFactor: [p, g3, x2], mrrFactors: h7 ? [...r10] : [u4.metallicFactor, u4.roughnessFactor, o8.mrrFactors[2]], isSchematic: h7, colorTextureTransformMatrix: r9(u4.colorTextureTransform), normalTextureTransformMatrix: r9(u4.normalTextureTransform), occlusionTextureTransformMatrix: r9(u4.occlusionTextureTransform), emissiveTextureTransformMatrix: r9(u4.emissiveTextureTransform), metallicRoughnessTextureTransformMatrix: r9(u4.metallicRoughnessTextureTransform), ...s8 }));
  }
  const f6 = i8.get(l4);
  if (r11.stageResources.materials.push(f6), a5) {
    const e12 = (e13) => {
      null != e13 && r11.stageResources.textures.push(n7.get(e13));
    };
    e12(u4.textureColor), e12(u4.textureNormal), e12(u4.textureOcclusion), e12(u4.textureEmissive), e12(u4.textureMetallicRoughness);
  }
  return f6;
}
function te(e11, r11) {
  const o8 = e11.attributes.position.count, s8 = o2(e11.indices || o8, e11.primitiveType), i8 = t4(3 * o8), { typedBuffer: n7, typedBufferStride: l4 } = e11.attributes.position;
  r5(i8, n7, e11.transform, 3, l4);
  const u4 = [[O3.POSITION, new s4(i8, 3, true)]], a5 = [[O3.POSITION, s8]];
  if (null != e11.attributes.normal) {
    const r12 = t4(3 * o8), { typedBuffer: i9, typedBufferStride: n8 } = e11.attributes.normal;
    g2(re, e11.transform), n2(r12, i9, re, 3, n8), u4.push([O3.NORMAL, new s4(r12, 3, true)]), a5.push([O3.NORMAL, s8]);
  }
  if (null != e11.attributes.tangent) {
    const r12 = t4(4 * o8), { typedBuffer: i9, typedBufferStride: n8 } = e11.attributes.tangent;
    g2(re, e11.transform), f3(r12, i9, re, 4, n8), u4.push([O3.TANGENT, new s4(r12, 4, true)]), a5.push([O3.TANGENT, s8]);
  }
  if (null != e11.attributes.texCoord0) {
    const t11 = t4(2 * o8), { typedBuffer: r12, typedBufferStride: i9 } = e11.attributes.texCoord0;
    n3(t11, r12, 2, i9), u4.push([O3.UV0, new s4(t11, 2, true)]), a5.push([O3.UV0, s8]);
  }
  if (null != e11.attributes.color) {
    const t11 = new Uint8Array(4 * o8);
    4 === e11.attributes.color.elementCount ? e11.attributes.color instanceof c ? u2(t11, e11.attributes.color, 255) : e11.attributes.color instanceof x ? t2(t11, e11.attributes.color) : e11.attributes.color instanceof L && u2(t11, e11.attributes.color, 1 / 256) : (t11.fill(255), e11.attributes.color instanceof i2 ? u(t11, e11.attributes.color, 255, 4) : e11.attributes.color instanceof O2 ? t(t11, e11.attributes.color.typedBuffer, 4, e11.attributes.color.typedBufferStride) : e11.attributes.color instanceof E && u(t11, e11.attributes.color, 1 / 256, 4)), u4.push([O3.COLOR, new s4(t11, 4, true)]), a5.push([O3.COLOR, s8]);
  }
  return { geometry: new b(r11, u4, a5), vertexCount: o8 };
}
var re = e4();
function oe(e11) {
  switch (e11) {
    case "BLEND":
      return i5.Blend;
    case "MASK":
      return i5.Mask;
    case "OPAQUE":
    case null:
    case void 0:
      return i5.Opaque;
  }
}
function se(e11, t11) {
  for (let r11 = 0; r11 < e11.model.lods.length; ++r11) {
    const f6 = e11.model.lods[r11];
    for (const d3 of f6.parts) {
      const f7 = d3.attributes.normal;
      if (null == f7)
        return;
      const p = d3.attributes.position, g3 = p.count, b2 = n(), T2 = n(), y = n(), R2 = new Uint8Array(4 * g3), w2 = new Float64Array(3 * g3), v3 = h2(e5(), d3.transform);
      let M2 = 0, j4 = 0;
      for (let o8 = 0; o8 < g3; o8++) {
        p.getVec(o8, T2), f7.getVec(o8, b2), O(T2, T2, d3.transform), e3(y, T2, t11.center), i(y, y, t11.radius);
        const s8 = y[2], m = s3(y), g4 = Math.min(0.45 + 0.55 * m * m, 1);
        i(y, y, t11.radius), null !== v3 && O(y, y, v3), z(y, y), r11 + 1 !== e11.model.lods.length && e11.model.lods.length > 1 && A(y, y, b2, s8 > -1 ? 0.2 : Math.min(-4 * s8 - 3.8, 1)), w2[M2] = y[0], w2[M2 + 1] = y[1], w2[M2 + 2] = y[2], M2 += 3, R2[j4] = 255 * g4, R2[j4 + 1] = 255 * g4, R2[j4 + 2] = 255 * g4, R2[j4 + 3] = 255, j4 += 4;
      }
      d3.attributes.normal = new i2(w2), d3.attributes.color = new x(R2);
    }
  }
}

export {
  r9 as r,
  u3 as u,
  n6 as n,
  r10 as r2,
  N,
  I2 as I,
  v2 as v,
  X,
  Y,
  Z2 as Z
};
//# sourceMappingURL=chunk-AN3WFAN2.js.map
