import {
  P
} from "./chunk-3LLZ72VA.js";
import {
  i
} from "./chunk-SGBMUZSF.js";
import {
  V,
  _,
  k2 as k,
  p as p2,
  q,
  z
} from "./chunk-LEDSC236.js";
import {
  A,
  g,
  p,
  r as r2,
  u
} from "./chunk-TPJLFGOT.js";
import {
  n,
  r
} from "./chunk-CQX57DED.js";
import {
  l
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-3R7FAT25.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Octree.js
var b = class _b {
  get bounds() {
    return this._root.bounds;
  }
  get halfSize() {
    return this._root.halfSize;
  }
  get root() {
    return this._root.node;
  }
  get maximumObjectsPerNode() {
    return this._maximumObjectsPerNode;
  }
  get maximumDepth() {
    return this._maximumDepth;
  }
  get objectCount() {
    return this._objectCount;
  }
  constructor(e2, t) {
    this.objectToBoundingSphere = e2, this._maximumObjectsPerNode = 10, this._maximumDepth = 20, this._degenerateObjects = /* @__PURE__ */ new Set(), this._root = new g2(), this._objectCount = 0, t && (void 0 !== t.maximumObjectsPerNode && (this._maximumObjectsPerNode = t.maximumObjectsPerNode), void 0 !== t.maximumDepth && (this._maximumDepth = t.maximumDepth));
  }
  destroy() {
    this._degenerateObjects.clear(), g2.clearPool(), B[0] = null, P2.prune(), H.prune();
  }
  add(e2, t = e2.length) {
    this._objectCount += t, this._grow(e2, t);
    const o = g2.acquire();
    for (let n2 = 0; n2 < t; n2++) {
      const t2 = e2[n2];
      this._isDegenerate(t2) ? this._degenerateObjects.add(t2) : (o.init(this._root), this._add(t2, o));
    }
    g2.release(o);
  }
  remove(e2, t = null) {
    this._objectCount -= e2.length;
    const o = g2.acquire();
    for (const n2 of e2) {
      const e3 = null != t ? t : q(this.objectToBoundingSphere(n2), w);
      E(e3[3]) ? (o.init(this._root), this._remove(n2, e3, o)) : this._degenerateObjects.delete(n2);
    }
    g2.release(o), this._shrink();
  }
  update(e2, t) {
    if (!E(t[3]) && this._isDegenerate(e2))
      return;
    const o = R(e2);
    this.remove(o, t), this.add(o);
  }
  forEachAlongRay(e2, t, o) {
    const n2 = p2(e2, t);
    this._forEachNode(this._root, (e3) => {
      if (!this._intersectsNode(n2, e3))
        return false;
      const t2 = e3.node;
      return t2.terminals.forAll((e4) => {
        this._intersectsObject(n2, e4) && o(e4);
      }), null !== t2.residents && t2.residents.forAll((e4) => {
        this._intersectsObject(n2, e4) && o(e4);
      }), true;
    });
  }
  forEachAlongRayWithVerticalOffset(e2, t, o, n2) {
    const i2 = p2(e2, t);
    this._forEachNode(this._root, (e3) => {
      if (!this._intersectsNodeWithOffset(i2, e3, n2))
        return false;
      const t2 = e3.node;
      return t2.terminals.forAll((e4) => {
        this._intersectsObjectWithOffset(i2, e4, n2) && o(e4);
      }), null !== t2.residents && t2.residents.forAll((e4) => {
        this._intersectsObjectWithOffset(i2, e4, n2) && o(e4);
      }), true;
    });
  }
  forEach(e2) {
    this._forEachNode(this._root, (t) => {
      const o = t.node;
      return o.terminals.forAll(e2), null !== o.residents && o.residents.forAll(e2), true;
    }), this._degenerateObjects.forEach(e2);
  }
  forEachDegenerateObject(e2) {
    this._degenerateObjects.forEach(e2);
  }
  findClosest(e2, t, i2, s = () => true, r3 = 1 / 0) {
    let h = 1 / 0, a = 1 / 0, l2 = null;
    const u2 = T(e2, t), c = (o) => {
      if (--r3, !s(o))
        return;
      const n2 = this.objectToBoundingSphere(o);
      if (!P(i2, n2))
        return;
      const u3 = z2(e2, t, z(n2)), c2 = u3 - n2[3], m = u3 + n2[3];
      c2 < h && (h = c2, a = m, l2 = o);
    };
    return this._forEachNodeDepthOrdered(this._root, (s2) => {
      if (r3 <= 0 || !P(i2, s2.bounds))
        return false;
      g(v, u2, s2.halfSize), u(v, v, s2.bounds);
      if (z2(e2, t, v) > a)
        return false;
      const h2 = s2.node;
      return h2.terminals.forAll((e3) => c(e3)), null !== h2.residents && h2.residents.forAll((e3) => c(e3)), true;
    }, e2, t), l2;
  }
  forEachInDepthRange(e2, t, i2, s, r3, h, a) {
    let l2 = -1 / 0, u2 = 1 / 0;
    const c = { setRange: (e3) => {
      i2 === _b.DepthOrder.FRONT_TO_BACK ? (l2 = Math.max(l2, e3.near), u2 = Math.min(u2, e3.far)) : (l2 = Math.max(l2, -e3.far), u2 = Math.min(u2, -e3.near));
    } };
    c.setRange(s);
    const m = z2(t, i2, e2), _2 = T(t, i2), p3 = T(t, -i2), g3 = (e3) => {
      if (!a(e3))
        return;
      const o = this.objectToBoundingSphere(e3), n2 = z(o), s2 = z2(t, i2, n2) - m, _3 = s2 - o[3], p4 = s2 + o[3];
      _3 > u2 || p4 < l2 || !P(h, o) || r3(e3, c);
    };
    this._forEachNodeDepthOrdered(this._root, (e3) => {
      if (!P(h, e3.bounds))
        return false;
      g(v, _2, e3.halfSize), u(v, v, e3.bounds);
      if (z2(t, i2, v) - m > u2)
        return false;
      g(v, p3, e3.halfSize), u(v, v, e3.bounds);
      if (z2(t, i2, v) - m < l2)
        return false;
      const s2 = e3.node;
      return s2.terminals.forAll((e4) => g3(e4)), null !== s2.residents && s2.residents.forAll((e4) => g3(e4)), true;
    }, t, i2);
  }
  forEachNode(e2) {
    this._forEachNode(this._root, (t) => e2(t.node, t.bounds, t.halfSize, t.depth));
  }
  forEachNeighbor(e2, t) {
    const o = k(t), n2 = z(t), s = (t2) => {
      const s2 = this.objectToBoundingSphere(t2), r4 = k(s2), h2 = o + r4;
      return !(p(z(s2), n2) - h2 * h2 <= 0) || e2(t2);
    };
    let r3 = true;
    const h = (e3) => {
      r3 && (r3 = s(e3));
    };
    this._forEachNode(this._root, (e3) => {
      const t2 = k(e3.bounds), s2 = o + t2;
      if (p(z(e3.bounds), n2) - s2 * s2 > 0)
        return false;
      const a = e3.node;
      return a.terminals.forAll(h), r3 && null !== a.residents && a.residents.forAll(h), r3;
    }), r3 && this.forEachDegenerateObject(h);
  }
  _intersectsNode(e2, t) {
    return j(t.bounds, 2 * -t.halfSize, C), j(t.bounds, 2 * t.halfSize, y), i(e2.origin, e2.direction, C, y);
  }
  _intersectsNodeWithOffset(e2, t, o) {
    return j(t.bounds, 2 * -t.halfSize, C), j(t.bounds, 2 * t.halfSize, y), o.applyToMinMax(C, y), i(e2.origin, e2.direction, C, y);
  }
  _intersectsObject(e2, t) {
    const o = this.objectToBoundingSphere(t);
    return !(o[3] > 0) || V(o, e2);
  }
  _intersectsObjectWithOffset(e2, t, o) {
    const n2 = this.objectToBoundingSphere(t);
    return !(n2[3] > 0) || V(o.applyToBoundingSphere(n2), e2);
  }
  _forEachNode(e2, t) {
    let o = g2.acquire().init(e2);
    const n2 = [o];
    for (; 0 !== n2.length; ) {
      if (o = n2.pop(), t(o) && !o.isLeaf())
        for (let e3 = 0; e3 < o.node.children.length; e3++) {
          o.node.children[e3] && n2.push(g2.acquire().init(o).advance(e3));
        }
      g2.release(o);
    }
  }
  _forEachNodeDepthOrdered(e2, t, o, n2 = _b.DepthOrder.FRONT_TO_BACK) {
    let i2 = g2.acquire().init(e2);
    const s = [i2];
    for (N(o, n2, K); 0 !== s.length; ) {
      if (i2 = s.pop(), t(i2) && !i2.isLeaf())
        for (let e3 = 7; e3 >= 0; --e3) {
          const t2 = K[e3];
          i2.node.children[t2] && s.push(g2.acquire().init(i2).advance(t2));
        }
      g2.release(i2);
    }
  }
  _remove(e2, t, o) {
    P2.clear();
    const n2 = o.advanceTo(t, (e3, t2) => {
      P2.push(e3.node), P2.push(t2);
    }) ? o.node.terminals : o.node.residents;
    if (n2.removeUnordered(e2), 0 === n2.length)
      for (let i2 = P2.length - 2; i2 >= 0; i2 -= 2) {
        const e3 = P2.data[i2], t2 = P2.data[i2 + 1];
        if (!this._purge(e3, t2))
          break;
      }
  }
  _nodeIsEmpty(e2) {
    if (0 !== e2.terminals.length)
      return false;
    if (null !== e2.residents)
      return 0 === e2.residents.length;
    for (let t = 0; t < e2.children.length; t++)
      if (e2.children[t])
        return false;
    return true;
  }
  _purge(e2, o) {
    return o >= 0 && (e2.children[o] = null), !!this._nodeIsEmpty(e2) && (null === e2.residents && (e2.residents = new l({ shrink: true })), true);
  }
  _add(e2, t) {
    t.advanceTo(this.objectToBoundingSphere(e2)) ? t.node.terminals.push(e2) : (t.node.residents.push(e2), t.node.residents.length > this._maximumObjectsPerNode && t.depth < this._maximumDepth && this._split(t));
  }
  _split(e2) {
    const t = e2.node.residents;
    e2.node.residents = null;
    for (let o = 0; o < t.length; o++) {
      const n2 = g2.acquire().init(e2);
      this._add(t.at(o), n2), g2.release(n2);
    }
  }
  _grow(e2, t) {
    if (0 !== t && (x(e2, t, (e3) => this.objectToBoundingSphere(e3), k2), E(k2[3]) && !this._fitsInsideTree(k2)))
      if (this._nodeIsEmpty(this._root.node))
        q(k2, this._root.bounds), this._root.halfSize = 1.25 * this._root.bounds[3], this._root.updateBoundsRadiusFromHalfSize();
      else {
        const e3 = this._rootBoundsForRootAsSubNode(k2);
        this._placingRootViolatesMaxDepth(e3) ? this._rebuildTree(k2, e3) : this._growRootAsSubNode(e3), g2.release(e3);
      }
  }
  _rebuildTree(e2, t) {
    r2(q2, t.bounds), q2[3] = t.halfSize, x([e2, q2], 2, (e3) => e3, I);
    const o = g2.acquire().init(this._root);
    this._root.initFrom(null, I, I[3]), this._root.increaseHalfSize(1.25), this._forEachNode(o, (e3) => (this.add(e3.node.terminals.data, e3.node.terminals.length), null !== e3.node.residents && this.add(e3.node.residents.data, e3.node.residents.length), true)), g2.release(o);
  }
  _placingRootViolatesMaxDepth(e2) {
    const t = Math.log(e2.halfSize / this._root.halfSize) * Math.LOG2E;
    let o = 0;
    return this._forEachNode(this._root, (e3) => (o = Math.max(o, e3.depth), o + t <= this._maximumDepth)), o + t > this._maximumDepth;
  }
  _rootBoundsForRootAsSubNode(e2) {
    const t = e2[3], o = e2;
    let n2 = -1 / 0;
    const i2 = this._root.bounds, s = this._root.halfSize;
    for (let h = 0; h < 3; h++) {
      const e3 = i2[h] - s - (o[h] - t), r4 = o[h] + t - (i2[h] + s), a = Math.max(0, Math.ceil(e3 / (2 * s))), d = Math.max(0, Math.ceil(r4 / (2 * s))) + 1, l2 = 2 ** Math.ceil(Math.log(a + d) * Math.LOG2E);
      n2 = Math.max(n2, l2), L[h].min = a, L[h].max = d;
    }
    for (let h = 0; h < 3; h++) {
      let e3 = L[h].min, t2 = L[h].max;
      const o2 = (n2 - (e3 + t2)) / 2;
      e3 += Math.ceil(o2), t2 += Math.floor(o2);
      const r4 = i2[h] - s - e3 * s * 2;
      F[h] = r4 + (t2 + e3) * s;
    }
    const r3 = n2 * s;
    return F[3] = r3 * A2, g2.acquire().initFrom(null, F, r3, 0);
  }
  _growRootAsSubNode(e2) {
    const t = this._root.node;
    r2(k2, this._root.bounds), k2[3] = this._root.halfSize, this._root.init(e2), e2.advanceTo(k2, null, true), e2.node.children = t.children, e2.node.residents = t.residents, e2.node.terminals = t.terminals;
  }
  _shrink() {
    for (; ; ) {
      const e2 = this._findShrinkIndex();
      if (-1 === e2)
        break;
      this._root.advance(e2), this._root.depth = 0;
    }
  }
  _findShrinkIndex() {
    if (0 !== this._root.node.terminals.length || this._root.isLeaf())
      return -1;
    let e2 = null;
    const t = this._root.node.children;
    let o = 0, n2 = 0;
    for (; n2 < t.length && null == e2; )
      o = n2++, e2 = t[o];
    for (; n2 < t.length; )
      if (t[n2++])
        return -1;
    return o;
  }
  _isDegenerate(e2) {
    return !E(this.objectToBoundingSphere(e2)[3]);
  }
  _fitsInsideTree(e2) {
    const t = this._root.bounds, o = this._root.halfSize;
    return e2[3] <= o && e2[0] >= t[0] - o && e2[0] <= t[0] + o && e2[1] >= t[1] - o && e2[1] <= t[1] + o && e2[2] >= t[2] - o && e2[2] <= t[2] + o;
  }
  toJSON() {
    const { maximumDepth: e2, maximumObjectsPerNode: t, _objectCount: o } = this, n2 = this._nodeToJSON(this._root.node);
    return { maximumDepth: e2, maximumObjectsPerNode: t, objectCount: o, root: { bounds: this._root.bounds, halfSize: this._root.halfSize, depth: this._root.depth, node: n2 } };
  }
  _nodeToJSON(e2) {
    var _a, _b2;
    const t = e2.children.map((e3) => e3 ? this._nodeToJSON(e3) : null), o = (_a = e2.residents) == null ? void 0 : _a.map((e3) => this.objectToBoundingSphere(e3)), n2 = (_b2 = e2.terminals) == null ? void 0 : _b2.map((e3) => this.objectToBoundingSphere(e3));
    return { children: t, residents: o, terminals: n2 };
  }
  static fromJSON(e2) {
    const t = new _b((e3) => e3, { maximumDepth: e2.maximumDepth, maximumObjectsPerNode: e2.maximumObjectsPerNode });
    return t._objectCount = e2.objectCount, t._root.initFrom(e2.root.node, e2.root.bounds, e2.root.halfSize, e2.root.depth), t;
  }
};
var g2 = class _g {
  constructor() {
    this.bounds = _(), this.halfSize = 0, this.initFrom(null, null, 0, 0);
  }
  init(e2) {
    return this.initFrom(e2.node, e2.bounds, e2.halfSize, e2.depth);
  }
  initFrom(e2, t, o, n2 = this.depth) {
    return this.node = null != e2 ? e2 : _g.createEmptyNode(), null != t && q(t, this.bounds), this.halfSize = o, this.depth = n2, this;
  }
  increaseHalfSize(e2) {
    this.halfSize *= e2, this.updateBoundsRadiusFromHalfSize();
  }
  updateBoundsRadiusFromHalfSize() {
    this.bounds[3] = this.halfSize * A2;
  }
  advance(e2) {
    let t = this.node.children[e2];
    t || (t = _g.createEmptyNode(), this.node.children[e2] = t), this.node = t, this.halfSize /= 2, this.depth++;
    const o = M[e2];
    return this.bounds[0] += o[0] * this.halfSize, this.bounds[1] += o[1] * this.halfSize, this.bounds[2] += o[2] * this.halfSize, this.updateBoundsRadiusFromHalfSize(), this;
  }
  advanceTo(e2, t, o = false) {
    for (; ; ) {
      if (this.isTerminalFor(e2))
        return t && t(this, -1), true;
      if (this.isLeaf()) {
        if (!o)
          return t && t(this, -1), false;
        this.node.residents = null;
      }
      const n2 = this._childIndex(e2);
      t && t(this, n2), this.advance(n2);
    }
  }
  isLeaf() {
    return null != this.node.residents;
  }
  isTerminalFor(e2) {
    return e2[3] > this.halfSize / 2;
  }
  _childIndex(e2) {
    const t = this.bounds;
    return (t[0] < e2[0] ? 1 : 0) + (t[1] < e2[1] ? 2 : 0) + (t[2] < e2[2] ? 4 : 0);
  }
  static createEmptyNode() {
    return { children: [null, null, null, null, null, null, null, null], terminals: new l({ shrink: true }), residents: new l({ shrink: true }) };
  }
  static acquire() {
    return _g._pool.acquire();
  }
  static release(e2) {
    _g._pool.release(e2);
  }
  static clearPool() {
    _g._pool.prune();
  }
};
function S(e2, t) {
  e2[0] = Math.min(e2[0], t[0] - t[3]), e2[1] = Math.min(e2[1], t[1] - t[3]), e2[2] = Math.min(e2[2], t[2] - t[3]);
}
function O(e2, t) {
  e2[0] = Math.max(e2[0], t[0] + t[3]), e2[1] = Math.max(e2[1], t[1] + t[3]), e2[2] = Math.max(e2[2], t[2] + t[3]);
}
function j(e2, t, o) {
  o[0] = e2[0] + t, o[1] = e2[1] + t, o[2] = e2[2] + t;
}
function x(e2, t, o, n2) {
  if (1 === t) {
    const t2 = o(e2[0]);
    q(t2, n2);
  } else {
    C[0] = 1 / 0, C[1] = 1 / 0, C[2] = 1 / 0, y[0] = -1 / 0, y[1] = -1 / 0, y[2] = -1 / 0;
    for (let n3 = 0; n3 < t; n3++) {
      const t2 = o(e2[n3]);
      E(t2[3]) && (S(C, t2), O(y, t2));
    }
    A(n2, C, y, 0.5), n2[3] = Math.max(y[0] - C[0], y[1] - C[1], y[2] - C[2]) / 2;
  }
}
function N(e2, t, o) {
  if (!H.length)
    for (let n2 = 0; n2 < 8; ++n2)
      H.push({ index: 0, distance: 0 });
  for (let n2 = 0; n2 < 8; ++n2) {
    const o2 = M[n2];
    H.data[n2].index = n2, H.data[n2].distance = z2(e2, t, o2);
  }
  H.sort((e3, t2) => e3.distance - t2.distance);
  for (let n2 = 0; n2 < 8; ++n2)
    o[n2] = H.data[n2].index;
}
function T(e2, t) {
  let o, n2 = 1 / 0;
  for (let i2 = 0; i2 < 8; ++i2) {
    const s = z2(e2, t, D[i2]);
    s < n2 && (n2 = s, o = D[i2]);
  }
  return o;
}
function z2(e2, t, o) {
  return t * (e2[0] * o[0] + e2[1] * o[1] + e2[2] * o[2]);
}
function E(e2) {
  return !isNaN(e2) && e2 !== -1 / 0 && e2 !== 1 / 0 && e2 > 0;
}
g2._pool = new e(g2), function(e2) {
  var t;
  (t = e2.DepthOrder || (e2.DepthOrder = {}))[t.FRONT_TO_BACK = 1] = "FRONT_TO_BACK", t[t.BACK_TO_FRONT = -1] = "BACK_TO_FRONT";
}(b || (b = {}));
var M = [r(-1, -1, -1), r(1, -1, -1), r(-1, 1, -1), r(1, 1, -1), r(-1, -1, 1), r(1, -1, 1), r(-1, 1, 1), r(1, 1, 1)];
var D = [r(-1, -1, -1), r(-1, -1, 1), r(-1, 1, -1), r(-1, 1, 1), r(1, -1, -1), r(1, -1, 1), r(1, 1, -1), r(1, 1, 1)];
var A2 = Math.sqrt(3);
var B = [null];
function R(e2) {
  return B[0] = e2, B;
}
var F = _();
var v = n();
var C = n();
var y = n();
var P2 = new l();
var w = _();
var k2 = _();
var q2 = _();
var I = _();
var L = [{ min: 0, max: 0 }, { min: 0, max: 0 }, { min: 0, max: 0 }];
var H = new l();
var K = [0, 0, 0, 0, 0, 0, 0, 0];
var W = b;

export {
  W
};
//# sourceMappingURL=chunk-Z6R62RNV.js.map
