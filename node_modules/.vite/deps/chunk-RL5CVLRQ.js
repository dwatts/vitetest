import {
  g
} from "./chunk-JHDKOKT6.js";
import {
  i as i2,
  n as n4
} from "./chunk-LIO6VZRI.js";
import {
  h
} from "./chunk-73PNWDTS.js";
import {
  P,
  u
} from "./chunk-N3RXOITN.js";
import {
  o as o4
} from "./chunk-CR5XNTAP.js";
import {
  o as o3
} from "./chunk-Z6IKMUOC.js";
import {
  e as e2
} from "./chunk-PV5KBAYL.js";
import {
  o as o5
} from "./chunk-WA4HIOYR.js";
import {
  a
} from "./chunk-3I3GE5YW.js";
import {
  e as e3
} from "./chunk-WRFNQB7U.js";
import {
  i2 as i3
} from "./chunk-BO2REVMA.js";
import {
  n as n3,
  o as o2
} from "./chunk-V66LHQVK.js";
import {
  e
} from "./chunk-CW7LIPBH.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  r
} from "./chunk-NLWV7Q6F.js";
import {
  n as n2
} from "./chunk-SS3YG6J3.js";
import {
  c,
  q
} from "./chunk-7EG7BYWF.js";
import {
  i,
  v
} from "./chunk-AQ7R6V4L.js";
import {
  d
} from "./chunk-TEHNQYQD.js";
import {
  o
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";

// node_modules/@arcgis/core/chunks/PointRenderer.glsl.js
var y = class extends n3 {
  constructor() {
    super(...arguments), this.clipBox = i(v), this.useFixedSizes = false, this.useRealWorldSymbolSizes = false, this.scaleFactor = 1, this.minSizePx = 0, this.size = 0, this.sizePx = 0;
  }
  get fixedSize() {
    return this.drawScreenSpace ? this.sizePx : this.size;
  }
  get screenMinSize() {
    return this.useFixedSizes ? 0 : this.minSizePx;
  }
  get drawScreenSpace() {
    return this.useFixedSizes && !this.useRealWorldSymbolSizes;
  }
};
var O2 = class extends u {
  constructor(e4, i4, o6) {
    super(e4), this.origin = e4, this.isLeaf = i4, this.splatSize = o6;
  }
};
function R(r2) {
  const a2 = new i3(), n5 = r2.output === h.Color, c2 = r2.output === h.Depth, l = r2.output === h.Highlight, { vertex: f, fragment: x } = a2;
  return a2.include(P, r2), a2.attributes.add(O.POSITION, "vec3"), a2.attributes.add(O.COLOR, "vec3"), f.uniforms.add(new o4("modelView", (e4, r3) => c(B, r3.camera.viewMatrix, q(B, e4.origin))), new e2("proj", (e4, i4) => i4.camera.projectionMatrix), new o5("screenMinMaxSize", (e4, i4, o6) => r(L, o6.useFixedSizes ? 0 : o6.minSizePx * i4.camera.pixelRatio, F(e4.isLeaf) * i4.camera.pixelRatio)), r2.useFixedSizes ? new e3("pointScale", (e4, i4) => r(L, e4.fixedSize * i4.camera.pixelRatio, i4.camera.fullHeight)) : new o5("pointScale", (e4, i4, o6) => r(L, e4.splatSize * o6.scaleFactor * i4.camera.pixelRatio, i4.camera.fullHeight / i4.camera.pixelRatio))), r2.clippingEnabled ? f.uniforms.add(new o3("clipMin", (e4, i4, o6) => o(_, o6.clipBox[0] - e4.origin[0], o6.clipBox[1] - e4.origin[1], o6.clipBox[2] - e4.origin[2])), new o3("clipMax", (e4, i4, o6) => o(_, o6.clipBox[3] - e4.origin[0], o6.clipBox[4] - e4.origin[1], o6.clipBox[5] - e4.origin[2]))) : (f.constants.add("clipMin", "vec3", [-d, -d, -d]), f.constants.add("clipMax", "vec3", [d, d, d])), c2 ? (i2(a2), n4(a2), a2.varyings.add("depth", "float")) : r2.output !== h.Highlight && a2.varyings.add("vColor", "vec3"), f.code.add(o2`
    void main(void) {
      // Move clipped points outside of clipspace
      if (position.x < clipMin.x || position.y < clipMin.y || position.z < clipMin.z ||
        position.x > clipMax.x || position.y > clipMax.y || position.z > clipMax.z) {
        gl_Position = vec4(0.0,0.0,0.0,2.0);
        gl_PointSize = 0.0;
        return;
      }

      if (rejectBySlice(position)) {
        gl_Position = vec4(0.0,0.0,0.0,2.0);
        gl_PointSize = 0.0;
        return;
      }

      // Position in camera space
      vec4 camera = modelView * vec4(position, 1.0);

      float pointSize = pointScale.x;
      vec4 position = proj * camera;
     ${r2.drawScreenSize ? o2`
      float clampedScreenSize = pointSize;` : o2`
      float pointRadius = 0.5 * pointSize;
      vec4 cameraOffset = camera + vec4(0.0, pointRadius, 0.0, 0.0);
      vec4 positionOffset = proj * cameraOffset;
      float radius = abs(positionOffset.y - position.y);
      float viewHeight = pointScale.y;
      // screen diameter = (2 * r / w) * (h / 2)
      float screenPointSize = (radius / position.w) * viewHeight;
      float clampedScreenSize = clamp(screenPointSize, screenMinMaxSize.x, screenMinMaxSize.y);
      // Shift towards camera, to move rendered point out of terrain i.e. to
      // the camera-facing end of the virtual point when considering it as a
      // 3D sphere.
      camera.xyz -= normalize(camera.xyz) * pointRadius * clampedScreenSize / screenPointSize;
      position = proj * camera;`}

     gl_PointSize = clampedScreenSize;
     gl_Position = position;

     ${c2 ? o2`depth = calculateLinearDepth(nearFar, camera.z);` : ""}
     ${n5 ? o2`vColor = color;` : ""}
    }
  `), x.include(a, r2), l && a2.include(g, r2), x.code.add(o2`
    void main(void) {
      vec2 vOffset = gl_PointCoord - vec2(0.5, 0.5);
      float r2 = dot(vOffset, vOffset);

      if (r2 > 0.25) {
        discard;
      }
      ${c2 ? o2`fragColor = float2rgba(depth);` : ""}
      ${l ? o2`outputHighlight();` : ""}
      ${n5 ? o2`fragColor = vec4(vColor, 1.0);` : ""}
    }
  `), a2;
}
function F(e4) {
  return e4 ? 256 : 64;
}
var B = e();
var _ = n();
var L = n2();
var C = Object.freeze(Object.defineProperty({ __proto__: null, PointRendererDrawParameters: O2, PointRendererPassParameters: y, build: R, getMaxPointSizeScreenspace: F }, Symbol.toStringTag, { value: "Module" }));

export {
  y,
  O2 as O,
  R,
  F,
  C
};
//# sourceMappingURL=chunk-RL5CVLRQ.js.map
