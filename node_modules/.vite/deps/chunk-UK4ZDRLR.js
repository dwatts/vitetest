import {
  n as n9
} from "./chunk-ULFDJHIR.js";
import {
  f as f5,
  r as r4
} from "./chunk-PL4QGMLB.js";
import {
  Fe,
  l2 as l6,
  m as m6,
  m2 as m7,
  s as s8
} from "./chunk-HBJAGP7O.js";
import {
  a as a8
} from "./chunk-KSNS4RYW.js";
import {
  d as d8
} from "./chunk-MYPCEJEE.js";
import {
  l as l4
} from "./chunk-F6PJCZPH.js";
import {
  i as i2
} from "./chunk-ANLIVU2T.js";
import {
  o as o4
} from "./chunk-WON6TZX6.js";
import {
  m as m4
} from "./chunk-3BTM6YO4.js";
import {
  ee
} from "./chunk-CPHFVZ42.js";
import {
  x as x3
} from "./chunk-7FGF24AQ.js";
import {
  i as i4,
  l3 as l5,
  s as s7
} from "./chunk-YOWAMJJI.js";
import {
  F as F3,
  c as c9
} from "./chunk-CS6BZGQO.js";
import {
  _ as _4,
  ne
} from "./chunk-XXN3TEOU.js";
import {
  v as v3
} from "./chunk-TE7N6C3J.js";
import {
  E as E5,
  I as I4,
  a2 as a7,
  e as e9
} from "./chunk-UYTAZUBJ.js";
import {
  C
} from "./chunk-2EO2WRP7.js";
import {
  c as c8,
  t as t10
} from "./chunk-VYGC2LVC.js";
import {
  a2 as a6
} from "./chunk-CXYYGJUL.js";
import {
  r as r3
} from "./chunk-FJA4J75M.js";
import {
  b as b3,
  b2 as b4,
  d as d7
} from "./chunk-BDX5TRUE.js";
import {
  c as c7
} from "./chunk-LIXBKTBN.js";
import {
  E as E4
} from "./chunk-6LC2JTLC.js";
import {
  s as s6
} from "./chunk-XM3YSFN6.js";
import {
  x as x2
} from "./chunk-K4WBDIIJ.js";
import {
  f as f4
} from "./chunk-ROPKVK6V.js";
import {
  e as e8,
  i as i3,
  t as t8
} from "./chunk-V6CD66ZZ.js";
import {
  W,
  _ as _3,
  s as s5
} from "./chunk-6FHMQNMS.js";
import {
  r as r2
} from "./chunk-KFDARCTS.js";
import {
  T as T2,
  e2 as e7
} from "./chunk-TRGMWULG.js";
import {
  n as n7
} from "./chunk-WTPQKRQM.js";
import {
  c as c6,
  d2 as d6,
  e as e6,
  t as t9
} from "./chunk-SMDDCTGQ.js";
import {
  E as E3
} from "./chunk-NU4UASX6.js";
import {
  t as t7
} from "./chunk-FB4A6PBH.js";
import {
  h as h4
} from "./chunk-73PNWDTS.js";
import {
  N as N2
} from "./chunk-2EWAI4LP.js";
import {
  n as n8
} from "./chunk-V66LHQVK.js";
import {
  t as t6
} from "./chunk-JP7O2ZWE.js";
import {
  I as I3,
  M as M2,
  N,
  c as c5,
  k
} from "./chunk-2XKILFME.js";
import {
  c as c4,
  n as n6,
  t as t5
} from "./chunk-G4LSNP77.js";
import {
  L
} from "./chunk-IG234GCS.js";
import {
  t as t3
} from "./chunk-TDPKDZC3.js";
import {
  t as t4
} from "./chunk-M5UHI5WR.js";
import {
  H as H2
} from "./chunk-Z7LZRT7C.js";
import {
  D,
  E as E2,
  G,
  R as R3,
  T,
  U as U2,
  _ as _2
} from "./chunk-BCDDCNQ2.js";
import {
  s as s4
} from "./chunk-6S2FCH6S.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  d as d5
} from "./chunk-MRYR5ID7.js";
import {
  e as e5
} from "./chunk-XIYY37WZ.js";
import {
  d as d4
} from "./chunk-CEFGWR5H.js";
import {
  b as b2,
  m as m5
} from "./chunk-O443WBFA.js";
import {
  a as a4
} from "./chunk-Z3GCSCQI.js";
import {
  u as u3
} from "./chunk-UU2XJGLA.js";
import {
  F as F2,
  I as I2
} from "./chunk-KRCNIFX2.js";
import {
  b,
  r
} from "./chunk-NLWV7Q6F.js";
import {
  l as l3
} from "./chunk-RVS5HU2K.js";
import {
  n as n5
} from "./chunk-SS3YG6J3.js";
import {
  a as a5
} from "./chunk-H37COY3W.js";
import {
  d as d3
} from "./chunk-VMTVUE47.js";
import {
  c as c3
} from "./chunk-GDZM4A6K.js";
import {
  h as h5
} from "./chunk-XWGNMTES.js";
import {
  In
} from "./chunk-BNBT4QTW.js";
import {
  w as w2
} from "./chunk-W4KI5YEI.js";
import {
  S,
  h as h2,
  h2 as h3,
  z
} from "./chunk-JNDFAMXY.js";
import {
  u as u2
} from "./chunk-DOQ3SAAR.js";
import {
  se
} from "./chunk-4BXK4H4L.js";
import {
  n as n4
} from "./chunk-4CZO65BK.js";
import {
  _,
  d as d2
} from "./chunk-SVCGLUNW.js";
import {
  E
} from "./chunk-A6VKJXIH.js";
import {
  V
} from "./chunk-7EQSYZHW.js";
import {
  o as o3
} from "./chunk-HIPTG7BJ.js";
import {
  j as j2
} from "./chunk-4OR73Y2R.js";
import {
  H,
  I,
  R as R2,
  c as c2,
  e as e4,
  i,
  m as m2,
  o as o2,
  q,
  u
} from "./chunk-EKJ2DJIR.js";
import {
  n as n3
} from "./chunk-CQX57DED.js";
import {
  M
} from "./chunk-3VUFACNT.js";
import {
  g,
  x
} from "./chunk-ZEEBL7ZN.js";
import {
  U,
  a as a3,
  f as f3,
  h,
  j as j3,
  l as l2,
  w
} from "./chunk-H7RDAEPY.js";
import {
  m as m3
} from "./chunk-JL3TJGVW.js";
import {
  m,
  t2,
  v as v2,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2,
  e as e3
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  n as n2
} from "./chunk-3R7FAT25.js";
import {
  c,
  d,
  f as f2,
  j,
  s as s3,
  v
} from "./chunk-7I33FAWS.js";
import {
  e as e2,
  f,
  l,
  n,
  o,
  t
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import {
  a
} from "./chunk-IYZKKFJM.js";
import {
  F,
  R,
  has
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/QueryEngine.js
var y2 = ee;
var c10 = class extends m {
  get layer() {
    return this.context.layer;
  }
  get spatialReference() {
    return this.context.spatialReference;
  }
  get _queryGeometryType() {
    switch (this.layer.geometryType) {
      case "multipoint":
      case "point":
      case "polygon":
      case "polyline":
        return this.layer.geometryType;
      case "mesh":
        return "polygon";
      default:
        return;
    }
  }
  get defaultQueryJSON() {
    return new b2({ outSpatialReference: this.spatialReference }).toJSON();
  }
  get _dataQueryEngine() {
    return this._ensureDataQueryEngine();
  }
  constructor(e10) {
    super(e10), this._dataQueryEngineInstance = null;
  }
  destroy() {
    this.clear();
  }
  clear() {
    return !!this._dataQueryEngineInstance && (this._dataQueryEngineInstance.destroy(), this._dataQueryEngineInstance = null, true);
  }
  async executeQueryForIdSet(e10, t12, r6) {
    return this._dataQueryEngine.executeQueryForIdSet(this._ensureQueryJSON(e10, t12), r6);
  }
  async executeQueryForCount(e10, t12) {
    return this._dataQueryEngine.executeQueryForCount(this._ensureQueryJSON(e10), t12);
  }
  async executeQueryForExtent(e10, t12) {
    const { count: r6, extent: s10 } = await this._dataQueryEngine.executeQueryForExtent(this._ensureQueryJSON(e10), t12);
    return { count: r6, extent: M.fromJSON(s10) };
  }
  async executeQueryForIds(e10, t12) {
    return this._dataQueryEngine.executeQueryForIds(this._ensureQueryJSON(e10), t12);
  }
  async executeQueryForLatestObservations(e10, t12) {
    const r6 = await this._dataQueryEngine.executeQueryForLatestObservations(this._ensureQueryJSON(e10), t12), s10 = d4.fromJSON(r6);
    return s10.features.forEach((e11) => {
      e11.layer = this.layer, e11.sourceLayer = this.layer;
    }), s10;
  }
  async executeQuery(e10, t12) {
    const r6 = await this._dataQueryEngine.executeQuery(this._ensureQueryJSON(e10), t12), s10 = d4.fromJSON(r6);
    return s10.features.forEach((e11) => {
      e11.layer = this.layer, e11.sourceLayer = this.layer;
    }), s10;
  }
  _ensureQueryJSON(e10, t12) {
    let r6 = this.defaultQueryJSON;
    if (null != e10 && ("outSpatialReference" in e10 && !e10.outSpatialReference && (e10.outSpatialReference = this.spatialReference), r6 = e10.toJSON()), null != t12) {
      const e11 = t12.geometries.map((e12) => e12.toJSON()).reduce((e12, t13) => (e12.rings = e12.rings.concat(t13.rings), e12));
      r6 = { ...r6, sceneFilter: { ...t12, geometry: e11 } };
    }
    return r6;
  }
  _ensureDataQueryEngine() {
    var _a;
    if (this._dataQueryEngineInstance)
      return this._dataQueryEngineInstance;
    const e10 = "timeInfo" in this.layer && this.layer.timeInfo && this.layer.timeInfo.toJSON() || null, t12 = this.layer.objectIdField, r6 = o3.toJSON(this._queryGeometryType), s10 = ((_a = this.layer.fields) == null ? void 0 : _a.map((e11) => e11.toJSON())) ?? [], n11 = this.priority, a9 = this.spatialReference.toJSON(), { hasZ: o5, hasM: u4, featureStore: c12, scheduler: l9 } = this.context;
    return this._dataQueryEngineInstance = new y2({ hasZ: o5, hasM: u4, geometryType: r6, fields: s10, timeInfo: e10, spatialReference: a9, objectIdField: t12, featureStore: c12, scheduler: l9, priority: n11 }), this._dataQueryEngineInstance;
  }
};
e([y({ constructOnly: true })], c10.prototype, "context", void 0), e([y({ constructOnly: true })], c10.prototype, "priority", void 0), e([y()], c10.prototype, "layer", null), e([y()], c10.prototype, "spatialReference", null), e([y()], c10.prototype, "_queryGeometryType", null), e([y()], c10.prototype, "defaultQueryJSON", null), c10 = e([a2("esri.views.3d.layers.graphics.QueryEngine")], c10);

// node_modules/@arcgis/core/views/3d/layers/support/attributeUtils.js
function n10(n11, t12, e10) {
  if (!e10 || null == t12)
    return null;
  if (!n11)
    return r5(t12, e10);
  const o5 = n11.get(e10);
  return o5 ? t12[o5.name] : null;
}
function r5(n11, r6) {
  const t12 = r6.toLowerCase();
  for (const e10 in n11)
    if (e10.toLowerCase() === t12)
      return n11[e10];
  return null;
}

// node_modules/@arcgis/core/views/3d/layers/support/FeatureVisibilityFilter.js
var y3 = class extends d3 {
  constructor(e10) {
    super(e10), this._updateTask = null, this._frameTask = null, this._queryEngine = null, this._updateRequested = true, this._updateVisibility = async (e11) => {
      if (null == this._compositedFeatureFilter && null == this._sceneFilter || 0 === this.context.getFeatureCount())
        return this._frameTask.schedule(() => this.clear(), e11);
      try {
        const t12 = await this._queryEngine.executeQueryForIdSet(this._compositedFeatureFilter, this._sceneFilter, e11);
        return this._frameTask.schedule(() => {
          this.context.updateFeatureVisibilities((e12) => t12.has(e12));
        }, e11);
      } catch (t12) {
        return f2(t12), s.getLogger(this).warn(`FeatureFilter query failed: ${t12}`, { error: t12 }), this._frameTask.schedule(() => {
          this.context.setAllFeaturesVisibility(true);
        }, e11);
      }
    };
  }
  initialize() {
    const e10 = I2.FILTER_VISIBILITY, { layer: t12, view: r6 } = this._layerView, { featureStore: i6 } = this.context, s10 = "hasZ" in this._layerView && this._layerView.hasZ, l9 = "hasM" in this._layerView && this._layerView.hasM;
    this._queryEngine = new c10({ context: { spatialReference: r6.spatialReference, layer: t12, scheduler: r6.resourceController.scheduler, featureStore: i6, hasM: l9, hasZ: s10 }, priority: e10 }), this._frameTask = this._layerView.view.resourceController.scheduler.registerTask(e10, this), this.updatingHandles.add(() => [this._compositedFeatureFilter, this._sceneFilter], () => this.reapply(), h);
  }
  destroy() {
    this._updateRequested = false, this.handles.removeAll(), this.updatingHandles.removeAll(), this.clear(), this._updateTask = e2(this._updateTask), this._frameTask = o(this._frameTask), this._queryEngine = l(this._queryEngine), this._set("context", null);
  }
  get updating() {
    return this.running || this.updatingHandles.updating || null != this._updateTask && !this._updateTask.finished;
  }
  get running() {
    return this._updateRequested || this._frameTask.updating;
  }
  get defaultVisibility() {
    return null == this._compositedFeatureFilter && null == this._sceneFilter;
  }
  get _featureFilter() {
    return "filter" in this._layerView ? this._layerView.filter : null;
  }
  get _sceneFilter() {
    return "layerFilter" in this._layerView ? this._layerView.layerFilter : null;
  }
  get _floorFilter() {
    return o4(this._layerView);
  }
  get _timeExtent() {
    return "timeExtent" in this._layerView ? this._layerView.timeExtent : null;
  }
  get _compositedFeatureFilter() {
    const { _featureFilter: e10, _timeExtent: t12, _floorFilter: r6 } = this;
    if (null == t12 && null == r6)
      return e10;
    const i6 = null != e10 ? e10.clone() : new d5();
    if (null != t12 && (i6.timeExtent = null != i6.timeExtent ? i6.timeExtent.intersection(t12) : t12), null != r6) {
      const e11 = null == i6.where || "" === i6.where;
      i6.where = e11 ? r6 : `(${i6.where}) AND (${r6})`;
    }
    return i6;
  }
  get _layerView() {
    return this.context.layerView;
  }
  reapply() {
    this._updateRequested = true;
  }
  clear() {
    this._queryEngine.clear(), this.context.clearFeaturesVisibility();
  }
  runTask(e10) {
    this._updateRequested && (this._updateTask = e2(this._updateTask), this._updateTask = d2(this._updateVisibility), this._updateRequested = false, e10.madeProgress()), this._frameTask.processQueue(e10);
  }
};
e([y({ constructOnly: true })], y3.prototype, "context", void 0), e([y()], y3.prototype, "updating", null), e([y()], y3.prototype, "running", null), e([y()], y3.prototype, "defaultVisibility", null), e([y()], y3.prototype, "_featureFilter", null), e([y()], y3.prototype, "_sceneFilter", null), e([y()], y3.prototype, "_floorFilter", null), e([y()], y3.prototype, "_timeExtent", null), e([y()], y3.prototype, "_compositedFeatureFilter", null), e([y()], y3.prototype, "_layerView", null), e([y()], y3.prototype, "_updateTask", void 0), e([y()], y3.prototype, "_updateRequested", void 0), y3 = e([a2("esri.views.3d.layers.support.FeatureVisibilityFilter")], y3);

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DFeatureProcessor.js
var A = class extends d3 {
  constructor(e10) {
    super(e10), this.type = "graphics-3d", this._randomRotationRenderers = null, this.elevationFeatureExpressionEnabled = false, this.scaleVisibilityEnabled = false, this.filterVisibilityEnabled = false, this.frustumVisibilityEnabled = false, this.elevationAlignmentEnabled = false, this.timeExtentEnabled = false, this.setUidToIdOnAdd = true, this.dataExtent = null, this.drapeSourceType = e9.Features, this.preferredUpdatePolicy = C.ASYNC, this._suspendResumeExtent = null;
  }
  initialize() {
    const e10 = this.owner, t12 = (this.filterVisibilityEnabled || this.timeExtentEnabled) && "multipatch" !== e10.layer.geometryType, i6 = new Fe({ owner: this, layer: this.layer, preferredUpdatePolicy: this.preferredUpdatePolicy, elevationFeatureExpressionEnabled: this.elevationFeatureExpressionEnabled, graphicSymbolSupported: false, hasZ: e10.hasZ, hasM: e10.hasM, setUidToIdOnAdd: this.setUidToIdOnAdd, componentFactories: { deconflictor: (t13) => e10.view.deconflictor.addGraphicsOwner(t13), labeler: (t13, i7) => e10.view.labeler.addGraphicsOwner(t13, i7), elevationAlignment: this.elevationAlignmentEnabled ? (t13, i7) => new l6({ graphicsCoreOwner: this, graphicsCore: t13, queryGraphicUIDsInExtent: i7, elevationProvider: e10.view.elevationProvider }) : null, scaleVisibility: this.scaleVisibilityEnabled ? (t13, i7) => new m6({ graphicsCoreOwner: this, layer: this.layer, queryGraphicUIDsInExtent: i7, graphicsCore: t13, basemapTerrain: e10.view.basemapTerrain }) : null, filterVisibility: t12 ? (t13) => new y3({ context: { layerView: e10, ...t13 } }) : null, objectStates: (e11) => new s8(e11) } });
    this._set("graphicsCore", i6), this.frustumVisibilityEnabled && this._set("frustumVisibility", new m7({ graphicsCoreOwner: this })), this.elevationAlignment && this.updatingHandles.add(() => this.layer.elevationInfo, (e11, t13) => {
      a4(e11, t13) && this.updatingHandles.addPromise(this.graphicsCore.elevationInfoChange());
    }), this.updatingHandles.add(() => this.layer.labelsVisible, () => this.graphicsCore.updateVisibilityInfo()), this.updatingHandles.add(() => this.layer.labelingInfo, (e11, t13) => {
      a4(e11, t13) && this.graphicsCore.updateLabelingInfo();
    }), this.updatingHandles.add(() => this.preferredUpdatePolicy, (e11) => this.graphicsCore.preferredUpdatePolicy = e11), this._set("initializePromise", this._initializeAsync()), this.updatingHandles.addPromise(this.initializePromise);
  }
  async _initializeAsync() {
    await v(this.graphicsCore.initializePromise);
    const e10 = this.owner;
    this.updatingHandles.add(() => this.renderer, (e11) => this.updatingHandles.addPromise(this.graphicsCore.rendererChange(e11))), this.updatingHandles.add(() => e10.fullOpacity, () => this.graphicsCore.opacityChange()), this._setupSuspendResumeExtent(), this.updateClippingExtent && (this.updatingHandles.add(() => e10.view.clippingArea, () => this._updateClippingExtent()), this._updateClippingExtent()), this.graphicsCore.startCreateGraphics(), this.graphicsCore.labelsEnabled && await v(this.graphicsCore.updateLabelingInfo());
  }
  destroy() {
    this.handles.removeAll(), this.updatingHandles.removeAll(), this._set("frustumVisibility", l(this.frustumVisibility)), this._set("graphicsCore", l(this.graphicsCore)), this._set("owner", null);
  }
  get layer() {
    return this.owner.layer;
  }
  get renderer() {
    const { renderer: e10, objectIdField: t12 } = this.layer;
    if (!e10 || !t12 || "heatmap" === e10.type || !e10.visualVariables)
      return e10;
    const i6 = e10.visualVariables.findIndex((e11) => "rotation" === e11.type && null != e11.valueExpression && e5(e11.valueExpression) === t12 && (null == e11.axis || "heading" === e11.axis) && "geographic" === e11.rotationType);
    if (i6 < 0)
      return e10;
    const s10 = e10.clone();
    return s10.visualVariables.splice(i6, 1), this._randomRotationRenderers || (this._randomRotationRenderers = /* @__PURE__ */ new WeakMap()), this._randomRotationRenderers.set(s10, t12), s10;
  }
  get scaleVisibility() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.scaleVisibility;
  }
  get filterVisibility() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.filterVisibility;
  }
  get elevationAlignment() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.elevationAlignment;
  }
  get objectStates() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.objectStates;
  }
  get suspendResumeExtentMode() {
    return "suspendResumeExtentMode" in this.owner ? this.owner.suspendResumeExtentMode : "computed";
  }
  get scaleVisibilitySuspended() {
    return null != this.scaleVisibility && this.scaleVisibility.suspended;
  }
  get suspended() {
    return this.owner.suspended;
  }
  get legendEnabled() {
    return null == this.frustumVisibility || !this.frustumVisibility.suspended;
  }
  get suspendInfo() {
    const e10 = {};
    return this.scaleVisibilitySuspended && (e10.outsideScaleRange = true), null != this.frustumVisibility && this.frustumVisibility.suspended && (e10.outsideOfView = true), e10;
  }
  get updating() {
    var _a, _b;
    return !!(((_a = this.graphicsCore) == null ? void 0 : _a.updating) || null != this.frustumVisibility && this.frustumVisibility.updating || ((_b = this.updatingHandles) == null ? void 0 : _b.updating));
  }
  get updatingRemaining() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.updatingRemaining) ?? 0;
  }
  get featureStore() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.featureStore;
  }
  get view() {
    return this.owner.view;
  }
  get loadedGraphics() {
    return this.owner.loadedGraphics;
  }
  get fullOpacity() {
    var _a;
    return (_a = this.owner) == null ? void 0 : _a.fullOpacity;
  }
  get filter() {
    return "filter" in this.owner ? this.owner.filter : null;
  }
  get slicePlaneEnabled() {
    return this.owner.slicePlaneEnabled;
  }
  get updatePolicy() {
    return this.owner.updatePolicy;
  }
  get featureSpatialReference() {
    return "featureSpatialReference" in this.owner ? this.owner.featureSpatialReference : this.owner.view.spatialReference;
  }
  get graphics3DGraphics() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.graphics3DGraphics;
  }
  get graphics3DGraphicsByObjectID() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.graphics3DGraphicsByObjectID;
  }
  get symbolUpdateType() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.symbolUpdateType;
  }
  get displayFeatureLimit() {
    var _a, _b, _c;
    const e10 = (_b = (_a = this.view.resourceController) == null ? void 0 : _a.memoryController) == null ? void 0 : _b.memoryFactor, t12 = (_c = this.graphicsCore) == null ? void 0 : _c.displayFeatureLimit;
    if (null == e10 || 1 === e10)
      return t12;
    const i6 = Math.ceil(t12.maximumNumberOfFeatures * e10), s10 = Math.ceil(t12.maximumTotalNumberOfFeatures * e10), r6 = Math.ceil(t12.minimumTotalNumberOfFeatures * e10);
    return { ...t12, maximumNumberOfFeatures: i6, maximumTotalNumberOfFeatures: s10, minimumTotalNumberOfFeatures: r6 };
  }
  get usedMemory() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.usedMemory) ?? 0;
  }
  get loadedFeatures() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.numberOfGraphics) ?? 0;
  }
  get usedMemoryPerFeature() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.usedMemoryPerGraphic) ?? 0;
  }
  get unprocessedMemoryEstimate() {
    var _a;
    return ((_a = this.graphicsCore) == null ? void 0 : _a.unprocessedMemoryEstimate) ?? 0;
  }
  get performanceInfo() {
    return { core: this.graphicsCore.performanceInfo, elevationUpdating: this.elevationAlignment.updating, visibilityFrustum: null == this.frustumVisibility || !this.frustumVisibility.suspended, visibilityScale: !this.scaleVisibilitySuspended };
  }
  maskOccludee(e10) {
    const { set: t12, handle: i6 } = this.objectStates.acquireSet(t6.MaskOccludee, null);
    return this.objectStates.setUid(t12, e10.uid), i6;
  }
  highlight(e10, i6) {
    if (e10 instanceof b2) {
      const { set: t12, handle: s10 } = this.objectStates.acquireSet(t6.Highlight, i6);
      return this.owner.queryObjectIds(e10).then((e11) => this.objectStates.setObjectIds(t12, e11)), s10;
    }
    if ("number" == typeof e10 || "string" == typeof e10)
      return this.highlight([e10], i6);
    if (e10 instanceof h5)
      return this.highlight([e10], i6);
    if ("toArray" in e10 && (e10 = e10.toArray()), Array.isArray(e10) && e10.length > 0) {
      if (e10[0] instanceof h5) {
        const t12 = e10;
        if (null == n10(this.layer.fieldsIndex, t12[0].attributes, i6)) {
          const e11 = t12.map((e12) => e12.uid), { set: i7, handle: s10 } = this.objectStates.acquireSet(t6.Highlight, null);
          return this.objectStates.setUids(i7, e11), s10;
        }
        e10 = t12.map((e11) => n10(this.layer.fieldsIndex, e11.attributes, i6));
      }
      if (Array.isArray(e10) && ("number" == typeof e10[0] || "string" == typeof e10[0])) {
        const t12 = e10, { set: s10, handle: r6 } = this.objectStates.acquireSet(t6.Highlight, i6);
        return this.objectStates.setObjectIds(s10, t12), r6;
      }
    }
    return U3;
  }
  resetObjectStates() {
    this.objectStates.reset();
  }
  whenGraphicBounds(e10, t12) {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.whenGraphicBounds(e10, t12);
  }
  computeAttachmentOrigin(e10, t12) {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.computeAttachmentOrigin(e10, t12);
  }
  notifyGraphicGeometryChanged(e10) {
    this.graphicsCore.notifyGraphicGeometryChanged(e10);
  }
  notifyGraphicVisibilityChanged(e10) {
    this.graphicsCore.notifyGraphicVisibilityChanged(e10);
  }
  getRenderingInfo(e10, t12, s10) {
    var _a;
    const r6 = i4(e10, { renderer: t12, arcade: s10 });
    if (null != r6 && r6.color) {
      const e11 = r6.color;
      e11[0] = e11[0] / 255, e11[1] = e11[1] / 255, e11[2] = e11[2] / 255;
    }
    if (null != r6 && null != t12 && ((_a = this._randomRotationRenderers) == null ? void 0 : _a.has(t12))) {
      const s11 = this._randomRotationRenderers.get(t12), n11 = e10.attributes[s11], a9 = new i2(0);
      a9.updateFloatArray([n11]), a9.updateUint8Array([173]), r6.heading = 8381e-11 * a9.digest();
    }
    return r6;
  }
  getRenderingInfoAsync(e10, t12, i6, s10) {
    return l5(e10, { renderer: t12, arcade: i6, ...s10 });
  }
  getSymbolLayerSize(e10, t12) {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.getSymbolLayerSize(e10, t12);
  }
  setObjectIdVisibility(e10, t12) {
    var _a;
    (_a = this.graphicsCore) == null ? void 0 : _a.setObjectIdVisibility(e10, t12);
  }
  refreshFilter() {
    null != this.filterVisibility && this.filterVisibility.reapply();
  }
  getGraphics3DGraphicByObjectId(e10) {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.getGraphics3DGraphicByObjectId(e10);
  }
  _updateClippingExtent() {
    const e10 = this.owner.view.clippingArea;
    this.graphicsCore.setClippingExtent(e10, this.owner.view.spatialReference) && (this.updateClippingExtent(e10) || this.graphicsCore.recreateAllGraphics());
  }
  _setupSuspendResumeExtent() {
    (this.frustumVisibility || this.scaleVisibility) && this.handles.add(l2(() => this.suspendResumeExtentMode, () => {
      switch (this.handles.remove(P), this.suspendResumeExtentMode) {
        case "computed":
          this.handles.add([l2(() => this.graphicsCore.computedExtent, (e10) => this._updateSuspendResumeExtent(e10), h), l2(() => this.graphicsCore.extentPadding, () => this._updateSuspendResumeExtent(this.graphicsCore.computedExtent))], P);
          break;
        case "data":
          this.handles.add([f3(() => this.dataExtent, (e10) => this._updateSuspendResumeExtent(e10), h), l2(() => this.graphicsCore.extentPadding, () => this._updateSuspendResumeExtent(this.dataExtent))], P);
          break;
        default:
          n4(this.suspendResumeExtentMode);
      }
    }, h));
  }
  _updateSuspendResumeExtent(e10) {
    e10 ? this._suspendResumeExtentChanged(this._extentToSuspendResumeRect(e10, this._suspendResumeExtent)) : this._suspendResumeExtentChanged(null);
  }
  _extentToSuspendResumeRect(e10, t12) {
    const i6 = this.owner.view.spatialReference;
    if (!e10.spatialReference.equals(i6)) {
      if (!x(e10, i6))
        return;
      e10 = g(e10, i6);
    }
    return F3(e10, t12, s7, this.graphicsCore.extentPadding);
  }
  _suspendResumeExtentChanged(e10) {
    null != this.frustumVisibility && this.frustumVisibility.setExtent(e10), null != this.scaleVisibility && this.scaleVisibility.setExtent(e10);
  }
};
e([y()], A.prototype, "type", void 0), e([y({ constructOnly: true })], A.prototype, "owner", void 0), e([y()], A.prototype, "layer", null), e([y()], A.prototype, "renderer", null), e([y({ constructOnly: true })], A.prototype, "updateClippingExtent", void 0), e([y({ constructOnly: true })], A.prototype, "elevationFeatureExpressionEnabled", void 0), e([y({ constructOnly: true })], A.prototype, "graphicsCore", void 0), e([y({ constructOnly: true })], A.prototype, "scaleVisibilityEnabled", void 0), e([y({ constructOnly: true })], A.prototype, "filterVisibilityEnabled", void 0), e([y({ constructOnly: true })], A.prototype, "frustumVisibilityEnabled", void 0), e([y({ constructOnly: true })], A.prototype, "elevationAlignmentEnabled", void 0), e([y({ constructOnly: true })], A.prototype, "timeExtentEnabled", void 0), e([y({ constructOnly: true })], A.prototype, "setUidToIdOnAdd", void 0), e([y()], A.prototype, "scaleVisibility", null), e([y()], A.prototype, "filterVisibility", null), e([y()], A.prototype, "elevationAlignment", null), e([y({ constructOnly: true })], A.prototype, "frustumVisibility", void 0), e([y()], A.prototype, "objectStates", null), e([y()], A.prototype, "initializePromise", void 0), e([y()], A.prototype, "suspendResumeExtentMode", null), e([y()], A.prototype, "dataExtent", void 0), e([y()], A.prototype, "scaleVisibilitySuspended", null), e([y()], A.prototype, "suspended", null), e([y()], A.prototype, "legendEnabled", null), e([y()], A.prototype, "suspendInfo", null), e([y()], A.prototype, "updating", null), e([y()], A.prototype, "updatingRemaining", null), e([y()], A.prototype, "featureStore", null), e([y()], A.prototype, "view", null), e([y()], A.prototype, "loadedGraphics", null), e([y()], A.prototype, "fullOpacity", null), e([y()], A.prototype, "filter", null), e([y()], A.prototype, "slicePlaneEnabled", null), e([y()], A.prototype, "drapeSourceType", void 0), e([y()], A.prototype, "updatePolicy", null), e([y()], A.prototype, "preferredUpdatePolicy", void 0), e([y()], A.prototype, "displayFeatureLimit", null), A = e([a2("esri.views.3d.layers.graphics.Graphics3DFeatureProcessor")], A);
var _5 = A;
var P = "suspendResumeExtentMode";
var U3 = { remove() {
}, pause() {
}, resume() {
} };

// node_modules/@arcgis/core/views/3d/layers/support/featureReference.js
var t11 = class {
  get isReferenced() {
    return 0 !== this.versions.length;
  }
  get isSingle() {
    return 1 === this.versions.length && 1 === this.versions[0].refCount;
  }
  constructor(e10, t12) {
    this._highestResolutionVersion = null, this.versions = [], this.ref(e10, t12);
  }
  ref(t12, s10) {
    const r6 = this.feature;
    i5.oldVersion = r6, this.feature && Object.defineProperty(t12, "uid", { value: this.feature.uid, configurable: true });
    for (const n11 of this.versions)
      if (n11.resolution === s10) {
        n11.refCount++;
        const s11 = this._highestResolutionVersion === n11 && !c5(t12, n11.feature);
        return (s11 || this._highestResolutionVersion !== n11) && (n11.feature = t12), i5.newVersion = s11 ? t12 : r6, i5;
      }
    const o5 = { feature: t12, resolution: s10, refCount: 1 };
    return this.versions.push(o5), !this._highestResolutionVersion || s10 < this._highestResolutionVersion.resolution ? (i5.newVersion = t12, this._highestResolutionVersion = o5) : i5.newVersion = r6, i5;
  }
  unref(e10) {
    for (let t12 = 0; t12 < this.versions.length; t12++) {
      const s10 = this.versions[t12];
      if (s10.resolution === e10)
        return s10.refCount--, i5.oldVersion = this.feature, 0 === s10.refCount && (this.versions[t12] = this.versions[this.versions.length - 1], this.versions.length--, this._highestResolutionVersion === s10 && (this._recalculateHighestResolutionVersion(), i5.oldVersion = s10.feature)), i5.newVersion = this.feature, i5;
    }
    return null;
  }
  get feature() {
    return this._highestResolutionVersion ? this._highestResolutionVersion.feature : null;
  }
  _recalculateHighestResolutionVersion() {
    if (0 === this.versions.length)
      return void (this._highestResolutionVersion = null);
    let e10 = this.versions[0];
    for (let t12 = 1; t12 < this.versions.length; t12++) {
      const s10 = this.versions[t12];
      s10.resolution < e10.resolution && (e10 = s10);
    }
    this._highestResolutionVersion = e10;
  }
};
var s9 = class {
  get isReferenced() {
    return 0 !== this._refCount;
  }
  get isSingle() {
    return 1 === this._refCount;
  }
  constructor(e10) {
    this._feature = e10, this._refCount = 1;
  }
  ref(t12) {
    return ++this._refCount, i5.oldVersion = this._feature, this.feature && Object.defineProperty(t12, "uid", { value: this.feature.uid, configurable: true }), c5(this._feature, t12) || (this._feature = t12), i5.newVersion = this._feature, i5;
  }
  unref() {
    return i5.oldVersion = this._feature, this._refCount > 0 && (this._refCount--, !this.isReferenced) ? (i5.newVersion = null, i5) : (i5.newVersion = this._feature, i5);
  }
  get feature() {
    return this._feature;
  }
};
var i5 = { oldVersion: null, newVersion: null };

// node_modules/@arcgis/core/views/3d/layers/support/FeatureTile.js
var _6 = 16438;
var d9 = /* @__PURE__ */ new Set();
var l7 = class {
  get displayingFeatures() {
    return this._displayingFeatures;
  }
  set displayingFeatures(t12) {
    this._displayingFeatures = t12, this.extentIncludingBorrowedFeatures = null;
  }
  get perTileMaximumNumberOfFeaturesExceeded() {
    return !this.filtered && (this.featuresMissing || this.features && this.featureLimit !== this.features.length);
  }
  get features() {
    return this._features;
  }
  get featureLimit() {
    return this._featureLimit;
  }
  set featureLimit(t12) {
    this._featureLimit !== t12 && (this._featureLimit = t12, this._estimatedUnusedSizeDirty = true);
  }
  get availableFields() {
    return this._availableFields;
  }
  setFeatures(t12, e10, s10) {
    this._availableFields = s10 ?? d9, this._features = t12, this._shuffled = false, this._estimatedSize = -1, this._estimatedUnusedSizeDirty = true, t12 && t12.length > 0 ? (this._emptyFeatureRatio = e10 / (t12.length + e10), this._numVertices = t12.reduce((t13, e11) => t13 + k(e11.geometry), 0)) : (this._emptyFeatureRatio = 0, this._numVertices = 0);
  }
  get emptyFeatureRatio() {
    return this._emptyFeatureRatio;
  }
  get numFeatures() {
    return this.hasPreciseFeatureCount ? this._numFeatures : this._features ? this._features.length : 0;
  }
  set numFeatures(t12) {
    this._numFeatures = t12;
  }
  get hasPreciseFeatureCount() {
    return this._numFeatures > m8;
  }
  get needsFeatureCount() {
    return this._numFeatures === m8;
  }
  get numVertices() {
    return this._numVertices;
  }
  constructor(t12) {
    this.descriptor = t12, this.fetchStatus = E6.FETCH_NEEDED, this._features = null, this._numVertices = 0, this._featureLimit = 0, this.featuresMissing = true, this._shuffled = false, this._numFeatures = m8, this._emptyFeatureRatio = 0, this._estimatedSize = -1, this._estimatedUnusedSize = 0, this._estimatedUnusedSizeDirty = false, this._availableFields = d9, this._displayingFeatures = null, this.alive = true, this.filtered = false;
  }
  get id() {
    return this.descriptor.id;
  }
  get estimatedSize() {
    return this.updateMemoryEstimates(), this._estimatedSize;
  }
  get estimatedUnusedSize() {
    return this._estimatedUnusedSize;
  }
  updateMemoryEstimates() {
    if (this._estimatedSize < 0) {
      if (this._estimatedSize = 0, this._estimatedUnusedSize = 0, this._features)
        for (let t12 = 0; t12 < this._features.length; ++t12) {
          const e10 = M2(this._features[t12]);
          this._estimatedSize += e10, t12 >= this.featureLimit && (this._estimatedUnusedSize += e10);
        }
      return true;
    }
    if (this._estimatedUnusedSizeDirty) {
      if (this._estimatedUnusedSize = 0, this._estimatedUnusedSizeDirty = false, this._features)
        for (let t12 = this.featureLimit; t12 < this._features.length; ++t12)
          this._estimatedUnusedSize += M2(this._features[t12]);
      return true;
    }
    return false;
  }
  get isFetching() {
    return this.fetchStatus === E6.FETCHING || this.fetchStatus === E6.REFETCHING;
  }
  get isRefetching() {
    return this.fetchStatus === E6.REFETCHING;
  }
  get needsFetching() {
    return this.fetchStatus === E6.FETCH_NEEDED || this.fetchStatus === E6.REFETCH_NEEDED;
  }
  get needsRefetching() {
    return this.fetchStatus === E6.REFETCH_NEEDED;
  }
  get isFetched() {
    return this.fetchStatus === E6.DONE || this.fetchStatus === E6.FULL;
  }
  resetFetching() {
    this.fetchStatus = this.fetchStatus === E6.REFETCHING ? E6.REFETCH_NEEDED : E6.FETCH_NEEDED;
  }
  get needsDisplayUpdate() {
    return !!this._features && !c11(this._features, this.displayingFeatures, this.featureLimit);
  }
  intersects(t12) {
    return null == t12 || !this.descriptor.extent || (o2(t12, g2), q(this.descriptor.extent, g2));
  }
  intersectionIncludingBorrowed(t12, e10) {
    const i6 = null != this.extentIncludingBorrowedFeatures ? this.extentIncludingBorrowedFeatures : this.descriptor.extent;
    return t12 || i6 ? (null != t12 ? (o2(t12, e10), R2(e10, i6, e10)) : e4(e10, i6), e10) : (e4(e10, I), e10);
  }
  _shuffle(e10) {
    this._features.sort((t12, s10) => I3(t12, e10) - I3(s10, e10)), F(this._features, _6), this._shuffled = true, this._estimatedUnusedSizeDirty = true;
  }
  reduceFeatures(t12, e10, s10) {
    if (t12 <= 0)
      return false;
    if (!this._features)
      return this.featureLimit = 0, false;
    let i6 = false;
    this.featureLimit = Math.ceil(this.numFeatures * t12), this.featureLimit > this._features.length && (this.featureLimit = this._features.length, this.fetchStatus === E6.DONE && this._features.length > 0 && (this.fetchStatus = E6.REFETCH_NEEDED, i6 = true)), !this._shuffled && t12 < 1 && this._shuffle(s10);
    const r6 = Math.max(this.featureLimit, Math.ceil(e10 * this.numFeatures));
    return this._features.length > r6 && (this._features.length = r6, this.featuresMissing = true, this.fetchStatus === E6.FULL && (this.fetchStatus = E6.DONE)), i6;
  }
  get cache() {
    return { availableFields: this._availableFields, features: this._features, numFeatures: this._numFeatures, emptyFeatureRatio: this._emptyFeatureRatio, fetchStatus: this.fetchStatus, featuresMissing: this.featuresMissing };
  }
  set cache(t12) {
    this.requestController = null, this._availableFields = t12.availableFields, this._features = t12.features, this._numFeatures = t12.numFeatures, this._emptyFeatureRatio = t12.emptyFeatureRatio, this.fetchStatus = t12.fetchStatus, this.featuresMissing = t12.featuresMissing, this._estimatedSize = -1, this._estimatedUnusedSizeDirty = true;
  }
};
var m8 = -1;
var F4 = -2;
var E6;
function c11(t12, e10, s10) {
  if (null == e10 || null == t12 || s10 !== e10.length || s10 > t12.length)
    return false;
  for (let i6 = 0; i6 < s10; ++i6)
    if (t12[i6] !== e10[i6])
      return false;
  return true;
}
!function(t12) {
  t12[t12.FETCH_NEEDED = 0] = "FETCH_NEEDED", t12[t12.REFETCH_NEEDED = 1] = "REFETCH_NEEDED", t12[t12.FETCHING = 2] = "FETCHING", t12[t12.REFETCHING = 3] = "REFETCHING", t12[t12.DONE = 4] = "DONE", t12[t12.FULL = 5] = "FULL";
}(E6 || (E6 = {}));
var g2 = i();

// node_modules/@arcgis/core/views/3d/layers/support/FeatureTileFetcher3D.js
var j4 = "esri.views.3d.layers.support.FeatureTileFetcher3D";
var P2 = s.getLogger(j4);
var N3 = class extends m {
  set maximumNumberOfFeatures(e10) {
    e10 = e10 || 1 / 0;
    const t12 = this._get("maximumNumberOfFeatures");
    e10 === t12 || e10 < 1 || (this._set("maximumNumberOfFeatures", e10), this._maximumFeaturesUpdated(t12, e10));
  }
  set memoryFactor(e10) {
    this.memoryFactor !== e10 && (this._set("memoryFactor", e10), this._setDirty());
  }
  set lodFactor(e10) {
    this.lodFactor !== e10 && (this._set("lodFactor", e10), this._supportsResolution && this.refetch());
  }
  get useTileCount() {
    return this._useTileCount && null != this.context.query.queryFeatureCount;
  }
  set useTileCount(e10) {
    this._useTileCount = e10, this.notifyChange("useTileCount");
  }
  get memoryForUnusedFeatures() {
    let e10 = 0;
    return this._featureTiles.forEach((t12) => e10 += t12.estimatedUnusedSize), e10;
  }
  get totalVertices() {
    let e10 = 0;
    return this._featureTiles.forEach((t12) => e10 += t12.numVertices), e10;
  }
  get totalFeatures() {
    let e10 = 0;
    return this._featureTiles.forEach((t12) => e10 += t12.numFeatures), e10;
  }
  set filterExtent(e10) {
    if (null != e10 && this.context.tilingScheme && !e10.spatialReference.equals(this.context.tilingScheme.spatialReference))
      return void P2.error("#filterExtent=", "extent needs to be in the same spatial reference as the tiling scheme");
    const t12 = this._get("filterExtent");
    if (t12 === e10 || null != t12 && e10 && t12.equals(e10))
      return;
    const s10 = null != e10 ? e10.clone() : null;
    this._set("filterExtent", s10), this._reclip(s10, t12);
  }
  constructor(e10) {
    super(e10), this._useTileCount = false, this.updating = false, this.running = false, this.updatingTotal = 0, this.updatingRemaining = 0, this.expectedFeatureDiff = 0, this.maximumNumberOfFeaturesExceeded = false, this.maximumNumberOfFeaturesExceededThrottle = 1e3, this._fullRatio = 1, this._farRatio = 1, this._changes = { updates: { adds: new Array(), removes: new Array() }, adds: new Array(), removes: new Array() }, this._handles = new t2(), this._frameTask = F2, this._dirty = false, this._featureTiles = /* @__PURE__ */ new Map(), this._displayingFeatureReferences = /* @__PURE__ */ new Map(), this._numDisplayingFeatureReferences = 0, this._suspended = true, this._pendingEdits = null;
  }
  initialize() {
    this._handles.add(a3(() => this.tileDescriptors, "change", () => this._setDirty(), { onListenerAdd: () => this._setDirty() })), this._objectIdField = this.context.objectIdField, this.FeatureReferenceClass = this.context.capabilities.supportsMultipleResolutions ? t11 : s9;
    const e10 = this.context.scheduler;
    null != e10 && (this._frameTask = e10.registerTask(I2.FEATURE_TILE_FETCHER, this)), this._setDirty();
  }
  destroy() {
    var _a;
    this._frameTask.remove(), this._handles = l(this._handles), this._featureTiles.forEach((e10) => {
      this._cancelFetchTile(e10), this._removeTile(e10);
    }), this._featureTiles.clear(), this._displayingFeatureReferences.clear(), (_a = this._pendingEdits) == null ? void 0 : _a.controller.abort(), this._pendingEdits = null;
  }
  get _paused() {
    return this._suspended || !!this._pendingEdits;
  }
  restart() {
    this._featureTiles.forEach((e10) => {
      this._cancelFetchTile(e10), this._clearTile(e10), this._resetFetchTile(e10);
    }), null != this.context.memoryCache && this.context.memoryCache.clear(), this._setDirty();
  }
  refetch() {
    this._featureTiles.forEach((e10) => {
      this._cancelFetchTile(e10), this._resetFetchTile(e10);
    }), null != this.context.memoryCache && this.context.memoryCache.clear(), this._setDirty();
  }
  suspend() {
    this._suspended || (this._suspended = true, this._pause(), this._setDirty());
  }
  resume() {
    this._suspended && (this._suspended = false, this._unpause());
  }
  _pause() {
    this._paused && (this._featureTiles.forEach((e10) => this._cancelFetchTile(e10)), this._updated());
  }
  _unpause() {
    this._paused || (this._setDirty(), this._updated());
  }
  get availableFields() {
    let e10 = null;
    return this._featureTiles.forEach((t12) => {
      null != t12.displayingFeatures && 0 !== t12.displayingFeatures.length && (null == e10 ? e10 = new Set(t12.availableFields) : e10.forEach((s10) => {
        t12.availableFields.has(s10) || e10.delete(s10);
      }));
    }), null != e10 ? e10 : /* @__PURE__ */ new Set();
  }
  applyEdits(e10) {
    this._pendingEdits || (this._pendingEdits = { edits: Promise.resolve(), count: 0, controller: new AbortController() }, this._pause());
    const t12 = this._pendingEdits;
    t12.count++;
    const s10 = t12.edits.then(() => e10.result.catch((e11) => {
      if (d(e11))
        throw e11;
      return null;
    }).then((e11) => e11 ? (this._applyEditsDeleteFeatures(e11.deletedFeatures), this._applyEditsAddUpdateFeatures(e11.addedFeatures, e11.updatedFeatures, t12.controller.signal).then(() => e11)) : e11).then((e11) => (0 == --t12.count && (this._pendingEdits === t12 && (this._pendingEdits = null), null != this.context.memoryCache && this.context.memoryCache.clear(), this._unpause(), this._updated()), e11)));
    return t12.edits = s10, this._updated(), s10;
  }
  _applyEditsDeleteFeatures(e10) {
    if (0 === e10.length)
      return;
    const t12 = this.context.globalIdField, s10 = t12 && this.availableFields.has(t12), i6 = /* @__PURE__ */ new Set(), r6 = this._objectIdField;
    e10.forEach(({ objectId: e11, globalId: a9 }) => {
      if ((!e11 || e11 < 0) && t12) {
        s10 || P2.errorOncePerTick(`Editing the specified service requires the layer's globalIdField, ${t12} to be included the layer's outFields for updates to be reflected in the view`);
        const e12 = this.features.find((e13) => e13.attributes && e13.attributes[t12] === a9);
        e12 && i6.add(I3(e12, r6));
      } else
        i6.add(e11);
    }), this._featureTiles.forEach((e11) => {
      if (!e11.features)
        return;
      const t13 = e11.features.filter((e12) => !i6.has(I3(e12, this._objectIdField)));
      t13.length !== e11.features.length && (e11.setFeatures(t13, 0, e11.availableFields), this._invalidateCounts());
    });
  }
  async _applyEditsAddUpdateFeatures(e10, t12, s10) {
    const i6 = [], r6 = /* @__PURE__ */ new Set();
    if (e10.forEach((e11) => i6.push(e11.objectId)), t12.forEach((e11) => {
      i6.push(e11.objectId), r6.add(e11.objectId);
    }), 0 === i6.length)
      return;
    const a9 = [];
    this._featureTiles.forEach((e11) => {
      const t13 = this._applyEditsAddUpdateTile(e11, i6, r6, s10);
      t13 && a9.push(t13);
    }), await j(a9);
  }
  async _applyEditsAddUpdateTile(e10, t12, s10, i6) {
    if (!e10.features)
      return;
    const r6 = this._createQuery(e10);
    r6.resultType = void 0, r6.cacheHint = false, r6.objectIds = t12;
    const a9 = await this._queryFeatures(r6, i6);
    let n11 = null;
    if (s10.size > 0) {
      const t13 = e10.features.filter((e11) => !s10.has(I3(e11, this._objectIdField)));
      t13.length !== e10.features.length && (n11 = t13);
    }
    if (a9.features.length > 0) {
      n11 || (n11 = e10.features.slice());
      for (const e11 of a9.features)
        n11.push(e11);
    }
    n11 && (e10.hasPreciseFeatureCount && (e10.numFeatures = Math.max(e10.numFeatures, n11.length)), e10.setFeatures(n11, 0, Q(e10.availableFields, a9.fields)), this._invalidateCounts());
  }
  _queryFeatures(e10, t12) {
    return this.context.query.queryFeaturesDehydrated(e10, { signal: t12, timeout: z2 });
  }
  _setDirty() {
    this._dirty = true, this._updated();
  }
  runTask(e10) {
    if (this._frameTask.processQueue(e10), !this._dirty || !this.initialized)
      return;
    this._dirty = false;
    const t12 = this._getListOfTiles();
    if (this._markTilesNotAlive(t12), !e10.run(() => this._addTiles(t12, e10)) || !e10.run(() => this._filterExtentTiles(t12, e10)) || !e10.run(() => this._removeTiles(t12, e10)) || e10.done)
      return void this._setDirty();
    const s10 = this._sortTiles(t12);
    e10.run(() => this._showTiles(s10, e10)) && e10.run(() => this._fetchTiles(s10, e10)) && e10.run(() => this._updateMemoryEstimates(s10, e10)) || this._setDirty(), this._updated(), this.updating || this._updateMaximumNumberOfFeaturesExceeded();
  }
  _markTilesNotAlive(e10) {
    for (const t12 of e10)
      t12.alive = false;
  }
  _addTiles(e10, t12) {
    return !this._suspended && (this.tileDescriptors.forEach((s10) => {
      const i6 = this._featureTiles.get(s10.id);
      i6 ? i6.alive = true : t12.done || (e10.push(this._addTile(s10)), t12.madeProgress());
    }), t12.hasProgressed);
  }
  _filterExtentTiles(e10, t12) {
    for (const s10 of e10) {
      if (t12.done)
        break;
      s10.alive && (s10.filtered = !s10.intersects(this.filterExtent), s10.filtered && (this._clearTile(s10), t12.madeProgress()));
    }
    return t12.hasProgressed;
  }
  _removeTiles(e10, t12) {
    for (let s10 = e10.length - 1; s10 >= 0 && !t12.done; s10--) {
      const i6 = e10[s10];
      i6.alive || (this._removeTile(i6), s10 !== e10.length - 1 && (e10[s10] = e10[e10.length - 1]), e10.pop(), t12.madeProgress());
    }
    return t12.hasProgressed;
  }
  _sortTiles(e10) {
    return e10.sort((e11, t12) => (e11.descriptor.loadPriority ?? 0) - (t12.descriptor.loadPriority ?? 0)), e10;
  }
  _showTiles(e10, t12) {
    const s10 = this._updateRatio(e10), i6 = (e11) => {
      const t13 = this._fullRatio < 1 ? s10(e11) * this._farRatio : 1;
      return e11.reduceFeatures(t13, this.memoryFactor, this._objectIdField) && this._setDirty(), this._showTile(e11);
    };
    for (const r6 of e10)
      if (!t12.run(() => i6(r6))) {
        this._setDirty();
        break;
      }
    return t12.hasProgressed;
  }
  _fetchTiles(e10, t12) {
    if (this._paused)
      return false;
    let s10 = false;
    for (const i6 of e10) {
      if (!i6.needsFetching)
        continue;
      const e11 = null != this.context.memoryCache ? this.context.memoryCache.pop(i6.id) : null;
      if (null == e11) {
        if (this._needsNumFeatures(i6)) {
          const e12 = new AbortController(), r6 = this._fetchTileCount(i6, e12.signal);
          this._handleRequest(i6, r6, e12, () => i6.numFeatures = F4), s10 = true, t12.madeProgress();
        }
        if (t12.done)
          return true;
      } else
        i6.cache = e11, this._setDirty(), this._scheduleUpdated(), t12.madeProgress();
    }
    if (s10)
      return t12.hasProgressed;
    for (const i6 of e10)
      if (i6.needsFetching) {
        const e11 = new AbortController(), s11 = this._fetchTile(i6, e11.signal);
        if (this._handleRequest(i6, s11, e11, (e12) => {
          i6.setFeatures([], 0, null), this._invalidateCounts(), i6.featuresMissing = false, this.context.logFetchError(P2, e12);
        }), t12.madeProgress())
          return true;
      }
    return t12.hasProgressed;
  }
  _updateMemoryEstimates(e10, t12) {
    return e10.some((e11) => !t12.run(() => e11.updateMemoryEstimates()) && (this._setDirty(), true)), t12.hasProgressed;
  }
  _reclip(e10, t12) {
    if (!this.initialized)
      return;
    const s10 = new Array();
    this._featureTiles.forEach((i6) => {
      null != i6.displayingFeatures && 0 !== i6.displayingFeatures.length && (i6.intersectionIncludingBorrowed(t12, H3), i6.intersectionIncludingBorrowed(e10, k2), H(H3, k2) || s10.push(i6));
    }), this._refreshDisplayingFeatures(s10), this._updated();
  }
  _refreshDisplayingFeatures(e10) {
    const t12 = /* @__PURE__ */ new Set(), s10 = this._changes.updates;
    for (const i6 of e10)
      if (null != i6.displayingFeatures)
        for (const e11 of i6.displayingFeatures) {
          const i7 = I3(e11, this._objectIdField);
          if (t12.has(i7))
            continue;
          t12.add(i7);
          const r6 = this._displayingFeatureReferences.get(i7).feature;
          s10.removes.push(r6), s10.adds.push(r6);
        }
    this._applyChanges();
  }
  _updated() {
    let e10 = 0;
    this._paused || this._featureTiles.forEach((t13) => t13.isFetching ? ++e10 : 0);
    const t12 = this._dirty || !!this._pendingEdits || e10 > 0;
    if (this._set("running", this._dirty), this._set("updating", t12), t12) {
      let t13 = 0, s10 = 0, i6 = 0, r6 = 0, a9 = 0;
      const n11 = this._displayingFeatureReferences.size / this._numDisplayingFeatureReferences;
      this._featureTiles.forEach((e11) => {
        if (++s10, e11.isFetching && e11.hasPreciseFeatureCount) {
          const t14 = this._maximumFeaturesForTile(e11) * (1 - e11.emptyFeatureRatio), s11 = null != e11.displayingFeatures ? e11.displayingFeatures.length * n11 : 0;
          a9 += t14 - s11;
        }
        e11.needsFetching ? ++r6 : e11.numFeatures > 0 && (++i6, t13 += e11.numFeatures);
      }), r6 += e10;
      let o5 = 0, u4 = 0;
      t13 ? (u4 = t13, o5 = Math.min(r6 * t13 / i6, t13)) : (u4 = s10, o5 = r6), a9 = Math.min(this.maximumNumberOfFeatures - this.features.length, a9), this._set("updatingTotal", u4), this._set("updatingRemaining", o5), this._set("expectedFeatureDiff", a9);
    } else
      this._set("updatingTotal", 0), this._set("updatingRemaining", 0), this._set("expectedFeatureDiff", 0);
    this.debugger && this.debugger.update();
  }
  _updateMaximumNumberOfFeaturesExceeded() {
    const e10 = n2(this._featureTiles, (e11) => e11.perTileMaximumNumberOfFeaturesExceeded);
    this._set("maximumNumberOfFeaturesExceeded", e10);
  }
  _updateRatio(e10) {
    const t12 = I5(e10), s10 = (e11) => 1 / (1 << Math.max(0, t12 - e11.descriptor.lij[0]));
    let i6 = 0, r6 = 0;
    for (const a9 of e10) {
      const e11 = a9.numFeatures;
      i6 += e11, r6 += e11 * s10(a9);
    }
    return this._fullRatio = Math.min(1, this.maximumNumberOfFeatures / i6), this._farRatio = this.maximumNumberOfFeatures / r6, this._scheduleUpdated(), s10;
  }
  _maximumFeaturesUpdated(e10, t12) {
    e10 !== t12 && (t12 > e10 && this._featureTiles.forEach((e11) => {
      if (!e11.featuresMissing)
        return;
      const t13 = this._maximumFeaturesForTile(e11);
      e11.features && (e11.features.length >= t13 || e11.fetchStatus === E6.FULL) || (this._cancelFetchTile(e11), this._resetFetchTile(e11));
    }), this._setDirty());
  }
  _addTile(e10) {
    const t12 = new l7(e10);
    return this._featureTiles.set(t12.id, t12), this._resetFetchTile(t12), this._referenceDisplayingFeaturesFromRelatedTiles(t12), t12;
  }
  _referenceDisplayingFeaturesFromRelatedTiles(e10) {
    const t12 = e10.descriptor.resolution;
    this._featureTiles.forEach((s10) => {
      if (!(null == s10.displayingFeatures || e10 === s10 || e10.descriptor.lij && s10.descriptor.lij && !x3(e10.descriptor.lij, s10.descriptor.lij))) {
        null == e10.displayingFeatures && (e10.displayingFeatures = []), e10.descriptor.extent && s10.descriptor.extent && (null == e10.extentIncludingBorrowedFeatures && (e10.extentIncludingBorrowedFeatures = u(e10.descriptor.extent)), m2(e10.extentIncludingBorrowedFeatures, s10.descriptor.extent, e10.extentIncludingBorrowedFeatures));
        for (const i6 of s10.displayingFeatures) {
          e10.displayingFeatures.push(i6);
          const s11 = this._displayingFeatureReferences.get(I3(i6, this._objectIdField));
          s11.ref(s11.feature, t12), this._numDisplayingFeatureReferences++;
        }
      }
    }), e10.featureLimit = null != e10.displayingFeatures ? e10.displayingFeatures.length : 0;
  }
  _removeTile(e10) {
    this._clearTile(e10), this._featureTiles.delete(e10.id);
  }
  _resetFetchTile(e10) {
    e10.filtered = !e10.intersects(this.filterExtent), e10.filtered ? e10.needsFetching && (e10.fetchStatus = E6.DONE) : e10.fetchStatus = E6.FETCH_NEEDED;
  }
  _cancelFetchTile(e10) {
    const t12 = e10.requestController;
    null != t12 && (e10.requestController = null, e10.resetFetching(), t12.abort());
  }
  async _fetchTileCount(e10, t12) {
    return e10.numFeatures = await this._fetchCount(e10, t12), this._updateRatio(this._getListOfTiles()), e10.fetchStatus === E6.REFETCHING ? E6.REFETCH_NEEDED : E6.FETCH_NEEDED;
  }
  async _fetchTile(e10, t12) {
    const s10 = this._maximumFeaturesForTile(e10);
    if (s10 <= 0)
      return S2(e10);
    const i6 = this._getMaxRecordCount(e10), r6 = Math.ceil(s10 / i6);
    if (U4(e10) || !this.context.capabilities.supportsMaxRecordCountFactor || e10.numFeatures <= s10 && r6 > b2.MAX_MAX_RECORD_COUNT_FACTOR)
      return this._fetchPagedTile(e10, t12);
    const a9 = this._createQuery(e10);
    if (a9.maxRecordCountFactor = Math.ceil(s10 / i6), e10.isRefetching && e10.features && e10.features.length > 0) {
      const t13 = Math.ceil(e10.features.length / (1 - e10.emptyFeatureRatio) / i6);
      a9.maxRecordCountFactor = Math.max(t13 + 1, a9.maxRecordCountFactor);
    }
    const { features: n11, exceededTransferLimit: o5, fields: l9 } = await this._queryFeatures(a9, t12), h9 = o5 ? a9.maxRecordCountFactor >= b2.MAX_MAX_RECORD_COUNT_FACTOR ? E6.FULL : E6.DONE : E6.FULL;
    return await this._frameTask.schedule(() => {
      e10.featuresMissing = n11.length < e10.numFeatures || !!o5;
      const t13 = this._removeEmptyFeatures(n11);
      e10.setFeatures(n11, t13, L2(l9));
    }, t12), s3(t12), this._invalidateCounts(), h9;
  }
  async _fetchCount(e10, t12) {
    return this.context.query.queryFeatureCount(this._createFeatureCountQuery(e10), { signal: t12 });
  }
  async _fetchPagedTile(e10, t12) {
    let s10, i6 = 0, r6 = 0, a9 = 0, n11 = this._maximumFeaturesForTile(e10) - a9;
    const o5 = this._getMaxRecordCount(e10);
    let l9 = null;
    for (; ; ) {
      const h9 = this._createQuery(e10), c12 = this._setPagingParameters(h9, i6, n11, o5), { features: d13, exceededTransferLimit: p2, fields: f8 } = await this._queryFeatures(h9, t12);
      if (await this._frameTask.schedule(() => {
        c12 && (i6 += h9.num), a9 += d13.length, r6 += this._removeEmptyFeatures(d13), e10.featuresMissing = i6 < e10.numFeatures || !!p2, s10 = s10 ? s10.concat(d13) : d13, l9 = Q(l9, f8), e10.setFeatures(s10, r6, l9);
      }, t12), s3(t12), this._invalidateCounts(), this._setDirty(), n11 = this._maximumFeaturesForTile(e10) - a9, !c12 || !p2 || n11 <= 0)
        return p2 ? E6.DONE : E6.FULL;
    }
  }
  _createFeatureCountQuery(e10) {
    const t12 = this._createQuery(e10);
    return this.context.capabilities.supportsCacheHint && (t12.resultType = void 0, t12.cacheHint = true), t12;
  }
  _createQuery(e10) {
    const t12 = this.context.createQuery(), s10 = e10.descriptor.extent;
    if (s10) {
      const e11 = this.context.tilingScheme.spatialReference;
      t12.geometry = c2(s10, e11);
    }
    return this._setResolutionParams(t12, e10), this._useTileQuery(e10) ? t12.resultType = "tile" : this.context.capabilities.supportsCacheHint && (t12.cacheHint = true), t12;
  }
  _setPagingParameters(e10, t12, s10, i6) {
    return !!this.context.capabilities.supportsPagination && (e10.start = t12, s10 > 0 && this.context.capabilities.supportsMaxRecordCountFactor ? (e10.maxRecordCountFactor = Math.ceil(s10 / i6), e10.num = Math.min(e10.maxRecordCountFactor * i6, s10)) : e10.num = Math.min(i6), true);
  }
  _getEffectiveTileResolution(e10) {
    if (null == e10.descriptor.resolution)
      return null;
    const t12 = this.context.viewingMode === l3.Global ? this.context.tilingScheme.resolutionAtLevel(3) : 1 / 0;
    return Math.min(e10.descriptor.resolution, t12) / this.lodFactor;
  }
  get _supportsResolution() {
    return this.context.capabilities.supportsMultipleResolutions && "point" !== this.context.geometryType;
  }
  _setResolutionParams(e10, t12) {
    if (!this._supportsResolution)
      return;
    const s10 = this._getEffectiveTileResolution(t12);
    null != s10 && (this.context.capabilities.supportsQuantization ? e10.quantizationParameters = new a5({ mode: "view", originPosition: "upper-left", tolerance: s10, extent: this.context.fullExtent }) : "polyline" === this.context.geometryType && (e10.maxAllowableOffset = s10));
  }
  _removeEmptyFeatures(e10) {
    const t12 = e10.length;
    for (let s10 = 0; s10 < e10.length; ) {
      const t13 = e10[s10];
      N(t13.geometry) ? ++s10 : (e10[s10] = e10[e10.length - 1], --e10.length);
    }
    return t12 - e10.length;
  }
  _needsNumFeatures(e10) {
    return this.useTileCount && e10.needsFeatureCount && !U4(e10);
  }
  _getMaxRecordCount(e10) {
    const { tileMaxRecordCount: t12, maxRecordCount: s10 } = this.context;
    return this._useTileQuery(e10) && null != t12 && t12 > 0 && this.context.capabilities.supportsResultType ? t12 : null != s10 && s10 > 0 ? s10 : V2;
  }
  _useTileQuery(e10) {
    return (!U4(e10) || !this.context.capabilities.supportsCacheHint) && this.context.capabilities.supportsResultType;
  }
  _handleRequest(e10, t12, s10, i6) {
    e10.fetchStatus = e10.needsRefetching ? E6.REFETCHING : E6.FETCHING, e10.requestController = s10;
    let r6 = false;
    t12.then((t13) => {
      e10.requestController = null, e10.fetchStatus = t13;
    }).catch((t13) => {
      e10.requestController === s10 && (e10.requestController = null, e10.fetchStatus = E6.DONE), d(t13) ? r6 = true : i6(t13);
    }).then(() => {
      r6 || this._setDirty(), this._scheduleUpdated();
    });
  }
  _scheduleUpdated() {
    this._handles && !this._handles.has("scheduleUpdated") && this._handles.add(v2(() => {
      this._handles.remove("scheduleUpdated"), this._updated();
    }), "scheduleUpdated");
  }
  _showTile(e10) {
    if (null != e10.displayingFeatures && !e10.needsDisplayUpdate)
      return false;
    const t12 = e10.features;
    if (0 === e10.featureLimit || !t12) {
      const t13 = null != e10.displayingFeatures && e10.displayingFeatures.length > 0;
      return this._hideTileFeatures(e10), e10.displayingFeatures = [], t13;
    }
    const s10 = e10.descriptor.resolution, i6 = this._changes.updates, r6 = this._changes.adds, a9 = Math.min(e10.featureLimit, t12.length);
    e10.featureLimit = a9;
    for (let n11 = 0; n11 < a9; ++n11) {
      const e11 = t12[n11], a10 = I3(e11, this._objectIdField), o5 = this._displayingFeatureReferences.get(a10);
      if (o5) {
        const t13 = o5.ref(e11, s10);
        t13.oldVersion !== t13.newVersion && (t13.oldVersion && i6.removes.push(t13.oldVersion), t13.newVersion && i6.adds.push(t13.newVersion));
      } else
        this._displayingFeatureReferences.set(a10, new this.FeatureReferenceClass(e11, s10)), r6.push(e11);
      this._numDisplayingFeatureReferences++;
    }
    return this._hideTileFeatures(e10), this._applyChanges(), e10.displayingFeatures = t12.slice(0, a9), true;
  }
  _hideTile(e10) {
    this._cancelFetchTile(e10), this._hideTileFeatures(e10);
  }
  _hideTileFeatures(e10) {
    if (null == e10.displayingFeatures)
      return;
    const t12 = this._changes.updates, s10 = this._changes.removes;
    for (const i6 of e10.displayingFeatures) {
      const r6 = I3(i6, this._objectIdField), a9 = this._displayingFeatureReferences.get(r6);
      if (!a9)
        continue;
      const n11 = a9.unref(e10.descriptor.resolution);
      this._numDisplayingFeatureReferences--, n11 ? n11.oldVersion !== n11.newVersion && (null == n11.newVersion ? (this._displayingFeatureReferences.delete(r6), n11.oldVersion && s10.push(n11.oldVersion)) : (t12.adds.push(n11.newVersion), n11.oldVersion && t12.removes.push(n11.oldVersion))) : console.error("Hiding unreferenced feature");
    }
    this._applyChanges(), e10.displayingFeatures = null;
  }
  _applyChanges() {
    const e10 = this._changes.updates;
    e10.removes.length > 0 && (this.features.removeMany(e10.removes), e10.removes.length = 0), e10.adds.length > 0 && (this.features.addMany(e10.adds), e10.adds.length = 0);
    const t12 = this._changes.adds, s10 = this._changes.removes, i6 = Math.min(t12.length, s10.length);
    let r6 = 0;
    for (; r6 < i6; ) {
      const e11 = Math.min(r6 + B, i6);
      this.features.addMany(t12.slice(r6, e11)), this.features.removeMany(s10.slice(r6, e11)), r6 = e11;
    }
    t12.length > i6 && this.features.addMany(0 === r6 ? t12 : t12.slice(r6)), s10.length > i6 && this.features.removeMany(0 === r6 ? s10 : s10.slice(r6)), t12.length = 0, s10.length = 0;
  }
  _clearTile(e10) {
    if (this._hideTile(e10), e10.features && null != this.context.memoryCache) {
      const t12 = 16 + e10.estimatedSize;
      this.context.memoryCache.put(e10.id, e10.cache, t12);
    }
    e10.setFeatures(null, 0, null), this._invalidateCounts();
  }
  _invalidateCounts() {
    this.notifyChange("totalVertices"), this.notifyChange("totalFeatures"), this.notifyChange("memoryForUnusedFeatures");
  }
  _getListOfTiles() {
    return Array.from(this._featureTiles.values());
  }
  get storedFeatures() {
    return this._getListOfTiles().reduce((e10, t12) => e10 + (t12.features ? t12.features.length : 0), 0);
  }
  get missingTiles() {
    return Array.from(this._featureTiles.values()).reduce((e10, t12) => e10 + (t12.needsFetching || t12.isFetching ? 1 : 0), 0);
  }
  _maximumFeaturesForTile(e10) {
    const t12 = e10.hasPreciseFeatureCount ? e10.numFeatures : 1 / 0, s10 = e10.hasPreciseFeatureCount ? t12 : this.maximumNumberOfFeatures, i6 = this._fullRatio < 1 ? this._farRatio : 1;
    return Math.min(Math.ceil(s10 * i6 / (1 - e10.emptyFeatureRatio)), t12);
  }
  get test() {
    return { process: (e10) => this.runTask(e10), getFeatureTileById: (e10) => this._featureTiles.get(e10), forEachFeatureTile: (e10) => this._featureTiles.forEach(e10) };
  }
};
function U4(e10) {
  return "dummy-tile-full-extent" === e10.id;
}
function I5(e10) {
  let t12 = 0;
  for (const s10 of e10)
    s10.features && s10.features.length > 0 && s10.alive && (t12 = Math.max(t12, s10.descriptor.lij[0]));
  return t12;
}
function A2(e10) {
  const t12 = e10.capabilities.query;
  return { supportsMultipleResolutions: q2(e10), supportsPagination: !(!t12 || !t12.supportsPagination), supportsResultType: !(!t12 || !t12.supportsResultType), supportsCacheHint: !(!t12 || !t12.supportsCacheHint), supportsQuantization: !(!t12 || !t12.supportsQuantization), supportsQuantizationEditMode: !(!t12 || !t12.supportsQuantizationEditMode), supportsMaxRecordCountFactor: !(!t12 || !t12.supportsMaxRecordCountFactor), supportsFormatPBF: !(!t12 || !t12.supportsFormatPBF) };
}
function q2(e10) {
  switch (e10.geometryType) {
    case "polyline":
      return true;
    case "polygon":
      return e10.capabilities && e10.capabilities.query && e10.capabilities.query.supportsQuantization;
    default:
      return false;
  }
}
function S2(e10) {
  return e10.setFeatures([], 0, null), e10.featuresMissing = false, E6.DONE;
}
function L2(e10) {
  return null == e10 ? /* @__PURE__ */ new Set() : new Set(e10.map((e11) => e11.name));
}
function Q(e10, t12) {
  if (null == e10 || null == t12)
    return L2(t12);
  const s10 = /* @__PURE__ */ new Set();
  for (const { name: i6 } of t12)
    e10.has(i6) && s10.add(i6);
  return s10;
}
e([y({ constructOnly: true })], N3.prototype, "features", void 0), e([y()], N3.prototype, "tileDescriptors", void 0), e([y({ value: 1 / 0 })], N3.prototype, "maximumNumberOfFeatures", null), e([y({ value: 1 })], N3.prototype, "memoryFactor", null), e([y({ value: 1 })], N3.prototype, "lodFactor", null), e([y()], N3.prototype, "useTileCount", null), e([y({ readOnly: true })], N3.prototype, "updating", void 0), e([y({ readOnly: true })], N3.prototype, "running", void 0), e([y({ readOnly: true })], N3.prototype, "updatingTotal", void 0), e([y({ readOnly: true })], N3.prototype, "updatingRemaining", void 0), e([y({ readOnly: true })], N3.prototype, "expectedFeatureDiff", void 0), e([y({ readOnly: true })], N3.prototype, "memoryForUnusedFeatures", null), e([y({ readOnly: true })], N3.prototype, "maximumNumberOfFeaturesExceeded", void 0), e([y({ constructOnly: true })], N3.prototype, "maximumNumberOfFeaturesExceededThrottle", void 0), e([y({ readOnly: true })], N3.prototype, "totalVertices", null), e([y({ readOnly: true })], N3.prototype, "totalFeatures", null), e([y()], N3.prototype, "filterExtent", null), e([y({ constructOnly: true })], N3.prototype, "context", void 0), N3 = e([a2(j4)], N3);
var V2 = 2e3;
var H3 = i();
var k2 = i();
var z2 = 6e5;
var B = 200;

// node_modules/@arcgis/core/views/3d/layers/support/FeatureTileFetcher3DDebugger.js
var h6 = [[0, 179, 255], [117, 62, 128], [0, 104, 255], [215, 189, 166], [32, 0, 193], [98, 162, 206], [102, 112, 129], [52, 125, 0], [142, 118, 246], [138, 83, 0], [92, 122, 255], [122, 55, 83], [0, 142, 255], [81, 40, 179], [0, 200, 244], [13, 24, 127], [0, 170, 147], [19, 58, 241], [22, 44, 35]];
var l8 = class {
  constructor(e10, t12, s10) {
    this._loadingGraphics = /* @__PURE__ */ new Map(), this._loadedGraphics = /* @__PURE__ */ new Map(), this._pendingGraphics = /* @__PURE__ */ new Map(), this._dataExtentGraphic = null, this._enabled = true, this._tileFetcher = e10, this._view = s10, this._tilingScheme = new v3(t12), this._loadedSymbols = h6.map((e11) => new S(new h2({ material: { color: [e11[0], e11[1], e11[2], 0.6] }, outline: { color: "black", size: 1 } }))), this._loadingSymbols = [new S(new h2({ material: { color: [200, 200, 200, 0.4] }, outline: { color: [30, 30, 30], size: 1 } }))], this._pendingSymbols = [new S(new h2({ material: { color: [100, 100, 100, 0.4] }, outline: { color: [30, 30, 30], size: 1 } }))], this._dataExtentSymbol = new S(new h2({ material: { color: [0, 0, 0, 0] }, outline: { color: "green", size: 4 } }));
  }
  destroy() {
    this.enabled = false;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e10) {
    this._enabled = e10, this.update();
  }
  update() {
    this._enabled ? (this._synchronizeMaps(this._loadingGraphics, { filter: (e10) => e10.isFetching, symbols: this._loadingSymbols }), this._synchronizeMaps(this._loadedGraphics, { filter: (e10) => !e10.isFetching, symbols: this._loadedSymbols }), this._synchronizeMaps(this._pendingGraphics, { filter: (e10) => !e10.isFetching, symbols: this._pendingSymbols }), this.showDataExtent(this._tileFetcher.filterExtent)) : (this._loadingGraphics.forEach((e10) => {
      this._view.graphics.removeMany(e10);
    }), this._loadingGraphics.clear(), this._loadedGraphics.forEach((e10) => {
      this._view.graphics.removeMany(e10);
    }), this._loadedGraphics.clear(), this._pendingGraphics.forEach((e10) => {
      this._view.graphics.removeMany(e10);
    }), this._pendingGraphics.clear(), this._dataExtentGraphic && (this._view.graphics.remove(this._dataExtentGraphic), this._dataExtentGraphic = null));
  }
  showDataExtent(i6) {
    if (this._dataExtentGraphic && (this._view.graphics.remove(this._dataExtentGraphic), this._dataExtentGraphic = null), null == i6)
      return;
    const s10 = j2.fromExtent(i6);
    this._dataExtentGraphic = new h5({ geometry: s10, symbol: this._dataExtentSymbol }), this._view.graphics.add(this._dataExtentGraphic);
  }
  _synchronizeMaps(t12, i6) {
    const a9 = [];
    t12.forEach((e10, t13) => {
      const s10 = this._tileFetcher.test.getFeatureTileById(t13);
      s10 && i6.filter(s10) || (this._view.graphics.removeMany(e10), a9.push(t13));
    }), a9.forEach((e10) => t12.delete(e10)), this._tileFetcher.test.forEachFeatureTile((a10) => {
      if (i6.filter(a10) && !t12.has(a10.id)) {
        const [r6, h9, l9] = a10.descriptor.lij;
        this._tilingScheme.ensureMaxLod(r6);
        const n11 = this._tilingScheme.getExtentGeometry(r6, h9, l9), c12 = [new h5({ geometry: n11, symbol: i6.symbols[r6 % i6.symbols.length] }), new h5({ geometry: n11.center, symbol: new h3({ verticalOffset: { screenLength: 40 / 0.75 }, callout: { type: "line", color: "white", border: { color: "black" } }, symbolLayers: [new z({ text: `${r6}/${h9}/${l9}`, halo: { color: "white", size: 1 / 0.75 }, material: { color: "black" }, size: 16 })] }) })];
        t12.set(a10.id, c12), this._view.graphics.addMany(c12);
      }
    });
  }
};

// node_modules/@arcgis/core/layers/graphics/controllers/FeatureTileController3D.js
var I6 = class extends m3(m) {
  set extent(e10) {
    if (null != e10 && !e10.spatialReference.equals(this.layerView.view.spatialReference))
      return void s.getLogger(this).error("#extent=", "extent needs to be in the same spatial reference as the view");
    const t12 = this._get("extent");
    if (t12 === e10)
      return;
    if (null != t12 && e10 && t12.equals(e10))
      return;
    const i6 = null != e10 ? e10.clone() : null;
    this._set("extent", i6);
  }
  get updating() {
    return !!(null != this._tileFetcher && this._tileFetcher.updating || null != this._fetchDataInfoPromise || "tiles" === this.mode && this.layerView.view.featureTiles && this.layerView.view.featureTiles.updating || this._watchUpdatingTracking && this._watchUpdatingTracking.updating);
  }
  get updatingTotal() {
    return this.updating && null != this._tileFetcher ? this._tileFetcher.updatingTotal : 0;
  }
  get updatingRemaining() {
    return this.updating && null != this._tileFetcher ? this._tileFetcher.updatingRemaining : 0;
  }
  get expectedFeatureDiff() {
    return this.updating && null != this._tileFetcher ? this._tileFetcher.expectedFeatureDiff : 0;
  }
  get memoryForUnusedFeatures() {
    return null != this._tileFetcher ? this._tileFetcher.memoryForUnusedFeatures : 0;
  }
  get maximumNumberOfFeaturesExceeded() {
    return !(null == this._tileFetcher || !this._tileFetcher.maximumNumberOfFeaturesExceeded);
  }
  get maximumNumberOfFeatures() {
    return null != this.displayFeatureLimit ? this.displayFeatureLimit.maximumNumberOfFeatures : 0;
  }
  set maximumNumberOfFeatures(e10) {
    e10 !== this.maximumNumberOfFeatures && this._overrideIfSome("maximumNumberOfFeatures", e10);
  }
  get hasMaximumNumberOfFeaturesOverride() {
    return this._isOverridden("maximumNumberOfFeatures");
  }
  get mode() {
    var _a, _b;
    const e10 = this.layerView.layer;
    if ("feature" === e10.type && null != e10.infoFor3D)
      return "snapshot";
    if (false === ((_b = (_a = this.layerView.view.qualitySettings) == null ? void 0 : _a.graphics3D) == null ? void 0 : _b.snapshotAvailable) || this.serviceDataCount === P3.NO_SERVICE_DATA_COUNT || this.vertexLimitExceeded)
      return "tiles";
    const t12 = this.layerView.view, i6 = t12 && t12.featureTiles, r6 = i6 && i6.tilingScheme;
    if (e10 && e10.minScale && this.serviceDataExtent && r6) {
      const t13 = this._approximateExtentSizeAtScale(e10.minScale, r6);
      if ((this.serviceDataExtent.width / t13 + this.serviceDataExtent.height / t13) / 2 > P3.MAX_SNAPSHOT_MIN_SCALE_FACTOR)
        return "tiles";
    }
    return !this.maximumNumberOfFeatures || this.serviceDataCount <= this.maximumNumberOfFeatures ? "snapshot" : "tiles";
  }
  get maxTotalSnapshotVertices() {
    const e10 = this._get("maxTotalSnapshotVertices") || 0, t12 = "snapshot" === this.mode && null != this._tileFetcher && this._tileFetcher.totalVertices || 0;
    return Math.max(e10, t12);
  }
  _approximateExtentSizeAtScale(e10, t12) {
    const i6 = this.layerView.view, r6 = Math.ceil((i6.width / t12.pixelSize + i6.height / t12.pixelSize) / 2), s10 = t12.levels[0];
    return r6 * ((s10.tileSize[0] / (s10.scale / e10) + s10.tileSize[1] / (s10.scale / e10)) / 2);
  }
  get tileDescriptors() {
    return "snapshot" === this.mode ? new V([{ id: "dummy-tile-full-extent", lij: [0, 0, 0] }]) : this.layerView.view.featureTiles ? this.layerView.view.featureTiles.tiles : new V();
  }
  get test() {
    return { fetchDataInfoPromise: this._fetchDataInfoPromise, tileFetcher: this._tileFetcher };
  }
  constructor(e10) {
    super(e10), this.type = "feature-tile-3d", this._watchUpdatingTracking = new c3(), this.serviceDataExtent = null, this.serviceDataCount = P3.NO_SERVICE_DATA_COUNT, this.vertexLimitExceeded = false, this.displayFeatureLimit = null, this._suspended = false, this._tileFetcher = null, this._handles = new t2(), this._fetchDataInfoPromise = null, this._fetchDataInfoAbortController = null, this._lifeCycleAbortController = new AbortController();
  }
  initialize() {
    this._watchUpdatingTracking.add(() => this.vertexLimitInfo, () => this._watchUpdatingTracking.addPromise(this._updateVertexLimitExceeded(null, this._lifeCycleAbortController.signal))), this._watchUpdatingTracking.add(() => this.mode, () => this._modeChanged(), h), this.addResolvingPromise(Promise.resolve().then(() => this._verifyCapabilities()).then(() => this._watchUpdatingTracking.addPromise(this._fetchServiceDataInfo())).then(() => this._initializeTileFetcher()));
  }
  _verifyCapabilities() {
    var _a;
    const e10 = this.layerView.layer;
    if ("ogc-feature" !== e10.type && !((_a = E(e10)) == null ? void 0 : _a.operations.supportsQuery))
      throw new s2("graphicscontroller:query-capability-required", "Service requires query capabilities to be used as a feature layer", { layer: e10 });
  }
  destroy() {
    this._cancelFetchServiceDataInfo(), this._tileFetcher = l(this._tileFetcher), this._handles = l(this._handles), this._tilesHandle = o(this._tilesHandle), this._lifeCycleAbortController = e2(this._lifeCycleAbortController), this._watchUpdatingTracking.destroy(), this._set("_watchUpdatingTracking", null);
  }
  suspend() {
    this._suspended || (this._suspended = true, null != this._tileFetcher && this._tileFetcher.suspend());
  }
  resume() {
    this._suspended && (this._suspended = false, null != this._tileFetcher && this._tileFetcher.resume());
  }
  restart() {
    const e10 = () => {
      null != this._tileFetcher && this._tileFetcher.restart();
    };
    this._watchUpdatingTracking.addPromise(this._fetchServiceDataInfo().then(e10, e10));
  }
  refetch() {
    const e10 = () => {
      null != this._tileFetcher && this._tileFetcher.refetch();
    };
    this._watchUpdatingTracking.addPromise(this._fetchServiceDataInfo().then(e10, e10));
  }
  _initializeTileFetcher() {
    const e10 = this.layerView.view;
    if (!e10)
      return;
    const t12 = j3(() => {
      var _a;
      return (_a = e10.featureTiles) == null ? void 0 : _a.tilingScheme;
    }, this._lifeCycleAbortController.signal);
    this._watchUpdatingTracking.addPromise(t12), t12.then(() => {
      const { layerView: t13, tileDescriptors: i6 } = this, r6 = t13.layer, s10 = new N3({ context: this.context, filterExtent: this.extent, tileDescriptors: i6, features: this.graphics });
      this._tileFetcher = s10, this._suspended ? this._tileFetcher.suspend() : this._tileFetcher.resume();
      const a9 = this.layerView.view.resourceController;
      a9 && this._handles.add(l2(() => {
        var _a;
        return (_a = a9.memoryController) == null ? void 0 : _a.memoryFactor;
      }, (e11) => s10.memoryFactor = e11, w));
      const l9 = "polygon" === this.context.geometryType ? "polygonLodFactor" : "polyline" === this.context.geometryType ? "polylineLodFactor" : null;
      l9 && this._handles.add(l2(() => {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.layerView.view) == null ? void 0 : _a.qualitySettings) == null ? void 0 : _b.graphics3D) == null ? void 0 : _c[l9];
      }, (e11) => s10.lodFactor = e11 || 1, h));
      const n11 = (e11) => {
        s10.maximumNumberOfFeatures = e11, s10.useTileCount = this.serviceDataCount > e11;
      }, o5 = (e11) => s10.useTileCount = e11 > this.maximumNumberOfFeatures;
      "ogc-feature" !== r6.type && this._watchUpdatingTracking.add(() => r6.createQueryVersion, () => this._dataFilterChanged()), this._watchUpdatingTracking.add(() => t13.availableFields, (e11, t14) => this._availableFieldsChanged(t14, e11)), this._watchUpdatingTracking.add(() => t13.requiredFields, (e11, t14) => this._requiredFieldsChanged(t14, e11)), this._handles.add([r6.on("apply-edits", (e11) => this._applyEdits(e11)), l2(() => this.extent, (e11) => s10.filterExtent = e11, U), l2(() => this.tileDescriptors, (e11) => s10.tileDescriptors = e11, U), l2(() => this.maximumNumberOfFeatures, n11, w), l2(() => this.serviceDataCount, o5, w), l2(() => t9.FEATURE_TILE_FETCH_SHOW_TILES, (t14) => {
        t14 && s10 && !s10.debugger ? (s10.debugger = new l8(s10, e10.featureTiles.tilingScheme.toTileInfo(), e10), s10.debugger.update()) : !t14 && this._tileFetcher && s10.debugger && (s10.debugger.destroy(), s10.debugger = null);
      }, w)]), this._supportsExceedsLimitQuery || this._watchUpdatingTracking.add(() => this.maxTotalSnapshotVertices, () => this._watchUpdatingTracking.addPromise(this._updateVertexLimitExceeded(null, this._lifeCycleAbortController.signal)));
    }).catch(() => {
    });
  }
  _modeChanged() {
    switch (this.mode) {
      case "tiles":
        this._tilesHandle || (this._tilesHandle = this.layerView.view.featureTiles.addClient());
        break;
      default:
        s.getLogger(this).warn("Unhandled feature layer mode " + this.mode);
      case "snapshot":
        null != this._tilesHandle && (this._tilesHandle.remove(), this._tilesHandle = null);
    }
  }
  _dataFilterChanged() {
    this._set("maxTotalSnapshotVertices", 0), this.notifyChange("maxTotalSnapshotVertices"), this.refetch();
  }
  _applyEdits(e10) {
    null != this._tileFetcher && this._tileFetcher.applyEdits(e10).then((e11) => {
      if (e11) {
        if (!this._lifeCycleAbortController)
          throw c();
        e11.exceededTransferLimit ? this.layerView.layer.refresh() : (e11.deletedFeatures.length || e11.updatedFeatures.length || e11.addedFeatures.length) && this._watchUpdatingTracking.addPromise(this._updateServiceDataExtent(this._lifeCycleAbortController.signal));
      }
    }).catch((e11) => {
      if (!d(e11))
        throw e11;
    });
  }
  _availableFieldsChanged(e10, t12) {
    null != this._tileFetcher && L3(this._tileFetcher.availableFields, t12) && this.refetch();
  }
  _requiredFieldsChanged(e10, t12) {
    null != this._tileFetcher && L3(this._tileFetcher.availableFields, t12) && this.restart();
  }
  _createVertexLimitExceededQuery(e10) {
    var _a;
    const t12 = this.layerView.layer, i6 = t12.createQuery();
    return i6.returnGeometry = false, i6.outStatistics = [new m5({ statisticType: "exceedslimit", maxVertexCount: e10, outStatisticFieldName: "exceedslimit", maxPointCount: 1e8, maxRecordCount: 1e8 })], ((_a = t12.capabilities) == null ? void 0 : _a.query.supportsCacheHint) && (i6.cacheHint = true), i6;
  }
  _createDataInfoQuery() {
    var _a;
    const e10 = this.layerView.layer, t12 = e10.createQuery();
    return t12.returnGeometry = false, t12.outSpatialReference = this.layerView.view.spatialReference, ((_a = e10.capabilities) == null ? void 0 : _a.query.supportsCacheHint) && (t12.cacheHint = true), t12;
  }
  _fullExtentIsAccurate() {
    const e10 = this.layerView.layer;
    if (e10.definitionExpression)
      return false;
    switch (e10.type) {
      case "feature":
      case "oriented-imagery":
        return w2(e10.url);
      case "csv":
      case "geojson":
      case "ogc-feature":
      case "wfs":
        return true;
      default:
        return;
    }
  }
  async _updateServiceDataExtent(e10) {
    try {
      await this._tryUpdateServiceDataExtent(e10);
    } catch (t12) {
      d(t12) || this._set("serviceDataExtent", a(this.layerView.fullExtentInLocalViewSpatialReference));
    }
  }
  async _tryUpdateServiceDataExtent(e10) {
    var _a;
    const t12 = this.layerView, i6 = t12.layer, r6 = ((_a = i6.capabilities) == null ? void 0 : _a.query.supportsExtent) ?? false, s10 = a(t12.fullExtentInLocalViewSpatialReference), a9 = i6.fullExtent, n11 = this._fullExtentIsAccurate(), o5 = this.serviceDataCount;
    if (r6 && o5 <= P3.MAX_FEATURE_COUNT_FOR_EXTENT && (!s10 || !n11) && "queryExtent" in i6) {
      const t13 = this._createDataInfoQuery(), r7 = await i6.queryExtent(t13, { timeout: P3.QUERY_EXTENT_TIMEOUT, signal: e10 });
      this._set("serviceDataExtent", r7.extent);
    } else if (s10)
      this._set("serviceDataExtent", s10);
    else if (null != a9) {
      const r7 = "portalItem" in i6 ? i6.portalItem : null, s11 = await a6(a9, t12.view.spatialReference, r7, e10);
      this._set("serviceDataExtent", s11);
    } else
      this._set("serviceDataExtent", null);
  }
  async _updateServiceDataCount(e10) {
    const t12 = this.layerView.layer;
    if (!("queryFeatureCount" in t12) || !has("featurelayer-snapshot-enabled"))
      return void this._set("serviceDataCount", P3.NO_SERVICE_DATA_COUNT);
    const r6 = await _(t12.queryFeatureCount(this._createDataInfoQuery(), { timeout: P3.QUERY_STATISTICS_TIMEOUT, signal: e10 }));
    if (true === r6.ok)
      this._set("serviceDataCount", r6.value);
    else {
      if (d(r6.error))
        throw r6.error;
      this._set("serviceDataCount", P3.NO_SERVICE_DATA_COUNT);
    }
  }
  get vertexLimitInfo() {
    if (null == this.displayFeatureLimit || null == this.displayFeatureLimit.averageSymbolComplexity)
      return null;
    const { averageSymbolComplexity: e10, maximumTotalNumberOfPrimitives: t12 } = this.displayFeatureLimit, { primitivesPerCoordinate: i6, primitivesPerFeature: r6 } = e10, s10 = this._get("vertexLimitInfo");
    return null == s10 || s10.maximumTotalNumberOfPrimitives !== t12 || s10.primitivesPerCoordinate !== i6 || s10.primitivesPerFeature !== r6 ? { primitivesPerCoordinate: i6, primitivesPerFeature: r6, maximumTotalNumberOfPrimitives: t12 } : s10;
  }
  get _supportsExceedsLimitQuery() {
    const e10 = this.layerView.layer;
    return null != e10.capabilities && e10.capabilities.operations && e10.capabilities.operations.supportsExceedsLimitStatistics;
  }
  get _minimumNumberOfVerticesForGeometry() {
    switch (this.layerView.layer.geometryType) {
      case "point":
      case "multipoint":
        return 1;
      case "polygon":
        return 4;
      case "polyline":
        return 2;
      case "multipatch":
      case "mesh":
        return 3;
      default:
        return 0;
    }
  }
  async _updateVertexLimitExceeded(e10, t12) {
    const r6 = this.vertexLimitInfo;
    if (null == r6)
      return void this._set("vertexLimitExceeded", false);
    const s10 = r6.primitivesPerFeature <= 0, a9 = this._minimumNumberOfVerticesForGeometry > 1;
    if (!s10 && !a9)
      return void this._set("vertexLimitExceeded", false);
    const { primitivesPerFeature: l9, primitivesPerCoordinate: n11, maximumTotalNumberOfPrimitives: o5 } = r6;
    let h9;
    0 !== l9 && null != e10 && await e10;
    const c12 = this.serviceDataCount, u4 = c12 !== P3.NO_SERVICE_DATA_COUNT;
    if (h9 = u4 ? Math.ceil((o5 - c12 * l9) / (n11 || 1)) : Math.ceil(o5 / (n11 || 1)), a9 && (h9 = Math.min(h9, N4)), u4 && this._minimumNumberOfVerticesForGeometry * c12 > h9)
      return void this._set("vertexLimitExceeded", true);
    if (!this._supportsExceedsLimitQuery || !has("featurelayer-snapshot-enabled"))
      return void this._set("vertexLimitExceeded", this.maxTotalSnapshotVertices > h9);
    const d13 = await _(this.layerView.layer.queryFeatures(this._createVertexLimitExceededQuery(h9), { timeout: P3.QUERY_STATISTICS_TIMEOUT, signal: t12 }));
    if (false === d13.ok) {
      if (d(d13.error))
        throw d13.error;
      return void this._set("vertexLimitExceeded", false);
    }
    const p2 = d13.value.features[0];
    p2 && p2.attributes ? this._set("vertexLimitExceeded", !!p2.attributes.exceedslimit) : this._set("vertexLimitExceeded", false);
  }
  async _fetchServiceDataInfo() {
    this._cancelFetchServiceDataInfo();
    let e10 = new AbortController();
    const t12 = e10.signal, i6 = this._updateServiceDataCount(t12), r6 = j([i6, this._updateVertexLimitExceeded(i6, t12)]), s10 = r6.then(() => this._updateServiceDataExtent(t12)).catch((e11) => {
      d(e11) || s.getLogger(this).error("#fetchServiceDataInfo()", e11);
    }).then(() => {
      s10 === this._fetchDataInfoPromise && (this._fetchDataInfoPromise = null, this._fetchDataInfoAbortController = null), e10 = null;
    });
    return e10 && (this._fetchDataInfoPromise = s10), this._fetchDataInfoAbortController = e10, r6.then(() => {
    }, () => {
    });
  }
  _cancelFetchServiceDataInfo() {
    const e10 = this._fetchDataInfoAbortController;
    e10 && (this._fetchDataInfoAbortController = null, this._fetchDataInfoPromise = null, e10.abort());
  }
  get debug() {
    return { storedFeatures: null != this._tileFetcher ? this._tileFetcher.storedFeatures : 0, totalFeatures: null != this._tileFetcher ? this._tileFetcher.totalFeatures : 0, totalVertices: null != this._tileFetcher ? this._tileFetcher.totalVertices : 0, missingTiles: null != this._tileFetcher ? this._tileFetcher.missingTiles : 0 };
  }
};
e([y({ readOnly: true })], I6.prototype, "type", void 0), e([y({ constructOnly: true })], I6.prototype, "graphics", void 0), e([y({ constructOnly: true })], I6.prototype, "layerView", void 0), e([y({ constructOnly: true })], I6.prototype, "context", void 0), e([y()], I6.prototype, "extent", null), e([y()], I6.prototype, "updating", null), e([y({ readOnly: true })], I6.prototype, "_watchUpdatingTracking", void 0), e([y()], I6.prototype, "updatingTotal", null), e([y()], I6.prototype, "updatingRemaining", null), e([y()], I6.prototype, "expectedFeatureDiff", null), e([y()], I6.prototype, "memoryForUnusedFeatures", null), e([y()], I6.prototype, "maximumNumberOfFeaturesExceeded", null), e([y({ readOnly: true })], I6.prototype, "serviceDataExtent", void 0), e([y({ readOnly: true })], I6.prototype, "serviceDataCount", void 0), e([y({ readOnly: true })], I6.prototype, "vertexLimitExceeded", void 0), e([y()], I6.prototype, "displayFeatureLimit", void 0), e([y({ type: Number })], I6.prototype, "maximumNumberOfFeatures", null), e([y({ readOnly: true })], I6.prototype, "mode", null), e([y({ readOnly: true })], I6.prototype, "maxTotalSnapshotVertices", null), e([y({ readOnly: true, dependsOn: ["mode"] })], I6.prototype, "tileDescriptors", null), e([y()], I6.prototype, "_tileFetcher", void 0), e([y()], I6.prototype, "_fetchDataInfoPromise", void 0), e([y({ readOnly: true })], I6.prototype, "vertexLimitInfo", null), I6 = e([a2("esri.layers.graphics.controllers.FeatureTileController3D")], I6);
var V3 = 1e4;
var U5 = 12e3;
var A3 = 1e4;
var N4 = 5e6;
function L3(e10, t12) {
  if (!t12)
    return false;
  for (const i6 of t12)
    if (!e10.has(i6))
      return true;
  return false;
}
var P3;
!function(e10) {
  function t12() {
    e10.MAX_FEATURE_COUNT_FOR_EXTENT = V3, e10.QUERY_STATISTICS_TIMEOUT = U5, e10.QUERY_EXTENT_TIMEOUT = A3;
  }
  e10.NO_SERVICE_DATA_COUNT = 1 / 0, e10.MAX_SNAPSHOT_MIN_SCALE_FACTOR = 5, e10.reset = t12;
}(P3 || (P3 = {})), P3.reset();

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/HeatmapTechnique.js
var h7 = class extends n8 {
  constructor() {
    super(...arguments), this.colorRamp = null, this.densityMap = null, this.searchRadius = 1, this.fieldTotal = 0, this.minDensity = 0, this.maxDensity = 100;
  }
};
var d10 = class _d extends e8 {
  constructor(e10, r6) {
    super(e10, r6, () => this.destroy());
  }
  initializeProgram(e10) {
    return new i3(e10.rctx, _d.shader.get().build(this.configuration), E3);
  }
  initializePipeline() {
    return W({ blending: c7, colorWrite: _3, depthTest: null, depthWrite: null });
  }
  get primitiveType() {
    return E2.TRIANGLE_STRIP;
  }
};
d10.shader = new t8(a8, () => import("./Heatmap.glsl-2H6SWGPI.js"));
var f6 = class extends s6 {
  constructor() {
    super(...arguments), this.usesHalfFloat = false;
  }
};
e([r2()], f6.prototype, "usesHalfFloat", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DrapedHeatmapRenderer.js
var x4 = class extends _4 {
  constructor(t12) {
    super(t12), this.pixelRatio = 1, this._colorRampData = new Uint8ClampedArray(4), this.type = "draped-heatmap", this._heatmapParameters = new h7();
    const e10 = new e7();
    e10.pixelFormat = t12.pixelFormat, e10.internalFormat = t12.internalFormat, e10.dataType = t12.dataType, e10.samplingMode = t12.samplingMode, e10.wrapMode = D.CLAMP_TO_EDGE;
    const r6 = t12.rendererContext.rctx;
    this._densityMap = new x2(r6, e10), this._quad = f4(r6);
    const a9 = new f6();
    a9.usesHalfFloat = t12.dataType !== U2.FLOAT, this._technique = new d10({ rctx: r6, viewingMode: l3.Local }, a9);
  }
  initialize() {
    const t12 = this._colorRampData, e10 = new e7(t12.length / 4, 1);
    e10.wrapMode = D.CLAMP_TO_EDGE, this._colorRamp = new T2(this.rctx, e10, t12), this._heatmapParameters.densityMap = this._densityMap.colorTexture, this.addHandles(l2(() => [this.colorRampData, this.minDensity, this.maxDensity, this.fieldTotal, this.pixelRatio, this.searchRadius], () => this.rendererContext.notifyContentChanged()));
  }
  destroy() {
    this._technique = f(this._technique), this._densityMap = t(this._densityMap), this._quad = t(this._quad), this._colorRamp = t(this._colorRamp);
  }
  get searchRadius() {
    return this._heatmapParameters.searchRadius;
  }
  set searchRadius(t12) {
    t12 !== this._heatmapParameters.searchRadius && (this._heatmapParameters.searchRadius = t12, this.notifyChange("searchRadius"));
  }
  get minDensity() {
    return this._heatmapParameters.minDensity;
  }
  set minDensity(t12) {
    t12 !== this._heatmapParameters.minDensity && (this._heatmapParameters.minDensity = t12, this.notifyChange("minDensity"));
  }
  get maxDensity() {
    return this._heatmapParameters.maxDensity;
  }
  set maxDensity(t12) {
    t12 !== this._heatmapParameters.maxDensity && (this._heatmapParameters.maxDensity = t12, this.notifyChange("maxDensity"));
  }
  get fieldTotal() {
    return this._heatmapParameters.fieldTotal;
  }
  set fieldTotal(t12) {
    this._heatmapParameters.fieldTotal = t12, this.notifyChange("fieldTotal");
  }
  get colorRampData() {
    return this._colorRampData;
  }
  set colorRampData(t12) {
    const { colorRamp: e10 } = this._heatmapParameters;
    if (null != e10 && t12 !== this._colorRampData) {
      const r6 = e10.descriptor.width, a9 = t12.length / 4;
      a9 !== r6 && e10.resize(a9, 1), e10.setData(t12);
    }
    this._colorRampData = t12;
  }
  get _colorRamp() {
    return this._heatmapParameters.colorRamp;
  }
  set _colorRamp(t12) {
    this._heatmapParameters.colorRamp = t12;
  }
  get hasHighlights() {
    return false;
  }
  get hasWater() {
    return false;
  }
  get rendersOccluded() {
    return false;
  }
  render(t12) {
    const e10 = this._sortedMaterialRenderers;
    if (0 === e10.length)
      return;
    const r6 = this.rctx.getBoundFramebufferObject(), a9 = this.rctx.getViewport(), { pixelRatio: i6 } = this, s10 = Math.ceil(a9.width * i6), o5 = Math.ceil(a9.height * i6);
    this._densityMap.resize(s10, o5), this.rctx.bindFramebuffer(this._densityMap), this.rctx.setViewport(0, 0, s10, o5), this.rctx.clear(_2.COLOR_BUFFER_BIT);
    let n11 = false;
    e10.forAll((e11) => {
      if (e11.material.shouldRender(t12)) {
        const r7 = e11.prepareTechnique(t12);
        null != r7 && (e11.render(t12, r7), n11 = true);
      }
    }), this.rctx.bindFramebuffer(r6), this.rctx.setViewport(a9.x, a9.y, a9.width, a9.height), n11 && (this.rctx.bindVAO(this._quad), this.rctx.bindTechnique(this._technique, this._heatmapParameters, t12.bindParameters), this.rctx.drawArrays(this._technique.primitiveType, 0, n7(this._quad, "geometry")));
  }
};
e([y()], x4.prototype, "searchRadius", null), e([y()], x4.prototype, "minDensity", null), e([y()], x4.prototype, "maxDensity", null), e([y()], x4.prototype, "fieldTotal", null), e([y()], x4.prototype, "pixelRatio", void 0), e([y()], x4.prototype, "colorRampData", null), e([y({ constructOnly: true })], x4.prototype, "dataType", void 0), e([y({ constructOnly: true })], x4.prototype, "samplingMode", void 0), e([y({ constructOnly: true })], x4.prototype, "pixelFormat", void 0), e([y({ constructOnly: true })], x4.prototype, "internalFormat", void 0), e([y()], x4.prototype, "_colorRampData", void 0), x4 = e([a2("esri.views.3d.webgl-engine.lib.DrapedHeatmapRenderer")], x4);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/HeatmapDensityTechnique.js
var d11 = class extends c6 {
  constructor() {
    super(...arguments), this.searchRadius = 128, this.resolutionForScale = 0;
  }
};
var f7 = class _f extends e8 {
  initializeProgram(e10) {
    return new i3(e10.rctx, _f.shader.get().build(this.configuration), E3);
  }
  initializePipeline() {
    return W({ blending: s5(R3.ONE, R3.ONE, T.ADD), colorWrite: _3, depthTest: null, depthWrite: null });
  }
  destroy() {
    super.destroy();
  }
};
f7.shader = new t8(d8, () => import("./HeatmapDensity.glsl-QF2TVIDD.js"));
var b5 = class extends s6 {
  constructor() {
    super(...arguments), this.isAttributeDriven = false, this.usesHalfFloat = false;
  }
};
e([r2()], b5.prototype, "isAttributeDriven", void 0), e([r2()], b5.prototype, "usesHalfFloat", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/HeatmapDensityMaterial.js
var h8 = 2;
var p = class extends d11 {
  constructor() {
    super(...arguments), this.isAttributeDriven = false, this.usesHalfFloats = false;
  }
};
var d12 = class extends d6 {
  constructor(t12) {
    super(t12, new p()), this._configuration = new b5();
  }
  requiresSlot(t12, e10) {
    return t12 === E4.DRAPED_MATERIAL && e10 === h4.Color;
  }
  getConfiguration() {
    return this._configuration.isAttributeDriven = this.parameters.isAttributeDriven, this._configuration.usesHalfFloat = this.parameters.usesHalfFloats, this._configuration;
  }
  createGLMaterial(t12) {
    return new A4(t12);
  }
  intersect() {
  }
  intersectDraped(r6, s10, i6, a9, o5, n11) {
    const l9 = r6.vertexAttributes.get(O.POSITION), { parameters: c12 } = this, { searchRadius: f8 } = c12, { screenToWorldRatio: m9 } = r6, T3 = f8 * m9 + h8 * m9, p2 = T3 * T3, d13 = l9.data.length / l9.size;
    for (let u4 = 0; u4 < d13; u4++) {
      const r7 = u4 * l9.size, s11 = r(E7, l9.data[r7], l9.data[r7 + 1]);
      b(s11, a9) < p2 && o5(n11.dist, n11.normal, -1, false);
    }
  }
  createBufferWriter() {
    return new I7(this.parameters.isAttributeDriven ? g3 : b6);
  }
};
var A4 = class extends t7 {
  beginSlot(t12) {
    return this.ensureTechnique(f7, t12);
  }
};
var I7 = class {
  constructor(t12) {
    this.vertexBufferLayout = t12;
  }
  elementCount(t12) {
    return t12.indices.get(O.POSITION).length * v4;
  }
  write(t12, e10, r6, s10, i6) {
    b4(r6.indices.get(O.POSITION), r6.vertexAttributes.get(O.POSITION).data, t12, s10.position, i6, v4);
    const a9 = r6.indices.get(O.POSITION).length, o5 = s10.uv0;
    let n11 = i6;
    for (let u4 = 0; u4 < a9; ++u4)
      o5.setValues(n11++, -1, -1), o5.setValues(n11++, 1, -1), o5.setValues(n11++, 1, 1), o5.setValues(n11++, 1, 1), o5.setValues(n11++, -1, 1), o5.setValues(n11++, -1, -1);
    const f8 = O.FEATUREATTRIBUTE in s10 ? s10.featureAttribute : null;
    f8 && d7(r6.indices.get(O.FEATUREATTRIBUTE), r6.vertexAttributes.get(O.FEATUREATTRIBUTE).data, f8, i6, v4);
  }
};
var b6 = H2().vec3f(O.POSITION).vec2f(O.UV0);
var g3 = b6.clone().f32(O.FEATUREATTRIBUTE);
var v4 = 6;
var E7 = n5();

// node_modules/@arcgis/core/views/3d/layers/support/HeatmapFeatureProcessor.js
var Z = "esri.views.3d.layers.support.HeatmapFeatureProcessor";
var z3 = s.getLogger(Z);
var $ = 112;
var q3 = class extends d3 {
  constructor(e10) {
    super(e10), this.type = "heatmap", this.preferredUpdatePolicy = C.ASYNC, this.dataExtent = null, this.drapeSourceType = e9.Features, this._renderGeometries = /* @__PURE__ */ new Map(), this._fieldTotal = 0, this._drapeSourceRenderer = null, this._dataType = U2.HALF_FLOAT, this._pixelFormat = G.RGBA, this.initializePromise = Promise.resolve();
  }
  initialize() {
    this._featureStore = new m4({ geometryType: "esriGeometryPoint", hasZ: this.hasZ, hasM: this.hasM });
    const { dataType: e10, samplingMode: t12, pixelFormat: r6, internalFormat: i6 } = n9(this._renderView.renderingContext, z3);
    this._dataType = e10, this._pixelFormat = r6;
    const a9 = e10 !== U2.FLOAT;
    this._drapeSourceRenderer = this.view.basemapTerrain.overlayManager.registerDrapeSource(this, x4, { ...this._rendererParameters, dataType: e10, samplingMode: t12, pixelFormat: r6, internalFormat: i6 }), this._material = new d12({ usesHalfFloats: a9 }), this._materialWithField = new d12({ usesHalfFloats: a9, isAttributeDriven: true }), this._filterVisibility = new y3({ context: { layerView: this.owner, featureStore: this.featureStore, getFeatureCount: () => this._loadedPointGraphics.length, setAllFeaturesVisibility: (e11) => this._setAllFeaturesVisibility(e11), clearFeaturesVisibility: () => this._setAllFeaturesVisibility(true), updateFeatureVisibilities: (e11) => this._updateFeatureVisibilities(e11) } }), this.updatingHandles.addOnCollectionChange(() => this._loadedPointGraphics, (e11) => this._onLoadedFeaturesChange(e11), h), this.updatingHandles.addWhen(() => this._materialParameters, (e11) => this._forEachMaterial((t13) => t13.setParameters(e11)), h), this.updatingHandles.add(() => this._rendererParameters, (e11) => this._drapeSourceRenderer.set(e11)), this.updatingHandles.add(() => this._heatmapRendererField, () => {
      this._recreate();
    }, U), this.updatingHandles.add(() => ({ fieldName: this._heatmapRendererFieldName, numeric: this._heatmapRendererFieldIsNumeric }), ({ fieldName: e11, numeric: t13 }) => {
      if (null != e11 && t13) {
        let t14 = 0;
        this._featureStore.forEach((r7) => t14 += r7.attributes[e11] ?? 0), this._fieldTotal = t14;
      } else
        this._fieldTotal = this._featureStore.numFeatures;
    }, h), this.handles.add([l2(() => ({ fieldName: this._heatmapRendererFieldName, field: this._heatmapRendererField }), ({ fieldName: e11, field: t13 }) => {
      e11 && !t13 && z3.warn(`Heatmap renderer field '${e11}' for layer '${this.layer.title ?? this.layer.id}' not found`);
    }), l2(() => ({ field: this._heatmapRendererField, numeric: this._heatmapRendererFieldIsNumeric }), ({ field: e11, numeric: t13 }) => {
      null == e11 || t13 || z3.warn(`Heatmap renderer field '${e11.name}' for layer '${this.layer.title ?? this.layer.id}' does not contain numeric values and cannot be used to drive the heatmap density`);
    }), e3(() => this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this))]);
  }
  destroy() {
    this._renderGeometries.clear(), this._material = t(this._material), this._materialWithField = t(this._materialWithField), this._featureStore.clear(), this._featureStore = null;
  }
  get layer() {
    return this.owner.layer;
  }
  get featureStore() {
    return this._featureStore;
  }
  get updating() {
    return this.updatingHandles.updating || this.filterVisibility.updating;
  }
  get updatingRemaining() {
    return 0;
  }
  get suspendInfo() {
    return {};
  }
  get legendEnabled() {
    return true;
  }
  get filterVisibility() {
    return this._filterVisibility;
  }
  get displayFeatureLimit() {
    var _a, _b, _c, _d, _e, _f;
    const e10 = ((_d = (_c = (_b = (_a = this.owner) == null ? void 0 : _a.view) == null ? void 0 : _b.resourceController) == null ? void 0 : _c.memoryController) == null ? void 0 : _d.memoryFactor) ?? 1, t12 = (_f = (_e = this.owner) == null ? void 0 : _e.view) == null ? void 0 : _f.qualitySettings, r6 = t12 ? Math.ceil(t12.heatmap.maxTotalNumberOfFeatures * e10) : 0;
    return { minimumTotalNumberOfFeatures: 0, maximumTotalNumberOfFeatures: r6, maximumTotalNumberOfPrimitives: r6 * 2, maximumNumberOfFeatures: r6 };
  }
  get hasZ() {
    return "hasZ" in this.layer && this.layer.hasZ;
  }
  get hasM() {
    return "hasM" in this.layer && this.layer.hasM;
  }
  get view() {
    return this.owner.view;
  }
  get fullOpacity() {
    return this.owner.fullOpacity;
  }
  get updatePolicy() {
    return this.owner.updatePolicy;
  }
  get scaleVisibilitySuspended() {
    if (!this._isScaleRangeActive)
      return false;
    const { minScale: e10, maxScale: t12 } = this.layer.effectiveScaleRange, { scale: r6 } = this.view;
    return !t10(r6, e10 ?? 0, t12 ?? 0);
  }
  get usedMemory() {
    var _a, _b;
    const e10 = this.usedMemoryPerFeature * this._featureStore.numFeatures, t12 = this._pixelFormat === G.RED ? 1 : 4, r6 = this._dataType === U2.FLOAT ? 4 : 2, i6 = Math.ceil((((_b = (_a = this._overlayRenderer) == null ? void 0 : _a.overlays[0]) == null ? void 0 : _b.resolution) ?? 0) * this._densityMapPixelRatio) ?? 0;
    return i6 * i6 * t12 * r6 + e10;
  }
  get usedMemoryPerFeature() {
    const e10 = this._loadedPointGraphics.find(() => true);
    if (null == e10)
      return 0;
    const t12 = t5(e10), s10 = n6(), o5 = 6;
    return o5 * c4([0, 0, 0], s10) + o5 * c4([0, 0], s10) + (this._heatmapRendererFieldIsNumeric ? o5 * s10 : 0) + t12;
  }
  get loadedFeatures() {
    return this._featureStore.numFeatures;
  }
  get unprocessedMemoryEstimate() {
    return 0;
  }
  get performanceInfo() {
    return { core: { visible: this._visibleFeatures, missing: 0, pending: 0 }, elevationUpdating: false, visibilityFrustum: true, visibilityScale: true };
  }
  get renderer() {
    return this._heatmapRenderer;
  }
  get _overlayRenderer() {
    return this.view.basemapTerrain.overlayManager.renderer;
  }
  get _overlaySpatialReference() {
    return this._overlayRenderer.spatialReference;
  }
  get _rendererParameters() {
    return { ...this._radiusParameter, ...this._densityParameters, ...this._colorRampParameter, ...this._pixelRatioParameter };
  }
  get _materialParameters() {
    return { ...this._radiusParameter, ...this._resolutionForScaleParameter };
  }
  get _densityParameters() {
    const e10 = this._heatmapRenderer;
    if (null == e10)
      return null;
    const { minDensity: t12, maxDensity: r6 } = e10;
    return { minDensity: t12, maxDensity: r6, fieldTotal: this._fieldTotal };
  }
  get _radiusParameter() {
    return n(this._heatmapRenderer, ({ radius: e10 }) => ({ searchRadius: u2(this._clampSearchRadius(e10)) }));
  }
  get _resolutionForScaleParameter() {
    return n(this._heatmapRenderer, ({ referenceScale: e10 }) => ({ resolutionForScale: 0 === e10 ? 0 : r3(e10, this.view.spatialReference) }));
  }
  get _colorRampParameter() {
    return n(this._heatmapRenderer, (e10) => ({ colorRampData: u3(e10.colorStops) }));
  }
  get _pixelRatioParameter() {
    return { pixelRatio: this._densityMapPixelRatio };
  }
  get _densityMapPixelRatio() {
    var _a, _b, _c, _d, _e, _f;
    const e10 = ((_d = (_c = (_b = (_a = this.owner) == null ? void 0 : _a.view) == null ? void 0 : _b.resourceController) == null ? void 0 : _c.memoryController) == null ? void 0 : _d.memoryFactor) ?? 1;
    return (((_f = (_e = this.owner) == null ? void 0 : _e.view) == null ? void 0 : _f.qualitySettings.heatmap.pixelRatio) ?? 1) * Math.sqrt(e10);
  }
  get _renderView() {
    return this.view._stage.renderView;
  }
  get _featuresArePoints() {
    return "point" === this.layer.geometryType;
  }
  get _loadedPointGraphics() {
    return this.owner.loadedGraphics;
  }
  get _heatmapRenderer() {
    const e10 = this.layer.renderer;
    return "heatmap" === (e10 == null ? void 0 : e10.type) ? e10 : null;
  }
  get _heatmapRendererFieldName() {
    return n(this._heatmapRenderer, (e10) => e10.field);
  }
  get _heatmapRendererField() {
    return n(this._heatmapRendererFieldName, (e10) => this.layer.fieldsIndex.get(e10));
  }
  get _heatmapRendererFieldIsNumeric() {
    const e10 = this._heatmapRendererField;
    return null != e10 && se(e10);
  }
  get _isScaleRangeActive() {
    const { layer: e10 } = this;
    if (!("effectiveScaleRange" in e10))
      return false;
    const { minScale: t12, maxScale: r6 } = e10.effectiveScaleRange;
    return c8(t12, r6);
  }
  get _visibleFeatures() {
    let e10 = 0;
    return this._renderGeometries.forEach((t12) => {
      t12.visible && ++e10;
    }), e10;
  }
  async whenGraphicBounds() {
    return null;
  }
  computeAttachmentOrigin() {
    return null;
  }
  highlight() {
    return k3;
  }
  maskOccludee() {
    return k3;
  }
  setObjectIdVisibility() {
  }
  refreshFilter() {
    this.filterVisibility.reapply();
  }
  _onLoadedFeaturesChange(e10) {
    if (!this._featuresArePoints)
      return;
    const { objectIdField: r6 } = this.layer;
    this._featureStore.removeManyById(e10.removed.map((e11) => I3(e11, r6))), this._featureStore.addMany(e10.added.map((e11) => {
      const t12 = new t3(L(new t4(), e11.geometry), e11.attributes, n(e11.centroid, (e12) => L(new t4(), e12)), I3(e11, r6));
      return t12.displayId = e11.uid, t12;
    }));
    const i6 = e10.added, a9 = e10.removed;
    this._fieldTotal += this._computeFieldTotalChange(i6, a9);
    const s10 = a9.map(({ uid: e11 }) => {
      const t12 = this._renderGeometries.get(e11);
      return this._renderGeometries.delete(e11), t12;
    }).filter(R), o5 = i6.map((e11) => {
      const t12 = this._pointGraphicToRenderGeometry(e11);
      return this._renderGeometries.set(e11.uid, t12), t12;
    });
    s10.length > 0 && this._drapeSourceRenderer.removeGeometries(s10, E5.REMOVE), o5.length > 0 && this._drapeSourceRenderer.addGeometries(o5, E5.ADD), (o5.length > 0 || s10.length > 0) && (this.filterVisibility.reapply(), this._renderView.requestRender());
  }
  _recreate() {
    if (!this._loadedPointGraphics)
      return;
    const e10 = this._loadedPointGraphics.toArray();
    this._onLoadedFeaturesChange({ added: e10, removed: e10 });
  }
  _pointGraphicToRenderGeometry(e10) {
    const t12 = this._heatmapRendererFieldName, r6 = null != t12 ? this._materialWithField : this._material, i6 = n3();
    In(e10.geometry, i6, this._overlaySpatialReference), i6[2] = ne;
    const a9 = [[O.POSITION, new s4(i6, i6.length)]], s10 = this._heatmapRendererFieldIsNumeric;
    null != t12 && a9.push([O.FEATUREATTRIBUTE, new s4([s10 ? e10.attributes[t12] ?? 0 : 0], 1)]);
    const o5 = new a7(new b3(r6, a9, null, null, e6.Point), { layerUid: this.layer.uid, graphicUid: e10.uid });
    return o5.visible = this.filterVisibility.defaultVisibility, o5;
  }
  _forEachMaterial(e10) {
    e10(this._material), e10(this._materialWithField);
  }
  _computeFieldTotalChange(e10, t12) {
    if (null == this._heatmapRendererFieldName || !this._heatmapRendererFieldIsNumeric)
      return e10.length - t12.length;
    const r6 = this._heatmapRendererFieldName, i6 = (e11, t13) => e11 + (t13.attributes[r6] ?? 0);
    return e10.reduce(i6, 0) - t12.reduce(i6, 0);
  }
  _clampSearchRadius(e10) {
    return e10 > $ && z3.warnOnce(`SceneView supports a maximum radius of ${$} pt for HeatmapRenderer.`), Math.min(e10, $);
  }
  _updateFeatureVisibilities(e10) {
    const t12 = [];
    this._featureStore.forEach(({ objectId: r6, displayId: i6 }) => {
      const a9 = e10(r6), s10 = this._renderGeometries.get(i6);
      s10 && s10.visible !== a9 && (t12.push(s10), s10.visible = a9);
    }), this._drapeSourceRenderer.modifyGeometries(t12, I4.VISIBILITY);
  }
  _setAllFeaturesVisibility(e10) {
    const t12 = [];
    for (const r6 of this._renderGeometries.values())
      r6.visible !== e10 && (t12.push(r6), r6.visible = e10);
    this._drapeSourceRenderer.modifyGeometries(t12, I4.VISIBILITY);
  }
  get test() {
    return { visibleFeatureCount: this._visibleFeatures };
  }
};
e([y()], q3.prototype, "type", void 0), e([y({ constructOnly: true })], q3.prototype, "owner", void 0), e([y()], q3.prototype, "layer", null), e([y()], q3.prototype, "featureStore", null), e([y()], q3.prototype, "updating", null), e([y()], q3.prototype, "updatingRemaining", null), e([y()], q3.prototype, "suspendInfo", null), e([y()], q3.prototype, "legendEnabled", null), e([y()], q3.prototype, "filterVisibility", null), e([y()], q3.prototype, "displayFeatureLimit", null), e([y()], q3.prototype, "preferredUpdatePolicy", void 0), e([y()], q3.prototype, "hasZ", null), e([y()], q3.prototype, "hasM", null), e([y()], q3.prototype, "dataExtent", void 0), e([y()], q3.prototype, "view", null), e([y()], q3.prototype, "fullOpacity", null), e([y()], q3.prototype, "updatePolicy", null), e([y()], q3.prototype, "drapeSourceType", void 0), e([y()], q3.prototype, "scaleVisibilitySuspended", null), e([y()], q3.prototype, "renderer", null), e([y()], q3.prototype, "_featureStore", void 0), e([y()], q3.prototype, "_filterVisibility", void 0), e([y()], q3.prototype, "_overlayRenderer", null), e([y()], q3.prototype, "_overlaySpatialReference", null), e([y()], q3.prototype, "_rendererParameters", null), e([y()], q3.prototype, "_materialParameters", null), e([y()], q3.prototype, "_densityParameters", null), e([y()], q3.prototype, "_radiusParameter", null), e([y()], q3.prototype, "_resolutionForScaleParameter", null), e([y()], q3.prototype, "_colorRampParameter", null), e([y()], q3.prototype, "_pixelRatioParameter", null), e([y()], q3.prototype, "_densityMapPixelRatio", null), e([y()], q3.prototype, "_renderGeometries", void 0), e([y()], q3.prototype, "_material", void 0), e([y()], q3.prototype, "_materialWithField", void 0), e([y()], q3.prototype, "_renderView", null), e([y()], q3.prototype, "_featuresArePoints", null), e([y()], q3.prototype, "_loadedPointGraphics", null), e([y()], q3.prototype, "_heatmapRenderer", null), e([y()], q3.prototype, "_heatmapRendererFieldName", null), e([y()], q3.prototype, "_heatmapRendererField", null), e([y()], q3.prototype, "_heatmapRendererFieldIsNumeric", null), e([y()], q3.prototype, "_fieldTotal", void 0), e([y()], q3.prototype, "_drapeSourceRenderer", void 0), e([y()], q3.prototype, "_isScaleRangeActive", null), q3 = e([a2(Z)], q3);
var k3 = e3();

// node_modules/@arcgis/core/views/3d/layers/FeatureLikeLayerView3D.js
var E8 = (E9) => {
  let v5 = class extends E9 {
    constructor() {
      super(...arguments), this.controller = null, this.updatePolicy = C.SYNC, this.suspendResumeExtentMode = "computed", this.slicePlaneEnabled = false, this.fullExtentInLocalViewSpatialReference = null, this.suspendResumeExtent = null, this._controllerCreated = false, this.supportsHeightUnitConversion = true, this._pendingController = null, this.queryEngine = null;
    }
    initialize() {
      const e10 = this.layer;
      if ("isTable" in e10 && e10.isTable)
        return void this.addResolvingPromise(Promise.reject(new s2("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: e10 })));
      this.addResolvingPromise(this._validateGeometryType()), this.updatingHandles.add(() => this.layer.renderer, (e11) => this._recreateProcessor(e11), h), this.addResolvingPromise((async () => {
        const e11 = await l4(this);
        this.fullExtentInLocalViewSpatialReference = e11, await this._initializeController();
      })()), this.updatingHandles.add(() => this.updatePolicy, (e11) => this.processor.preferredUpdatePolicy = e11);
      const t12 = () => this.processor.featureStore;
      this.queryEngine = new c10({ context: { spatialReference: this.view.spatialReference, layer: this.layer, scheduler: this.view.resourceController.scheduler, get featureStore() {
        return t12();
      }, hasZ: this.hasZ, hasM: this.hasM }, priority: I2.FEATURE_QUERY_ENGINE }), this.notifyChange("updating");
    }
    destroy() {
      this._destroyPendingController(), this.controller = l(this.controller), this._set("processor", l(this.processor)), this.queryEngine = l(this.queryEngine), this.loadedGraphics = null;
    }
    _destroyPendingController() {
      this._pendingController = l(this._pendingController);
    }
    get legendEnabled() {
      var _a;
      return this.canResume() && ((_a = this.processor) == null ? void 0 : _a.legendEnabled);
    }
    get graphics3DProcessor() {
      var _a;
      return "graphics-3d" === ((_a = this.processor) == null ? void 0 : _a.type) ? this.processor : null;
    }
    get heatmapProcessor() {
      var _a;
      return "heatmap" === ((_a = this.processor) == null ? void 0 : _a.type) ? this.processor : null;
    }
    get symbologySnappingSupported() {
      var _a, _b;
      const e10 = (_b = (_a = this.layer) == null ? void 0 : _a.renderer) == null ? void 0 : _b.getSymbols();
      return (e10 == null ? void 0 : e10.some(N2)) ?? false;
    }
    getHit(e10) {
      var _a;
      let r6;
      return (_a = this.loadedGraphics) == null ? void 0 : _a.forEach((t12) => {
        t12.uid === e10 && (r6 = c9(t12, this.layer));
      }), r6 ? { type: "graphic", graphic: r6, layer: r6.layer } : null;
    }
    whenGraphicBounds(e10, r6) {
      var _a;
      return (_a = this.processor) == null ? void 0 : _a.whenGraphicBounds(e10, r6);
    }
    computeAttachmentOrigin(e10, r6) {
      var _a;
      return (_a = this.processor) == null ? void 0 : _a.computeAttachmentOrigin(e10, r6);
    }
    async elevationAlignPointsInFeatures(e10, t12) {
      const s10 = this.graphics3DProcessor;
      if (null == s10)
        throw new s2("featurelayerview3d:missing-processor", "A Graphics3D processor is needed to resolve graphics elevation.");
      return f5(this.view, this.layer, (e11) => s10.getGraphics3DGraphicByObjectId(e11), e10, t12);
    }
    async queryForSymbologySnapping(e10, r6) {
      return this.symbologySnappingSupported ? r4(this.graphics3DProcessor, e10, r6) : { candidates: [], sourceCandidateIndices: [] };
    }
    queryFeatures(e10, r6) {
      return this.queryEngine.executeQuery(this._ensureQuery(e10), r6 == null ? void 0 : r6.signal);
    }
    queryObjectIds(e10, r6) {
      return this.queryEngine.executeQueryForIds(this._ensureQuery(e10), r6 == null ? void 0 : r6.signal);
    }
    queryFeatureCount(e10, r6) {
      return this.queryEngine.executeQueryForCount(this._ensureQuery(e10), r6 == null ? void 0 : r6.signal);
    }
    queryExtent(e10, r6) {
      return this.queryEngine.executeQueryForExtent(this._ensureQuery(e10), r6 == null ? void 0 : r6.signal);
    }
    _ensureQuery(e10) {
      return null == e10 ? this.createQuery() : b2.from(e10);
    }
    highlight(e10) {
      return this.processor.highlight(e10, this.layer.objectIdField);
    }
    maskOccludee(e10) {
      return this.processor.maskOccludee(e10);
    }
    canResume() {
      var _a;
      return super.canResume() && !((_a = this.processor) == null ? void 0 : _a.scaleVisibilitySuspended);
    }
    getSuspendInfo() {
      const e10 = super.getSuspendInfo();
      return this.processor ? { ...e10, ...this.processor.suspendInfo } : e10;
    }
    isUpdating() {
      var _a, _b, _c;
      return !(!this.processor || this.processor.destroyed) && !(this._controllerCreated && !((_a = this.controller) == null ? void 0 : _a.updating) && ((_c = (_b = this.view) == null ? void 0 : _b.basemapTerrain) == null ? void 0 : _c.ready) && !this.processor.updating);
    }
    async _initializeController() {
      const e10 = this.createController();
      this._pendingController = e10, await e10.when(), this._setControllerWhenInitialized(e10);
    }
    async _setControllerWhenInitialized(e10) {
      try {
        await this.when();
      } catch (r6) {
      }
      this._controllerCreated = true, this.notifyChange("updating"), this.isResolved() && !this.destroyed ? (await j3(() => {
        var _a, _b;
        return (_b = (_a = this.view) == null ? void 0 : _a.basemapTerrain) == null ? void 0 : _b.ready;
      }), this.beforeSetController(e10), this._pendingController = null, this.controller = e10, this.loadedGraphics = e10.graphics, this.notifyChange("updating")) : this._destroyPendingController();
    }
    _updateClippingExtent(e10) {
      if (this.clippingExtent = e10, !this.controller)
        return false;
      switch (this.controller.type) {
        case "stream":
          return false;
        case "feature-tile-3d":
          return this.controller.extent = e10, true;
      }
    }
    async _validateGeometryType() {
      switch (this.layer.geometryType) {
        case "multipatch":
        case "multipoint":
          throw new s2("featurelayerview3d:unsupported-geometry-type", "Unsupported geometry type ${geometryType}", { geometryType: this.layer.geometryType });
      }
    }
    _recreateProcessor(e10) {
      var _a, _b;
      const r6 = "heatmap" === (e10 == null ? void 0 : e10.type), t12 = "heatmap" === ((_a = this.processor) == null ? void 0 : _a.type), s10 = this.processor;
      if (s10 && r6 === t12)
        return;
      const o5 = r6 ? new q3({ owner: this }) : new _5({ owner: this, frustumVisibilityEnabled: true, scaleVisibilityEnabled: true, filterVisibilityEnabled: true, timeExtentEnabled: true, elevationAlignmentEnabled: true, elevationFeatureExpressionEnabled: true, preferredUpdatePolicy: this.updatePolicy, updateClippingExtent: (e11) => this._updateClippingExtent(e11) });
      this._set("processor", o5), s10 == null ? void 0 : s10.destroy(), (_b = this.queryEngine) == null ? void 0 : _b.clear(), this.addResolvingPromise(o5.initializePromise);
    }
    _getResourceInfo() {
      var _a;
      const e10 = this.controller instanceof I6 ? this.controller : null;
      return { displayedNumberOfFeatures: (_a = this.loadedGraphics) == null ? void 0 : _a.length, maximumNumberOfFeatures: (e10 == null ? void 0 : e10.maximumNumberOfFeatures) ?? -1, totalNumberOfFeatures: (e10 == null ? void 0 : e10.serviceDataCount) ?? -1, nodes: 0, ...this.processor.performanceInfo };
    }
    get performanceInfo() {
      return this._getResourceInfo();
    }
  };
  return e([y()], v5.prototype, "loadedGraphics", void 0), e([y()], v5.prototype, "suspended", void 0), e([y({ readOnly: true })], v5.prototype, "legendEnabled", null), e([y()], v5.prototype, "updating", void 0), e([y()], v5.prototype, "controller", void 0), e([y()], v5.prototype, "processor", void 0), e([y({ readOnly: true })], v5.prototype, "updatePolicy", void 0), e([y({ readOnly: true })], v5.prototype, "suspendResumeExtentMode", void 0), e([y({ type: Boolean })], v5.prototype, "slicePlaneEnabled", void 0), e([y({ readOnly: true })], v5.prototype, "suspendInfo", void 0), e([y()], v5.prototype, "graphics3DProcessor", null), e([y()], v5.prototype, "heatmapProcessor", null), e([y()], v5.prototype, "symbologySnappingSupported", null), v5 = e([a2("esri.views.3d.layers.FeatureLikeLayerView3D")], v5), v5;
};

export {
  A2 as A,
  I6 as I,
  n10 as n,
  c10 as c,
  _5 as _,
  E8 as E
};
//# sourceMappingURL=chunk-UK4ZDRLR.js.map
