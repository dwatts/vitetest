import {
  m as m2,
  p
} from "./chunk-RZONPIMD.js";
import {
  m
} from "./chunk-FAU6BZC4.js";
import {
  U,
  b,
  w,
  x,
  z
} from "./chunk-JPKFB2QL.js";
import {
  E,
  M,
  O as O2,
  R,
  _,
  h as h2,
  j as j2,
  v as v2
} from "./chunk-KSBQD24F.js";
import {
  o as o2,
  t as t2
} from "./chunk-UM64E5NS.js";
import {
  n as n2,
  r as r2
} from "./chunk-2SZNVP5H.js";
import {
  c as c2
} from "./chunk-NETCTS4Y.js";
import {
  v
} from "./chunk-OKABUMQT.js";
import {
  e as e4,
  o
} from "./chunk-CW7LIPBH.js";
import {
  e as e5
} from "./chunk-TYOIANOD.js";
import {
  e as e3
} from "./chunk-VN2IXVGV.js";
import {
  g
} from "./chunk-JB7FDW5N.js";
import {
  Cn,
  yn,
  zn
} from "./chunk-BNBT4QTW.js";
import {
  B,
  C,
  P,
  c,
  f as f2,
  h
} from "./chunk-7EG7BYWF.js";
import {
  F,
  O
} from "./chunk-TPJLFGOT.js";
import {
  e as e2,
  f,
  n,
  r,
  t
} from "./chunk-CQX57DED.js";
import {
  W,
  j
} from "./chunk-RTDN6KAT.js";
import {
  l
} from "./chunk-MP6GH2AC.js";
import {
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";

// node_modules/@arcgis/core/geometry/support/MeshTransform.js
var v3;
var b2 = v3 = class extends l {
  constructor(t3) {
    super(t3), this.translation = n(), this.rotationAxis = e2(z), this.rotationAngle = 0, this.scale = r(1, 1, 1);
  }
  get rotation() {
    return U(this.rotationAxis, this.rotationAngle);
  }
  set rotation(t3) {
    this.rotationAxis = t(x(t3)), this.rotationAngle = b(t3);
  }
  get localMatrix() {
    const t3 = e4();
    return v(M2, x(this.rotation), w(this.rotation)), P(t3, M2, this.translation, this.scale), t3;
  }
  get localMatrixInverse() {
    return h(e4(), this.localMatrix);
  }
  applyLocal(t3, o4) {
    return O(o4, t3, this.localMatrix);
  }
  applyLocalInverse(t3, o4) {
    return O(o4, t3, this.localMatrixInverse);
  }
  equals(t3) {
    return this === t3 || null != t3 && B(this.localMatrix, t3.localMatrix);
  }
  clone() {
    const t3 = { translation: t(this.translation), rotationAxis: t(this.rotationAxis), rotationAngle: this.rotationAngle, scale: t(this.scale) };
    return new v3(t3);
  }
};
e([y({ type: [Number], nonNullable: true, json: { write: true } })], b2.prototype, "translation", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], b2.prototype, "rotationAxis", void 0), e([y({ type: Number, nonNullable: true, json: { write: true } })], b2.prototype, "rotationAngle", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], b2.prototype, "scale", void 0), e([y()], b2.prototype, "rotation", null), e([y()], b2.prototype, "localMatrix", null), e([y()], b2.prototype, "localMatrixInverse", null), b2 = v3 = e([a("esri.geometry.support.MeshTransform")], b2);
var M2 = e5();
var N = b2;

// node_modules/@arcgis/core/geometry/support/meshUtils/geographicUtils.js
function r3(e6, r4) {
  return e6.isGeographic || e6.isWebMercator && ((r4 == null ? void 0 : r4.geographic) ?? true);
}
function o3(r4, o4, g2) {
  const i = !r4.isGeoreferenced;
  null != (g2 == null ? void 0 : g2.geographic) && g2.geographic !== i && s.getLogger(o4).warnOnce(`Specifying the 'geographic' parameter (${g2.geographic}) for a Mesh vertex space of type "${r4.type}" is not supported. This parameter will be ignored.`);
}

// node_modules/@arcgis/core/geometry/support/meshUtils/georeference.js
function O3(n3, t3, e6) {
  return r3(t3.spatialReference, e6) ? Z(n3, t3, e6) : L(n3, t3, e6);
}
function T(n3, t3, e6, r4) {
  const { position: o4, normal: i, tangent: a2 } = n3;
  if (!t3.isRelative)
    return { position: o4, normal: i, tangent: a2 };
  const l2 = (e6 == null ? void 0 : e6.localMatrix) ?? o;
  return O3({ position: r2(new Float64Array(o4.length), o4, l2), normal: null != i ? M(i, new Float32Array(i.length), l2) : null, tangent: null != a2 ? O2(a2, new Float32Array(a2.length), l2) : null }, t3.getOriginPoint(r4), { geographic: !t3.isGeoreferenced });
}
function q(n3, t3, e6) {
  if (e6 == null ? void 0 : e6.useTransform) {
    const { position: r4, normal: o4, tangent: i } = n3, { x: a2, y: s2, z: l2 } = t3, c3 = r(a2, s2, l2 ?? 0);
    return { vertexAttributes: { position: r4, normal: o4, tangent: i }, vertexSpace: e6.geographic ?? 1 ? new m2({ origin: c3 }) : new m({ origin: c3 }), transform: new N() };
  }
  return { vertexAttributes: O3(n3, t3, e6), vertexSpace: new p(), transform: null };
}
function D(n3, t3, e6) {
  return r3(t3.spatialReference, e6) ? K(n3, t3, e6) : J(n3, t3, e6);
}
function E2(n3, t3, e6, r4, o4) {
  if (!t3.isRelative)
    return D(n3, r4, o4);
  const { spatialReference: i } = r4, a2 = T(n3, t3, e6, i);
  return r4.equals(t3.getOriginPoint(i)) ? J(a2, r4, o4) : D(a2, r4, o4);
}
function I({ positions: n3, transform: t3, vertexSpace: e6, inSpatialReference: i, outSpatialReference: a2, outPositions: l2, local: f3 }) {
  const p2 = e6.isRelative ? e6.origin : f, w2 = e6.isRelative ? (t3 == null ? void 0 : t3.localMatrix) ?? o : o;
  if (e6.isGeoreferenced) {
    const t4 = l2 ?? t2(n3.length);
    if (C(w2, o) ? o2(t4, n3) : r2(t4, n3, w2), !F(p2, f)) {
      const [n4, e7, r4] = p2;
      for (let o4 = 0; o4 < t4.length; o4 += 3)
        t4[o4] += n4, t4[o4 + 1] += e7, t4[o4 + 2] += r4;
    }
    return yn(t4, i, 0, t4, a2, 0, t4.length / 3), t4;
  }
  const A = c2(i), x2 = !f3 && Cn(i, A) ? A : i;
  zn(i, p2, $, x2), c($, $, w2);
  const v4 = l2 ?? t2(n3.length);
  return r2(v4, n3, $), yn(v4, x2, 0, v4, a2, 0, v4.length / 3), v4;
}
function L(n3, t3, e6) {
  const r4 = new Float64Array(n3.position.length), o4 = n3.position, i = t3.x, a2 = t3.y, s2 = t3.z ?? 0, l2 = Y(e6 ? e6.unit : null, t3.spatialReference);
  for (let c3 = 0; c3 < o4.length; c3 += 3)
    r4[c3] = o4[c3] * l2 + i, r4[c3 + 1] = o4[c3 + 1] * l2 + a2, r4[c3 + 2] = o4[c3 + 2] * l2 + s2;
  return { position: r4, normal: n3.normal, tangent: n3.tangent };
}
function Z(n3, t3, e6) {
  const r4 = t3.spatialReference, o4 = N2(t3, e6, $), i = new Float64Array(n3.position.length), a2 = B2(n3.position, o4, r4, i), s2 = g(nn, o4);
  return { position: a2, normal: C2(a2, i, n3.normal, s2, r4), tangent: H(a2, i, n3.tangent, s2, r4) };
}
function B2(n3, t3, e6, r4) {
  r2(r4, n3, t3);
  const o4 = new Float64Array(n3.length);
  return E(r4, o4, e6);
}
function C2(n3, t3, e6, r4, o4) {
  if (null == e6)
    return null;
  const i = new Float32Array(e6.length);
  return n2(i, e6, r4), j2(i, n3, t3, o4, i), i;
}
function H(n3, t3, e6, r4, o4) {
  if (null == e6)
    return null;
  const i = new Float32Array(e6.length);
  n2(i, e6, r4, 4);
  for (let a2 = 3; a2 < i.length; a2 += 4)
    i[a2] = e6[a2];
  return v2(i, n3, t3, o4, i), i;
}
function J(n3, t3, e6) {
  const r4 = new Float64Array(n3.position.length), o4 = n3.position, i = t3.x, a2 = t3.y, s2 = t3.z ?? 0, l2 = Y(e6 ? e6.unit : null, t3.spatialReference);
  for (let c3 = 0; c3 < o4.length; c3 += 3)
    r4[c3] = (o4[c3] - i) / l2, r4[c3 + 1] = (o4[c3 + 1] - a2) / l2, r4[c3 + 2] = (o4[c3 + 2] - s2) / l2;
  return { position: r4, normal: n3.normal, tangent: n3.tangent };
}
function K(n3, t3, e6) {
  const r4 = t3.spatialReference;
  N2(t3, e6, $);
  const o4 = h(_2, $), a2 = new Float64Array(n3.position.length), s2 = Q(n3.position, r4, o4, a2), l2 = g(nn, o4);
  return { position: s2, normal: W2(n3.normal, n3.position, a2, r4, l2), tangent: X(n3.tangent, n3.position, a2, r4, l2) };
}
function N2(n3, t3, e6) {
  zn(n3.spatialReference, [n3.x, n3.y, n3.z ?? 0], e6, c2(n3.spatialReference));
  const r4 = Y(t3 ? t3.unit : null, n3.spatialReference);
  return f2(e6, e6, [r4, r4, r4]), e6;
}
function Q(n3, t3, e6, r4) {
  const o4 = h2(n3, t3, r4), i = new Float64Array(o4.length);
  return r2(i, o4, e6), i;
}
function W2(n3, t3, e6, r4, o4) {
  if (null == n3)
    return null;
  const i = _(n3, t3, e6, r4, new Float32Array(n3.length));
  return n2(i, i, o4), i;
}
function X(n3, t3, e6, r4, o4) {
  if (null == n3)
    return null;
  const i = R(n3, t3, e6, r4, new Float32Array(n3.length));
  return n2(i, i, o4, 4), i;
}
function Y(e6, r4) {
  if (null == e6)
    return 1;
  const o4 = W(r4);
  return 1 / j(o4, "meters", e6);
}
var $ = e4();
var _2 = e4();
var nn = e3();

export {
  N,
  r3 as r,
  o3 as o,
  O3 as O,
  T,
  q,
  D,
  E2 as E,
  I
};
//# sourceMappingURL=chunk-NJB7437O.js.map
