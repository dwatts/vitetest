import {
  d as d2,
  o as o2
} from "./chunk-5XCEDULD.js";
import {
  F,
  U
} from "./chunk-DB3QP4OO.js";
import {
  c
} from "./chunk-Y3PBROKK.js";
import "./chunk-SCHIU6CT.js";
import {
  M,
  i,
  t
} from "./chunk-V33FVMPT.js";
import "./chunk-U67EYFX3.js";
import "./chunk-XKYCNHCM.js";
import "./chunk-YEDW7SLL.js";
import {
  E
} from "./chunk-6LC2JTLC.js";
import {
  h
} from "./chunk-73PNWDTS.js";
import {
  k,
  l as l2
} from "./chunk-3LLZ72VA.js";
import "./chunk-4SIKLJSS.js";
import {
  I,
  N,
  O
} from "./chunk-BCDDCNQ2.js";
import "./chunk-3TTW7E7W.js";
import "./chunk-FOEAKQNX.js";
import "./chunk-LEDSC236.js";
import "./chunk-NETCTS4Y.js";
import "./chunk-OKABUMQT.js";
import "./chunk-CW7LIPBH.js";
import "./chunk-TYOIANOD.js";
import "./chunk-VN2IXVGV.js";
import "./chunk-WWUAHPIM.js";
import "./chunk-YGUWDSEH.js";
import {
  n as n2
} from "./chunk-63ERNIOV.js";
import "./chunk-LVVQ2RQY.js";
import {
  l as l3
} from "./chunk-RVS5HU2K.js";
import "./chunk-JB7FDW5N.js";
import "./chunk-SS3YG6J3.js";
import {
  h as h2
} from "./chunk-XWGNMTES.js";
import "./chunk-6NNEHJYI.js";
import "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-JNDFAMXY.js";
import "./chunk-NTEKJWGF.js";
import "./chunk-TFIKV5RU.js";
import "./chunk-KW6QQDGN.js";
import "./chunk-AQ7R6V4L.js";
import "./chunk-DOQ3SAAR.js";
import "./chunk-4BXK4H4L.js";
import "./chunk-SLVNG7FV.js";
import "./chunk-DEZCXTA3.js";
import "./chunk-RRJGZKNX.js";
import "./chunk-PL5Q4C6Y.js";
import "./chunk-KFSY6ZZH.js";
import "./chunk-7EQSYZHW.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import "./chunk-4OR73Y2R.js";
import "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import {
  x
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-Z2ZUNW5S.js";
import "./chunk-7L7Z2HXM.js";
import "./chunk-75NKPXTR.js";
import "./chunk-EUVARFSM.js";
import "./chunk-3VUFACNT.js";
import "./chunk-ZEEBL7ZN.js";
import "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-SJ2GJCS2.js";
import {
  l
} from "./chunk-H7RDAEPY.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-7KH4CLS5.js";
import {
  a
} from "./chunk-WCHO7VLT.js";
import "./chunk-JL3TJGVW.js";
import "./chunk-JZM5YUHA.js";
import {
  j
} from "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import "./chunk-V76KGJFU.js";
import "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import {
  d
} from "./chunk-7I33FAWS.js";
import {
  o
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  has
} from "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/libs/vxl/enums.js
var e;
var i2;
var t2;
var n3;
var a2;
var o3;
!function(e3) {
  e3[e3.Binary = 0] = "Binary", e3[e3.JSON = 1] = "JSON";
}(e || (e = {})), function(e3) {
  e3[e3.TreeIndex = 0] = "TreeIndex", e3[e3.TreeStats = 1] = "TreeStats", e3[e3.TreeData = 2] = "TreeData", e3[e3.BrickBundles = 3] = "BrickBundles", e3[e3.Section = 4] = "Section", e3[e3.VariableStats = 5] = "VariableStats";
}(i2 || (i2 = {})), function(e3) {
  e3[e3.None = 1] = "None", e3[e3.Front = 2] = "Front", e3[e3.Back = 3] = "Back";
}(t2 || (t2 = {})), function(e3) {
  e3[e3.Low = 0] = "Low", e3[e3.Medium = 1] = "Medium", e3[e3.High = 2] = "High";
}(n3 || (n3 = {})), function(e3) {
  e3[e3.None = 0] = "None", e3[e3.StaticSections = 1] = "StaticSections", e3[e3.Slices = 2] = "Slices", e3[e3.DynamicSections = 4] = "DynamicSections", e3[e3.GhostShell = 8] = "GhostShell", e3[e3.Isosurface = 16] = "Isosurface", e3[e3.Quality = 32] = "Quality", e3[e3.SunLocation = 64] = "SunLocation", e3[e3.StaticSectionSelection = 128] = "StaticSectionSelection", e3[e3.ExaggerationAndOffset = 256] = "ExaggerationAndOffset", e3[e3.CurrentTime = 512] = "CurrentTime", e3[e3.CurrentVariable = 1024] = "CurrentVariable", e3[e3.DeleteIsosurface = 2048] = "DeleteIsosurface", e3[e3.ContainerVisibility = 4096] = "ContainerVisibility", e3[e3.RenderMode = 8192] = "RenderMode", e3[e3.Optimization = 16384] = "Optimization", e3[e3.VariableStyles = 32768] = "VariableStyles", e3[e3.VolumeStyles = 65536] = "VolumeStyles", e3[e3.AnalysisSlice = 131072] = "AnalysisSlice";
}(a2 || (a2 = {})), function(e3) {
  e3[e3.Isosurfaces = 0] = "Isosurfaces", e3[e3.DynamicSections = 1] = "DynamicSections", e3[e3.StaticSections = 2] = "StaticSections";
}(o3 || (o3 = {}));

// node_modules/@arcgis/core/libs/vxl/VxlModule.js
function e2(t3) {
  return new Promise((e3) => import("./vxlLayer-3MB246MJ.js").then((t4) => t4.v).then(({ default: n4 }) => {
    const r = n4({ locateFile: i3, preinitializedWebGLContext: t3, onRuntimeInitialized: () => e3(r) });
  })).catch((t4) => {
    throw t4;
  });
}
function i3(e3) {
  return a(`esri/libs/vxl/${e3}`);
}

// node_modules/@arcgis/core/layers/VoxelWasmPerSceneView.js
var S = s.getLogger("esri.layers.VoxelWasmPerSceneView");
var P;
!function(e3) {
  e3[e3.Lifetime = 1] = "Lifetime", e3[e3.RequestResponse = 2] = "RequestResponse", e3[e3.Rendering = 3] = "Rendering", e3[e3.Error = 4] = "Error";
}(P || (P = {}));
var U2 = class {
  constructor(e3) {
    this._halfIntTexturesAvailable = false, this._textureFloatLinearAvailable = false, this._havePreparedWithAllLayers = false, this._readyWatchHandle = null, this._qualityWatchHandle = null, this._stationaryWatchHandle = null, this._timeExtentWatchHandle = null, this._renderPluginContext = null, this._vxlPromise = null, this._vxl = null, this._pluginIsActive = false, this._moreToLoad = false, this._viewportWidth = -1, this._viewportHeight = -1, this._newLayers = [], this._layers = /* @__PURE__ */ new Map(), this._shaderOutput = h.Color, this._renderSlot = E.VOXEL, this._rctx = null, this._renderTargetToRestore = null, this._lastFrameWasStationary = false, this._wasmMemBlockSizes = [512, 1024, 2048, 4096, 8192, 16384, 32768, 65536], this._wasmMemBlocks = /* @__PURE__ */ new Map(), this._dbgFlags = /* @__PURE__ */ new Set(), this._captureFrustum = false, this._frustum = null, this._frustumRenderableId = -1, this._renderCoordsHelper = null, this.type = i.VOXEL, this.slicePlaneEnabled = true, this.isGround = false, this.layerUid = [], this._view = e3, this._initialize();
  }
  get canRender() {
    return !!this._vxl && "local" === this._view.viewingMode;
  }
  _dbg(e3, t3) {
    this._dbgFlags.has(e3) && (e3 === P.Error ? S.error(t3) : S.warn(t3));
  }
  _removeRenderPlugin() {
    this._pluginIsActive && this._view._stage && (this._dbg(P.Lifetime, "--removeRenderPlugin--"), this._view._stage.removeRenderPlugin(this)), this._pluginIsActive = false;
  }
  _initialize() {
    this._dbg(P.Lifetime, "--initialize--");
    for (const e3 of this._wasmMemBlockSizes)
      this._wasmMemBlocks.set(e3, 0);
    this._readyWatchHandle = l(() => this._view.ready, (e3) => {
      e3 && "local" === this._view.viewingMode ? (this._dbg(P.Lifetime, "view ready status changed to ready on a local view, calling addRenderPlugin"), this._view._stage.addRenderPlugin([this._renderSlot], this), this._pluginIsActive = true) : (this._dbg(P.Lifetime, "view ready status changed, not ready or not a local view!"), this._removeRenderPlugin());
    }, { initial: true }), this._qualityWatchHandle = l(() => {
      var _a;
      return (_a = this._view) == null ? void 0 : _a.qualityProfile;
    }, (e3) => {
      this._dbg(P.Rendering, "qualityProfile changed to " + e3), this._vxl && this._vxl.set_quality(this._toWasmQuality(e3));
    }, { initial: true }), this._timeExtentWatchHandle = l(() => {
      var _a;
      return (_a = this._view) == null ? void 0 : _a.timeExtent;
    }, () => {
      var _a;
      if (this._vxl) {
        const e3 = this._getTimeArgs((_a = this._view) == null ? void 0 : _a.timeExtent);
        this._dbg(P.Rendering, "sceneView timeExtent changed to useTime=" + e3.useTime + " st=" + e3.startTime + " et=" + e3.endTime), this._vxl.set_scene_time_extent(e3.startTime, e3.endTime, e3.useTime), this._renderPluginContext.requestRender();
      }
    }, { initial: true }), this._stationaryWatchHandle = l(() => {
      var _a;
      return (_a = this._view) == null ? void 0 : _a.stationary;
    }, (e3) => {
      this._vxl && e3 && !this._lastFrameWasStationary && this._renderPluginContext.requestRender();
    });
  }
  initializeRenderContext(e3) {
    this._dbg(P.Lifetime, "--initializeRenderContext--");
    const t3 = e3.renderContext.rctx;
    t3.type === n2.WEBGL2 ? (this._renderPluginContext = e3, this._rctx = e3.renderContext.rctx, this._halfIntTexturesAvailable = !!this._rctx.capabilities.textureNorm16, this._textureFloatLinearAvailable = this._rctx.capabilities.textureFloatLinear, this._initializeWasm(t3.gl)) : this._dbg(P.Error, "WebGL 1 context only!");
  }
  uninitializeRenderContext() {
    this._renderPluginContext = null, this._rctx = null, this._dbg(P.Lifetime, "--uninitializeRenderContext--");
  }
  _restoreFramebuffer() {
    if (!this._renderTargetToRestore)
      return;
    const e3 = this._renderTargetToRestore.fbo;
    if (!!!this._rctx)
      return void this._dbg(P.Error, "no context in restoreFramebuffer!");
    this._rctx.bindFramebuffer(e3, true);
    const t3 = this._renderTargetToRestore.viewport;
    this._rctx.setViewport(t3.x, t3.y, t3.width, t3.height);
  }
  _bindPreviousDepthToSlot(e3, t3) {
    const i4 = !!this._rctx, s2 = !!this._renderTargetToRestore;
    if (!i4 || !s2)
      return 0;
    const r = this._renderTargetToRestore.fbo.depthStencilTexture;
    return r ? (0 === t3 ? this._rctx.bindTexture(null, e3, true) : this._rctx.bindTexture(r, e3, true), 1) : (this._dbg(P.Error, "no depth/stencil texture exists!"), 0);
  }
  _modifyResourceCount(e3, t3, i4) {
    if (!this._rctx)
      return void this._dbg(P.Error, "modifyAllocation callback has no rendering context!");
    const s2 = e3;
    1 === i4 ? this._rctx.instanceCounter.increment(s2, t3) : this._rctx.instanceCounter.decrement(s2, t3);
  }
  _setBlendState(e3, t3, i4, s2) {
    this._rctx ? (this._rctx.setBlendingEnabled(1 === e3), this._rctx.setBlendFunction(t3, i4), this._rctx.setBlendEquation(s2)) : this._dbg(P.Error, "setBlendState callback has no rendering context!");
  }
  _setFrontFace(e3) {
    this._rctx ? this._rctx.setFrontFace(e3) : this._dbg(P.Error, "setFrontFace callback has no rendering context!");
  }
  _setDepthStencilStateFunction(e3, t3, i4) {
    this._rctx ? (this._rctx.setDepthFunction(i4), this._rctx.setDepthTestEnabled(1 === e3), this._rctx.setDepthWriteEnabled(1 === t3), this._rctx.setStencilTestEnabled(false), this._rctx.setStencilFunction(I.ALWAYS, 0, 255), this._rctx.setStencilOpSeparate(N.FRONT, O.KEEP, O.INCR, O.KEEP), this._rctx.setStencilOpSeparate(N.BACK, O.KEEP, O.DECR, O.KEEP)) : this._dbg(P.Error, "setDepthStencilStateFunction callback has no rendering context!");
  }
  _setRasterizerState(e3) {
    if (this._rctx)
      switch (e3) {
        case t2.None:
          this._rctx.setFaceCullingEnabled(false);
          break;
        case t2.Back:
          this._rctx.setCullFace(N.BACK), this._rctx.setFaceCullingEnabled(true);
          break;
        case t2.Front:
          this._rctx.setCullFace(N.FRONT), this._rctx.setFaceCullingEnabled(true);
      }
    else
      this._dbg(P.Error, "setRasterizerState callback has no rendering context!");
  }
  _setViewport(e3, t3, i4, s2) {
    this._rctx ? this._rctx.setViewport(e3, t3, i4, s2) : this._dbg(P.Error, "setViewport callback has no rendering context!");
  }
  _updateMemoryUsage() {
    this._layers.forEach((e3, t3) => {
      if (e3.needMemoryUsageUpdate) {
        const i4 = this._vxl.estimate_memory_usage(t3);
        i4 >= 0 && (e3.needMemoryUsageUpdate = false, e3.layerView.setUsedMemory(i4));
      }
    });
  }
  _syncRequestsResponses() {
    this._layers.forEach((e3, i4) => {
      const s2 = [];
      e3.responses.forEach((t3, r) => {
        s2.push(r), this._dbg(P.RequestResponse, "responding for requestID:" + r + " size:" + t3.size), this._vxl.respond(i4, r, t3), t3.requestType !== i2.TreeIndex && t3.requestType !== i2.Section || (e3.needMemoryUsageUpdate = true);
      });
      const a3 = e3.responses;
      for (const t3 of s2)
        a3.delete(t3);
      const n4 = this._vxl.get_new_requests(i4), o4 = e3.abortController.signal;
      for (const l4 in n4) {
        e3.outstandingRequestCount += 1, 1 === e3.outstandingRequestCount && e3.layerView.updatingFlagChanged();
        const i5 = n4[l4], s3 = { responseType: "array-buffer", signal: o4 };
        this._dbg(P.RequestResponse, "making requestID:" + l4 + " url:" + i5.url), j(i5.url, s3).then((t3) => {
          e3.outstandingRequestCount -= 1, 0 === e3.outstandingRequestCount && e3.layerView.updatingFlagChanged(), this._dbg(P.RequestResponse, "have response for requestID:" + l4);
          let s4 = 0;
          if (t3.data.byteLength > 0) {
            s4 = this._vxl._malloc(t3.data.byteLength);
            const e4 = new Uint8Array(this._vxl.HEAPU8.buffer, s4, t3.data.byteLength), i6 = new Uint8Array(t3.data);
            for (let s5 = 0; s5 < t3.data.byteLength; ++s5)
              e4[s5] = i6[s5];
          }
          a3.set(+l4, { responseType: i5.responseType, ptr: s4, size: t3.data.byteLength, success: true, requestType: i5.requestType });
        }).catch((t3) => {
          e3.outstandingRequestCount -= 1, 0 === e3.outstandingRequestCount && e3.layerView.updatingFlagChanged(), d(t3) || (this._dbg(P.Error, `requestID:${l4} failed, error=${t3.toString()}`), a3.set(+l4, { responseType: i5.responseType, ptr: 0, size: 0, success: false, requestType: i5.requestType }));
        });
      }
    });
  }
  updateWasmCamera(e3) {
    this._vxl.set_projection_matrix.apply(this._vxl, e3.projectionMatrix), this._vxl.set_view_matrix.apply(this._vxl, e3.viewMatrix), this._vxl.set_near_far(e3.near, e3.far);
  }
  isUpdating(e3) {
    if (!this._vxl && this._vxlPromise)
      return true;
    const t3 = this._layers.get(e3);
    return !!t3 && t3.outstandingRequestCount > 0;
  }
  getLayerTimes(e3) {
    const t3 = [];
    return this._layers.forEach((i4, s2) => {
      if (i4.layerView.wasmLayerId === e3.wasmLayerId) {
        const i5 = this._vxl.get_layer_epoch_times(s2, e3.layer.currentVariableId);
        for (let e4 = 0; e4 < i5.length; ++e4)
          t3.push(i5[e4]);
      }
    }), t3;
  }
  getCurrentLayerTimeIndex(e3) {
    let t3 = 0;
    return this._layers.forEach((i4, s2) => {
      i4.layerView.wasmLayerId === e3.wasmLayerId && (t3 = this._vxl.get_layer_current_time_id(s2));
    }), t3;
  }
  setEnabled(e3, t3) {
    this._layers.forEach((i4, s2) => {
      i4.layerView.wasmLayerId === e3.wasmLayerId && (this._vxl.set_enabled(s2, t3), i4.needMemoryUsageUpdate = true, this._renderPluginContext.requestRender());
    });
  }
  setStaticSections(e3, t3) {
    const i4 = { mask: a2.StaticSections, staticSections: t3 };
    return this._doMaskedUIUpdate(e3, i4, true);
  }
  setCurrentVariable(e3, t3) {
    const i4 = { mask: a2.CurrentVariable, currentVariable: t3 };
    return this._doMaskedUIUpdate(e3, i4, true);
  }
  setRenderMode(e3, t3) {
    const i4 = { mask: a2.RenderMode, renderMode: t3 };
    return this._doMaskedUIUpdate(e3, i4, true);
  }
  setVerticalExaggerationAndOffset(e3, t3, i4, s2) {
    const r = { mask: a2.ExaggerationAndOffset, volStyleDesc: { volumeId: t3, verticalExaggeration: i4, verticalOffset: s2 } };
    return this._doMaskedUIUpdate(e3, r, true);
  }
  setVariableStyles(e3, t3) {
    const i4 = { mask: a2.VariableStyles, variableStyles: t3 };
    return this._doMaskedUIUpdate(e3, i4, true);
  }
  setVolumeStyles(e3, t3) {
    const i4 = { mask: a2.VolumeStyles, volumeStyles: t3 };
    return this._doMaskedUIUpdate(e3, i4, true);
  }
  setEnableDynamicSections(e3, t3) {
    const i4 = { mask: a2.ContainerVisibility, containerIsVisible: t3, container: o3.DynamicSections };
    return this._doMaskedUIUpdate(e3, i4, true);
  }
  setEnableIsosurfaces(e3, t3) {
    const i4 = { mask: a2.ContainerVisibility, containerIsVisible: t3, container: o3.Isosurfaces };
    return this._doMaskedUIUpdate(e3, i4, true);
  }
  setEnableSections(e3, t3) {
    const i4 = { mask: a2.ContainerVisibility, containerIsVisible: t3, container: o3.StaticSections };
    return this._doMaskedUIUpdate(e3, i4, true);
  }
  setAnalysisSlice(e3, t3, i4, s2) {
    const r = { mask: a2.AnalysisSlice, analysisSlice: { point: i4, normal: s2, enabled: t3 } };
    return this._doMaskedUIUpdate(e3, r, true);
  }
  _doMaskedUIUpdate(e3, t3, i4) {
    if (!this._vxl)
      return false;
    let s2 = false;
    return this._layers.forEach((i5, r) => {
      if (i5.layerView.wasmLayerId === e3.wasmLayerId) {
        const e4 = { str: JSON.stringify(t3), byteCount: 0, ptr: 0, isReusable: false };
        this._allocateBlock(e4) && (s2 = 1 === this._vxl.handle_masked_ui_update(r, e4.ptr, e4.byteCount), e4.isReusable || this._vxl._free(e4.ptr));
      }
    }), s2 && i4 && this._renderPluginContext.requestRender(), s2;
  }
  _addTriangleToWasmBuffer(e3, t3, i4, s2, r) {
    return e3[3 * t3] = i4[0], e3[3 * t3 + 1] = i4[1], e3[3 * t3 + 2] = i4[2], e3[3 * (t3 += 1)] = s2[0], e3[3 * t3 + 1] = s2[1], e3[3 * t3 + 2] = s2[2], e3[3 * (t3 += 1)] = r[0], e3[3 * t3 + 1] = r[1], e3[3 * t3 + 2] = r[2], t3 += 1;
  }
  _addNormalToWasmBuffer(e3, t3, i4) {
    return e3[3 * t3] = i4[0], e3[3 * t3 + 1] = i4[1], e3[3 * t3 + 2] = i4[2], t3 += 1;
  }
  _doCaptureFrustum() {
    if (!this._vxl)
      return;
    const e3 = 36, t3 = e3 / 3, i4 = this._vxl._malloc(3 * e3 * Float32Array.BYTES_PER_ELEMENT), s2 = new Float32Array(this._vxl.HEAPF32.buffer, i4, 3 * e3), r = this._vxl._malloc(3 * t3 * Float32Array.BYTES_PER_ELEMENT), a3 = new Float32Array(this._vxl.HEAPF32.buffer, r, e3), n4 = this._frustum.points[k.NEAR_BOTTOM_LEFT], o4 = this._frustum.points[k.NEAR_BOTTOM_RIGHT], l4 = this._frustum.points[k.NEAR_TOP_RIGHT], _ = this._frustum.points[k.NEAR_TOP_LEFT], u = this._frustum.points[k.FAR_BOTTOM_LEFT], c2 = this._frustum.points[k.FAR_BOTTOM_RIGHT], m = this._frustum.points[k.FAR_TOP_RIGHT], g = this._frustum.points[k.FAR_TOP_LEFT];
    let f = 0, p = 0;
    const x2 = this._frustum.planes[l2.NEAR];
    f = this._addTriangleToWasmBuffer(s2, f, l4, o4, n4), p = this._addNormalToWasmBuffer(a3, p, x2), f = this._addTriangleToWasmBuffer(s2, f, n4, _, l4), p = this._addNormalToWasmBuffer(a3, p, x2);
    const y = this._frustum.planes[l2.FAR];
    f = this._addTriangleToWasmBuffer(s2, f, u, c2, m), p = this._addNormalToWasmBuffer(a3, p, y), f = this._addTriangleToWasmBuffer(s2, f, m, g, u), p = this._addNormalToWasmBuffer(a3, p, y);
    const v = this._frustum.planes[l2.TOP];
    f = this._addTriangleToWasmBuffer(s2, f, m, l4, _), p = this._addNormalToWasmBuffer(a3, p, v), f = this._addTriangleToWasmBuffer(s2, f, _, g, m), p = this._addNormalToWasmBuffer(a3, p, v);
    const b = this._frustum.planes[l2.BOTTOM];
    f = this._addTriangleToWasmBuffer(s2, f, n4, o4, c2), p = this._addNormalToWasmBuffer(a3, p, b), f = this._addTriangleToWasmBuffer(s2, f, c2, u, n4), p = this._addNormalToWasmBuffer(a3, p, b);
    const w = this._frustum.planes[l2.LEFT];
    f = this._addTriangleToWasmBuffer(s2, f, _, n4, u), p = this._addNormalToWasmBuffer(a3, p, w), f = this._addTriangleToWasmBuffer(s2, f, u, g, _), p = this._addNormalToWasmBuffer(a3, p, w);
    const T = this._frustum.planes[l2.RIGHT];
    f = this._addTriangleToWasmBuffer(s2, f, l4, m, c2), p = this._addNormalToWasmBuffer(a3, p, T), f = this._addTriangleToWasmBuffer(s2, f, c2, o4, l4), p = this._addNormalToWasmBuffer(a3, p, T), -1 !== this._frustumRenderableId && this._vxl.remove_generic_mesh(this._frustumRenderableId), this._frustumRenderableId = this._vxl.add_generic_mesh(i4, 3 * e3, r, e3, 255, 0, 0, 64), this._vxl._free(i4), this._vxl._free(r), this._captureFrustum = false, this._renderPluginContext.requestRender();
  }
  captureFrustum() {
    null === this._renderCoordsHelper && (this._renderCoordsHelper = U.create(l3.Local, F(false, this._view.spatialReference))), null === this._frustum && (this._frustum = new d2(this._renderCoordsHelper)), this._captureFrustum = true, null !== this._renderPluginContext && this._renderPluginContext.requestRender();
  }
  toggleFullVolumeExtentDraw(e3) {
    this._vxl && this._layers.forEach((t3, i4) => {
      t3.layerView.wasmLayerId === e3.wasmLayerId && (this._vxl.toggle_full_volume_extent_draw(i4), this._renderPluginContext.requestRender());
    });
  }
  addVoxelLayer(e3) {
    if (!this._vxl) {
      const t4 = { layerView: e3, resolveCallback: null, rejectCallback: null }, i4 = new Promise((e4, i5) => {
        t4.resolveCallback = e4, t4.rejectCallback = i5;
      });
      return this._newLayers.push(t4), i4;
    }
    const t3 = this._addVoxelLayer(e3);
    return t3 < 0 ? Promise.reject(-1) : Promise.resolve(t3);
  }
  removeVoxelLayer(e3) {
    if (!this._vxl) {
      const t4 = this._newLayers.findIndex((t5) => e3.uid === t5.layerView.uid);
      t4 >= 0 && (this._newLayers[t4].resolveCallback(-1), this._newLayers.splice(t4, 1));
      const i5 = this._newLayers.length;
      return 0 === i5 && (this._dbg(P.Lifetime, " no voxel layers left after removing a layer, removing RenderPlugin and destroying"), this.destroy()), i5;
    }
    let t3 = -1;
    this._layers.forEach((i5, s2) => {
      if (i5.layerView.wasmLayerId === e3.wasmLayerId) {
        t3 = s2, i5.abortController.abort(), this._vxl.remove_layer(t3);
        const r = this.layerUid.indexOf(e3.layer.uid);
        -1 !== r && this.layerUid.splice(r, 1);
      }
    }), t3 >= 0 && this._layers.delete(t3);
    const i4 = this._layers.size;
    return 0 === i4 && (this._dbg(P.Lifetime, " no voxel layers left after removing a layer, removing RenderPlugin and destroying"), this.destroy()), i4;
  }
  _getBlockSize(e3) {
    for (const t3 of this._wasmMemBlockSizes)
      if (e3 < t3)
        return t3;
    return -1;
  }
  _allocateBlock(e3) {
    e3.byteCount = this._vxl.lengthBytesUTF8(e3.str) + 1;
    const t3 = this._getBlockSize(e3.byteCount);
    return t3 < 0 ? (e3.isReusable = false, e3.ptr = this._vxl._malloc(e3.byteCount)) : (e3.isReusable = true, e3.ptr = this._wasmMemBlocks.get(t3), 0 === e3.ptr && (e3.ptr = this._vxl._malloc(t3), this._wasmMemBlocks.set(t3, e3.ptr))), 0 !== e3.ptr && (this._vxl.stringToUTF8(e3.str, e3.ptr, e3.byteCount), true);
  }
  _getTimeArgs(e3) {
    let t3 = -Number.MAX_VALUE, i4 = Number.MAX_VALUE, s2 = false;
    return null != e3 && (e3.isAllTime ? s2 = true : (null != e3.start && (s2 = true, t3 = e3.start.getTime() / 1e3), null != e3.end && (s2 = true, i4 = e3.end.getTime() / 1e3))), { startTime: t3, endTime: i4, useTime: s2 };
  }
  _addVoxelLayer(e3) {
    var _a, _b;
    const t3 = e3.layer;
    let i4 = -1;
    const s2 = t3.getConfiguration();
    if (s2.length < 1)
      return -1;
    const r = { str: s2, byteCount: 0, ptr: 0, isReusable: false };
    if (!this._allocateBlock(r))
      return -1;
    const a3 = this._getTimeArgs((_a = this._view) == null ? void 0 : _a.timeExtent), n4 = this._view.spatialReference.isWGS84 && t3.spatialReference.isWGS84 ? 111319.49079327357 : 1;
    if (i4 = this._vxl.add_layer(t3.serviceRoot, r.ptr, r.byteCount, n4, n4, a3.startTime, a3.endTime, a3.useTime, this._toWasmQuality(this._view.qualityProfile)), r.isReusable || this._vxl._free(r.ptr), i4 >= 0) {
      ((_b = t3.test) == null ? void 0 : _b.constantUpscaling) && (this._setUpscalingLimits(0, 0.25, 0.25), this._setUpscalingLimits(1, 0.5, 0.5), this._setUpscalingLimits(2, 0.75, 0.75));
      const s3 = new AbortController();
      if (this._layers.set(i4, { layerView: e3, responses: /* @__PURE__ */ new Map(), outstandingRequestCount: 0, abortController: s3, needMemoryUsageUpdate: false }), this.layerUid.push(e3.layer.uid), !this._halfIntTexturesAvailable || has("mac")) {
        const t4 = [];
        let i5 = "";
        for (const s4 of e3.layer.variables)
          "Int16" !== s4.renderingFormat.type && "UInt16" !== s4.renderingFormat.type || (t4.push(s4.name), s4.id === e3.layer.currentVariableId && (i5 = s4.name));
        "" !== i5 && S.error("#addVoxelLayer_error()", e3.layer, `The voxel layer '${e3.layer.title}' cannot render the current variable '${i5}' in this browser`), t4.length > 0 && S.warn("#addVoxelLayer_warning()", e3.layer, `The voxel layer '${e3.layer.title}' cannot render the variables '${t4.toString()}' in this browser`);
      }
      if (!this._textureFloatLinearAvailable) {
        const t4 = [];
        let i5 = "";
        for (const s4 of e3.layer.variables)
          "Float32" === s4.renderingFormat.type && (t4.push(s4.name), s4.id === e3.layer.currentVariableId && (i5 = s4.name));
        "" !== i5 && S.error("#addVoxelLayer_error()", e3.layer, `The voxel layer '${e3.layer.title}' cannot render the current variable '${i5}' in this browser`), t4.length > 0 && S.warn("#addVoxelLayer_warning()", e3.layer, `The voxel layer '${e3.layer.title}' cannot render the variables '${t4.toString()}' in this browser`);
      }
      return has("esri-mobile") && S.warnOnce("Mobile support differs across devices. Voxel layer might not display as expected."), i4;
    }
    return -1;
  }
  prepareRender(e3) {
    if (!this._vxl)
      return;
    const t3 = e3.bindParameters.camera.viewForward, i4 = e3.bindParameters.camera.eye;
    this._vxl.update_camera_pos_and_direction(i4[0], i4[1], i4[2], t3[0], t3[1], t3[2]);
    const s2 = this._vxl.cull();
    this._dbg(P.RequestResponse, "missingResourceCount=" + s2), this._moreToLoad = s2 > 0, this._havePreparedWithAllLayers = 0 === this._newLayers.length, this._updateMemoryUsage();
  }
  render(e3) {
    if (!this._vxl || e3.output !== this._shaderOutput || e3.bindParameters.slot !== this._renderSlot)
      return;
    for (const i4 of this._newLayers) {
      const e4 = this._addVoxelLayer(i4.layerView);
      -1 === e4 ? i4.rejectCallback(-1) : i4.resolveCallback(e4);
    }
    if (this._newLayers = [], 0 === this._layers.size)
      return void this._dbg(P.Error, "No voxel layers but RenderPlugin instance is being asked to render!");
    this._lastFrameWasStationary = this._view.stationary, this._syncRequestsResponses(), this._beforeDraw(), this._vxl.begin_color_frame(!this._view._stage.renderer.isFeatureEnabled(o2.HighResolutionVoxel), e3.bindParameters.lighting.mainLight.direction[0], e3.bindParameters.lighting.mainLight.direction[1], e3.bindParameters.lighting.mainLight.direction[2]);
    const t3 = this._renderTargetToRestore.viewport;
    t3.width === this._viewportWidth && t3.height === this._viewportHeight || (this._viewportWidth = t3.width, this._viewportHeight = t3.height, this._vxl.set_viewport(t3.width, t3.height), this._layers.forEach((e4) => {
      e4.needMemoryUsageUpdate = true;
    })), 0 === t3.x && 0 === t3.y || this._dbg(P.Error, "Unsupported viewport parameters detected!"), this.updateWasmCamera(e3.bindParameters.camera), this._captureFrustum && (this._frustum.update(e3.bindParameters.camera), this._doCaptureFrustum()), this._vxl.draw(), this._afterDraw(), (this._moreToLoad || !this._havePreparedWithAllLayers && this._layers.size > 0) && this._renderPluginContext.requestRender();
  }
  destroy() {
    this._dbg(P.Lifetime, "--destroy--"), this._removeRenderPlugin(), this._readyWatchHandle = o(this._readyWatchHandle), this._qualityWatchHandle = o(this._qualityWatchHandle), this._timeExtentWatchHandle = o(this._timeExtentWatchHandle), this._stationaryWatchHandle = o(this._stationaryWatchHandle), this._vxl && (this._layers.forEach((e3) => {
      e3.abortController.abort();
    }), this._wasmMemBlocks.forEach((e3) => {
      0 !== e3 && this._vxl._free(e3);
    }), this._vxl.uninitialize_voxel_wasm(), this._vxl = null);
  }
  _initializeWasm(e3) {
    return this._vxl ? Promise.resolve() : (this._vxlPromise || (this._vxlPromise = e2(e3).then((e4) => {
      var _a;
      if (this._vxl = e4, this._vxlPromise = null, this._newLayers.length <= 0)
        return this._dbg(P.Lifetime, " no voxel layers left after WASM downloaded, removing RenderPlugin and destroying"), void this.destroy();
      const t3 = this._getTimeArgs((_a = this._view) == null ? void 0 : _a.timeExtent), i4 = this._vxl.addFunction(this._restoreFramebuffer.bind(this), "v"), s2 = this._vxl.addFunction(this._setBlendState.bind(this), "viiii"), r = this._vxl.addFunction(this._setFrontFace.bind(this), "vi"), a3 = this._vxl.addFunction(this._setRasterizerState.bind(this), "vi"), n4 = this._vxl.addFunction(this._setDepthStencilStateFunction.bind(this), "viii"), o4 = this._vxl.addFunction(this._setViewport.bind(this), "viiii"), l4 = this._vxl.addFunction(this._bindPreviousDepthToSlot.bind(this), "iii"), h3 = this._vxl.addFunction(this._modifyResourceCount.bind(this), "viii"), d3 = this._halfIntTexturesAvailable && !has("mac"), _ = this._textureFloatLinearAvailable;
      this._vxl.initialize_voxel_wasm(i4, s2, r, a3, n4, o4, l4, h3, t3.startTime, t3.endTime, t3.useTime, d3, _), this._renderPluginContext && this._renderPluginContext.requestRender();
    }).catch(() => {
      for (const e4 of this._newLayers)
        e4.rejectCallback(-2);
      this._dbg(P.Error, " WASM failed to download, removing RenderPlugin and destroying"), this.destroy();
    })), this._vxlPromise);
  }
  pickDepth(e3, t3, i4) {
    if (!this._vxl || !this._rctx || 0 === this._layers.size)
      return null;
    const s2 = i4.viewport[3] - t3;
    if (e3 < 0 || e3 > i4.viewport[2] || t3 < 0 || t3 > i4.viewport[3])
      return this._dbg(P.Error, `[js] pickDepth: outOfRange, screenXY=[${e3.toFixed(0)}, ${s2.toFixed(0)}]]`), null;
    this._beforeDraw();
    const r = i4.viewForward, a3 = i4.eye;
    this._vxl.update_camera_pos_and_direction(a3[0], a3[1], a3[2], r[0], r[1], r[2]), this.updateWasmCamera(i4), this._vxl.begin_frame();
    const n4 = this._vxl.pick_depth(e3, s2);
    if (this._afterDraw(), n4.success) {
      return n4.distanceToCamera;
    }
    return null;
  }
  pickObject(e3, t3, i4, s2) {
    if (!this._vxl || !this._rctx || 0 === this._layers.size)
      return null;
    const r = Math.round(e3), a3 = Math.round(t3);
    if (r < 0 || r > i4.viewport[2] || a3 < 0 || a3 > i4.viewport[3])
      return this._dbg(P.Error, `[js] pickObject: outOfRange, screenXY=[${r}, ${a3}], vp=[${i4.viewport.toString()}]`), null;
    this._beforeDraw();
    const n4 = i4.viewForward, o4 = i4.eye;
    this._vxl.update_camera_pos_and_direction(o4[0], o4[1], o4[2], n4[0], n4[1], n4[2]), this.updateWasmCamera(i4), this._vxl.begin_frame();
    let l4 = null;
    if (0 === s2.length)
      l4 = this._vxl.pick_object(r, a3, 0, 0);
    else {
      const e4 = { str: JSON.stringify({ layerIds: s2 }), byteCount: 0, ptr: 0, isReusable: false };
      this._allocateBlock(e4) && (l4 = this._vxl.pick_object(r, a3, e4.ptr, e4.byteCount), e4.isReusable || this._vxl._free(e4.ptr));
    }
    return this._afterDraw(), l4;
  }
  _beforeDraw() {
    this._renderTargetToRestore = { fbo: this._rctx.getBoundFramebufferObject(), viewport: this._rctx.getViewport() }, this._rctx.setPolygonOffsetFillEnabled(false), this._rctx.setScissorTestEnabled(false), this._rctx.setColorMask(true, true, true, true);
  }
  _afterDraw() {
    this._renderTargetToRestore.fbo = null, this._rctx.externalTextureUnitUpdate(this._vxl.get_texture_units_bound_in_frame(), this._vxl.get_active_texture_unit()), this._rctx.externalVertexArrayObjectUpdate(), this._rctx.externalVertexBufferUpdate(), this._rctx.externalProgramUpdate();
  }
  intersect(e3, t3, i4, s2, r) {
    if (!this._vxl || !this._rctx || 0 === this._layers.size || !e3.options.selectionMode || e3.options.isFiltered)
      return;
    if (r[0] < 0 || r[0] > e3.camera.viewport[2] || r[1] < 0 || r[1] > e3.camera.viewport[3])
      return this._dbg(P.Error, `[js] VoxelWasmPerScene.intersect: outOfRange, screenXY=[${r[0].toFixed(0)}, ${r[1].toFixed(0)}]`), null;
    const a3 = [];
    this._layers.forEach((t4) => {
      e3.options.filteredLayerUids.includes(t4.layerView.layer.uid) && a3.push(t4.layerView.wasmLayerId);
    });
    const l4 = this.pickObject(r[0], r[1], e3.camera, a3);
    if (null == l4 || -1 === l4.layerId)
      return;
    const h3 = this._layers.get(l4.layerId);
    if (h3) {
      const t4 = h3.layerView.layer.uid, r2 = l4.distanceToCamera / x(i4, s2), a4 = n();
      a4[0] = l4.worldX, a4[1] = l4.worldY, a4[2] = l4.worldZ;
      const d3 = {};
      if (null != l4.continuousValue && null != l4.continuousValueUnits ? d3["Voxel.ServiceValue"] = `${l4.continuousValue.toLocaleString()} ${l4.continuousValueUnits}` : null != l4.uniqueValueLabel && null != l4.uniqueValue ? d3["Voxel.ServiceValue"] = `${l4.uniqueValueLabel} (${l4.uniqueValue})` : null != l4.uniqueValue && (d3["Voxel.ServiceValue"] = `${l4.uniqueValue}`), d3["Voxel.ServiceVariableLabel"] = l4.variableLabel, d3["Voxel.Position"] = l4.voxelSpacePosition, null != l4.epochTime && null != l4.nativeTime && null != l4.nativeTimeUnits) {
        const e4 = new Date(l4.epochTime);
        d3["Voxel.ServiceLocalTime"] = e4.toString(), d3["Voxel.ServiceNativeTime"] = `${l4.nativeTime.toLocaleString()} ${l4.nativeTimeUnits}`;
      }
      null != l4.depth && null != l4.depthUnits && (d3["Voxel.ServiceDepth"] = `${l4.depth.toLocaleString()} ${l4.depthUnits}`);
      const _ = l4.faceNormal;
      d3["Voxel.WorldPosition"] = `[${a4[0]}, ${a4[1]}, ${a4[2]}]`;
      const u = (e4) => {
        const i5 = new c(a4, t4, () => this._createVoxelGraphic(h3.layerView.layer, d3));
        e4.set(this.type, i5, r2, _);
      }, c2 = e3.results, m = e3.options.store === t.ALL;
      if ((null == c2.min.dist || r2 < c2.min.dist) && u(c2.min), (null == c2.max.dist || r2 > c2.max.dist) && u(c2.max), m) {
        const t5 = M(e3.ray);
        u(t5), e3.results.all.push(t5);
      }
    }
  }
  _createVoxelGraphic(t3, i4) {
    return new h2({ layer: t3, sourceLayer: t3, attributes: i4 });
  }
  _toWasmQuality(e3) {
    switch (e3) {
      case "low":
        return 0;
      case "medium":
        return 1;
      case "high":
        return 2;
    }
  }
  _setUpscalingLimits(e3, t3, i4) {
    this._vxl && this._vxl.set_upscaling_limits(e3, t3, i4);
  }
};
export {
  U2 as default
};
//# sourceMappingURL=VoxelWasmPerSceneView-FJVK7RUA.js.map
