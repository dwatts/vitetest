import {
  v as v2,
  w as w2
} from "./chunk-TE7N6C3J.js";
import {
  s as s3
} from "./chunk-SGBMUZSF.js";
import {
  I
} from "./chunk-KRCNIFX2.js";
import {
  l as l2
} from "./chunk-RVS5HU2K.js";
import {
  ce
} from "./chunk-BNBT4QTW.js";
import {
  v
} from "./chunk-A6VKJXIH.js";
import {
  V
} from "./chunk-7EQSYZHW.js";
import {
  i,
  k,
  o as o3,
  p
} from "./chunk-EKJ2DJIR.js";
import {
  A,
  d as d2
} from "./chunk-TEHNQYQD.js";
import {
  P,
  e as e3,
  g,
  r,
  u
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import {
  P as P2,
  R,
  T,
  o2
} from "./chunk-RTDN6KAT.js";
import {
  j
} from "./chunk-43LWRDQS.js";
import {
  m,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  C,
  c,
  d,
  s as s2,
  w
} from "./chunk-7I33FAWS.js";
import {
  e as e2,
  l,
  o
} from "./chunk-DWOEYHKS.js";
import {
  s3 as s
} from "./chunk-HMVAPW5X.js";
import {
  a
} from "./chunk-IYZKKFJM.js";
import {
  z
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/support/AsyncWorkerQueue.js
var s4 = class {
  constructor(t) {
    this.client = t, this._cancelled = false, this.size = 0, this.duration = 0;
  }
};
var e4 = class {
  constructor(t) {
    this.typeWorkerQuota = t, this.tasks = new Array(), this.numWorkers = 0, this.statistics = new r2();
  }
};
var r2 = class {
  constructor() {
    this.requests = 0, this.size = 0, this.duration = 0, this.speed = 0;
  }
};
var i2 = class {
  constructor(t, s8, r3, i4) {
    this._workerFunc = t, this._callbackFunc = s8, this._maxTotalNumWorkers = r3, this._totalNumWorkers = 0, this._clients = i4.map((t2) => new e4(t2));
  }
  destroy() {
    this._clients.length = 0;
  }
  hasQuota(t) {
    const s8 = this._clients[t];
    return !!s8 && (this._totalNumWorkers < this._maxTotalNumWorkers || s8.numWorkers + s8.tasks.length < s8.typeWorkerQuota);
  }
  push(t) {
    const s8 = this._clients[t.client];
    s8 && (this._totalNumWorkers < this._maxTotalNumWorkers ? (s8.numWorkers++, this._totalNumWorkers++, this._workerFunc(t, (t2, s9) => this._taskCallback(t2, s9))) : s8.tasks.push(t));
  }
  cancel(t) {
    this._taskFinished(t), t._cancelled = true;
  }
  _taskFinished(s8) {
    const e5 = this._clients[s8.client];
    this._totalNumWorkers--, e5 && (e5.numWorkers--, e5.statistics.requests++, e5.statistics.size += s8.size || 0, e5.statistics.duration += s8.duration || 0, e5.statistics.speed = e5.statistics.duration > 0 ? e5.statistics.size / e5.statistics.duration : 0, s3(e5.numWorkers >= 0)), this._next();
  }
  _next() {
    for (const t of this._clients)
      if (t && t.numWorkers < t.typeWorkerQuota && this._processQueue(t))
        return;
    for (const t of this._clients)
      if (t && this._processQueue(t))
        return;
  }
  _processQueue(t) {
    for (; t.tasks.length > 0; )
      if (this._workerFunc(t.tasks.shift(), (t2, s8) => this._taskCallback(t2, s8)))
        return t.numWorkers++, this._totalNumWorkers++, true;
    return false;
  }
  _taskCallback(t, s8) {
    t._cancelled || (this._callbackFunc(t, s8), this._taskFinished(t));
  }
  getStatsForType(t) {
    const s8 = this._clients[t];
    return s8 ? { quota: s8.typeWorkerQuota, workers: s8.numWorkers, queueSize: s8.tasks.length, requestStats: s8.statistics } : null;
  }
  get test() {
    const t = this;
    return { set workerFunc(s8) {
      t._workerFunc = s8;
    } };
  }
};

// node_modules/@arcgis/core/views/3d/support/StreamDataLoader.js
var D = class extends m {
  constructor() {
    super(...arguments), this._tasks = /* @__PURE__ */ new Map(), this._onLoadQueue = new Array(), this._doneQueue = new Array(), this.updating = false;
  }
  setup(e5, t, s8) {
    this._loadQueue = new i2((e6, t2) => this._startLoading(e6, t2), (e6, t2) => this._doneLoadingCB(e6, t2), e5, t), s8 && (this._frameTask = s8.registerTask(I.STREAM_DATA_LOADER, this));
  }
  destroy() {
    this._frameTask = o(this._frameTask), this._tasks.forEach((e5) => e2(e5.abortController)), this._loadQueue = l(this._loadQueue), this._onLoadQueue = null, this._doneQueue = null, this._tasks = null;
  }
  hasDownloadSlots(e5) {
    return this._loadQueue.hasQuota(e5);
  }
  request(e5, t, s8, r3 = {}) {
    const o5 = C();
    o5.__signal = null != r3 ? r3.signal : null;
    const a6 = this._createOrUpdateTask(e5, t, s8, r3, o5);
    return w(r3, () => this._cancelRequest(a6, o5)), o5.promise;
  }
  _createTask(e5, t, s8, r3, o5, a6) {
    const n2 = new O(e5, t, s8, r3, o5);
    return this._updateTask(n2, a6), this._tasks.set(o5, n2), 1 === this._tasks.size && this._set("updating", true), this._loadQueue.push(n2), n2;
  }
  _cancelRequest(e5, t) {
    var _a;
    z(e5.resolvers, t), t.reject(c()), 0 === e5.resolvers.length && (e5.status === T2.DOWNLOADING && (e5.status = T2.CANCELLED, this._loadQueue.cancel(e5), (_a = e5.abortController) == null ? void 0 : _a.abort(), e5.request = null, e5.abortController = null), e5.status = T2.CANCELLED, this._tasks.delete(e5.key), 0 === this._tasks.size && this._set("updating", false));
  }
  _updateTask(e5, t) {
    e5.resolvers.push(t);
  }
  _createOrUpdateTask(e5, t, s8, r3, o5) {
    const a6 = Q(null != r3 && r3.uid || e5, t, s8), n2 = this._tasks.get(a6);
    return n2 ? (this._updateTask(n2, o5), n2) : this._createTask(e5, r3, t, s8, a6, o5);
  }
  _doneLoadingCB(e5, t) {
    this._loadQueue && (s3(e5.status === T2.DOWNLOADING), e5.status = T2.DOWNLOADED, this._frameTask ? this._doneQueue.push({ task: e5, err: t }) : this._doneLoading(e5, t));
  }
  get running() {
    return this._doneQueue.length > 0 || this._onLoadQueue.length > 0;
  }
  runTask(e5) {
    for (; !e5.done && this._onLoadQueue.length > 0; ) {
      const t = this._onLoadQueue.shift();
      s2(t.task.abortController), t.task.abortController = null, t.callback(t.task), e5.madeProgress();
    }
    for (; !e5.done && this._doneQueue.length > 0; ) {
      const t = this._doneQueue.shift();
      t.task.status !== T2.DOWNLOADED && (t.err = t.err || c()), this._doneLoading(t.task, t.err), e5.madeProgress();
    }
  }
  _doneLoading(e5, t) {
    if (t && !d(t) && e5.numRetries > 0)
      return --e5.numRetries, void this._loadQueue.push(e5);
    let s8 = e5.result instanceof HTMLImageElement ? 0 : e5.resolvers.length;
    for (const r3 of e5.resolvers)
      if (t)
        d(t) ? r3.reject(t) : r3.reject(new s("stream-data-loader:request-error", `Failed to request resource at '${e5.url}'. ${t}`, { url: e5.url, error: t }));
      else {
        --s8;
        const t2 = s8 <= 0 ? e5.result : a(e5.result);
        r3.resolve(t2);
      }
    this._tasks.delete(e5.key), 0 === this._tasks.size && this._set("updating", false);
  }
  _startLoading(e5, s8) {
    if (e5.status === T2.CANCELLED)
      return false;
    let r3, o5;
    switch (e5.startTime = performance.now(), e5.status = T2.DOWNLOADING, e5.docType) {
      case "binary":
        o5 = "array-buffer", r3 = 0;
        break;
      case "image":
        o5 = "image";
        break;
      case "image+type":
        o5 = "array-buffer";
        break;
      default:
        o5 = "json";
    }
    e5.abortController = new AbortController();
    const a6 = e5.abortController.signal;
    e5.request = j(e5.url, { ...e5.options, responseType: o5, timeout: r3, signal: a6 });
    let n2 = () => {
    };
    const i4 = (t) => {
      e5.duration = performance.now() - e5.startTime, e5.size = t instanceof ArrayBuffer ? t.byteLength : e5.size || 0, e5.result = t, this._frameTask ? this._onLoadQueue.push({ callback: s8, task: e5 }) : (e5.abortController = null, s8(e5));
    }, u3 = (t) => {
      e5.status === T2.DOWNLOADING && s8(e5, t), n2();
    };
    return "image+type" !== e5.docType ? (e5.request.then((e6) => i4(e6.data), u3), true) : (e5.request.then((s9) => {
      const l4 = s9.data, h2 = b(l4);
      if (o5 = "image", e5.size = l4.byteLength, "unknown" === h2)
        return e5.request = j(e5.url, { responseType: o5, timeout: r3, signal: a6 }), void e5.request.then((e6) => i4(e6.data), u3);
      const c5 = new Blob([l4], { type: h2 }), d6 = window.URL.createObjectURL(c5);
      n2 = () => window.URL.revokeObjectURL(d6), e5.request = j(d6, { responseType: o5, timeout: r3, signal: a6 }), e5.request.then((e6) => i4(new A2(e6.data, h2, n2)), u3);
    }, u3), true);
  }
  get test() {
    return { loadQueue: this._loadQueue };
  }
};
e([y({ readOnly: true })], D.prototype, "updating", void 0), D = e([a2("esri.views.3d.support.StreamDataLoader")], D);
var y2 = { numRetries: 0 };
function b(e5) {
  if (e5.byteLength < 2)
    return "unknown";
  const t = new Uint8Array(e5, 0, e5.byteLength);
  return 137 === t[0] && 80 === t[1] ? "image/png" : 71 === t[0] && 73 === t[1] ? "image/gif" : 66 === t[0] && 77 === t[1] ? "image/bmp" : 255 === t[0] && 216 === t[1] ? "image/jpeg" : "unknown";
}
var A2 = class {
  constructor(e5, t, s8) {
    this.image = e5, this.type = t, this.release = s8;
  }
  get isOpaque() {
    return "image/jpeg" === this.type;
  }
};
var O = class extends s4 {
  constructor(e5, t, s8, r3, o5) {
    super(r3), this.url = e5, this.options = t, this.docType = s8, this.key = o5, this.result = null, this.status = T2.QUEUED, this.request = null, this.abortController = null, this.resolvers = new Array(), this.startTime = 0, this.numRetries = y2.numRetries;
  }
};
function Q(e5, t, s8) {
  return `${e5}:${t}:${s8}`;
}
var T2;
!function(e5) {
  e5[e5.QUEUED = 1] = "QUEUED", e5[e5.DOWNLOADING = 2] = "DOWNLOADING", e5[e5.DOWNLOADED = 3] = "DOWNLOADED", e5[e5.CANCELLED = 4] = "CANCELLED";
}(T2 || (T2 = {}));

// node_modules/@arcgis/core/views/3d/terrain/ITile.js
var T3;
var S;
!function(T6) {
  T6[T6.INSIDE = 0] = "INSIDE", T6[T6.INTERSECTS = 1] = "INTERSECTS", T6[T6.OUTSIDE = 2] = "OUTSIDE";
}(T3 || (T3 = {})), function(T6) {
  T6[T6.NORTH = 0] = "NORTH", T6[T6.NORTH_EAST = 1] = "NORTH_EAST", T6[T6.EAST = 2] = "EAST", T6[T6.SOUTH_EAST = 3] = "SOUTH_EAST", T6[T6.SOUTH = 4] = "SOUTH", T6[T6.SOUTH_WEST = 5] = "SOUTH_WEST", T6[T6.WEST = 6] = "WEST", T6[T6.NORTH_WEST = 7] = "NORTH_WEST";
}(S || (S = {}));

// node_modules/@arcgis/core/views/3d/terrain/TerrainConst.js
var s5 = 64;
var i3 = 512;
var a3 = 2.5;
var l3 = A(d2 / 10);
var c2 = 2;
var m2 = i();
v2.WebMercatorAuxiliarySphere.getExtent(0, 0, 0, m2);
var u2 = i([-180, -90, 180, 90]);
var p2 = "Cannot extend surface to encompass all layers because it would result in too many root tiles.";
var f = "Surface extent is too large for tile resolution at level 0.";
var g2 = 3;
var x = g2;
function d3(e5) {
  return e5 < 4 ? 3 : x;
}

// node_modules/@arcgis/core/chunks/terrainUtilsPlanar.js
var g3 = n();
var d4 = n();
var M = n();
var x2 = n();
function S2(e5, t, n2 = 0) {
  const o5 = e5.extent;
  if (null == o5)
    return false;
  if (0 === n2)
    return p(o5, t);
  const r3 = Math.min(o5[2] - o5[0], o5[3] - o5[1]);
  return k(o5, t, n2 * r3);
}
function v3(e5, s8, l4, a6) {
  r(g3, l4), g3[a6] = s8[a6];
  const c5 = e3(g3, g3, s8), u3 = e3(d4, e5, s8), f2 = P(u3, c5), m4 = P(c5, c5);
  let h2;
  h2 = f2 <= 0 ? s8 : m4 <= f2 ? l4 : u(g3, s8, g(c5, c5, f2 / m4));
  const p4 = e3(g3, e5, h2);
  return Math.PI / 2 - Math.atan(p4[2] / Math.sqrt(p4[0] * p4[0] + p4[1] * p4[1]));
}
function j2(e5, t, n2) {
  const o5 = e5.extent;
  if (null == o5)
    return 0;
  M[0] = o5[0], M[1] = o5[1], M[2] = n2, x2[0] = o5[2], x2[1] = o5[3], x2[2] = n2;
  let r3 = 1 / 0, i4 = 1 / 0;
  return t[0] < M[0] ? r3 = v3(t, M, x2, 0) : t[0] > x2[0] && (r3 = v3(t, x2, M, 0)), t[1] < M[1] ? i4 = v3(t, M, x2, 1) : t[1] > x2[1] && (i4 = v3(t, x2, M, 1)), Math.min(r3, i4);
}
function T4(t, n2, o5) {
  if (null == t)
    return w2();
  if (t.spatialReference.isGeographic && !ce(t.spatialReference))
    return new s("tilingscheme:local-unsupported-spatial-reference", "The tiling scheme spatial reference is not supported in local scenes");
  const r3 = v2.checkUnsupported(t);
  if (null != r3)
    return r3;
  if (null == o5)
    return new s("tilingscheme:extent-not-exist", "The layer does not provide a layer extent.");
  const i4 = w3(t, o5);
  if (i4)
    return i4;
  const s8 = t.spatialReference;
  return null == n2 || s8.equals(n2) || n2.isWGS84 && s8.isWebMercator ? null : new s("tilingscheme:spatial-reference-mismatch", "The tiling scheme does not match the spatial reference of the local scene");
}
function w3(t, n2) {
  const o5 = t.lods, r3 = o5[0].resolution * 2 ** o5[0].level, i4 = [r3 * t.size[0], r3 * t.size[1]], s8 = [t.origin.x, t.origin.y], l4 = o3(n2), a6 = i();
  v2.computeRowColExtent(l4, i4, s8, a6);
  const c5 = (a6[2] - a6[0]) * (a6[3] - a6[1]);
  if (c5 > s5) {
    const n3 = o5[0].scale * 2 ** o5[0].level;
    let i5 = Math.max((l4[3] - l4[1]) / t.size[1], (l4[2] - l4[0]) / t.size[0]) * n3 / r3;
    const s9 = Math.floor(Math.log(i5) / Math.log(10));
    return i5 = Math.ceil(i5 / 10 ** s9) * 10 ** s9, new s("tilingscheme:too-many-root-tiles", "Scale of level 0 of the tiling scheme (1:" + Math.floor(n3).toLocaleString() + ") is too large for the layer's extent. Suggested scale: 1:" + i5.toLocaleString() + ".", { level0Scale: n3, suggestedLevel0Scale: i5, requiredNumRootTiles: c5, allowedNumRootTiles: s5 });
  }
  return null;
}
var y3 = Object.freeze(Object.defineProperty({ __proto__: null, checkIfTileInfoSupportedForViewSR: T4, isInsideExtent: S2, tiltToExtentEdge: j2 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/terrainUtilsSpherical.js
function o4() {
  return true;
}
function s6() {
  return 0;
}
function c3(o5, s8) {
  if (null == o5)
    return w2();
  const c5 = o5.lods.length - 1, a6 = o5.spatialReference, m4 = ce(a6) || T(a6) || P2(a6);
  if (a6.isWebMercator) {
    if (!v2.makeWebMercatorAuxiliarySphere(c5).compatibleWith(o5))
      return new s("tilingscheme:incompatible-global-web-mercator", "The tiling scheme is not compatible with the ArcGIS Online Web Mercator tiling scheme");
  } else {
    if (!m4)
      return new s("tilingscheme:global-unsupported-spatial-reference", "The tiling scheme spatial reference is not supported in global scenes");
    if (!v2.makeGCSWithTileSize(o5.spatialReference, o5.size[0], c5).compatibleWith(o5))
      return o5.spatialReference.isWGS84 ? new s("tilingscheme:incompatible-global-wgs84", "The tiling scheme is not compatible with the ArcGIS Online WGS84 tiling scheme") : new s("tilingscheme:incompatible-global", "The tiling scheme is not compatible with the ArcGIS Online tiling scheme");
  }
  return null == s8 || o5.spatialReference.equals(s8) ? void 0 : new s("tilingscheme:spatial-reference-mismatch", "The tiling scheme does not match the spatial reference of the global scene");
}
var a4 = Object.freeze(Object.defineProperty({ __proto__: null, checkIfTileInfoSupportedForViewSR: c3, isInsideExtent: o4, tiltToExtentEdge: s6 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/terrain/terrainUtils.js
var c4 = { [l2.Global]: a4, [l2.Local]: y3 };
function a5(t, n2) {
  t || console.warn("Terrain: " + n2);
}
var T5 = false;
var s7 = false;
function S3(t) {
  s7 = t, T5 = T5 || t;
}
function E(t) {
  T5 = t;
}
function p3(t, n2) {
  var _a;
  if (T5 && !t) {
    const t2 = (_a = new Error().stack) == null ? void 0 : _a.slice(5);
    throw console.warn("Terrain internal: " + (n2 ?? "") + " at " + t2), new Error("Assertion failed" + (n2 ? ": " + n2 : ""));
  }
}
function m3(t) {
  return O2(t) ? { fullExtent: t.fullExtent, minScale: t.layer.minScale, maxScale: t.layer.maxScale, tilemapCache: null } : t.layer;
}
function H(t) {
  return "imagery-tile" === (t == null ? void 0 : t.type) || "wcs" === (t == null ? void 0 : t.type);
}
function O2(t) {
  return "imagery-tile-3d" === (t == null ? void 0 : t.type);
}
function y4(t) {
  return "tile-3d" === (t == null ? void 0 : t.type);
}
function _(t) {
  return "vector-tile-3d" === (t == null ? void 0 : t.type);
}
function I2(t) {
  return "wmts-3d" === (t == null ? void 0 : t.type);
}
function R2(t) {
  return "elevation-3d" === (t == null ? void 0 : t.type);
}
function d5(t) {
  return "group" === (t == null ? void 0 : t.type);
}
function U(t) {
  return t && (y4(t) || I2(t) || O2(t) || _(t));
}
function W(t) {
  return t && (y4(t) || O2(t) || _(t) || I2(t));
}
function N(t) {
  return W(t) || R2(t);
}
function x3(t) {
  var _a;
  const n2 = (_a = t == null ? void 0 : t.sourceLayerInfo) == null ? void 0 : _a.data;
  return null != n2 && "type" in n2 && "raster-tile" === n2.type;
}
function A3(t) {
  return L(t == null ? void 0 : t.sourceLayerInfo);
}
function g4(t) {
  var _a;
  const n2 = (_a = t == null ? void 0 : t.sourceLayerInfo) == null ? void 0 : _a.data;
  return null != n2 && "type" in n2 && "tile-texture" === n2.type;
}
function h(t) {
  var _a;
  const n2 = (_a = t == null ? void 0 : t.sourceLayerInfo) == null ? void 0 : _a.data;
  return n2 instanceof HTMLImageElement || n2 instanceof A2 || n2 instanceof HTMLCanvasElement || n2 instanceof ImageData;
}
function L(t) {
  return null != (t == null ? void 0 : t.data) && "type" in t.data && "vector-tile" === t.data.type;
}
function w4(t) {
  return null != t && "release" in t && t.release(), null;
}
function j3(t) {
  return t.fetchTile && false !== t.hasOverriddenFetchTile;
}
function C2(t, n2, e5, r3) {
  return c4[r3].checkIfTileInfoSupportedForViewSR(t, e5, n2);
}
function b2(t, n2, e5) {
  let r3 = null, l4 = null;
  if ("wmts" === (t == null ? void 0 : t.type)) {
    const o5 = v4(t, n2, e5);
    r3 = o5.tileInfo, l4 = o5.fullExtent;
  } else {
    l4 = H(t) ? t.getCompatibleFullExtent(n2) : t.fullExtent;
    const i4 = e5 === l2.Local;
    if (H(t))
      r3 = t.getCompatibleTileInfo(n2, l4, i4);
    else if ("vector-tile" === (t == null ? void 0 : t.type)) {
      const e6 = i4 && !M2(n2) || k2.force512VTL, o5 = t.tileInfo.spatialReference.isGeographic;
      r3 = e6 ? t.tileInfo : t.tileInfo.getOrCreateCompatible(256, o5 ? 1 : 2);
    } else
      r3 = t.tileInfo;
  }
  return null != r3 && null != l4 && null == C2(r3, l4, n2, e5) ? { tileInfo: r3, fullExtent: l4 } : null;
}
function v4(n2, e5, o5) {
  const l4 = v(n2);
  if (null != l4) {
    if (!V.isCollection(l4))
      return { tileInfo: l4.tileInfo, fullExtent: l4.fullExtent };
    {
      const t = l4.find((t2) => null == C2(t2.tileInfo, t2.fullExtent, e5, o5));
      if (t)
        return { tileInfo: t.tileInfo, fullExtent: t.fullExtent };
    }
  }
  return { tileInfo: null, fullExtent: null };
}
function M2(t) {
  return t.isWGS84 || t.isWebMercator || o2(t) || !R(t);
}
var k2 = { force512VTL: false };
function V2(t) {
  return "[" + t[0] + "," + t[1] + "," + t[2] + "]";
}
function F(t) {
  return "(" + t[0] + "," + t[1] + "," + t[2] + ")";
}
function G(t, n2, e5 = Z) {
  return Math.abs(t - n2) < e5;
}
function D2(t) {
  return t === S.NORTH_EAST ? S.SOUTH_WEST : t === S.NORTH_WEST ? S.SOUTH_EAST : t === S.SOUTH_WEST ? S.NORTH_EAST : S.NORTH_WEST;
}
function P3(t) {
  return t === S.NORTH ? S.SOUTH : t === S.EAST ? S.WEST : t === S.SOUTH ? S.NORTH : S.EAST;
}
function q(t) {
  return t === S.NORTH_WEST || t === S.SOUTH_WEST;
}
function z2(t) {
  return t === S.NORTH_WEST || t === S.NORTH_EAST;
}
function B(t) {
  return t === S.NORTH_WEST || t === S.WEST || t === S.SOUTH_WEST;
}
function J(t) {
  return t === S.NORTH_EAST || t === S.EAST || t === S.SOUTH_EAST;
}
function K(t) {
  return t === S.SOUTH_EAST || t === S.SOUTH || t === S.SOUTH_WEST;
}
function Q2(t) {
  return t === S.NORTH_EAST || t === S.NORTH || t === S.NORTH_WEST;
}
var X = [S.NORTH, S.EAST, S.SOUTH, S.WEST];
var Y = [S.NORTH_EAST, S.SOUTH_EAST, S.SOUTH_WEST, S.NORTH_WEST];
var Z = 1e-5;

export {
  s5 as s,
  i3 as i,
  a3 as a,
  l3 as l,
  c2 as c,
  m2 as m,
  u2 as u,
  p2 as p,
  f,
  d3 as d,
  D,
  A2 as A,
  T3 as T,
  S,
  a5 as a2,
  T5 as T2,
  s7 as s2,
  S3 as S2,
  E,
  p3 as p2,
  m3 as m2,
  H,
  O2 as O,
  y4 as y,
  _,
  R2 as R,
  d5 as d2,
  U,
  W,
  N,
  x3 as x,
  A3 as A2,
  g4 as g,
  h,
  L,
  w4 as w,
  j3 as j,
  C2 as C,
  b2 as b,
  M2 as M,
  k2 as k,
  V2 as V,
  F,
  G,
  D2,
  P3 as P,
  q,
  z2 as z,
  B,
  J,
  K,
  Q2 as Q,
  X,
  Y
};
//# sourceMappingURL=chunk-5IRKUUA3.js.map
