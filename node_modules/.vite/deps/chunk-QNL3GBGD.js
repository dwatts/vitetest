import {
  o
} from "./chunk-IMCUA6JI.js";
import {
  m as m2,
  p
} from "./chunk-RZONPIMD.js";
import {
  m
} from "./chunk-FAU6BZC4.js";
import {
  y
} from "./chunk-UM64E5NS.js";
import {
  n,
  s
} from "./chunk-2SZNVP5H.js";
import {
  f
} from "./chunk-ZEEBL7ZN.js";
import {
  a
} from "./chunk-WCHO7VLT.js";

// node_modules/@arcgis/core/libs/i3s/enums.js
var n2;
var e;
!function(n4) {
  n4[n4.None = 0] = "None", n4[n4.Int16 = 1] = "Int16", n4[n4.Int32 = 2] = "Int32";
}(n2 || (n2 = {})), function(n4) {
  n4[n4.Replace = 0] = "Replace", n4[n4.Outside = 1] = "Outside", n4[n4.Inside = 2] = "Inside", n4[n4.Finished = 3] = "Finished";
}(e || (e = {}));

// node_modules/@arcgis/core/libs/i3s/I3SModule.js
function e2() {
  return n3 || (n3 = new Promise((t) => import("./i3s-4KUXZJKS.js").then((t2) => t2.i).then(({ default: e3 }) => {
    const n4 = e3({ locateFile: i, onRuntimeInitialized: () => t(n4) });
    delete n4.then;
  })).catch((t) => {
    throw t;
  })), n3;
}
function i(e3) {
  return a(`esri/libs/i3s/${e3}`);
}
var n3;

// node_modules/@arcgis/core/views/3d/layers/SceneLayerWorker.js
async function c(e3) {
  await j();
  const r = [e3.geometryBuffer];
  return { result: A(e3, r), transferList: r };
}
async function u(e3) {
  var _a;
  await j();
  const r = [e3.geometryBuffer], { geometryBuffer: t } = e3, o2 = t.byteLength, n4 = E._malloc(o2), s2 = new Uint8Array(E.HEAPU8.buffer, n4, o2);
  s2.set(new Uint8Array(t));
  const i2 = E.dracoDecompressPointCloudData(n4, s2.byteLength);
  if (E._free(n4), i2.error.length > 0)
    throw new Error(`i3s.wasm: ${i2.error}`);
  const a2 = ((_a = i2.featureIds) == null ? void 0 : _a.length) > 0 ? i2.featureIds.slice() : null, f2 = i2.positions.slice();
  return a2 && r.push(a2.buffer), r.push(f2.buffer), { result: { positions: f2, featureIds: a2 }, transferList: r };
}
async function m3(e3) {
  await j(), S(e3);
  const r = { buffer: e3.buffer };
  return { result: r, transferList: [r.buffer] };
}
async function y2(e3) {
  await j(), w(e3);
}
async function p2(e3) {
  await j(), E.setLegacySchema(e3.context, e3.jsonSchema);
}
async function d(s2) {
  const { localMatrix: i2, origin: a2, positions: f2, vertexSpace: l, local: c2 } = s2, u2 = f.fromJSON(s2.inSpatialReference), m4 = f.fromJSON(s2.outSpatialReference), y3 = { georeferenced: p, georeferencedRelative: m, local: m2 }[l.type].fromJSON(l);
  let p3;
  if ("georeferenced" === y3.type) {
    const { projectBuffer: e3, initializeProjection: r } = await import("./projection-XFNRQLB3.js");
    await r(u2, m4), p3 = new Float64Array(f2.length), e3(f2, u2, 0, p3, m4, 0, p3.length / 3);
  } else {
    const { project: e3 } = await import("./georeference-46HDKQR7.js");
    p3 = y(e3({ positions: f2, transform: i2 ? { localMatrix: i2 } : void 0, vertexSpace: y3, inSpatialReference: u2, outSpatialReference: m4, local: c2 }));
  }
  const d2 = p3.length, [b2, h2, g2] = a2;
  for (let e3 = 0; e3 < d2; e3 += 3)
    p3[e3] -= b2, p3[e3 + 1] -= h2, p3[e3 + 2] -= g2;
  return { result: { projected: p3, original: f2 }, transferList: [p3.buffer, f2.buffer] };
}
async function b({ normalMatrix: e3, normals: r }) {
  const t = new Float32Array(r.length);
  return n(t, r, e3), s(t, t), { result: { transformed: t, original: r }, transferList: [t.buffer, r.buffer] };
}
function h(e3) {
  _(e3);
}
var g;
var E;
function w(e3) {
  const r = e3.modifications, t = E._malloc(8 * r.length), o2 = new Float64Array(E.HEAPU8.buffer, t, r.length);
  for (let n4 = 0; n4 < r.length; ++n4)
    o2[n4] = r[n4];
  E.setModifications(e3.context, t, r.length, e3.isGeodetic), E._free(t);
}
function A(e3, r) {
  if (!E)
    return null;
  const { context: t, localOrigin: o2, globalTrafo: n4, mbs: s2, obb: i2, elevationOffset: f2, geometryBuffer: l, geometryDescriptor: c2, indexToVertexProjector: u2, vertexToRenderProjector: m4 } = e3, y3 = E._malloc(l.byteLength), p3 = 33, d2 = E._malloc(p3 * Float64Array.BYTES_PER_ELEMENT), b2 = new Uint8Array(E.HEAPU8.buffer, y3, l.byteLength);
  b2.set(new Uint8Array(l));
  const h2 = new Float64Array(E.HEAPU8.buffer, d2, p3);
  I(h2, o2);
  let g2 = h2.byteOffset + 3 * h2.BYTES_PER_ELEMENT, w2 = new Float64Array(h2.buffer, g2);
  I(w2, n4), g2 += 16 * h2.BYTES_PER_ELEMENT, w2 = new Float64Array(h2.buffer, g2), I(w2, s2), g2 += 4 * h2.BYTES_PER_ELEMENT, null != i2 && (w2 = new Float64Array(h2.buffer, g2), I(w2, i2.center), g2 += 3 * h2.BYTES_PER_ELEMENT, w2 = new Float64Array(h2.buffer, g2), I(w2, i2.halfSize), g2 += 3 * h2.BYTES_PER_ELEMENT, w2 = new Float64Array(h2.buffer, g2), I(w2, i2.quaternion));
  const A2 = c2, L2 = { isDraco: false, isLegacy: false, color: e3.layouts.some((e4) => e4.some((e5) => "color" === e5.name)), normal: e3.needNormals && e3.layouts.some((e4) => e4.some((e5) => "normalCompressed" === e5.name)), uv0: e3.layouts.some((e4) => e4.some((e5) => "uv0" === e5.name)), uvRegion: e3.layouts.some((e4) => e4.some((e5) => "uvRegion" === e5.name)), featureIndex: A2.featureIndex }, S2 = E.process(t, !!e3.obb, y3, b2.byteLength, A2, L2, d2, f2, u2, m4, e3.normalReferenceFrame);
  if (E._free(d2), E._free(y3), S2.error.length > 0)
    throw new Error(`i3s.wasm: ${S2.error}`);
  if (S2.discarded)
    return null;
  const _2 = S2.componentOffsets.length > 0 ? S2.componentOffsets.slice() : null, j2 = S2.featureIds.length > 0 ? S2.featureIds.slice() : null, x2 = S2.anchorIds.length > 0 ? Array.from(S2.anchorIds) : null, T = S2.anchors.length > 0 ? Array.from(S2.anchors) : null, M = S2.interleavedVertedData.slice().buffer, P = S2.indicesType === n2.Int16 ? new Uint16Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 2).slice() : new Uint32Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 4).slice(), R = S2.positions.slice(), U = S2.positionIndicesType === n2.Int16 ? new Uint16Array(S2.positionIndices.buffer, S2.positionIndices.byteOffset, S2.positionIndices.byteLength / 2).slice() : new Uint32Array(S2.positionIndices.buffer, S2.positionIndices.byteOffset, S2.positionIndices.byteLength / 4).slice(), v = { layout: e3.layouts[0], interleavedVertexData: M, indices: P, hasColors: S2.hasColors, hasModifications: S2.hasModifications, positionData: { data: R, indices: U } };
  return j2 && r.push(j2.buffer), _2 && r.push(_2.buffer), r.push(M), r.push(P.buffer), r.push(R.buffer), r.push(U.buffer), { componentOffsets: _2, featureIds: j2, anchorIds: x2, anchors: T, transformedGeometry: v, obb: S2.obb };
}
function L(e3) {
  return 0 === e3 ? o.Unmodified : 1 === e3 ? o.PotentiallyModified : 2 === e3 ? o.Culled : o.Unknown;
}
function S(e3) {
  const { context: r, buffer: t } = e3, o2 = E._malloc(t.byteLength), n4 = t.byteLength / Float64Array.BYTES_PER_ELEMENT, s2 = new Float64Array(E.HEAPU8.buffer, o2, n4), i2 = new Float64Array(t);
  s2.set(i2), E.filterOBBs(r, o2, n4), i2.set(s2), E._free(o2);
}
function _(e3) {
  E && (E.destroy(e3), E = null);
}
function I(e3, r) {
  for (let t = 0; t < r.length; ++t)
    e3[t] = r[t];
}
function j() {
  return E ? Promise.resolve() : (g || (g = e2().then((e3) => {
    E = e3, g = null;
  })), g);
}
var x = { transform: A, destroy: _ };

export {
  e,
  c,
  u,
  m3 as m,
  y2 as y,
  p2 as p,
  d,
  b,
  h,
  w,
  L,
  S,
  j,
  x
};
//# sourceMappingURL=chunk-QNL3GBGD.js.map
