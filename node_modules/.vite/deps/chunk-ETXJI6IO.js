import {
  o
} from "./chunk-WON6TZX6.js";
import {
  n,
  p
} from "./chunk-BFVDDR4R.js";
import {
  w as w2
} from "./chunk-DZRIMGKU.js";
import {
  d
} from "./chunk-MRYR5ID7.js";
import {
  b as b2
} from "./chunk-O443WBFA.js";
import {
  b
} from "./chunk-IQRLZSBX.js";
import {
  $,
  D,
  Ee,
  F,
  I,
  L,
  b as b3,
  g,
  i,
  q,
  v
} from "./chunk-4BXK4H4L.js";
import {
  a as a2,
  l,
  w
} from "./chunk-H7RDAEPY.js";
import {
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  j
} from "./chunk-7I33FAWS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";

// node_modules/@arcgis/core/views/layers/FeatureLayerView.js
var q2 = "esri.views.layers.FeatureLayerView";
var P = s.getLogger(q2);
var _ = (r) => {
  let _2 = class extends r {
    constructor(...e2) {
      super(...e2), this._updatingRequiredFieldsPromise = null, this.filter = null, this.timeExtent = null, this.layer = null, this.requiredFields = [], this.view = null;
    }
    initialize() {
      this.handles.add([l(() => {
        var _a;
        const e2 = this.layer;
        return [(_a = e2 == null ? void 0 : e2.elevationInfo) == null ? void 0 : _a.featureExpressionInfo, e2 && "displayField" in e2 ? e2.displayField : null, e2 && "timeInfo" in e2 && e2.timeInfo, e2 && "renderer" in e2 && e2.renderer, e2 && "labelingInfo" in e2 && e2.labelingInfo, e2 && "floorInfo" in e2 && e2.floorInfo, this.filter, this.featureEffect, this.timeExtent];
      }, () => this._handleRequiredFieldsChange(), w), a2(() => {
        var _a;
        return (_a = this.view) == null ? void 0 : _a.floors;
      }, "change", () => this._handleRequiredFieldsChange()), a2(() => {
        const e2 = this.layer;
        return e2 && "sublayers" in e2 ? e2.sublayers : null;
      }, "change", () => this._handleRequiredFieldsChange())]);
    }
    get availableFields() {
      const { layer: e2, layer: { fieldsIndex: t }, requiredFields: r2 } = this;
      return "outFields" in e2 && e2.outFields ? g(t, [...b3(t, e2.outFields), ...r2]) : g(t, r2);
    }
    get featureEffect() {
      return this.layer && "featureEffect" in this.layer ? this.layer.featureEffect : null;
    }
    set featureEffect(e2) {
      this._override("featureEffect", e2);
    }
    get maximumNumberOfFeatures() {
      return 0;
    }
    set maximumNumberOfFeatures(e2) {
      P.error("#maximumNumberOfFeatures=", "Setting maximum number of features is not supported");
    }
    get maximumNumberOfFeaturesExceeded() {
      return false;
    }
    highlight(e2) {
      throw new Error("missing implementation");
    }
    createQuery() {
      const e2 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference }, t = null != this.filter ? this.filter.createQuery(e2) : new b2(e2);
      if ("feature" === this.layer.type) {
        const e3 = o(this);
        null != e3 && (t.where = t.where ? `(${t.where}) AND (${e3})` : e3);
      }
      return null != this.timeExtent && (t.timeExtent = null != t.timeExtent ? t.timeExtent.intersection(this.timeExtent) : this.timeExtent.clone()), t;
    }
    createAggregateQuery() {
      const e2 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference };
      return new b2(e2);
    }
    queryFeatures(e2, t) {
      throw new Error("missing implementation");
    }
    queryObjectIds(e2, t) {
      throw new Error("missing implementation");
    }
    queryFeatureCount(e2, t) {
      throw new Error("missing implementation");
    }
    queryExtent(e2, t) {
      throw new Error("missing implementation");
    }
    async fetchPopupFeatures(e2, t) {
      const r2 = this.validateFetchPopupFeatures(t);
      if (r2)
        throw r2;
      return this.fetchClientPopupFeatures(t);
    }
    _loadArcadeModules(e2) {
      return e2.get("expressionInfos.length") || Array.isArray(e2.content) && e2.content.some((e3) => "expression" === e3.type) ? i() : Promise.resolve();
    }
    _handleRequiredFieldsChange() {
      const e2 = this._updateRequiredFields();
      this._set("_updatingRequiredFieldsPromise", e2), e2.then(() => {
        this._updatingRequiredFieldsPromise === e2 && this._set("_updatingRequiredFieldsPromise", null);
      });
    }
    async _updateRequiredFields() {
      if (!this.layer || !this.view)
        return;
      const e2 = "3d" === this.view.type, { layer: t, layer: { fieldsIndex: r2, objectIdField: s3 } } = this, o2 = "renderer" in t && t.renderer, n2 = "orderBy" in t && t.orderBy, l2 = "featureReduction" in t ? t.featureReduction : null, a3 = /* @__PURE__ */ new Set(), u = await j([o2 ? o2.collectRequiredFields(a3, r2) : null, q(a3, t), e2 ? v(a3, t) : null, null != this.filter ? L(a3, t, this.filter) : null, null != this.featureEffect ? L(a3, t, this.featureEffect.filter) : null, l2 ? $(a3, t, l2) : null, n2 ? D(a3, t, n2) : null]);
      if ("timeInfo" in t && t.timeInfo && this.timeExtent && F(a3, t.fieldsIndex, [t.timeInfo.startField, t.timeInfo.endField]), "feature" === t.type && (t.floorInfo && F(a3, t.fieldsIndex, [t.floorInfo.floorField]), e2 && null != t.infoFor3D && (null == t.globalIdField && P.error("globalIdField missing on 3DObjectFeatureLayer"), F(a3, t.fieldsIndex, [t.globalIdField]))), "subtype-group" === t.type) {
        I(a3, r2, t.subtypeField);
        const e3 = t.sublayers.map((e4) => {
          var _a;
          return Promise.all([(_a = e4.renderer) == null ? void 0 : _a.collectRequiredFields(a3, r2), q(a3, e4)]);
        });
        await j(e3);
      }
      for (const i2 of u)
        i2.error && P.error(i2.error);
      I(a3, r2, s3), e2 && "displayField" in t && t.displayField && I(a3, r2, t.displayField);
      const p2 = Array.from(a3).sort();
      this._set("requiredFields", p2);
    }
    validateFetchPopupFeatures(e2) {
      if (null == e2)
        return null;
      for (const r2 of e2.clientGraphics ?? []) {
        const i2 = r2.layer;
        if ("popupEnabled" in i2 && !i2.popupEnabled)
          return new s2("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: i2 });
        if (r2.isAggregate) {
          const e3 = "featureReduction" in i2 ? i2.featureReduction : null;
          if (!(e3 && "popupTemplate" in e3 && e3.popupEnabled && e3.popupTemplate))
            return new s2("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: i2 });
        } else if ("popupTemplate" in i2) {
          if (!p(i2, e2))
            return new s2("featurelayerview:fetchPopupFeatures", "Layer does not define a popup template", { layer: i2 });
        }
      }
    }
    async fetchClientPopupFeatures(e2) {
      const t = null != e2 ? e2.clientGraphics : null;
      if (!t || 0 === t.length)
        return [];
      const r2 = new Array(t.length), i2 = /* @__PURE__ */ new Map(), s3 = await this.createPopupQuery(e2);
      for (let o2 = 0; o2 < t.length; o2++) {
        const n2 = t[o2];
        if (n2.isAggregate) {
          r2[o2] = n2;
          continue;
        }
        const l2 = n2.layer;
        if (!("popupEnabled" in l2))
          continue;
        const a3 = b3(this.layer.fieldsIndex, s3.outFields), u = p(l2, e2);
        if (null == u)
          continue;
        const p2 = await this._loadArcadeModules(u);
        p2 && p2.arcadeUtils.hasGeometryOperations(u) || !Ee(a3, n2) ? i2.set(n2.getObjectId(), { graphic: n2, index: o2 }) : r2[o2] = n2;
      }
      if ("stream" === this.layer.type || 0 === i2.size)
        return r2.filter(Boolean);
      s3.objectIds = Array.from(i2.keys());
      try {
        const e3 = await this.layer.queryFeatures(s3);
        for (const t2 of e3.features) {
          const { graphic: { geometry: e4 }, index: s4 } = i2.get(t2.getObjectId());
          t2.geometry || (t2.geometry = e4), r2[s4] = t2;
        }
      } catch {
      }
      return r2.filter(Boolean);
    }
    async createPopupQuery(e2) {
      const t = this.layer.createQuery(), r2 = /* @__PURE__ */ new Set();
      let i2 = false;
      const s3 = null != e2 && e2.clientGraphics ? e2.clientGraphics.map((e3) => e3.layer) : [this.layer];
      for (const o2 of s3) {
        if (!("popupEnabled" in o2))
          continue;
        const t2 = p(o2, e2);
        if (null == t2)
          continue;
        const s4 = await this._loadArcadeModules(t2), n2 = s4 && s4.arcadeUtils.hasGeometryOperations(t2);
        i2 = !("point" !== this.layer.geometryType && !n2);
        const l2 = await n(this.layer, t2);
        for (const e3 of l2)
          r2.add(e3);
      }
      if (t.returnGeometry = i2, t.returnZ = i2, t.returnM = i2, t.outFields = Array.from(r2), t.outSpatialReference = this.view.spatialReference, "feature" === this.layer.type) {
        const e3 = o(this);
        null != e3 && (t.where = t.where ? `(${t.where}) AND (${e3})` : e3);
      }
      return t;
    }
    canResume() {
      return !!super.canResume() && (null == this.timeExtent || !this.timeExtent.isEmpty);
    }
  };
  return e([y()], _2.prototype, "_updatingRequiredFieldsPromise", void 0), e([y({ readOnly: true })], _2.prototype, "availableFields", null), e([y({ type: w2 })], _2.prototype, "featureEffect", null), e([y({ type: d })], _2.prototype, "filter", void 0), e([y(b)], _2.prototype, "timeExtent", void 0), e([y()], _2.prototype, "layer", void 0), e([y({ type: Number })], _2.prototype, "maximumNumberOfFeatures", null), e([y({ readOnly: true, type: Boolean })], _2.prototype, "maximumNumberOfFeaturesExceeded", null), e([y({ readOnly: true })], _2.prototype, "requiredFields", void 0), e([y()], _2.prototype, "suspended", void 0), e([y()], _2.prototype, "view", void 0), _2 = e([a(q2)], _2), _2;
};

export {
  _
};
//# sourceMappingURL=chunk-ETXJI6IO.js.map
