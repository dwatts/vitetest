import {
  i as i2,
  n as n2,
  r
} from "./chunk-SAAQQDRS.js";
import {
  S,
  c as c3,
  m as m3,
  p
} from "./chunk-D6UIL3LF.js";
import "./chunk-B5TYSRH2.js";
import {
  a as a2
} from "./chunk-XBN7M5OG.js";
import "./chunk-BPITJIFG.js";
import {
  m as m2
} from "./chunk-3BTM6YO4.js";
import "./chunk-6OVHX5ZO.js";
import {
  o as o2
} from "./chunk-N6RC4PHI.js";
import {
  ee
} from "./chunk-CPHFVZ42.js";
import "./chunk-LLQHB2ZB.js";
import "./chunk-CFEAJLOI.js";
import "./chunk-RBDJB3ZY.js";
import "./chunk-RRRAGAMB.js";
import "./chunk-ERFCZMKG.js";
import "./chunk-C2GW4T2D.js";
import "./chunk-FLA7Z76H.js";
import "./chunk-LFQ3TKCC.js";
import "./chunk-ZD5B6I7X.js";
import "./chunk-HAYOKZGJ.js";
import "./chunk-SO7CVIZK.js";
import "./chunk-FJYIB7HF.js";
import {
  c as c4,
  t as t3
} from "./chunk-G4LSNP77.js";
import "./chunk-S5RIUWET.js";
import "./chunk-MVWFPLOX.js";
import "./chunk-X3YW4YOG.js";
import {
  ft,
  it,
  yt
} from "./chunk-IG234GCS.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-BA6PBZHC.js";
import {
  E
} from "./chunk-WWUAHPIM.js";
import "./chunk-NDKDK4Y5.js";
import {
  b as b2
} from "./chunk-O443WBFA.js";
import "./chunk-RGS3ANC3.js";
import "./chunk-YA7WDOJK.js";
import {
  h
} from "./chunk-OZL6Q7O2.js";
import "./chunk-467UETSR.js";
import "./chunk-SHFLRM67.js";
import "./chunk-ZWFMUHG3.js";
import "./chunk-EFRTD25L.js";
import "./chunk-GSS6WNQU.js";
import "./chunk-C2EHS6UI.js";
import "./chunk-GZTLZ6RD.js";
import "./chunk-KRCNIFX2.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-M6OG7C2T.js";
import "./chunk-GOK5MP3B.js";
import {
  j as j2
} from "./chunk-DSWGERIY.js";
import {
  t as t2
} from "./chunk-Y2ZDD3I4.js";
import "./chunk-H37COY3W.js";
import {
  d as d2
} from "./chunk-VMTVUE47.js";
import {
  c as c2
} from "./chunk-GDZM4A6K.js";
import "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import {
  w
} from "./chunk-W4KI5YEI.js";
import "./chunk-CAFGOFIE.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-TFIKV5RU.js";
import "./chunk-AQ7R6V4L.js";
import "./chunk-4BXK4H4L.js";
import "./chunk-SLVNG7FV.js";
import "./chunk-OZXJDVTE.js";
import {
  b,
  d
} from "./chunk-SVCGLUNW.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import "./chunk-4OR73Y2R.js";
import {
  c,
  i,
  l,
  o,
  q
} from "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import {
  M
} from "./chunk-3VUFACNT.js";
import {
  f as f2
} from "./chunk-ZEEBL7ZN.js";
import "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import {
  U,
  j,
  l as l2
} from "./chunk-H7RDAEPY.js";
import "./chunk-ODFH3BSN.js";
import {
  n
} from "./chunk-7KH4CLS5.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import {
  m,
  t2 as t,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a,
  e as e2
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import {
  C,
  f,
  s as s3
} from "./chunk-7I33FAWS.js";
import "./chunk-DWOEYHKS.js";
import {
  s2
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  s
} from "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/core/AsyncSequence.js
var r2 = class extends m {
  constructor() {
    super(...arguments), this.updating = false, this._pending = [];
  }
  push(s4, t5) {
    this._pending.push({ promise: s4, callback: t5 }), 1 === this._pending.length && this._process();
  }
  _process() {
    if (!this._pending.length)
      return void (this.updating = false);
    this.updating = true;
    const s4 = this._pending[0];
    s4.promise.then((t5) => s4.callback(t5)).catch(() => {
    }).then(() => {
      this._pending.shift(), this._process();
    });
  }
};
e([y()], r2.prototype, "updating", void 0), r2 = e([a("esri.core.AsyncSequence")], r2);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/PendingFeatureTile.js
var r3 = class {
  constructor(t5, e3) {
    this.data = t5, this.resolution = e3, this.state = { type: u.CREATED }, this.alive = true;
  }
  process(t5) {
    switch (this.state.type) {
      case u.CREATED:
        return this.state = this._gotoFetchCount(this.state, t5), this.state.task.promise.then(t5.resume, t5.resume);
      case u.FETCH_COUNT:
        break;
      case u.FETCHED_COUNT:
        return this.state = this._gotoFetchFeatures(this.state, t5), this.state.task.promise.then(t5.resume, t5.resume);
      case u.FETCH_FEATURES:
        break;
      case u.FETCHED_FEATURES:
        this.state = this._goToDone(this.state, t5);
      case u.DONE:
    }
    return null;
  }
  get debugInfo() {
    return { data: this.data, featureCount: this._featureCount, state: this._stateToString };
  }
  get _featureCount() {
    switch (this.state.type) {
      case u.CREATED:
      case u.FETCH_COUNT:
        return 0;
      case u.FETCHED_COUNT:
        return this.state.featureCount;
      case u.FETCH_FEATURES:
        return this.state.previous.featureCount;
      case u.FETCHED_FEATURES:
        return this.state.features.length;
      case u.DONE:
        return this.state.previous.features.length;
    }
  }
  get _stateToString() {
    switch (this.state.type) {
      case u.CREATED:
        return "created";
      case u.FETCH_COUNT:
        return "fetch-count";
      case u.FETCHED_COUNT:
        return "fetched-count";
      case u.FETCH_FEATURES:
        return "fetch-features";
      case u.FETCHED_FEATURES:
        return "fetched-features";
      case u.DONE:
        return "done";
    }
  }
  _gotoFetchCount(s4, a3) {
    return { type: u.FETCH_COUNT, previous: s4, task: d(async (t5) => {
      const s5 = await b(a3.fetchCount(this, t5));
      this.state.type === u.FETCH_COUNT && (this.state = this._gotoFetchedCount(this.state, s5.ok ? s5.value : 1 / 0));
    }) };
  }
  _gotoFetchedCount(t5, e3) {
    return { type: u.FETCHED_COUNT, featureCount: e3, previous: t5 };
  }
  _gotoFetchFeatures(s4, a3) {
    return { type: u.FETCH_FEATURES, previous: s4, task: d(async (t5) => {
      const E5 = await b(a3.fetchFeatures(this, s4.featureCount, t5));
      this.state.type === u.FETCH_FEATURES && (this.state = this._gotoFetchedFeatures(this.state, E5.ok ? E5.value : []));
    }) };
  }
  _gotoFetchedFeatures(t5, e3) {
    return { type: u.FETCHED_FEATURES, previous: t5, features: e3 };
  }
  _goToDone(t5, e3) {
    return e3.finish(this, t5.features), { type: u.DONE, previous: t5 };
  }
  reset() {
    const t5 = this.state;
    switch (this.state = { type: u.CREATED }, t5.type) {
      case u.CREATED:
      case u.FETCHED_COUNT:
      case u.FETCHED_FEATURES:
      case u.DONE:
        break;
      case u.FETCH_COUNT:
      case u.FETCH_FEATURES:
        t5.task.abort();
    }
  }
  intersects(t5) {
    return null == t5 || !this.data.extent || (o(t5, T), q(this.data.extent, T));
  }
};
var u;
!function(t5) {
  t5[t5.CREATED = 0] = "CREATED", t5[t5.FETCH_COUNT = 1] = "FETCH_COUNT", t5[t5.FETCHED_COUNT = 2] = "FETCHED_COUNT", t5[t5.FETCH_FEATURES = 3] = "FETCH_FEATURES", t5[t5.FETCHED_FEATURES = 4] = "FETCHED_FEATURES", t5[t5.DONE = 5] = "DONE";
}(u || (u = {}));
var T = i();

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiledFetcher.js
var I = class extends d2 {
  get _minimumVerticesPerFeature() {
    var _a;
    switch ((_a = this.store) == null ? void 0 : _a.featureStore.geometryType) {
      case "esriGeometryPoint":
      case "esriGeometryMultipoint":
        return 1;
      case "esriGeometryPolygon":
        return 4;
      case "esriGeometryPolyline":
        return 2;
    }
  }
  set filter(e3) {
    const t5 = this._get("filter"), i3 = this._filterProperties(e3);
    JSON.stringify(t5) !== JSON.stringify(i3) && this._set("filter", i3);
  }
  set customParameters(e3) {
    const t5 = this._get("customParameters");
    JSON.stringify(t5) !== JSON.stringify(e3) && this._set("customParameters", e3);
  }
  get _configuration() {
    return { filter: this.filter, customParameters: this.customParameters, tileInfo: this.tileInfo, tileSize: this.tileSize };
  }
  set tileInfo(e3) {
    const t5 = this._get("tileInfo");
    t5 !== e3 && (null != e3 && null != t5 && JSON.stringify(e3) === JSON.stringify(t5) || (this._set("tileInfo", e3), this.store.tileInfo = e3));
  }
  set tileSize(e3) {
    this._get("tileSize") !== e3 && this._set("tileSize", e3);
  }
  get updating() {
    return this.updatingExcludingEdits || this._pendingEdits.updating;
  }
  get updatingExcludingEdits() {
    return this.updatingHandles.updating;
  }
  get hasZ() {
    return this.store.featureStore.hasZ;
  }
  constructor(e3) {
    super(e3), this.tilesOfInterest = [], this.availability = 0, this._pendingTiles = /* @__PURE__ */ new Map(), this._pendingEdits = new r2(), this._pendingEditsAbortController = new AbortController();
  }
  initialize() {
    this._initializeFetchExtent(), this.updatingHandles.add(() => this._configuration, () => this.refresh()), this.updatingHandles.add(() => this.tilesOfInterest, (e3, i3) => {
      s(e3, i3, ({ id: e4 }, { id: t5 }) => e4 === t5) || this._process();
    }, U);
  }
  destroy() {
    this._pendingTiles.forEach((e3) => this._deletePendingTile(e3)), this._pendingTiles.clear(), this.store.destroy(), this.tilesOfInterest.length = 0, this._pendingEditsAbortController.abort(), this._pendingEditsAbortController = null;
  }
  refresh() {
    this.store.refresh(), this._pendingTiles.forEach((e3) => this._deletePendingTile(e3)), this._process();
  }
  applyEdits(e3) {
    this._pendingEdits.push(e3, async (e4) => {
      if (0 === e4.addedFeatures.length && 0 === e4.updatedFeatures.length && 0 === e4.deletedFeatures.length)
        return;
      for (const [, i3] of this._pendingTiles)
        i3.reset();
      const t5 = { ...e4, deletedFeatures: e4.deletedFeatures.map(({ objectId: e5, globalId: t6 }) => e5 && -1 !== e5 ? e5 : this._lookupObjectIdByGlobalId(t6)) };
      await this.updatingHandles.addPromise(this.store.processEdits(t5, (e5, t6) => this._queryFeaturesById(e5, t6), this._pendingEditsAbortController.signal)), this._processPendingTiles();
    });
  }
  _initializeFetchExtent() {
    if (!this.capabilities.query.supportsExtent || !w(this.url))
      return;
    const e3 = d(async (e4) => {
      var _a;
      try {
        const t5 = await S(this.url, new b2({ where: "1=1", outSpatialReference: this.spatialReference, cacheHint: this.capabilities.query.supportsCacheHint ?? void 0 }), { query: this._configuration.customParameters, signal: e4 });
        this.store.extent = M.fromJSON((_a = t5.data) == null ? void 0 : _a.extent);
      } catch (t5) {
        f(t5), s2.getLogger(this).warn("Failed to fetch data extent", t5);
      }
    });
    this.updatingHandles.addPromise(e3.promise.then(() => this._process())), this.handles.add(e2(() => e3.abort()));
  }
  get debugInfo() {
    return { numberOfFeatures: this.store.featureStore.numFeatures, tilesOfInterest: this.tilesOfInterest, pendingTiles: Array.from(this._pendingTiles.values()).map((e3) => e3.debugInfo), storedTiles: this.store.debugInfo };
  }
  _process() {
    this._markTilesNotAlive(), this._createPendingTiles(), this._deletePendingTiles(), this._processPendingTiles();
  }
  _markTilesNotAlive() {
    for (const [, e3] of this._pendingTiles)
      e3.alive = false;
  }
  _createPendingTiles() {
    const e3 = this._collectMissingTilesInfo();
    if (this._setAvailability(null == e3 ? 1 : e3.coveredArea / e3.fullArea), null != e3)
      for (const { data: t5, resolution: i3 } of e3.missingTiles) {
        const e4 = this._pendingTiles.get(t5.id);
        e4 ? (e4.resolution = i3, e4.alive = true) : this._createPendingTile(t5, i3);
      }
  }
  _collectMissingTilesInfo() {
    let e3 = null;
    for (let t5 = this.tilesOfInterest.length - 1; t5 >= 0; t5--) {
      const i3 = this.tilesOfInterest[t5], s4 = this.store.process(i3, (e4, t6) => this._verifyTileComplexity(e4, t6));
      null == e3 ? e3 = s4 : e3.prepend(s4);
    }
    return e3;
  }
  _deletePendingTiles() {
    for (const [, e3] of this._pendingTiles)
      e3.alive || this._deletePendingTile(e3);
  }
  _processPendingTiles() {
    const e3 = { fetchCount: (e4, t5) => this._fetchCount(e4, t5), fetchFeatures: (e4, t5, i3) => this._fetchFeatures(e4, t5, i3), finish: (e4, t5) => this._finishPendingTile(e4, t5), resume: () => this._processPendingTiles() };
    if (this._ensureFetchAllCounts(e3))
      for (const [, t5] of this._pendingTiles)
        this._verifyTileComplexity(this.store.getFeatureCount(t5.data), t5.resolution) && this.updatingHandles.addPromise(t5.process(e3));
  }
  _verifyTileComplexity(e3, t5) {
    return this._verifyVertexComplexity(e3) && this._verifyFeatureDensity(e3, t5);
  }
  _verifyVertexComplexity(e3) {
    return e3 * this._minimumVerticesPerFeature < C2;
  }
  _verifyFeatureDensity(e3, t5) {
    if (null == this.tileInfo)
      return false;
    const i3 = this.tileSize * t5;
    return e3 * (E2 / (i3 * i3)) < S2;
  }
  _ensureFetchAllCounts(e3) {
    let t5 = true;
    for (const [, i3] of this._pendingTiles)
      i3.state.type < u.FETCHED_COUNT && this.updatingHandles.addPromise(i3.process(e3)), i3.state.type <= u.FETCH_COUNT && (t5 = false);
    return t5;
  }
  _finishPendingTile(e3, t5) {
    this.store.add(e3.data, t5), this._deletePendingTile(e3), this._updateAvailability();
  }
  _updateAvailability() {
    const e3 = this._collectMissingTilesInfo();
    this._setAvailability(null == e3 ? 1 : e3.coveredArea / e3.fullArea);
  }
  _setAvailability(e3) {
    this._set("availability", e3);
  }
  _createPendingTile(e3, t5) {
    const i3 = new r3(e3, t5);
    return this._pendingTiles.set(e3.id, i3), i3;
  }
  _deletePendingTile(e3) {
    e3.reset(), this._pendingTiles.delete(e3.data.id);
  }
  async _fetchCount(e3, t5) {
    return this.store.fetchCount(e3.data, this.url, this._createCountQuery(e3), { query: this.customParameters, timeout: O, signal: t5 });
  }
  async _fetchFeatures(e3, t5, i3) {
    let s4 = 0;
    const r4 = [];
    let n3 = 0, o3 = t5;
    for (; ; ) {
      const a3 = this._createFeaturesQuery(e3), l3 = this._setPagingParameters(a3, s4, o3), { features: u2, exceededTransferLimit: c5 } = await this._queryFeatures(a3, i3);
      l3 && (s4 += a3.num), n3 += u2.length;
      for (const e4 of u2)
        r4.push(e4);
      if (o3 = t5 - n3, !l3 || !c5 || o3 <= 0)
        return r4;
    }
  }
  _filterProperties(e3) {
    return null == e3 ? { where: "1=1", gdbVersion: void 0, timeExtent: void 0 } : { where: e3.where || "1=1", timeExtent: e3.timeExtent, gdbVersion: e3.gdbVersion };
  }
  _lookupObjectIdByGlobalId(e3) {
    const t5 = this.globalIdField, i3 = this.objectIdField;
    if (null == t5)
      throw new Error("Expected globalIdField to be defined");
    let s4 = null;
    if (this.store.featureStore.forEach((r4) => {
      e3 === r4.attributes[t5] && (s4 = r4.objectId ?? r4.attributes[i3]);
    }), null == s4)
      throw new Error(`Expected to find a feature with globalId ${e3}`);
    return s4;
  }
  _queryFeaturesById(e3, t5) {
    const i3 = this._createFeaturesQuery();
    return i3.objectIds = e3, this._queryFeatures(i3, t5);
  }
  _queryFeatures(e3, t5) {
    return this.capabilities.query.supportsFormatPBF ? this._queryFeaturesPBF(e3, t5) : this._queryFeaturesJSON(e3, t5);
  }
  async _queryFeaturesPBF(e3, t5) {
    const { sourceSpatialReference: i3 } = this, { data: s4 } = await c3(this.url, e3, new a2({ sourceSpatialReference: i3 }), { query: this._configuration.customParameters, timeout: O, signal: t5 });
    return ft(s4);
  }
  async _queryFeaturesJSON(e3, t5) {
    const { sourceSpatialReference: i3 } = this, { data: s4 } = await m3(this.url, e3, i3, { query: this._configuration.customParameters, timeout: O, signal: t5 });
    return it(s4, this.objectIdField);
  }
  _createCountQuery(e3) {
    const t5 = this._createBaseQuery(e3);
    return this.capabilities.query.supportsCacheHint && (t5.cacheHint = true), t5;
  }
  _createFeaturesQuery(e3 = null) {
    const t5 = this._createBaseQuery(e3);
    return t5.outFields = this.globalIdField ? [this.globalIdField, this.objectIdField] : [this.objectIdField], t5.returnGeometry = true, null != e3 && (this.capabilities.query.supportsResultType ? t5.resultType = "tile" : this.capabilities.query.supportsCacheHint && (t5.cacheHint = true)), t5;
  }
  _createBaseQuery(e3) {
    const t5 = new b2({ returnZ: this.hasZ, returnM: false, geometry: null != this.tileInfo && null != e3 ? c(e3.data.extent, this.tileInfo.spatialReference) : void 0 }), i3 = this._configuration.filter;
    return null != i3 && (t5.where = i3.where, t5.gdbVersion = i3.gdbVersion, t5.timeExtent = i3.timeExtent), t5.outSpatialReference = this.spatialReference, t5;
  }
  _setPagingParameters(e3, t5, i3) {
    if (!this.capabilities.query.supportsPagination)
      return false;
    const { supportsMaxRecordCountFactor: s4, supportsCacheHint: r4, tileMaxRecordCount: n3, maxRecordCount: o3, supportsResultType: a3 } = this.capabilities.query, l3 = s4 ? b2.MAX_MAX_RECORD_COUNT_FACTOR : 1, u2 = l3 * ((a3 || r4) && n3 ? n3 : o3 || v);
    return e3.start = t5, s4 ? (e3.maxRecordCountFactor = Math.min(l3, Math.ceil(i3 / u2)), e3.num = Math.min(i3, e3.maxRecordCountFactor * u2)) : e3.num = Math.min(i3, u2), true;
  }
};
e([y({ constructOnly: true })], I.prototype, "url", void 0), e([y({ constructOnly: true })], I.prototype, "objectIdField", void 0), e([y({ constructOnly: true })], I.prototype, "globalIdField", void 0), e([y({ constructOnly: true })], I.prototype, "capabilities", void 0), e([y({ constructOnly: true })], I.prototype, "sourceSpatialReference", void 0), e([y({ constructOnly: true })], I.prototype, "spatialReference", void 0), e([y({ constructOnly: true })], I.prototype, "store", void 0), e([y({ readOnly: true })], I.prototype, "_minimumVerticesPerFeature", null), e([y()], I.prototype, "filter", null), e([y()], I.prototype, "customParameters", null), e([y({ readOnly: true })], I.prototype, "_configuration", null), e([y()], I.prototype, "tileInfo", null), e([y()], I.prototype, "tileSize", null), e([y()], I.prototype, "tilesOfInterest", void 0), e([y({ readOnly: true })], I.prototype, "updating", null), e([y({ readOnly: true })], I.prototype, "updatingExcludingEdits", null), e([y({ readOnly: true })], I.prototype, "availability", void 0), e([y()], I.prototype, "hasZ", null), I = e([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiledFetcher")], I);
var v = 2e3;
var O = 6e5;
var C2 = 1e6;
var E2 = 25;
var S2 = 1;

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileCache.js
var t4 = class {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._byteSize = 0;
  }
  set(t5, e3) {
    this.delete(t5), this._store.set(t5, e3), this._byteSize += e3.byteSize;
  }
  delete(t5) {
    const e3 = this._store.get(t5);
    return !!this._store.delete(t5) && (null != e3 && (this._byteSize -= e3.byteSize), true);
  }
  get(t5) {
    return this._used(t5), this._store.get(t5);
  }
  has(t5) {
    return this._used(t5), this._store.has(t5);
  }
  clear() {
    this._store.clear();
  }
  applyByteSizeLimit(t5, e3) {
    for (const [s4, r4] of this._store) {
      if (this._byteSize <= t5)
        break;
      this.delete(s4), e3(r4);
    }
  }
  values() {
    return this._store.values();
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
  _used(t5) {
    const e3 = this._store.get(t5);
    e3 && (this._store.delete(t5), this._store.set(t5, e3));
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileStore.js
var g = class extends m {
  constructor(e3) {
    super(e3), this.tileInfo = null, this.extent = null, this.maximumByteSize = 10 * E.MEGABYTES, this._tileBounds = new o2(), this._tiles = new t4(), this._refCounts = /* @__PURE__ */ new Map(), this._tileFeatureCounts = /* @__PURE__ */ new Map(), this._tmpBoundingRect = i();
  }
  add(e3, t5) {
    const s4 = [];
    for (const i3 of t5)
      this._referenceFeature(i3.objectId) === I2.ADDED && s4.push(i3);
    this._addTileStorage(e3, new Set(t5.map((e4) => e4.objectId)), y2(t5)), this.featureStore.addMany(s4), this._tiles.applyByteSizeLimit(this.maximumByteSize, (e4) => this._removeTileStorage(e4));
  }
  destroy() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  clear() {
    this.featureStore.clear(), this._tileBounds.clear(), this._tiles.clear(), this._refCounts.clear();
  }
  refresh() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  processEdits(e3, t5, s4) {
    return this._processEditsDelete(e3.deletedFeatures.concat(e3.updatedFeatures)), this._processEditsRefetch(e3.addedFeatures.concat(e3.updatedFeatures), t5, s4);
  }
  _addTileStorage(e3, t5, s4) {
    const i3 = e3.id;
    this._tiles.set(i3, new E3(e3, t5, s4)), this._tileBounds.set(i3, e3.extent), this._tileFeatureCounts.set(i3, t5.size);
  }
  _remove({ id: e3 }) {
    const t5 = this._tiles.get(e3);
    t5 && this._removeTileStorage(t5);
  }
  _removeTileStorage(e3) {
    const t5 = [];
    for (const i3 of e3.objectIds)
      this._unreferenceFeature(i3) === I2.REMOVED && t5.push(i3);
    this.featureStore.removeManyById(t5);
    const s4 = e3.data.id;
    this._tiles.delete(s4), this._tileBounds.delete(s4);
  }
  _processEditsDelete(e3) {
    this.featureStore.removeManyById(e3);
    for (const [, t5] of this._tiles) {
      for (const s4 of e3)
        t5.objectIds.delete(s4);
      this._tileFeatureCounts.set(t5.data.id, t5.objectIds.size);
    }
    for (const t5 of e3)
      this._refCounts.delete(t5);
  }
  async _processEditsRefetch(e3, t5, s4) {
    const i3 = (await t5(e3, s4)).features, { hasZ: r4, hasM: o3 } = this.featureStore;
    for (const n3 of i3) {
      const e4 = yt(this._tmpBoundingRect, n3.geometry, r4, o3);
      null != e4 && this._tileBounds.forEachInBounds(e4, (e5) => {
        const t6 = this._tiles.get(e5);
        this.featureStore.add(n3);
        const s5 = n3.objectId;
        t6.objectIds.has(s5) || (t6.objectIds.add(s5), this._referenceFeature(s5), this._tileFeatureCounts.set(t6.data.id, t6.objectIds.size));
      });
    }
  }
  process(e3, t5 = () => true) {
    if (null == this.tileInfo || !e3.extent || null != this.extent && !q(o(this.extent, this._tmpBoundingRect), e3.extent))
      return new T2(e3);
    if (this._tiles.has(e3.id))
      return new T2(e3);
    const s4 = this._createTileTree(e3, this.tileInfo);
    return this._simplify(s4, t5, null, 0, 1), this._collectMissingTiles(e3, s4, this.tileInfo);
  }
  get debugInfo() {
    return Array.from(this._tiles.values()).map(({ data: e3 }) => ({ data: e3, featureCount: this._tileFeatureCounts.get(e3.id) || 0 }));
  }
  getFeatureCount(e3) {
    return this._tileFeatureCounts.get(e3.id) ?? 0;
  }
  async fetchCount(e3, t5, s4, i3) {
    const r4 = this._tileFeatureCounts.get(e3.id);
    if (null != r4)
      return r4;
    const o3 = await p(t5, s4, i3);
    return this._tileFeatureCounts.set(e3.id, o3.data.count), o3.data.count;
  }
  _createTileTree(e3, t5) {
    const s4 = new S3(e3.level, e3.row, e3.col);
    return t5.updateTileInfo(s4, j2.ExtrapolateOptions.POWER_OF_TWO), this._tileBounds.forEachInBounds(e3.extent, (i3) => {
      var _a;
      const r4 = (_a = this._tiles.get(i3)) == null ? void 0 : _a.data;
      r4 && this._tilesAreRelated(e3, r4) && this._populateChildren(s4, r4, t5, this._tileFeatureCounts.get(r4.id) || 0);
    }), s4;
  }
  _tilesAreRelated(e3, t5) {
    if (!e3 || !t5)
      return false;
    if (e3.level === t5.level)
      return e3.row === t5.row && e3.col === t5.col;
    const s4 = e3.level < t5.level, i3 = s4 ? e3 : t5, r4 = s4 ? t5 : e3, o3 = 1 << r4.level - i3.level;
    return Math.floor(r4.row / o3) === i3.row && Math.floor(r4.col / o3) === i3.col;
  }
  _populateChildren(e3, t5, s4, i3) {
    const r4 = t5.level - e3.level - 1;
    if (r4 < 0)
      return void (e3.isLeaf = true);
    const o3 = t5.row >> r4, n3 = t5.col >> r4, l3 = e3.row << 1, a3 = n3 - (e3.col << 1) + (o3 - l3 << 1), c5 = e3.children[a3];
    if (null != c5)
      this._populateChildren(c5, t5, s4, i3);
    else {
      const r5 = new S3(e3.level + 1, o3, n3);
      s4.updateTileInfo(r5, j2.ExtrapolateOptions.POWER_OF_TWO), e3.children[a3] = r5, this._populateChildren(r5, t5, s4, i3);
    }
  }
  _simplify(e3, t5, s4, i3, r4) {
    const o3 = r4 * r4;
    if (e3.isLeaf)
      return t5(this.getFeatureCount(e3), r4) ? 0 : (this._remove(e3), null != s4 && (s4.children[i3] = null), o3);
    const n3 = r4 / 2, l3 = n3 * n3;
    let a3 = 0;
    for (let c5 = 0; c5 < e3.children.length; c5++) {
      const s5 = e3.children[c5];
      a3 += null != s5 ? this._simplify(s5, t5, e3, c5, n3) : l3;
    }
    return 0 === a3 ? this._mergeChildren(e3) : 1 - a3 / o3 < j3 && (this._purge(e3), null != s4 && (s4.children[i3] = null), a3 = o3), a3;
  }
  _mergeChildren(e3) {
    const t5 = /* @__PURE__ */ new Set();
    let s4 = 0;
    this._forEachLeaf(e3, (e4) => {
      const i3 = this._tiles.get(e4.id);
      if (i3) {
        s4 += i3.byteSize;
        for (const e5 of i3.objectIds)
          t5.has(e5) || (t5.add(e5), this._referenceFeature(e5));
        this._remove(e4);
      }
    }), this._addTileStorage(e3, t5, s4), e3.isLeaf = true, e3.children[0] = e3.children[1] = e3.children[2] = e3.children[3] = null, this._tileFeatureCounts.set(e3.id, t5.size);
  }
  _forEachLeaf(e3, t5) {
    for (const s4 of e3.children)
      null != s4 && (s4.isLeaf ? t5(s4) : this._forEachLeaf(s4, t5));
  }
  _purge(e3) {
    if (null != e3)
      if (e3.isLeaf)
        this._remove(e3);
      else
        for (let t5 = 0; t5 < e3.children.length; t5++) {
          const s4 = e3.children[t5];
          this._purge(s4), e3.children[t5] = null;
        }
  }
  _collectMissingTiles(e3, t5, s4) {
    const i3 = new F(s4, e3, this.extent);
    return this._collectMissingTilesRecurse(t5, i3, 1), i3.info;
  }
  _collectMissingTilesRecurse(e3, t5, s4) {
    if (e3.isLeaf)
      return;
    if (!e3.hasChildren)
      return void t5.addMissing(e3.level, e3.row, e3.col, s4);
    const i3 = s4 / 2;
    for (let r4 = 0; r4 < e3.children.length; r4++) {
      const s5 = e3.children[r4];
      null == s5 ? t5.addMissing(e3.level + 1, (e3.row << 1) + ((2 & r4) >> 1), (e3.col << 1) + (1 & r4), i3) : this._collectMissingTilesRecurse(s5, t5, i3);
    }
  }
  _referenceFeature(e3) {
    const t5 = (this._refCounts.get(e3) || 0) + 1;
    return this._refCounts.set(e3, t5), 1 === t5 ? I2.ADDED : I2.UNCHANGED;
  }
  _unreferenceFeature(e3) {
    const t5 = (this._refCounts.get(e3) || 0) - 1;
    return 0 === t5 ? (this._refCounts.delete(e3), I2.REMOVED) : (t5 > 0 && this._refCounts.set(e3, t5), I2.UNCHANGED);
  }
  get test() {
    return { tiles: Array.from(this._tiles.values()).map((e3) => `${e3.data.id}:[${Array.from(e3.objectIds)}]`), featureReferences: Array.from(this._refCounts.keys()).map((e3) => `${e3}:${this._refCounts.get(e3)}`) };
  }
};
function y2(e3) {
  return e3.reduce((e4, t5) => e4 + v2(t5), 0);
}
function v2(e3) {
  return 32 + C3(e3.geometry) + t3(e3.attributes);
}
function C3(e3) {
  if (null == e3)
    return 0;
  const t5 = c4(e3.lengths, 4);
  return 32 + c4(e3.coords, 8) + t5;
}
e([y({ constructOnly: true })], g.prototype, "featureStore", void 0), e([y()], g.prototype, "tileInfo", void 0), e([y()], g.prototype, "extent", void 0), e([y()], g.prototype, "maximumByteSize", void 0), g = e([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTileStore")], g);
var E3 = class {
  constructor(e3, t5, s4) {
    this.data = e3, this.objectIds = t5, this.byteSize = s4;
  }
};
var S3 = class {
  constructor(e3, t5, s4) {
    this.level = e3, this.row = t5, this.col = s4, this.isLeaf = false, this.extent = null, this.children = [null, null, null, null];
  }
  get hasChildren() {
    return !this.isLeaf && (null != this.children[0] || null != this.children[1] || null != this.children[2] || null != this.children[3]);
  }
};
var T2 = class {
  constructor(e3, t5 = []) {
    this.missingTiles = t5, this.fullArea = 0, this.coveredArea = 0, this.fullArea = l(e3.extent), this.coveredArea = this.fullArea;
  }
  prepend(e3) {
    this.missingTiles = e3.missingTiles.concat(this.missingTiles), this.coveredArea += e3.coveredArea, this.fullArea += e3.fullArea;
  }
};
var F = class {
  constructor(e3, t5, s4) {
    this._tileInfo = e3, this._extent = null, this.info = new T2(t5), null != s4 && (this._extent = o(s4));
  }
  addMissing(e3, t5, s4, i3) {
    const r4 = new t2(null, e3, t5, s4);
    this._tileInfo.updateTileInfo(r4, j2.ExtrapolateOptions.POWER_OF_TWO), null == r4.extent || null != this._extent && !q(this._extent, r4.extent) || (this.info.missingTiles.push({ data: r4, resolution: i3 }), this.info.coveredArea -= l(r4.extent));
  }
};
var j3 = 0.18751;
var I2;
!function(e3) {
  e3[e3.ADDED = 0] = "ADDED", e3[e3.REMOVED = 1] = "REMOVED", e3[e3.UNCHANGED = 2] = "UNCHANGED";
}(I2 || (I2 = {}));

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker.js
var I3 = class extends n.EventedAccessor {
  constructor() {
    super(...arguments), this._isInitializing = true, this.remoteClient = null, this._whenSetup = C(), this._elevationAligner = i2(), this._elevationFilter = r(), this._symbologyCandidatesFetcher = n2(), this._handles = new t(), this._updatingHandles = new c2(), this._editsUpdatingHandles = new c2(), this._pendingApplyEdits = /* @__PURE__ */ new Map(), this._alignPointsInFeatures = async (e3, t5) => {
      const i3 = { points: e3 }, r4 = await this.remoteClient.invoke("alignElevation", i3, { signal: t5 });
      return s3(t5), r4;
    }, this._getSymbologyCandidates = async (e3, t5) => {
      const i3 = { candidates: e3, spatialReference: this._spatialReference.toJSON() }, r4 = await this.remoteClient.invoke("getSymbologyCandidates", i3, { signal: t5 });
      return s3(t5), r4;
    };
  }
  get updating() {
    return this.updatingExcludingEdits || this._editsUpdatingHandles.updating || this._featureFetcher.updating;
  }
  get updatingExcludingEdits() {
    return this._featureFetcher.updatingExcludingEdits || this._isInitializing || this._updatingHandles.updating;
  }
  destroy() {
    var _a, _b, _c, _d;
    (_a = this._featureFetcher) == null ? void 0 : _a.destroy(), (_b = this._queryEngine) == null ? void 0 : _b.destroy(), (_c = this._featureStore) == null ? void 0 : _c.clear(), (_d = this._handles) == null ? void 0 : _d.destroy();
  }
  async setup(e3) {
    if (this.destroyed)
      return { result: {} };
    const { geometryType: t5, objectIdField: i3, timeInfo: r4, fields: s4 } = e3.serviceInfo, { hasZ: a3 } = e3, l3 = f2.fromJSON(e3.spatialReference);
    this._spatialReference = l3, this._featureStore = new m2({ ...e3.serviceInfo, hasZ: a3, hasM: false }), this._queryEngine = new ee({ spatialReference: e3.spatialReference, featureStore: this._featureStore, geometryType: t5, fields: s4, hasZ: a3, hasM: false, objectIdField: i3, timeInfo: r4 }), this._featureFetcher = new I({ store: new g({ featureStore: this._featureStore }), url: e3.serviceInfo.url, objectIdField: e3.serviceInfo.objectIdField, globalIdField: e3.serviceInfo.globalIdField, capabilities: e3.serviceInfo.capabilities, spatialReference: l3, sourceSpatialReference: f2.fromJSON(e3.serviceInfo.spatialReference) });
    const d3 = "3d" === e3.configuration.viewType;
    return this._elevationAligner = i2(d3, { elevationInfo: null != e3.elevationInfo ? h.fromJSON(e3.elevationInfo) : null, alignPointsInFeatures: this._alignPointsInFeatures, spatialReference: l3 }), this._elevationFilter = r(d3), this._handles.add([l2(() => this._featureFetcher.availability, (e4) => this.emit("notify-availability", { availability: e4 }), U), l2(() => this.updating, () => this._notifyUpdating())]), this._whenSetup.resolve(), this._isInitializing = false, this.configure(e3.configuration);
  }
  async configure(e3) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), this._updateFeatureFetcherConfiguration(e3), { result: {} };
  }
  async fetchCandidates(e3, t5) {
    await this._whenSetup.promise, s3(t5);
    const i3 = E4(e3), r4 = null != t5 ? t5.signal : null, n3 = await this._queryEngine.executeQueryForSnapping(i3, r4);
    s3(r4);
    const a3 = await this._elevationAligner.alignCandidates(n3.candidates, r4);
    s3(r4);
    const o3 = await this._symbologyCandidatesFetcher.fetch(a3, r4);
    s3(r4);
    const l3 = 0 === o3.length ? a3 : a3.concat(o3);
    return { result: { candidates: this._elevationFilter.filter(i3, l3) } };
  }
  async updateTiles(e3, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s3(t5), this._featureFetcher.tileSize = e3.tileSize, this._featureFetcher.tilesOfInterest = e3.tiles, this._featureFetcher.tileInfo = null != e3.tileInfo ? j2.fromJSON(e3.tileInfo) : null, b3;
  }
  async refresh(e3, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s3(t5), this._featureFetcher.refresh(), b3;
  }
  async whenNotUpdating(e3, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s3(t5), await j(() => !this.updatingExcludingEdits, t5), s3(t5), b3;
  }
  async getDebugInfo(e3, t5) {
    return s3(t5), { result: this._featureFetcher.debugInfo };
  }
  async beginApplyEdits(e3, t5) {
    this._updatingHandles.addPromise(this._whenSetup.promise), s3(t5);
    const i3 = C();
    return this._pendingApplyEdits.set(e3.id, i3), this._featureFetcher.applyEdits(i3.promise), this._editsUpdatingHandles.addPromise(i3.promise), b3;
  }
  async endApplyEdits(e3, t5) {
    const i3 = this._pendingApplyEdits.get(e3.id);
    return i3 && i3.resolve(e3.edits), s3(t5), b3;
  }
  async notifyElevationSourceChange(e3, t5) {
    return this._elevationAligner.notifyElevationSourceChange(), b3;
  }
  async notifySymbologyChange(e3, t5) {
    return this._symbologyCandidatesFetcher.notifySymbologyChange(), b3;
  }
  async setSymbologySnappingSupported(e3) {
    return this._symbologyCandidatesFetcher = n2(e3, this._getSymbologyCandidates), b3;
  }
  _updateFeatureFetcherConfiguration(e3) {
    this._featureFetcher.filter = null != e3.filter ? b2.fromJSON(e3.filter) : null, this._featureFetcher.customParameters = e3.customParameters;
  }
  _notifyUpdating() {
    this.emit("notify-updating", { updating: this.updating });
  }
};
e([y({ readOnly: true })], I3.prototype, "updating", null), e([y({ readOnly: true })], I3.prototype, "updatingExcludingEdits", null), e([y()], I3.prototype, "_isInitializing", void 0), I3 = e([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorker")], I3);
var w2 = I3;
function E4(e3) {
  return { point: e3.point, mode: e3.mode, distance: e3.distance, returnEdge: e3.returnEdge, returnVertex: e3.returnVertex, query: null != e3.filter ? e3.filter : { where: "1=1" } };
}
var b3 = { result: {} };
export {
  w2 as default
};
//# sourceMappingURL=FeatureServiceSnappingSourceWorker-QAOIFUWD.js.map
