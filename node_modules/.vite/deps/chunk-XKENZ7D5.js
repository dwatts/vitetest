import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import {
  a
} from "./chunk-IYZKKFJM.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/LEPCC.js
var t = true;
var o = { identifierOffset: 0, identifierLength: 10, versionOffset: 10, checksumOffset: 12, byteCount: 16 };
function r(e, r2, n2) {
  return { identifier: String.fromCharCode.apply(null, new Uint8Array(e, n2 + o.identifierOffset, o.identifierLength)), version: r2.getUint16(n2 + o.versionOffset, t), checksum: r2.getUint32(n2 + o.checksumOffset, t) };
}
var n = { sizeLo: 0, sizeHi: 4, minX: 8, minY: 16, minZ: 24, maxX: 32, maxY: 40, maxZ: 48, errorX: 56, errorY: 64, errorZ: 72, count: 80, reserved: 84, byteCount: 88 };
function i(e, o2) {
  return { sizeLo: e.getUint32(o2 + n.sizeLo, t), sizeHi: e.getUint32(o2 + n.sizeHi, t), minX: e.getFloat64(o2 + n.minX, t), minY: e.getFloat64(o2 + n.minY, t), minZ: e.getFloat64(o2 + n.minZ, t), maxX: e.getFloat64(o2 + n.maxX, t), maxY: e.getFloat64(o2 + n.maxY, t), maxZ: e.getFloat64(o2 + n.maxZ, t), errorX: e.getFloat64(o2 + n.errorX, t), errorY: e.getFloat64(o2 + n.errorY, t), errorZ: e.getFloat64(o2 + n.errorZ, t), count: e.getUint32(o2 + n.count, t), reserved: e.getUint32(o2 + n.reserved, t) };
}
function c(t2) {
  const c3 = new DataView(t2, 0);
  let d3 = 0;
  const { identifier: l3, version: a4 } = r(t2, c3, d3);
  if (d3 += o.byteCount, "LEPCC     " !== l3)
    throw new s2("lepcc-decode-error", "Bad identifier");
  if (a4 > 1)
    throw new s2("lepcc-decode-error", "Unknown version");
  const u3 = i(c3, d3);
  d3 += n.byteCount;
  if (u3.sizeHi * 2 ** 32 + u3.sizeLo !== t2.byteLength)
    throw new s2("lepcc-decode-error", "Bad size");
  const f3 = new Float64Array(3 * u3.count), h3 = [], w3 = [], g2 = [], p2 = [];
  if (d3 = s3(t2, d3, h3), d3 = s3(t2, d3, w3), d3 = s3(t2, d3, g2), d3 = s3(t2, d3, p2), d3 !== t2.byteLength)
    throw new s2("lepcc-decode-error", "Bad length");
  let m2 = 0, U = 0;
  for (let e = 0; e < h3.length; e++) {
    U += h3[e];
    let t3 = 0;
    for (let o2 = 0; o2 < w3[e]; o2++) {
      t3 += g2[m2];
      const e2 = p2[m2];
      f3[3 * m2] = Math.min(u3.maxX, u3.minX + 2 * u3.errorX * t3), f3[3 * m2 + 1] = Math.min(u3.maxY, u3.minY + 2 * u3.errorY * U), f3[3 * m2 + 2] = Math.min(u3.maxZ, u3.minZ + 2 * u3.errorZ * e2), m2++;
    }
  }
  return { errorX: u3.errorX, errorY: u3.errorY, errorZ: u3.errorZ, result: f3 };
}
function s3(e, t2, o2) {
  const r2 = [];
  t2 = d(e, t2, r2);
  const n2 = [];
  for (let i2 = 0; i2 < r2.length; i2++) {
    n2.length = 0, t2 = d(e, t2, n2);
    for (let e2 = 0; e2 < n2.length; e2++)
      o2.push(n2[e2] + r2[i2]);
  }
  return t2;
}
function d(o2, r2, n2) {
  const i2 = new DataView(o2, r2), c3 = i2.getUint8(0), s5 = 31 & c3, d3 = !!(32 & c3), l3 = (192 & c3) >> 6;
  let a4 = 0;
  if (0 === l3)
    a4 = i2.getUint32(1, t), r2 += 5;
  else if (1 === l3)
    a4 = i2.getUint16(1, t), r2 += 3;
  else {
    if (2 !== l3)
      throw new s2("lepcc-decode-error", "Bad count type");
    a4 = i2.getUint8(1), r2 += 2;
  }
  if (d3)
    throw new s2("lepcc-decode-error", "LUT not implemented");
  const u3 = Math.ceil(a4 * s5 / 8), f3 = new Uint8Array(o2, r2, u3);
  let h3 = 0, w3 = 0, g2 = 0;
  const p2 = -1 >>> 32 - s5;
  for (let e = 0; e < a4; e++) {
    for (; w3 < s5; )
      h3 |= f3[g2] << w3, w3 += 8, g2 += 1;
    n2[e] = h3 & p2, h3 >>>= s5, w3 -= s5, w3 + s5 > 32 && (h3 |= f3[g2 - 1] >> 8 - w3);
  }
  return r2 + g2;
}
var l = { sizeLo: 0, sizeHi: 4, count: 8, colorMapCount: 12, lookupMethod: 14, compressionMethod: 15, byteCount: 16 };
function a2(e, o2) {
  return { sizeLo: e.getUint32(o2 + l.sizeLo, t), sizeHi: e.getUint32(o2 + l.sizeHi, t), count: e.getUint32(o2 + l.count, t), colorMapCount: e.getUint16(o2 + l.colorMapCount, t), lookupMethod: e.getUint8(o2 + l.lookupMethod), compressionMethod: e.getUint8(o2 + l.compressionMethod) };
}
function u(t2) {
  const n2 = new DataView(t2, 0);
  let i2 = 0;
  const { identifier: c3, version: s5 } = r(t2, n2, i2);
  if (i2 += o.byteCount, "ClusterRGB" !== c3)
    throw new s2("lepcc-decode-error", "Bad identifier");
  if (s5 > 1)
    throw new s2("lepcc-decode-error", "Unknown version");
  const d3 = a2(n2, i2);
  i2 += l.byteCount;
  if (d3.sizeHi * 2 ** 32 + d3.sizeLo !== t2.byteLength)
    throw new s2("lepcc-decode-error", "Bad size");
  if ((2 === d3.lookupMethod || 1 === d3.lookupMethod) && 0 === d3.compressionMethod) {
    if (3 * d3.colorMapCount + d3.count + i2 !== t2.byteLength || d3.colorMapCount > 256)
      throw new s2("lepcc-decode-error", "Bad count");
    const o2 = new Uint8Array(t2, i2, 3 * d3.colorMapCount), r2 = new Uint8Array(t2, i2 + 3 * d3.colorMapCount, d3.count), n3 = new Uint8Array(3 * d3.count);
    for (let e = 0; e < d3.count; e++) {
      const t3 = r2[e];
      n3[3 * e] = o2[3 * t3], n3[3 * e + 1] = o2[3 * t3 + 1], n3[3 * e + 2] = o2[3 * t3 + 2];
    }
    return n3;
  }
  if (0 === d3.lookupMethod && 0 === d3.compressionMethod) {
    if (3 * d3.count + i2 !== t2.byteLength || 0 !== d3.colorMapCount)
      throw new s2("lepcc-decode-error", "Bad count");
    return new Uint8Array(t2, i2).slice();
  }
  if (d3.lookupMethod <= 2 && 1 === d3.compressionMethod) {
    if (i2 + 3 !== t2.byteLength || 1 !== d3.colorMapCount)
      throw new s2("lepcc-decode-error", "Bad count");
    const o2 = n2.getUint8(i2), r2 = n2.getUint8(i2 + 1), c4 = n2.getUint8(i2 + 2), s6 = new Uint8Array(3 * d3.count);
    for (let e = 0; e < d3.count; e++)
      s6[3 * e] = o2, s6[3 * e + 1] = r2, s6[3 * e + 2] = c4;
    return s6;
  }
  throw new s2("lepcc-decode-error", "Bad method " + d3.lookupMethod + "," + d3.compressionMethod);
}
var f = { sizeLo: 0, sizeHi: 4, count: 8, scaleFactor: 12, bitsPerPoint: 14, reserved: 15, byteCount: 16 };
function h(e, o2) {
  return { sizeLo: e.getUint32(o2 + f.sizeLo, t), sizeHi: e.getUint32(o2 + f.sizeHi, t), count: e.getUint32(o2 + f.count, t), scaleFactor: e.getUint16(o2 + f.scaleFactor, t), bitsPerPoint: e.getUint8(o2 + f.bitsPerPoint), reserved: e.getUint8(o2 + f.reserved) };
}
function w(t2) {
  const n2 = new DataView(t2, 0);
  let i2 = 0;
  const { identifier: c3, version: s5 } = r(t2, n2, i2);
  if (i2 += o.byteCount, "Intensity " !== c3)
    throw new s2("lepcc-decode-error", "Bad identifier");
  if (s5 > 1)
    throw new s2("lepcc-decode-error", "Unknown version");
  const l3 = h(n2, i2);
  i2 += f.byteCount;
  if (l3.sizeHi * 2 ** 32 + l3.sizeLo !== t2.byteLength)
    throw new s2("lepcc-decode-error", "Bad size");
  const a4 = new Uint16Array(l3.count);
  if (8 === l3.bitsPerPoint) {
    if (l3.count + i2 !== t2.byteLength)
      throw new s2("lepcc-decode-error", "Bad size");
    const o2 = new Uint8Array(t2, i2, l3.count);
    for (let e = 0; e < l3.count; e++)
      a4[e] = o2[e] * l3.scaleFactor;
  } else if (16 === l3.bitsPerPoint) {
    if (2 * l3.count + i2 !== t2.byteLength)
      throw new s2("lepcc-decode-error", "Bad size");
    const o2 = new Uint16Array(t2, i2, l3.count);
    for (let e = 0; e < l3.count; e++)
      a4[e] = o2[e] * l3.scaleFactor;
  } else {
    const o2 = [];
    if (d(t2, i2, o2) !== t2.byteLength)
      throw new s2("lepcc-decode-error", "Bad size");
    for (let e = 0; e < l3.count; e++)
      a4[e] = o2[e] * l3.scaleFactor;
  }
  return a4;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SBinaryReader.js
var u2 = s.getLogger("esri.views.3d.layers.i3s.I3SBinaryReader");
function a3(t2, n2, r2) {
  let o2 = "", i2 = 0;
  for (; i2 < r2; ) {
    const u3 = t2[n2 + i2];
    if (u3 < 128)
      o2 += String.fromCharCode(u3), i2++;
    else if (u3 >= 192 && u3 < 224) {
      if (i2 + 1 >= r2)
        throw new s2("utf8-decode-error", "UTF-8 Decode failed. Two byte character was truncated.");
      const a4 = (31 & u3) << 6 | 63 & t2[n2 + i2 + 1];
      o2 += String.fromCharCode(a4), i2 += 2;
    } else if (u3 >= 224 && u3 < 240) {
      if (i2 + 2 >= r2)
        throw new s2("utf8-decode-error", "UTF-8 Decode failed. Multi byte character was truncated.");
      const a4 = (15 & u3) << 12 | (63 & t2[n2 + i2 + 1]) << 6 | 63 & t2[n2 + i2 + 2];
      o2 += String.fromCharCode(a4), i2 += 3;
    } else {
      if (!(u3 >= 240 && u3 < 248))
        throw new s2("utf8-decode-error", "UTF-8 Decode failed. Invalid multi byte sequence.");
      {
        if (i2 + 3 >= r2)
          throw new s2("utf8-decode-error", "UTF-8 Decode failed. Multi byte character was truncated.");
        const a4 = (7 & u3) << 18 | (63 & t2[n2 + i2 + 1]) << 12 | (63 & t2[n2 + i2 + 2]) << 6 | 63 & t2[n2 + i2 + 3];
        if (a4 >= 65536) {
          const e = 55296 + (a4 - 65536 >> 10), t3 = 56320 + (1023 & a4);
          o2 += String.fromCharCode(e, t3);
        } else
          o2 += String.fromCharCode(a4);
        i2 += 4;
      }
    }
  }
  return o2;
}
function s4(e, t2) {
  const n2 = { byteOffset: 0, byteCount: 0, fields: /* @__PURE__ */ Object.create(null) };
  let r2 = 0;
  for (let o2 = 0; o2 < t2.length; o2++) {
    const i2 = t2[o2], u3 = i2.valueType || i2.type, a4 = A[u3];
    n2.fields[i2.property] = a4(e, r2), r2 += h2[u3].BYTES_PER_ELEMENT;
  }
  return n2.byteCount = r2, n2;
}
function c2(e, t2, n2) {
  return f2(e, t2, n2).map((e2) => {
    const t3 = e2 ? Date.parse(e2) : null;
    return t3 && !Number.isNaN(t3) ? t3 : null;
  });
}
function f2(t2, n2, r2) {
  const o2 = [];
  let i2, u3, s5 = 0;
  for (u3 = 0; u3 < t2; u3 += 1) {
    if (i2 = n2[u3], i2 > 0) {
      if (o2.push(a3(r2, s5, i2 - 1)), 0 !== r2[s5 + i2 - 1])
        throw new s2("string-array-error", "Invalid string array: missing null termination.");
    } else
      o2.push(null);
    s5 += i2;
  }
  return o2;
}
function l2(e, t2) {
  return new (0, h2[t2.valueType])(e, t2.byteOffset, t2.count * t2.valuesPerElement);
}
function d2(e, t2) {
  return new Uint8Array(e, t2.byteOffset, t2.byteCount);
}
function b(n2, r2, o2) {
  const i2 = null != r2.header ? s4(n2, r2.header) : { byteOffset: 0, byteCount: 0, fields: { count: o2 } }, u3 = { header: i2, byteOffset: i2.byteCount, byteCount: 0, entries: /* @__PURE__ */ Object.create(null) };
  let a4 = i2.byteCount;
  for (let s5 = 0; s5 < r2.ordering.length; s5++) {
    const n3 = r2.ordering[s5], o3 = a(r2[n3]);
    if (o3.count = i2.fields.count ?? 0, "String" === o3.valueType) {
      if (o3.byteOffset = a4, o3.byteCount = i2.fields[n3 + "ByteCount"], "UTF-8" !== o3.encoding)
        throw new s2("unsupported-encoding", "Unsupported String encoding.", { encoding: o3.encoding });
      if (o3.timeEncoding && "ECMA_ISO8601" !== o3.timeEncoding)
        throw new s2("unsupported-time-encoding", "Unsupported time encoding.", { timeEncoding: o3.timeEncoding });
    } else {
      if (!O2(o3.valueType))
        throw new s2("unsupported-value-type", "Unsupported binary valueType", { valueType: o3.valueType });
      {
        const e = E(o3.valueType);
        a4 += a4 % e != 0 ? e - a4 % e : 0, o3.byteOffset = a4, o3.byteCount = e * o3.valuesPerElement * o3.count;
      }
    }
    a4 += o3.byteCount ?? 0, u3.entries[n3] = o3;
  }
  return u3.byteCount = a4 - u3.byteOffset, u3;
}
function y(t2, n2, r2) {
  if (n2 !== t2 && u2.error(`Invalid ${r2} buffer size
 expected: ${t2}, actual: ${n2})`), n2 < t2)
    throw new s2("buffer-too-small", "Binary buffer is too small", { expectedSize: t2, actualSize: n2 });
}
function g(e) {
  return { isDraco: false, isLegacy: false, color: null != e.color, normal: null != e.normal, uv0: null != e.uv0, uvRegion: null != e.uvRegion, featureIndex: null != e.faceRange && null != e.featureId };
}
function w2(e, t2) {
  const n2 = s4(e, t2 && t2.header);
  let r2 = n2.byteCount;
  const o2 = { isDraco: false, header: n2, byteOffset: n2.byteCount, byteCount: 0, vertexAttributes: {} }, i2 = n2.fields, u3 = null != i2.vertexCount ? i2.vertexCount : i2.count;
  for (const s5 of t2.ordering) {
    if (!t2.vertexAttributes[s5])
      continue;
    const e2 = { ...t2.vertexAttributes[s5], byteOffset: r2, count: u3 }, n3 = C[s5] || "_" + s5;
    o2.vertexAttributes[n3] = e2, r2 += E(e2.valueType) * e2.valuesPerElement * u3;
  }
  const a4 = i2.faceCount;
  if (t2.faces && a4) {
    o2.faces = {};
    for (const e2 of t2.ordering) {
      if (!t2.faces[e2])
        continue;
      const n3 = { ...t2.faces[e2], byteOffset: r2, count: a4 };
      o2.faces[e2] = n3, r2 += E(n3.valueType) * n3.valuesPerElement * a4;
    }
  }
  const c3 = i2.featureCount;
  if (t2.featureAttributes && t2.featureAttributeOrder && c3) {
    o2.featureAttributes = {};
    for (const e2 of t2.featureAttributeOrder) {
      if (!t2.featureAttributes[e2])
        continue;
      const n3 = { ...t2.featureAttributes[e2], byteOffset: r2, count: c3 };
      o2.featureAttributes[e2] = n3;
      r2 += ("UInt64" === n3.valueType ? 8 : E(n3.valueType)) * n3.valuesPerElement * c3;
    }
  }
  return y(r2, e.byteLength, "geometry"), o2.byteCount = r2 - o2.byteOffset, o2;
}
function p(e, t2) {
  return !(!e || !e.compressedAttributes || "draco" !== e.compressedAttributes.encoding) ? v(e.compressedAttributes.attributes) : e ? g(e) : m(t2);
}
function m(e) {
  const t2 = { isDraco: false, isLegacy: true, color: false, normal: false, uv0: false, uvRegion: false, featureIndex: false };
  for (const n2 of e.ordering)
    if (e.vertexAttributes[n2])
      switch (n2) {
        case "position":
          break;
        case "normal":
          t2.normal = true;
          break;
        case "color":
          t2.color = true;
          break;
        case "uv0":
          t2.uv0 = true;
          break;
        case "region":
          t2.uvRegion = true;
      }
  return e.featureAttributes && e.featureAttributeOrder && (t2.featureIndex = true), t2;
}
function v(e) {
  const t2 = { isDraco: true, isLegacy: false, color: false, normal: false, uv0: false, uvRegion: false, featureIndex: false };
  for (const n2 of e)
    switch (n2) {
      case "position":
        break;
      case "normal":
        t2.normal = true;
        break;
      case "uv0":
        t2.uv0 = true;
        break;
      case "color":
        t2.color = true;
        break;
      case "uv-region":
        t2.uvRegion = true;
        break;
      case "feature-index":
        t2.featureIndex = true;
    }
  return t2;
}
var C = { position: O.POSITION, normal: O.NORMAL, color: O.COLOR, uv0: O.UV0, region: O.UVREGION };
function I(t2, n2, i2) {
  if ("lepcc-rgb" === t2.encoding)
    return u(n2);
  if ("lepcc-intensity" === t2.encoding)
    return w(n2);
  if (null != t2.encoding && "" !== t2.encoding)
    throw new s2("unknown-attribute-storage-info-encoding", "Unknown Attribute Storage Info Encoding");
  t2["attributeByteCounts "] && !t2.attributeByteCounts && (u2.warn("Warning: Trailing space in 'attributeByteCounts '."), t2.attributeByteCounts = t2["attributeByteCounts "]), "ObjectIds" === t2.ordering[0] && t2.hasOwnProperty("objectIds") && (u2.warn("Warning: Case error in objectIds"), t2.ordering[0] = "objectIds");
  const a4 = b(n2, t2, i2);
  y(a4.byteOffset + a4.byteCount, n2.byteLength, "attribute");
  const s5 = a4.entries.attributeValues || a4.entries.objectIds;
  if (s5) {
    if ("String" === s5.valueType) {
      const e = a4.entries.attributeByteCounts, t3 = l2(n2, e), r2 = d2(n2, s5);
      return s5.timeEncoding ? c2(e.count, t3, r2) : f2(e.count, t3, r2);
    }
    return l2(n2, s5);
  }
  throw new s2("bad-attribute-storage-info", "Bad attributeStorageInfo specification.");
}
var h2 = { Float32: Float32Array, Float64: Float64Array, UInt8: Uint8Array, Int8: Int8Array, UInt16: Uint16Array, Int16: Int16Array, UInt32: Uint32Array, Int32: Int32Array };
var A = { Float32: (e, t2) => new DataView(e, 0).getFloat32(t2, true), Float64: (e, t2) => new DataView(e, 0).getFloat64(t2, true), UInt8: (e, t2) => new DataView(e, 0).getUint8(t2), Int8: (e, t2) => new DataView(e, 0).getInt8(t2), UInt16: (e, t2) => new DataView(e, 0).getUint16(t2, true), Int16: (e, t2) => new DataView(e, 0).getInt16(t2, true), UInt32: (e, t2) => new DataView(e, 0).getUint32(t2, true), Int32: (e, t2) => new DataView(e, 0).getInt32(t2, true) };
function O2(e) {
  return h2.hasOwnProperty(e);
}
function E(e) {
  return O2(e) ? h2[e].BYTES_PER_ELEMENT : 0;
}

export {
  c,
  l2 as l,
  w2 as w,
  p,
  I
};
//# sourceMappingURL=chunk-XKENZ7D5.js.map
