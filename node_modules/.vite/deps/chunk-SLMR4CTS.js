import {
  I
} from "./chunk-XKENZ7D5.js";
import {
  O as O2,
  R,
  ae
} from "./chunk-GZTS5346.js";
import {
  a,
  f as f3
} from "./chunk-EK3Y2IYO.js";
import {
  s as s2
} from "./chunk-6S2FCH6S.js";
import {
  e as e5,
  n as n3
} from "./chunk-BZL5MAFP.js";
import {
  e as e4
} from "./chunk-XY26YCFX.js";
import {
  c
} from "./chunk-NETCTS4Y.js";
import {
  B,
  S,
  y
} from "./chunk-OKABUMQT.js";
import {
  e as e3
} from "./chunk-CW7LIPBH.js";
import {
  e as e2
} from "./chunk-VN2IXVGV.js";
import {
  b
} from "./chunk-O443WBFA.js";
import {
  p as p2
} from "./chunk-JB7FDW5N.js";
import {
  Cn,
  Hn,
  yn,
  zn
} from "./chunk-BNBT4QTW.js";
import {
  h
} from "./chunk-7EG7BYWF.js";
import {
  C,
  f as f2,
  i,
  q
} from "./chunk-EKJ2DJIR.js";
import {
  E,
  J,
  O,
  g,
  o as o2,
  r,
  u
} from "./chunk-TPJLFGOT.js";
import {
  n as n2
} from "./chunk-CQX57DED.js";
import {
  f
} from "./chunk-ZEEBL7ZN.js";
import {
  A2 as A,
  G
} from "./chunk-RTDN6KAT.js";
import {
  j as j2
} from "./chunk-43LWRDQS.js";
import {
  j
} from "./chunk-7I33FAWS.js";
import {
  n
} from "./chunk-DWOEYHKS.js";
import {
  s3 as s
} from "./chunk-HMVAPW5X.js";
import {
  e2 as e,
  has,
  o,
  p,
  x
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SProjectionUtil.js
function n4(o3, r2, n5, s4) {
  const c3 = h2(o3, r2, n5), i2 = e3();
  return zn(n5, c3, i2, s4), i2;
}
var s3 = 1;
var c2 = 5 - s3;
function h2(t, a2, n5) {
  const h3 = n2(), i2 = t[3], e6 = 2 ** (Math.ceil(Math.log(i2) * Math.LOG2E / c2) * c2 + s3);
  if (n5.isGeographic) {
    const o3 = e6 / A(n5).radius * 180 / Math.PI, a3 = Math.round(t[1] / o3), s4 = Math.max(-90, Math.min(90, a3 * o3)), c3 = o3 / Math.cos((Math.abs(s4) - o3 / 2) / 180 * Math.PI), i3 = Math.round(t[0] / c3) * c3;
    h3[0] = i3, h3[1] = s4;
  } else {
    const o3 = Math.round(t[0] / e6), r2 = Math.round(t[1] / e6);
    h3[0] = o3 * e6, h3[1] = r2 * e6;
  }
  const M = t[2] + a2, m = Math.round(M / e6);
  return h3[2] = m * e6, h3;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SUtil.js
function Q(e6) {
  return e6 ? parseInt(e6.substring(e6.lastIndexOf("/") + 1, e6.length), 10) : void 0;
}
function Z(e6) {
  var _a;
  if (has("disable-feature:i3s-draco") || !e6)
    return false;
  for (const t of e6)
    for (const e7 of t.geometryBuffers)
      if ("draco" === ((_a = e7.compressedAttributes) == null ? void 0 : _a.encoding))
        return true;
  return false;
}
function H(e6, t, r2, n5) {
  r2.traverse(t, (t2) => {
    const r3 = t2.mbs;
    return (null != r3 && te(e6, r3)) !== ee.OUTSIDE && (n5(t2), true);
  });
}
function J2(e6, t, r2) {
  let n5 = 0, o3 = 0;
  for (let a2 = 0; a2 < t.length && n5 < e6.length; a2++)
    e6[n5] === t[a2] && (r2(a2) && (e6[o3] = e6[n5], o3++), n5++);
  e6.length = o3;
}
function V(e6, r2, n5) {
  let o3 = 0, a2 = 0;
  for (; o3 < n5.length; ) {
    x(e6, n5[o3]) >= 0 === r2 && (n5[a2] = n5[o3], a2++), o3++;
  }
  n5.length = a2;
}
var X = i();
function Y(e6, t) {
  if (0 === t.rotationScale[1] && 0 === t.rotationScale[2] && 0 === t.rotationScale[3] && 0 === t.rotationScale[5] && 0 === t.rotationScale[6] && 0 === t.rotationScale[7])
    return X[0] = (e6[0] - t.position[0]) / t.rotationScale[0], X[1] = (e6[1] - t.position[1]) / t.rotationScale[4], X[2] = (e6[2] - t.position[0]) / t.rotationScale[0], X[3] = (e6[3] - t.position[1]) / t.rotationScale[4], X;
}
var ee;
function te(e6, t) {
  const r2 = t[0], n5 = t[1], o3 = t[3], a2 = e6[0] - r2, i2 = r2 - e6[2], s4 = e6[1] - n5, l = n5 - e6[3], c3 = Math.max(a2, i2, 0), u2 = Math.max(s4, l, 0), f4 = c3 * c3 + u2 * u2;
  if (f4 > o3 * o3)
    return ee.OUTSIDE;
  if (f4 > 0)
    return ee.INTERSECTS_CENTER_OUTSIDE;
  return -Math.max(a2, i2, s4, l) > o3 ? ee.INSIDE : ee.INTERSECTS_CENTER_INSIDE;
}
function re(e6, t, r2) {
  const n5 = [], o3 = r2 && r2.missingFields, a2 = r2 && r2.originalFields;
  for (const i2 of e6) {
    const e7 = i2.toLowerCase();
    let r3 = false;
    for (const o4 of t)
      if (e7 === o4.name.toLowerCase()) {
        n5.push(o4.name), r3 = true, a2 && a2.push(i2);
        break;
      }
    !r3 && o3 && o3.push(i2);
  }
  return n5;
}
async function ne(e6, t, r2, o3, a2) {
  if (0 === t.length)
    return [];
  const i2 = e6.attributeStorageInfo;
  if (null != e6.associatedLayer)
    try {
      return await ae2(e6.associatedLayer, t, r2, o3);
    } catch (s4) {
      if (e6.associatedLayer.loaded)
        throw s4;
    }
  if (i2) {
    const s4 = oe(t, r2, a2);
    if (null == s4)
      throw new s("scenelayer:features-not-loaded", "Tried to query attributes for unloaded features");
    const l = e6.parsedUrl.path;
    return (await Promise.all(s4.map((e7) => se(l, i2, e7.node, e7.indices, o3).then((t2) => {
      for (let r3 = 0; r3 < e7.graphics.length; r3++) {
        const n5 = e7.graphics[r3], o4 = t2[r3];
        if (n5.attributes)
          for (const e8 in n5.attributes)
            e8 in o4 || (o4[e8] = n5.attributes[e8]);
        n5.attributes = o4;
      }
      return e7.graphics;
    })))).flat();
  }
  throw new s("scenelayer:no-attribute-source", "This scene layer does not have a source for attributes available");
}
function oe(e6, t, r2) {
  const n5 = /* @__PURE__ */ new Map(), o3 = [], a2 = r2();
  for (const i2 of e6) {
    const e7 = i2.attributes[t];
    for (let t2 = 0; t2 < a2.length; t2++) {
      const r3 = a2[t2], s4 = r3.featureIds.indexOf(e7);
      if (s4 >= 0) {
        let e8 = n5.get(r3.node);
        e8 || (e8 = { node: r3.node, indices: [], graphics: [] }, o3.push(e8), n5.set(r3.node, e8)), e8.indices.push(s4), e8.graphics.push(i2);
        for (let r4 = t2; r4 > 0; r4--)
          a2[r4] = a2[r4 - 1];
        a2[0] = r3;
        break;
      }
    }
  }
  return o3;
}
async function ae2(e6, t, r2, n5) {
  t.sort((e7, t2) => e7.attributes[r2] - t2.attributes[r2]);
  const o3 = t.map((e7) => e7.attributes[r2]), a2 = [], i2 = re(n5, e6.fields, { originalFields: a2 }), s4 = await ie(e6, o3, i2);
  for (let l = 0; l < t.length; l++) {
    const e7 = t[l], r3 = s4[l], n6 = {};
    if (e7.attributes)
      for (const t2 in e7.attributes)
        n6[t2] = e7.attributes[t2];
    for (let t2 = 0; t2 < a2.length; t2++)
      n6[a2[t2]] = r3[i2[t2]];
    e7.attributes = n6;
  }
  return t;
}
function ie(e6, t, o3) {
  const a2 = e6.capabilities.query.maxRecordCount;
  if (null != a2 && t.length > a2) {
    const n5 = p(t, a2);
    return Promise.all(n5.map((t2) => ie(e6, t2, o3))).then((e7) => e7.flat());
  }
  const i2 = new b({ objectIds: t, outFields: o3, orderByFields: [e6.objectIdField] });
  return e6.queryFeatures(i2).then((e7) => {
    if (e7 && e7.features && e7.features.length === t.length)
      return e7.features.map((e8) => e8.attributes);
    throw new s("scenelayer:feature-not-in-associated-layer", "Feature not found in associated feature layer");
  });
}
function se(e6, t, r2, n5, o3) {
  return le(e6, t, r2.resources.attributes, n5, o3);
}
function le(t, r2, n5, o3, i2) {
  const s4 = [];
  for (const e6 of r2)
    if (e6 && i2.includes(e6.name)) {
      const r3 = `${t}/nodes/${n5}/attributes/${e6.key}/0`;
      s4.push({ url: r3, storageInfo: e6 });
    }
  return j(s4.map((t2) => j2(t2.url, { responseType: "array-buffer" }).then((e6) => I(t2.storageInfo, e6.data)))).then((e6) => {
    const t2 = [];
    for (const r3 of o3) {
      const n6 = {};
      for (let t3 = 0; t3 < e6.length; t3++) {
        const o4 = e6[t3].value;
        null != o4 && (n6[s4[t3].storageInfo.name] = fe(o4, r3));
      }
      t2.push(n6);
    }
    return t2;
  });
}
!function(e6) {
  e6[e6.OUTSIDE = 0] = "OUTSIDE", e6[e6.INTERSECTS_CENTER_OUTSIDE = 1] = "INTERSECTS_CENTER_OUTSIDE", e6[e6.INTERSECTS_CENTER_INSIDE = 2] = "INTERSECTS_CENTER_INSIDE", e6[e6.INSIDE = 3] = "INSIDE";
}(ee || (ee = {}));
var ce = -32768;
var ue = -(2 ** 31);
function fe(e6, t) {
  if (!e6)
    return null;
  const r2 = e6[t];
  if (o(e6))
    return r2 === ce ? null : r2;
  if (e(e6))
    return r2 === ue ? null : r2;
  return r2 != r2 ? null : r2;
}
function pe(e6) {
  const t = e6.store, r2 = t.indexCRS || t.geographicCRS, o3 = void 0 === r2 ? t.indexWKT : void 0;
  if (o3) {
    if (!e6.spatialReference)
      throw new s("layerview:no-store-spatial-reference-wkt-index-and-no-layer-spatial-reference", "Found indeWKT in the scene layer store but no layer spatial reference", {});
    if (o3 !== e6.spatialReference.wkt)
      throw new s("layerview:store-spatial-reference-wkt-index-incompatible", "The indeWKT of the scene layer store does not match the WKT of the layer spatial reference", {});
  }
  const a2 = r2 ? new f(Q(r2)) : e6.spatialReference;
  return a2.equals(e6.spatialReference) ? e6.spatialReference : a2;
}
function me(e6) {
  const t = e6.store, r2 = t.vertexCRS || t.projectedCRS, o3 = void 0 === r2 ? t.vertexWKT : void 0;
  if (o3) {
    if (!e6.spatialReference)
      throw new s("layerview:no-store-spatial-reference-wkt-vertex-and-no-layer-spatial-reference", "Found vertexWKT in the scene layer store but no layer spatial reference", {});
    if (o3 !== e6.spatialReference.wkt)
      throw new s("layerview:store-spatial-reference-wkt-vertex-incompatible", "The vertexWKT of the scene layer store does not match the WKT of the layer spatial reference", {});
  }
  const a2 = r2 ? new f(Q(r2)) : e6.spatialReference;
  return a2.equals(e6.spatialReference) ? e6.spatialReference : a2;
}
function he(e6, t) {
  return null == t ? "@null" : t === c(t) ? "@ECEF" : e6.equals(t) ? "" : null != t.wkid ? "@" + t.wkid : null;
}
function de(e6, t, r2) {
  if (!Cn(e6, t))
    throw new s("layerview:spatial-reference-incompatible", "The spatial reference of this scene layer is incompatible with the spatial reference of the view", {});
  if ("local" === r2 && !be(e6, t))
    throw new s("layerview:spatial-reference-incompatible", "The spatial reference of this scene layer is incompatible with the spatial reference of the view", {});
}
function ye(e6, t, r2) {
  var _a, _b;
  if (((_a = e6.serviceUpdateTimeStamp) == null ? void 0 : _a.lastUpdate) !== ((_b = t.serviceUpdateTimeStamp) == null ? void 0 : _b.lastUpdate) || !r2.isEmpty || n(e6.associatedLayer, (e7) => e7.url) !== n(t.associatedLayer, (e7) => e7.url))
    throw new s("layerview:recycle-failed");
}
function be(e6, t) {
  return e6.equals(t) || e6.isWGS84 && t.isWebMercator || e6.isWebMercator && t.isWGS84;
}
function ge(e6, t, r2) {
  const n5 = pe(e6), o3 = me(e6);
  de(n5, t, r2), de(o3, t, r2);
}
function Se(e6) {
  return (null == e6.geometryType || "triangles" === e6.geometryType) && ((null == e6.topology || "PerAttributeArray" === e6.topology) && (null != e6.vertexAttributes && null != e6.vertexAttributes.position));
}
function we(e6) {
  if (null == e6.store || null == e6.store.defaultGeometrySchema || !Se(e6.store.defaultGeometrySchema))
    throw new s("scenelayer:unsupported-geometry-schema", "The geometry schema of this scene layer is not supported.", { url: e6.parsedUrl.path });
}
function Te(e6, t) {
  ge(e6, t.spatialReference, t.viewingMode);
}
function Ee(e6) {
  return null != e6.geometryType && "points" === e6.geometryType && ((null == e6.topology || "PerAttributeArray" === e6.topology) && ((null == e6.encoding || "" === e6.encoding || "lepcc-xyz" === e6.encoding) && (null != e6.vertexAttributes && null != e6.vertexAttributes.position)));
}
function ve(e6) {
  if (null == e6.store || null == e6.store.defaultGeometrySchema || !Ee(e6.store.defaultGeometrySchema))
    throw new s("pointcloud:unsupported-geometry-schema", "The geometry schema of this point cloud scene layer is not supported.", {});
}
function Me(e6, t) {
  de(e6.spatialReference, t.spatialReference, t.viewingMode);
}
function Ie(e6) {
  return "simple" === e6.type || "class-breaks" === e6.type || "unique-value" === e6.type;
}
function Re(e6) {
  return "mesh-3d" === e6.type;
}
function xe(e6) {
  if (null == e6 || !Ie(e6))
    return true;
  if (("unique-value" === e6.type || "class-breaks" === e6.type) && null == e6.defaultSymbol)
    return true;
  const t = e6.getSymbols();
  if (0 === t.length)
    return true;
  for (const r2 of t) {
    if (!Re(r2) || 0 === r2.symbolLayers.length)
      return true;
    for (const e7 of r2.symbolLayers.items)
      if ("fill" !== e7.type || null == e7.material || null == e7.material.color || "replace" !== e7.material.colorMixMode)
        return true;
  }
  return false;
}
var je = f3({ color: [0, 0, 0, 0], opacity: 0 });
var qe = class {
  constructor() {
    this.edgeMaterial = null, this.material = null, this.castShadows = true;
  }
};
function Ue(e6) {
  const t = new qe();
  let r2 = false, n5 = false;
  for (const o3 of e6.symbolLayers.items)
    if ("fill" === o3.type && o3.enabled) {
      const e7 = o3.material, a2 = o3.edges;
      if (null != e7 && !r2) {
        const n6 = e7.color, a3 = e5(e7.colorMixMode);
        t.material = null != n6 ? { color: [n6.r / 255, n6.g / 255, n6.b / 255], alpha: n6.a, colorMixMode: a3 } : { color: [1, 1, 1], alpha: 1, colorMixMode: n3.Multiply }, t.castShadows = o3.castShadows, r2 = true;
      }
      null == a2 || n5 || (t.edgeMaterial = a(a2, {}), n5 = true);
    }
  return t.material || (t.material = { color: [1, 1, 1], alpha: 1, colorMixMode: n3.Multiply }), t;
}
function ke(e6, t) {
  return (0 | e6) + (0 | t) | 0;
}
function Ce(e6, t, r2, n5, o3 = 0) {
  n5 === c(n5) ? t.isGeographic ? Ge(e6, r2, t, o3) : Le(e6, r2, t, o3) : t.isWGS84 && (n5.isWebMercator || G(n5)) ? Ne(t, e6, n5, r2, o3) : t.isWebMercator && G(n5) ? _e(t, e6, n5, r2, o3) : e6 === r2 ? (r2.center[2] += o3, yn(r2.center, t, 0, r2.center, n5, 0, 1)) : (o2(r2.center, e6.center[0], e6.center[1], e6.center[2] + o3), yn(r2.center, t, 0, r2.center, n5, 0, 1), B(r2.quaternion, e6.quaternion), r(r2.halfSize, e6.halfSize));
}
function Ne(e6, t, r2, n5, o3) {
  r(De, t.center), De[2] += o3;
  const a2 = c(r2);
  yn(De, e6, 0, De, a2, 0, 1), Oe(a2, t, De, r2, n5);
}
var ze = new Array(24);
var We = new s2(ze, 3, true);
var Ae = n2();
var De = n2();
var Fe = e2();
function _e(e6, t, r2, n5, o3) {
  r(De, t.center), De[2] += o3, Oe(e6, t, De, r2, n5);
}
function Oe(e6, t, r2, n5, o3) {
  const a2 = p2(Fe, t.quaternion);
  for (let i2 = 0; i2 < 8; ++i2) {
    for (let e7 = 0; e7 < 3; ++e7)
      Ae[e7] = t.halfSize[e7] * (0 != (i2 & 1 << e7) ? -1 : 1);
    for (let e7 = 0; e7 < 3; ++e7) {
      let t2 = r2[e7];
      for (let r3 = 0; r3 < 3; ++r3)
        t2 += Ae[r3] * a2[3 * r3 + e7];
      ze[3 * i2 + e7] = t2;
    }
  }
  yn(ze, e6, 0, ze, n5, 0, 8), R(We, o3);
}
function Le(e6, t, r2, n5) {
  ae(e6, Je), o2(t.center, e6.center[0], e6.center[1], e6.center[2] + n5), zn(r2, t.center, Ze, c(r2)), o2(t.center, Ze[12], Ze[13], Ze[14]);
  const o3 = 2 * Math.sqrt(1 + Ze[0] + Ze[5] + Ze[10]);
  He[0] = (Ze[6] - Ze[9]) / o3, He[1] = (Ze[8] - Ze[2]) / o3, He[2] = (Ze[1] - Ze[4]) / o3, He[3] = 0.25 * o3, y(t.quaternion, He, e6.quaternion), S(He, t.quaternion);
  let a2 = 0, i2 = 0, s4 = 0;
  for (const l of Je)
    l[2] += n5, yn(l, r2, 0, l, c(r2), 0, 1), J(et, l, t.center), E(et, et, He), a2 = Math.max(a2, Math.abs(et[0])), i2 = Math.max(i2, Math.abs(et[1])), s4 = Math.max(s4, Math.abs(et[2]));
  o2(t.halfSize, a2, i2, s4);
}
function Ge(e6, t, r2, n5) {
  const o3 = A(r2), a2 = 1 + Math.max(0, n5) / (o3.radius + e6.center[2]);
  o2(t.center, e6.center[0], e6.center[1], e6.center[2] + n5), yn(t.center, r2, 0, t.center, c(r2), 0, 1), B(t.quaternion, e6.quaternion), S(He, e6.quaternion), o2(et, 0, 0, 1), E(et, et, He), o2(et, e6.halfSize[0] * Math.abs(et[0]), e6.halfSize[1] * Math.abs(et[1]), e6.halfSize[2] * Math.abs(et[2])), g(et, et, o3.inverseFlattening), u(t.halfSize, e6.halfSize, et), g(t.halfSize, t.halfSize, a2);
}
function Ke(e6, t, r2, n5, o3, a2) {
  if (!a2 || 0 === a2.length || null == t || !e6.mbs)
    return null;
  const i2 = n4(e6.mbs, o3, r2, t);
  h(rt, i2);
  let s4 = null;
  const l = () => {
    if (!s4)
      if (s4 = Je, C(Xe), null != e6.serviceObb) {
        Ce(e6.serviceObb, r2, Ye, t, o3), ae(Ye, s4);
        for (const e7 of s4)
          O(e7, e7, rt), f2(Xe, e7);
      } else {
        const n6 = e6.mbs;
        if (!n6)
          return;
        const a3 = n6[3];
        Hn(n6, r2, et, t), O(et, et, rt), et[2] += o3;
        for (let e7 = 0; e7 < 8; ++e7) {
          const t2 = 1 & e7 ? a3 : -a3, r3 = 2 & e7 ? a3 : -a3, n7 = 4 & e7 ? a3 : -a3, o4 = s4[e7];
          r(o4, [et[0] + t2, et[1] + r3, et[2] + n7]), f2(Xe, o4);
        }
      }
  };
  let c3 = 1 / 0, f4 = -1 / 0;
  const p3 = (e7) => {
    if ("replace" !== e7.type)
      return;
    const r3 = e7.geometry;
    if (!(r3 == null ? void 0 : r3.hasZ))
      return;
    C(Ve);
    const o4 = r3.spatialReference || n5, a3 = r3.rings.reduce((e8, r4) => r4.reduce((e9, r5) => (Hn(r5, o4, et, t), O(et, et, rt), f2(Ve, et), Math.min(et[2], e9)), e8), 1 / 0);
    l(), q(Xe, Ve) && (c3 = Math.min(c3, a3), f4 = Math.max(f4, a3));
  };
  if (a2.forEach((e7) => p3(e7)), c3 === 1 / 0)
    return null;
  const m = (e7, t2, r3) => {
    O(et, r3, i2), e7[t2] = et[0], e7[t2 + 1] = et[1], e7[t2 + 2] = et[2], t2 += 24, r3[2] = c3, O(et, r3, i2), e7[t2] = et[0], e7[t2 + 1] = et[1], e7[t2 + 2] = et[2], t2 += 24, r3[2] = f4, O(et, r3, i2), e7[t2] = et[0], e7[t2 + 1] = et[1], e7[t2 + 2] = et[2];
  };
  for (let u2 = 0; u2 < 8; ++u2)
    m(tt.data, 3 * u2, s4[u2]);
  return R(tt);
}
function Be(e6) {
  return null != e6 && e6.halfSize[0] >= 0;
}
function Pe(e6) {
  return e6[3] >= 0;
}
function $e(e6) {
  null != e6 && (e6.halfSize[0] = -1);
}
function Qe(e6) {
  null != e6 && (e6[3] = -1);
}
var Ze = e3();
var He = e4();
var Je = [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]];
var Ve = i();
var Xe = i();
var Ye = O2();
var et = n2();
var tt = { data: new Array(72), size: 3, exclusive: true, stride: 3 };
var rt = e3();

export {
  n4 as n,
  h2 as h,
  Z,
  H,
  J2 as J,
  V,
  Y,
  ee,
  te,
  re,
  ne,
  le,
  fe,
  pe,
  me,
  he,
  de,
  ye,
  ge,
  we,
  Te,
  ve,
  Me,
  xe,
  je,
  Ue,
  ke,
  Ce,
  Ke,
  Be,
  Pe,
  $e,
  Qe
};
//# sourceMappingURL=chunk-SLMR4CTS.js.map
