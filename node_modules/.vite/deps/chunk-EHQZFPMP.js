import {
  d,
  o as o3
} from "./chunk-VC3BY3DV.js";
import {
  o as o4
} from "./chunk-Z6IKMUOC.js";
import {
  e
} from "./chunk-YVVROPAO.js";
import {
  s
} from "./chunk-BFVOSCOB.js";
import {
  e as e2
} from "./chunk-QS45OHBM.js";
import {
  s as s2
} from "./chunk-Z3NHJA5D.js";
import {
  a
} from "./chunk-BO2REVMA.js";
import {
  o as o2
} from "./chunk-V66LHQVK.js";
import {
  n as n3
} from "./chunk-YGUWDSEH.js";
import {
  n as n2
} from "./chunk-4CZO65BK.js";
import {
  o
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import {
  r2 as r
} from "./chunk-3CQBBMMD.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/TextureAtlasLookup.glsl.js
function e3(e4) {
  e4.fragment.code.add(o2`vec4 textureAtlasLookup(sampler2D tex, vec2 textureCoordinates, vec4 atlasRegion) {
vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;
vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;
float maxdUV = 0.125;
vec2 dUVdx = clamp(dFdx(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
vec2 dUVdy = clamp(dFdy(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
return textureGrad(tex, uvAtlas, dUVdx, dUVdy);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTextureCoordinates.glsl.js
function s3(s4, a3) {
  switch (s4.include(o3, a3), a3.textureCoordinateType) {
    case d.Default:
    case d.Compressed:
      return void s4.fragment.code.add(o2`vec4 textureLookup(sampler2D tex, vec2 uv) {
return texture(tex, uv);
}`);
    case d.Atlas:
      return s4.include(e3), void s4.fragment.code.add(o2`vec4 textureLookup(sampler2D tex, vec2 uv) {
return textureAtlasLookup(tex, uv, vuvRegion);
}`);
    default:
      n2(a3.textureCoordinateType);
    case d.None:
    case d.COUNT:
      return;
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js
var c;
!function(e4) {
  e4[e4.Disabled = 0] = "Disabled", e4[e4.Normal = 1] = "Normal", e4[e4.Schematic = 2] = "Schematic", e4[e4.Water = 3] = "Water", e4[e4.WaterOnIntegratedMesh = 4] = "WaterOnIntegratedMesh", e4[e4.Terrain = 5] = "Terrain", e4[e4.TerrainWithWater = 6] = "TerrainWithWater", e4[e4.COUNT = 7] = "COUNT";
}(c || (c = {}));
function l2(n4, u) {
  const l3 = n4.fragment, m2 = u.hasMetallicRoughnessTexture || u.hasEmissionTexture || u.hasOcclusionTexture;
  if (u.pbrMode === c.Normal && m2 && n4.include(s3, u), u.pbrMode !== c.Schematic)
    if (u.pbrMode !== c.Disabled) {
      if (u.pbrMode === c.Normal) {
        l3.code.add(o2`vec3 mrr;
vec3 emission;
float occlusion;`);
        const e4 = u.pbrTextureBindType;
        u.hasMetallicRoughnessTexture && (l3.uniforms.add(e4 === a.Pass ? new s2("texMetallicRoughness", (e5) => e5.textureMetallicRoughness) : new s("texMetallicRoughness", (e5) => e5.textureMetallicRoughness)), l3.code.add(o2`void applyMetallnessAndRoughness(vec2 uv) {
vec3 metallicRoughness = textureLookup(texMetallicRoughness, uv).rgb;
mrr[0] *= metallicRoughness.b;
mrr[1] *= metallicRoughness.g;
}`)), u.hasEmissionTexture && (l3.uniforms.add(e4 === a.Pass ? new s2("texEmission", (e5) => e5.textureEmissive) : new s("texEmission", (e5) => e5.textureEmissive)), l3.code.add(o2`void applyEmission(vec2 uv) {
emission *= textureLookup(texEmission, uv).rgb;
}`)), u.hasOcclusionTexture ? (l3.uniforms.add(e4 === a.Pass ? new s2("texOcclusion", (e5) => e5.textureOcclusion) : new s("texOcclusion", (e5) => e5.textureOcclusion)), l3.code.add(o2`void applyOcclusion(vec2 uv) {
occlusion *= textureLookup(texOcclusion, uv).r;
}
float getBakedOcclusion() {
return occlusion;
}`)) : l3.code.add(o2`float getBakedOcclusion() { return 1.0; }`), e4 === a.Pass ? l3.uniforms.add(new e("emissionFactor", (e5) => e5.emissiveFactor), new e("mrrFactors", (e5) => e5.mrrFactors)) : l3.uniforms.add(new o4("emissionFactor", (e5) => e5.emissiveFactor), new o4("mrrFactors", (e5) => e5.mrrFactors)), l3.code.add(o2`
    void applyPBRFactors() {
      mrr = mrrFactors;
      emission = emissionFactor;
      occlusion = 1.0;

      ${u.hasMetallicRoughnessTexture ? o2`applyMetallnessAndRoughness(${u.hasMetallicRoughnessTextureTransform ? o2`metallicRoughnessUV` : "vuv0"});` : ""}

      ${u.hasEmissionTexture ? o2`applyEmission(${u.hasEmissiveTextureTransform ? o2`emissiveUV` : "vuv0"});` : ""}

      ${u.hasOcclusionTexture ? o2`applyOcclusion(${u.hasOcclusionTextureTransform ? o2`occlusionUV` : "vuv0"});` : ""}
    }
  `);
      }
    } else
      l3.code.add(o2`float getBakedOcclusion() { return 1.0; }`);
  else
    l3.code.add(o2`vec3 mrr = vec3(0.0, 0.6, 0.2);
vec3 emission = vec3(0.0);
float occlusion = 1.0;
void applyPBRFactors() {}
float getBakedOcclusion() { return 1.0; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl.js
function m(n4, g) {
  const m2 = n4.fragment, o5 = void 0 !== g.lightingSphericalHarmonicsOrder ? g.lightingSphericalHarmonicsOrder : 2;
  0 === o5 ? (m2.uniforms.add(new e("lightingAmbientSH0", (n5, t) => o(a2, t.lighting.sh.r[0], t.lighting.sh.g[0], t.lighting.sh.b[0]))), m2.code.add(o2`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 1 === o5 ? (m2.uniforms.add(new e2("lightingAmbientSH_R", (i, n5) => r(r2, n5.lighting.sh.r[0], n5.lighting.sh.r[1], n5.lighting.sh.r[2], n5.lighting.sh.r[3])), new e2("lightingAmbientSH_G", (i, n5) => r(r2, n5.lighting.sh.g[0], n5.lighting.sh.g[1], n5.lighting.sh.g[2], n5.lighting.sh.g[3])), new e2("lightingAmbientSH_B", (i, n5) => r(r2, n5.lighting.sh.b[0], n5.lighting.sh.b[1], n5.lighting.sh.b[2], n5.lighting.sh.b[3]))), m2.code.add(o2`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec4 sh0 = vec4(
0.282095,
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y
);
vec3 ambientLight = vec3(
dot(lightingAmbientSH_R, sh0),
dot(lightingAmbientSH_G, sh0),
dot(lightingAmbientSH_B, sh0)
);
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 2 === o5 && (m2.uniforms.add(new e("lightingAmbientSH0", (n5, t) => o(a2, t.lighting.sh.r[0], t.lighting.sh.g[0], t.lighting.sh.b[0])), new e2("lightingAmbientSH_R1", (i, n5) => r(r2, n5.lighting.sh.r[1], n5.lighting.sh.r[2], n5.lighting.sh.r[3], n5.lighting.sh.r[4])), new e2("lightingAmbientSH_G1", (i, n5) => r(r2, n5.lighting.sh.g[1], n5.lighting.sh.g[2], n5.lighting.sh.g[3], n5.lighting.sh.g[4])), new e2("lightingAmbientSH_B1", (i, n5) => r(r2, n5.lighting.sh.b[1], n5.lighting.sh.b[2], n5.lighting.sh.b[3], n5.lighting.sh.b[4])), new e2("lightingAmbientSH_R2", (i, n5) => r(r2, n5.lighting.sh.r[5], n5.lighting.sh.r[6], n5.lighting.sh.r[7], n5.lighting.sh.r[8])), new e2("lightingAmbientSH_G2", (i, n5) => r(r2, n5.lighting.sh.g[5], n5.lighting.sh.g[6], n5.lighting.sh.g[7], n5.lighting.sh.g[8])), new e2("lightingAmbientSH_B2", (i, n5) => r(r2, n5.lighting.sh.b[5], n5.lighting.sh.b[6], n5.lighting.sh.b[7], n5.lighting.sh.b[8]))), m2.code.add(o2`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
vec4 sh1 = vec4(
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y,
1.092548 * normal.x * normal.y
);
vec4 sh2 = vec4(
1.092548 * normal.y * normal.z,
0.315392 * (3.0 * normal.z * normal.z - 1.0),
1.092548 * normal.x * normal.z,
0.546274 * (normal.x * normal.x - normal.y * normal.y)
);
ambientLight += vec3(
dot(lightingAmbientSH_R1, sh1),
dot(lightingAmbientSH_G1, sh1),
dot(lightingAmbientSH_B1, sh1)
);
ambientLight += vec3(
dot(lightingAmbientSH_R2, sh2),
dot(lightingAmbientSH_G2, sh2),
dot(lightingAmbientSH_B2, sh2)
);
return ambientLight * (1.0 - ambientOcclusion);
}`), g.pbrMode !== c.Normal && g.pbrMode !== c.Schematic || m2.code.add(o2`const vec3 skyTransmittance = vec3(0.9, 0.9, 1.0);
vec3 calculateAmbientRadiance(float ambientOcclusion)
{
vec3 ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2;
return ambientLight *= (1.0 - ambientOcclusion) * skyTransmittance;
}`));
}
var a2 = n();
var r2 = n3();

export {
  e3 as e,
  s3 as s,
  c,
  l2 as l,
  m
};
//# sourceMappingURL=chunk-EHQZFPMP.js.map
