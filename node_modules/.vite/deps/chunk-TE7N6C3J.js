import {
  j,
  p as p2
} from "./chunk-DSWGERIY.js";
import {
  ce
} from "./chunk-BNBT4QTW.js";
import {
  i
} from "./chunk-EKJ2DJIR.js";
import {
  M,
  N,
  y
} from "./chunk-TEHNQYQD.js";
import {
  M as M2
} from "./chunk-3VUFACNT.js";
import {
  f,
  f2,
  p2 as p,
  x2 as x
} from "./chunk-ZEEBL7ZN.js";
import {
  H,
  P,
  T
} from "./chunk-RTDN6KAT.js";
import {
  s3 as s
} from "./chunk-HMVAPW5X.js";

// node_modules/@arcgis/core/views/3d/terrain/TilingScheme.js
var x2 = 12;
var v = class _v {
  constructor(e) {
    const i2 = _v.checkUnsupported(e);
    if (null != i2)
      throw i2;
    const t = e;
    this.spatialReference = t.spatialReference, this._isWebMercator = this.spatialReference.isWebMercator, this._isGCS = ce(this.spatialReference) || T(this.spatialReference) || P(this.spatialReference), this.origin = [t.origin.x, t.origin.y], this.pixelSize = t.size[0], this.dpi = t.dpi;
    const s2 = t.lods.reduce((e2, i3, t2) => (i3.level < e2.min && (e2.min = i3.level, e2.minIndex = t2), e2.max = Math.max(e2.max, i3.level), e2), { min: 1 / 0, minIndex: 0, max: -1 / 0 }), r = t.lods[s2.minIndex], n = 2 ** r.level;
    let o = r.resolution * n, a = r.scale * n;
    this.levels = new Array(s2.max + 1);
    for (let l = 0; l < this.levels.length; l++)
      this.levels[l] = { resolution: o, scale: a, tileSize: [o * t.size[0], o * t.size[1]] }, o /= 2, a /= 2;
  }
  clone() {
    return new _v(this.toTileInfo());
  }
  toTileInfo() {
    return new j({ dpi: this.dpi, origin: new x({ x: this.origin[0], y: this.origin[1], spatialReference: this.spatialReference }), size: [this.pixelSize, this.pixelSize], spatialReference: this.spatialReference, lods: this.levels.map((e, i2) => new p2({ level: i2, scale: e.scale, resolution: e.resolution })) });
  }
  getExtent(e, i2, t, s2) {
    const r = this.levels[e], n = r.tileSize[0], l = r.tileSize[1];
    s2[0] = this.origin[0] + t * n, s2[2] = this.origin[0] + (t + 1) * n, s2[3] = this.origin[1] - i2 * l, s2[1] = this.origin[1] - (i2 + 1) * l;
  }
  convertExtentToRadians(e, t) {
    this._isWebMercator ? (t[0] = p(e[0]), t[1] = f2(e[1]), t[2] = p(e[2]), t[3] = f2(e[3])) : this._isGCS && (t[0] = M(e[0]), t[1] = M(e[1]), t[2] = M(e[2]), t[3] = M(e[3]));
  }
  getExtentGeometry(e, i2, t, s2 = new M2()) {
    return this.getExtent(e, i2, t, M3), s2.spatialReference = this.spatialReference, s2.xmin = M3[0], s2.ymin = M3[1], s2.xmax = M3[2], s2.ymax = M3[3], s2.zmin = void 0, s2.zmax = void 0, s2;
  }
  ensureMaxLod(e) {
    if (null == e)
      return false;
    let i2 = false;
    for (; this.levels.length <= e; ) {
      const e2 = this.levels[this.levels.length - 1], t = e2.resolution / 2;
      this.levels.push({ resolution: t, scale: e2.scale / 2, tileSize: [t * this.pixelSize, t * this.pixelSize] }), i2 = true;
    }
    return i2;
  }
  capMaxLod(e) {
    this.levels.length > e + 1 && (this.levels.length = e + 1);
  }
  getMaxLod() {
    return this.levels.length - 1;
  }
  scaleAtLevel(e) {
    return this.levels[0].scale / 2 ** e;
  }
  levelAtScale(e) {
    const i2 = this.levels[0].scale;
    return e >= i2 ? 0 : Math.log(i2 / e) * Math.LOG2E;
  }
  resolutionAtLevel(e) {
    return this.levels[0].resolution / 2 ** e;
  }
  compatibleWith(e) {
    if (!(e instanceof _v)) {
      if (_v.checkUnsupported(e))
        return false;
      e = new _v(e);
    }
    if (!e.spatialReference.equals(this.spatialReference))
      return false;
    if (e.pixelSize !== this.pixelSize)
      return false;
    const i2 = Math.min(this.levels.length, e.levels.length) - 1, s2 = this.levels[i2].resolution;
    let r = 0.5 * s2;
    if (!N(e.origin[0], this.origin[0], r) || !N(e.origin[1], this.origin[1], r))
      return false;
    return r = 0.5 * s2 / 2 ** i2 / this.pixelSize * x2, N(s2, e.levels[i2].resolution, r);
  }
  rootTilesInExtent(e, i2 = null, t = 1 / 0) {
    const s2 = new Array(), r = this.levels[0].tileSize;
    if (null == e || 0 === r[0] || 0 === r[1])
      return s2;
    _v.computeRowColExtent(e, r, this.origin, M3);
    let n = M3[1], l = M3[3], o = M3[0], a = M3[2];
    const h = a - o, c = l - n;
    if (h * c > t) {
      const e2 = Math.floor(Math.sqrt(t));
      c > e2 && (n = n + Math.floor(0.5 * c) - Math.floor(0.5 * e2), l = n + e2), h > e2 && (o = o + Math.floor(0.5 * h) - Math.floor(0.5 * e2), a = o + e2);
    }
    for (let m = n; m < l; m++)
      for (let e2 = o; e2 < a; e2++)
        s2.push([0, m, e2]);
    return null != i2 && (i2[0] = this.origin[0] + o * r[0], i2[1] = this.origin[1] - l * r[1], i2[2] = this.origin[0] + a * r[0], i2[3] = this.origin[1] - n * r[1]), s2;
  }
  static computeRowColExtent(e, i2, t, s2) {
    const r = 1e-3 * (e[2] - e[0] + (e[3] - e[1]));
    s2[0] = Math.max(0, Math.floor((e[0] + r - t[0]) / i2[0])), s2[2] = Math.max(0, Math.ceil((e[2] - r - t[0]) / i2[0])), s2[1] = Math.max(0, Math.floor((t[1] - e[3] + r) / i2[1])), s2[3] = Math.max(0, Math.ceil((t[1] - e[1] - r) / i2[1]));
  }
  static isPowerOfTwo(e) {
    const i2 = e.lods, t = i2[0].resolution * 2 ** i2[0].level;
    return !i2.some((e2) => !y(e2.resolution, t / 2 ** e2.level));
  }
  static hasGapInLevels(e) {
    const i2 = e.lods.map((e2) => e2.level);
    i2.sort((e2, i3) => e2 - i3);
    for (let t = 1; t < i2.length; t++)
      if (i2[t] !== i2[0] + t)
        return true;
    return false;
  }
  static tileSizeSupported(e) {
    const i2 = e.size[1];
    return i2 === e.size[0] && 0 == (i2 & i2 - 1) && i2 >= 128 && i2 <= 512;
  }
  static hasOriginPerLODs(e) {
    const i2 = e.origin;
    return e.lods.some((e2) => null != e2.origin && (e2.origin[0] !== i2.x || e2.origin[1] !== i2.y));
  }
  static getMissingTileInfoError() {
    return new s("tilingscheme:tile-info-missing", "Tiling scheme must have tiling information");
  }
  static checkUnsupported(i2) {
    return null == i2 ? w() : i2.lods.length < 1 ? new s("tilingscheme:generic", "Tiling scheme must have at least one level") : _v.isPowerOfTwo(i2) ? _v.hasGapInLevels(i2) ? new s("tilingscheme:gaps", "Tiling scheme levels must not have gaps between min and max level") : _v.tileSizeSupported(i2) ? _v.hasOriginPerLODs(i2) ? new s("tilingscheme:multiple-origin", "Tiling scheme levels must not have their own origin") : null : new s("tilingscheme:tile-size", "Tiles must be square and size must be one of [128, 256, 512]") : new s("tilingscheme:power-of-two", "Tiling scheme must be power of two");
  }
  static fromExtent(e, i2) {
    const t = e[2] - e[0], s2 = e[3] - e[1], n = H(i2), l = 1.2 * Math.max(t, s2), o = 256, a = 96, h = 0.0254, c = new _v(new j({ size: [o, o], origin: new x({ x: e[0] - 0.5 * (l - t), y: e[3] + 0.5 * (l - s2) }), lods: [new p2({ level: 0, resolution: l / o, scale: 1 / (o / a * h / (l * n)) })], spatialReference: i2 }));
    return c.ensureMaxLod(20), c;
  }
  static makeWebMercatorAuxiliarySphere(e) {
    const i2 = new _v(_v.WebMercatorAuxiliarySphereTileInfo);
    return i2.ensureMaxLod(e), i2;
  }
  static makeGCSWithTileSize(e, i2 = 256, t = 16) {
    const s2 = 256 / i2, r = new _v(new j({ size: [i2, i2], origin: new x({ x: -180, y: 90, spatialReference: e }), spatialReference: e, lods: [new p2({ level: 0, resolution: 0.703125 * s2, scale: 295497598570834e-6 * s2 })] }));
    return r.ensureMaxLod(t), r;
  }
  get test() {
    return { isWebMercator: this._isWebMercator, isGCS: this._isGCS };
  }
};
function w() {
  return new s("tilingscheme:tile-info-missing", "Tiling scheme must have tiling information");
}
v.WebMercatorAuxiliarySphereTileInfo = new j({ size: [256, 256], origin: new x({ x: -20037508342787e-6, y: 20037508342787e-6, spatialReference: f.WebMercator }), spatialReference: f.WebMercator, lods: [new p2({ level: 0, resolution: 156543.03392800014, scale: 591657527591555e-6 })] }), v.WebMercatorAuxiliarySphere = v.makeWebMercatorAuxiliarySphere(19);
var M3 = i();

export {
  v,
  w
};
//# sourceMappingURL=chunk-TE7N6C3J.js.map
