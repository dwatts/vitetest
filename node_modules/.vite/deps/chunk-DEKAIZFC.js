import {
  o as o2
} from "./chunk-QVPAZ7EL.js";
import {
  c2
} from "./chunk-ZYHVS2T2.js";
import {
  f
} from "./chunk-XUU35WPC.js";
import {
  c
} from "./chunk-EHQZFPMP.js";
import {
  a,
  t
} from "./chunk-WH76OAIT.js";
import {
  h
} from "./chunk-73PNWDTS.js";
import {
  n as n3
} from "./chunk-3ROGWJVH.js";
import {
  A,
  O
} from "./chunk-BUCIQGFS.js";
import {
  s as s2
} from "./chunk-Z3NHJA5D.js";
import {
  o
} from "./chunk-V66LHQVK.js";
import {
  n as n2
} from "./chunk-YGUWDSEH.js";
import {
  M,
  l,
  s
} from "./chunk-EKJ2DJIR.js";
import {
  n
} from "./chunk-CQX57DED.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/renderPasses/AllRenderPasses.js
var e = class extends f {
  constructor() {
    super(...arguments), this.slicePlaneLocalOrigin = n(), this.origin = this.slicePlaneLocalOrigin, this.modelTransformation = null;
  }
};
var o3;
!function(t2) {
  t2[t2.Material = 0] = "Material", t2[t2.ShadowMap = 1] = "ShadowMap", t2[t2.Highlight = 2] = "Highlight";
}(o3 || (o3 = {}));
var n4 = class extends e {
  constructor() {
    super(...arguments), this.identifier = o3.Material, this.output = h.Color, this.transparent = false, this.integratedMesh = false;
  }
};
var h2 = class extends e {
  constructor() {
    super(...arguments), this.identifier = o3.ShadowMap;
  }
};
var l2 = class extends e {
  constructor() {
    super(...arguments), this.identifier = o3.Highlight;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js
var y;
function m(e2, o4) {
  const { vertex: r, fragment: t2 } = e2;
  r.uniforms.add(new o2("overlayTexOffset", (e3, o5) => h3(e3, o5)), new o2("overlayTexScale", (e3, o5) => b(e3, o5))), t2.constants.add("overlayOpacity", "float", 1), t2.uniforms.add(new s2("ovColorTex", (e3, o5) => g(e3, o5))), C(e2, o4);
}
function C(e2, o4) {
  o4.pbrMode !== c.Water && o4.pbrMode !== c.WaterOnIntegratedMesh && o4.pbrMode !== c.TerrainWithWater || e2.include(c2, o4);
  const { vertex: r, fragment: t2 } = e2;
  e2.varyings.add("vtcOverlay", "vec4"), r.code.add(o`void setOverlayVTC(in vec2 uv) {
vtcOverlay = vec4(uv, uv) * overlayTexScale + overlayTexOffset;
}`), t2.code.add(o`bool isValid(vec2 uv, vec2 dxdy) {
return (uv.x >= 0.0 + dxdy.x) && (uv.x <= 1.0 - dxdy.x) && (uv.y >= 0.0 + dxdy.y) && (uv.y <= 1.0 - dxdy.y);
}
vec4 getOverlayColor(sampler2D ov0Tex, vec4 texCoords) {
vec4 color0 = texture(ov0Tex, vec2(texCoords.x * 0.5, texCoords.y));
vec4 color1 = texture(ov0Tex, vec2(texCoords.z * 0.5 + 0.5, texCoords.w));
bool isValid0 = isValid(texCoords.xy, fwidth(texCoords.xy));
bool isValid1 = isValid(texCoords.zw, vec2(0.0, 0.0));
return mix(color1 * float(isValid1), color0, float(isValid0));
}`), t2.code.add(o`vec4 getCombinedOverlayColor() {
return overlayOpacity * getOverlayColor(ovColorTex, vtcOverlay);
}`), t2.code.add(o`vec4 getOverlayColorTexel(vec4 texCoords) {
vec2 texDim =  vec2(textureSize(ovColorTex, 0));
vec4 color0 = texelFetch(ovColorTex, ivec2(vec2(texCoords.x * 0.5, texCoords.y)*texDim), 0);
vec4 color1 = texelFetch(ovColorTex, ivec2(vec2(texCoords.z * 0.5 + 0.5, texCoords.w)*texDim), 0);
bool isValid0 = isValid(texCoords.xy, fwidth(texCoords.xy));
bool isValid1 = isValid(texCoords.zw, vec2(0.0, 0.0));
return mix(color1 * float(isValid1), color0, float(isValid0));
}`), o4.pbrMode !== c.Water && o4.pbrMode !== c.WaterOnIntegratedMesh && o4.pbrMode !== c.TerrainWithWater || (t(t2), a(t2), t2.code.add(o`vec4 getOverlayWaterColor(vec4 maskInput, vec4 colorInput, vec3 vposEyeDir,
float shadow, vec3 localUp, mat3 tbn, vec3 position, vec3 positionWorld) {
vec3 n = normalize(tbn *  (2.0 * maskInput.rgb - vec3(1.0)));
vec3 v = vposEyeDir;
vec3 final = getSeaColor(n, v, mainLightDirection, colorInput.rgb, mainLightIntensity, localUp, 1.0 - shadow, maskInput.w, position, positionWorld);
return vec4(final, colorInput.w);
}`));
}
function g(e2, o4) {
  return 0 === o4.overlays.length ? null : e2.identifier === o3.Material && e2.output === h.Color ? o4.overlays[O.INNER].getColorTextureNoRasterImage() : e2.identifier === o3.Material && e2.output === h.ObjectAndLayerIdColor ? o4.overlays[O.INNER].getColorTexture(n3.ObjectAndLayerIdColor) : e2.identifier === o3.Highlight ? o4.overlays[O.INNER].getValidTexture(A.Highlight) : null;
}
function h3(e2, a2) {
  for (const i of a2.overlays) {
    const { index: a3, extent: l3 } = i;
    l(l3) > 0 && (T[2 * a3] = e2.toMapSpace[0] / M(l3) - l3[0] / M(l3), T[2 * a3 + 1] = e2.toMapSpace[1] / s(l3) - l3[1] / s(l3));
  }
  return T;
}
function b(e2, a2) {
  for (const i of a2.overlays) {
    const { index: a3, extent: l3 } = i;
    l(l3) > 0 && (T[2 * a3] = e2.toMapSpace[2] / M(l3), T[2 * a3 + 1] = e2.toMapSpace[3] / s(l3));
  }
  return T;
}
!function(e2) {
  e2[e2.Disabled = 0] = "Disabled", e2[e2.Enabled = 1] = "Enabled", e2[e2.EnabledWithWater = 2] = "EnabledWithWater", e2[e2.COUNT = 3] = "COUNT";
}(y || (y = {}));
var T = n2();

export {
  o3 as o,
  n4 as n,
  h2 as h,
  l2 as l,
  y,
  m,
  C,
  g
};
//# sourceMappingURL=chunk-DEKAIZFC.js.map
