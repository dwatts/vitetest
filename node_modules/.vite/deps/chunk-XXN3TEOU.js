import {
  J
} from "./chunk-FIJZ6LYC.js";
import {
  i as i7
} from "./chunk-MUANV6E3.js";
import {
  $
} from "./chunk-SFIT2AUF.js";
import {
  B,
  V,
  c as c8
} from "./chunk-DBIFU6GO.js";
import {
  M,
  i as i6,
  t as t10
} from "./chunk-V33FVMPT.js";
import {
  E as E5,
  I as I2,
  a as a5,
  e as e11,
  t as t8
} from "./chunk-UYTAZUBJ.js";
import {
  C as C2,
  c as c7,
  e as e12,
  t as t9
} from "./chunk-2EO2WRP7.js";
import {
  s as s5
} from "./chunk-NBYHM3OO.js";
import {
  x as x2
} from "./chunk-B76MSEZ4.js";
import {
  c as c9
} from "./chunk-ZYHVS2T2.js";
import {
  i as i5
} from "./chunk-XYSQCP5F.js";
import {
  d,
  i as i4
} from "./chunk-MPIXWRXJ.js";
import {
  t as t3
} from "./chunk-XKYCNHCM.js";
import {
  b,
  r2 as r5
} from "./chunk-BDX5TRUE.js";
import {
  A,
  E as E3,
  S as S2,
  a as a4,
  c as c4,
  l as l6
} from "./chunk-LIXBKTBN.js";
import {
  E as E4
} from "./chunk-6LC2JTLC.js";
import {
  s as s4
} from "./chunk-XM3YSFN6.js";
import {
  v
} from "./chunk-XUU35WPC.js";
import {
  _ as _3,
  i as i3,
  w as w2
} from "./chunk-KSA6GV6M.js";
import {
  x
} from "./chunk-K4WBDIIJ.js";
import {
  f as f2,
  g as g2
} from "./chunk-ROPKVK6V.js";
import {
  r as r7
} from "./chunk-KM375BNF.js";
import {
  c as c6
} from "./chunk-FB6EWBGE.js";
import {
  e as e10,
  i as i2,
  t as t5
} from "./chunk-V6CD66ZZ.js";
import {
  W,
  _ as _2,
  a as a3,
  l as l5
} from "./chunk-6FHMQNMS.js";
import {
  r as r6,
  t as t6
} from "./chunk-KFDARCTS.js";
import {
  T,
  e2 as e8
} from "./chunk-TRGMWULG.js";
import {
  n as n7
} from "./chunk-WTPQKRQM.js";
import {
  c as c3,
  e as e7,
  e2 as e9,
  o2 as o3,
  t as t7
} from "./chunk-SMDDCTGQ.js";
import {
  E as E2
} from "./chunk-NU4UASX6.js";
import {
  c as c2
} from "./chunk-EHQZFPMP.js";
import {
  t as t4
} from "./chunk-FB4A6PBH.js";
import {
  o as o5
} from "./chunk-IBJTEQQG.js";
import {
  o as o4
} from "./chunk-SADO52IH.js";
import {
  h as h3
} from "./chunk-73PNWDTS.js";
import {
  c as c5,
  g,
  h as h4
} from "./chunk-3ROGWJVH.js";
import {
  A as A2,
  O as O2
} from "./chunk-BUCIQGFS.js";
import {
  N
} from "./chunk-JP7O2ZWE.js";
import {
  r as r4
} from "./chunk-M7PTINEZ.js";
import {
  h as h2,
  s as s2
} from "./chunk-SGBMUZSF.js";
import {
  D,
  E,
  F,
  L,
  R,
  _
} from "./chunk-BCDDCNQ2.js";
import {
  s as s3
} from "./chunk-6S2FCH6S.js";
import {
  e as e6
} from "./chunk-CW7LIPBH.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  e as e5,
  i
} from "./chunk-SHFLRM67.js";
import {
  r as r2
} from "./chunk-YGUWDSEH.js";
import {
  C,
  I
} from "./chunk-KRCNIFX2.js";
import {
  l as l4
} from "./chunk-RVS5HU2K.js";
import {
  n as n6,
  r as r3
} from "./chunk-SS3YG6J3.js";
import {
  yn
} from "./chunk-BNBT4QTW.js";
import {
  Q,
  c,
  h,
  o as o2,
  q
} from "./chunk-7EG7BYWF.js";
import {
  e as e4,
  o
} from "./chunk-TPJLFGOT.js";
import {
  n as n4,
  r
} from "./chunk-CQX57DED.js";
import {
  a as a2,
  l as l3,
  w
} from "./chunk-H7RDAEPY.js";
import {
  n as n5
} from "./chunk-7KH4CLS5.js";
import {
  e as e2,
  e2 as e3,
  m,
  n3 as n,
  n4 as n2,
  t2,
  u2 as u,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a,
  l as l2
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  n as n3
} from "./chunk-3R7FAT25.js";
import {
  f,
  l,
  t
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import {
  S,
  has,
  z
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/terrain/OverlayFramebufferObject.js
var i8 = class {
  constructor(e14, i12) {
    this._fbo = null;
    const p2 = new e8();
    p2.wrapMode = D.CLAMP_TO_EDGE, p2.samplingMode = L.LINEAR_MIPMAP_LINEAR, p2.hasMipmap = i12, p2.maxAnisotropy = 8, this._fbo = new x(e14, p2);
  }
  dispose() {
    this._fbo = t(this._fbo);
  }
  getTexture() {
    var _a;
    return (_a = this._fbo) == null ? void 0 : _a.colorTexture;
  }
  isValid() {
    return null != this._fbo;
  }
  resize(e14, r14) {
    var _a;
    (_a = this._fbo) == null ? void 0 : _a.resize(e14, r14);
  }
  bind(e14) {
    e14.bindFramebuffer(this._fbo);
  }
  generateMipMap() {
    var _a;
    const e14 = (_a = this._fbo) == null ? void 0 : _a.colorTexture;
    (e14 == null ? void 0 : e14.descriptor.hasMipmap) && e14.generateMipmap();
  }
  disposeRenderTargetMemory() {
    var _a;
    (_a = this._fbo) == null ? void 0 : _a.resize(0, 0);
  }
  get gpuMemoryUsage() {
    var _a;
    return ((_a = this._fbo) == null ? void 0 : _a.gpuMemoryUsage) ?? 0;
  }
};

// node_modules/@arcgis/core/views/3d/terrain/OverlayRenderTarget.js
var s6 = class {
  constructor(r14, o11, s13, a8 = true) {
    this.output = o11, this.type = s13, this.valid = false, this.lastUsed = n(1 / 0), this.fbo = new i8(r14, a8);
  }
};
var a6 = class {
  constructor(e14) {
    this.renderTargets = [new s6(e14, h3.Color, A2.Color), new s6(e14, h3.Color, A2.ColorNoRasterImage), new s6(e14, h3.Highlight, A2.Highlight, false), new s6(e14, h3.Normal, A2.Water), new s6(e14, h3.Color, A2.Occluded)], has("enable-feature:objectAndLayerId-rendering") && this.renderTargets.push(new s6(e14, h3.ObjectAndLayerIdColor, A2.ObjectAndLayerIdColor));
  }
  getTarget(e14) {
    return this.renderTargets[e14].fbo;
  }
  dispose() {
    for (const e14 of this.renderTargets)
      e14.fbo.dispose();
  }
  disposeRenderTargetMemory() {
    for (const e14 of this.renderTargets)
      e14.fbo.disposeRenderTargetMemory();
  }
  validateUsageForTarget(r14, t15, o11) {
    return r14 ? (t15.lastUsed = o11, false) : o11 - t15.lastUsed > d2 ? (t15.fbo.disposeRenderTargetMemory(), t15.lastUsed = n(1 / 0), false) : t15.lastUsed < 1 / 0;
  }
  get gpuMemoryUsage() {
    return this.renderTargets.reduce((e14, r14) => e14 + r14.fbo.gpuMemoryUsage, 0);
  }
};
var d2 = n(1e3);

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechniqueRepository.js
var r8 = class {
  constructor(t15) {
    this._context = t15, this._perConstructorInstances = new t3(), this._frameCounter = 0, this._keepAliveFrameCount = n8;
  }
  get viewingMode() {
    return this._context.viewingMode;
  }
  get constructionContext() {
    return this._context;
  }
  destroy() {
    this._perConstructorInstances.forEach((e14) => e14.forEach((e15) => e15.technique.destroy())), this._perConstructorInstances.clear();
  }
  acquire(e14, t15 = o6) {
    const r14 = t15.key;
    let n14 = this._perConstructorInstances.get(e14, r14);
    if (null == n14) {
      const o11 = new e14(this._context, t15, () => this.release(o11));
      n14 = new s7(o11), this._perConstructorInstances.set(e14, r14, n14);
    }
    return ++n14.refCount, n14.technique;
  }
  releaseAndAcquire(e14, t15, r14) {
    if (null != r14) {
      if (t15.key === r14.key)
        return r14;
      this.release(r14);
    }
    return this.acquire(e14, t15);
  }
  release(e14) {
    if (null == e14 || this._perConstructorInstances.empty)
      return;
    const t15 = this._perConstructorInstances.get(e14.constructor, e14.key);
    null != t15 && (--t15.refCount, 0 === t15.refCount && (t15.refZeroFrame = this._frameCounter));
  }
  frameUpdate() {
    this._frameCounter++, this._keepAliveFrameCount !== n8 && this._perConstructorInstances.forEach((e14, t15) => {
      e14.forEach((e15, r14) => {
        0 === e15.refCount && e15.refZeroFrame + this._keepAliveFrameCount < this._frameCounter && (e15.technique.destroy(), this._perConstructorInstances.delete(t15, r14));
      });
    });
  }
  async reloadAll() {
    const e14 = new Array();
    this._perConstructorInstances.forEach((t15, r14) => {
      const s13 = async (e15, t16) => {
        const r15 = t16.shader;
        r15 && (await r15.reload(), e15.forEach((e16) => e16.technique.reload(this._context)));
      };
      e14.push(s13(t15, r14));
    }), await Promise.all(e14);
  }
};
var s7 = class {
  constructor(e14) {
    this.technique = e14, this.refCount = 0, this.refZeroFrame = 0;
  }
};
var n8 = -1;
var o6 = new t6();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLMaterialRepository.js
var s8 = class {
  constructor(e14, t15, i12, s13) {
    this._textureRepository = e14, this._techniqueRepository = t15, this.materialChanged = i12, this.requestRender = s13, this._id2glMaterialRef = new t3();
  }
  dispose() {
    this._textureRepository.destroy();
  }
  acquire(e14, t15, r14) {
    if (this._ownMaterial(e14), !e14.requiresSlot(t15, r14))
      return null;
    let i12 = this._id2glMaterialRef.get(r14, e14.id);
    if (null == i12) {
      const t16 = e14.createGLMaterial({ material: e14, techniqueRep: this._techniqueRepository, textureRep: this._textureRepository, output: r14 });
      i12 = new o7(t16), this._id2glMaterialRef.set(r14, e14.id, i12);
    }
    return i12.ref(), i12.glMaterial;
  }
  release(e14, r14) {
    const i12 = this._id2glMaterialRef.get(r14, e14.id);
    null != i12 && (i12.unref(), i12.referenced || (t(i12.glMaterial), this._id2glMaterialRef.delete(r14, e14.id)));
  }
  _ownMaterial(t15) {
    null != t15.repository && t15.repository !== this && s.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository").error("Material is already owned by a different material repository"), t15.repository = this;
  }
};
var o7 = class {
  constructor(e14) {
    this.glMaterial = e14, this._refCnt = 0;
  }
  ref() {
    ++this._refCnt;
  }
  unref() {
    --this._refCnt, s2(this._refCnt >= 0);
  }
  get referenced() {
    return this._refCnt > 0;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/testUtils.js
var e13 = { orderedRepackingEnabled: false };
var n9 = { rootOrigin: null };

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GridLocalOriginFactory.js
var f3 = class {
  constructor(i12) {
    this._originSR = i12, this._origins = /* @__PURE__ */ new Map(), this._objects = /* @__PURE__ */ new Map(), this._gridSize = 5e5, this._rootOriginId = "root/" + e3();
  }
  getOrigin(t15) {
    const r14 = this._origins.get(this._rootOriginId);
    if (null == r14) {
      const i12 = n9.rootOrigin;
      if (null != i12)
        return this._origins.set(this._rootOriginId, c5(i12[0], i12[1], i12[2], this._rootOriginId)), this.getOrigin(t15);
      const r15 = c5(t15[0] + Math.random() - 0.5, t15[1] + Math.random() - 0.5, t15[2] + Math.random() - 0.5, this._rootOriginId);
      return this._origins.set(this._rootOriginId, r15), r15;
    }
    const o11 = this._gridSize, s13 = Math.round(t15[0] / o11), e14 = Math.round(t15[1] / o11), n14 = Math.round(t15[2] / o11), a8 = `${s13}/${e14}/${n14}`;
    let m3 = this._origins.get(a8);
    const g3 = 0.5 * o11;
    if (e4(p, t15, r14.vec3), p[0] = Math.abs(p[0]), p[1] = Math.abs(p[1]), p[2] = Math.abs(p[2]), p[0] < g3 && p[1] < g3 && p[2] < g3) {
      if (m3) {
        const r15 = Math.max(...p);
        e4(p, t15, m3.vec3), p[0] = Math.abs(p[0]), p[1] = Math.abs(p[1]), p[2] = Math.abs(p[2]);
        if (Math.max(...p) < r15)
          return m3;
      }
      return r14;
    }
    return m3 || (m3 = c5(s13 * o11, e14 * o11, n14 * o11, a8), this._origins.set(a8, m3)), m3;
  }
  _drawOriginBox(t15, i12 = r2(1, 1, 0, 1)) {
    const r14 = window.view, h6 = r14._stage, c11 = i12.toString();
    if (!this._objects.has(c11)) {
      this._material = new B({ width: 2, color: i12 }), h6.add(this._material);
      const t16 = new c8(h6, { pickable: false }), r15 = new V({ castShadow: false });
      h6.add(r15), t16.add(r15), this._objects.set(c11, r15);
    }
    const f5 = this._objects.get(c11), p2 = [0, 1, 5, 4, 0, 2, 1, 7, 6, 2, 0, 1, 3, 7, 5, 4, 6, 2, 0], j2 = p2.length, l8 = new Array(3 * j2), u2 = new Array(), b2 = 0.5 * this._gridSize;
    for (let o11 = 0; o11 < j2; o11++)
      l8[3 * o11] = t15[0] + (1 & p2[o11] ? b2 : -b2), l8[3 * o11 + 1] = t15[1] + (2 & p2[o11] ? b2 : -b2), l8[3 * o11 + 2] = t15[2] + (4 & p2[o11] ? b2 : -b2), o11 > 0 && u2.push(o11 - 1, o11);
    yn(l8, this._originSR, 0, l8, r14.renderSpatialReference, 0, j2);
    const M3 = new b(this._material, [[O.POSITION, new s3(l8, 3, true)]], [[O.POSITION, u2]], null, e7.Line);
    h6.add(M3), f5.addGeometry(M3);
  }
  get test() {
    const t15 = this;
    return { set gridSize(i12) {
      t15._gridSize = i12;
    } };
  }
};
var p = n4();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/BindParameters.js
var o8 = class {
  constructor(o11, l8, m3) {
    this.shadowMap = o11, this.ssaoHelper = l8, this.slicePlane = m3, this.slot = E4.OPAQUE_MATERIAL, this.hasOccludees = false, this.enableFillLights = true, this.transparencyPassType = o4.NONE, this.alignPixelEnabled = false, this._camera = new $(), this._inverseViewport = n6(), this.oldLighting = new _3(), this.newLighting = new _3(), this._fadedLighting = new _3(), this._lighting = this.newLighting, this.ssr = new c9(), this.multipassTerrain = new o5(), this.multipassGeometry = new s5(), this.overlays = [], this.cloudsFade = new i5();
  }
  get camera() {
    return this._camera;
  }
  set camera(i12) {
    this._camera = this.ssr.camera = i12, this._inverseViewport[0] = 1 / i12.fullViewport[2], this._inverseViewport[1] = 1 / i12.fullViewport[3];
  }
  get inverseViewport() {
    return this._inverseViewport;
  }
  get lighting() {
    return this._lighting;
  }
  get weatherFading() {
    return this._lighting === this._fadedLighting;
  }
  fadeLighting(i12) {
    const { oldLighting: t15, newLighting: s13 } = this;
    i12 >= 1 ? this._lighting = s13 : (this._fadedLighting.lerpLighting(t15, s13, i12), this._lighting = this._fadedLighting);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/RenderContext.js
var i9 = class {
  constructor(e14, a8, i12, n14 = null) {
    this.rctx = e14, this.sliceHelper = n14, this.lastFrameCamera = new $(), this.output = h3.Color, this.renderOccludedMask = l7, this.bindParameters = new o8(a8, i12, null != n14 ? n14.plane : null), this.bindParameters.alignPixelEnabled = true;
  }
  resetRenderOccludedMask() {
    this.renderOccludedMask = l7;
  }
};
var n10 = class extends i9 {
  constructor(r14, s13, t15, a8, i12) {
    super(r14, t15, a8, i12), this.offscreenRenderingHelper = s13, this.sliceHelper = i12, this.time = n(0);
  }
};
var l7 = o3.Occlude | o3.OccludeAndTransparent | o3.OccludeAndTransparentStencil;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/ChangeSet.js
var s9 = class {
  constructor() {
    this.adds = new l2(), this.removes = new l2(), this.updates = new l2({ allocator: (e14) => e14 || new r9(), deallocator: (e14) => (e14.renderGeometry = null, e14) });
  }
  clear() {
    this.adds.clear(), this.removes.clear(), this.updates.clear();
  }
  prune() {
    this.adds.prune(), this.removes.prune(), this.updates.prune();
  }
  get empty() {
    return 0 === this.adds.length && 0 === this.removes.length && 0 === this.updates.length;
  }
};
var r9 = class {
};
var t11 = class {
  constructor() {
    this.adds = new Array(), this.removes = new Array(), this.updates = new Array();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/rendererUtils.js
function r10(r14) {
  const n14 = /* @__PURE__ */ new Map(), o11 = (r15) => {
    let t15 = n14.get(r15);
    return t15 || (t15 = new t11(), n14.set(r15, t15)), t15;
  };
  return r14.removes.forAll((e14) => {
    t12(e14) && o11(e14.material).removes.push(e14);
  }), r14.adds.forAll((e14) => {
    t12(e14) && o11(e14.material).adds.push(e14);
  }), r14.updates.forAll((e14) => {
    t12(e14.renderGeometry) && o11(e14.renderGeometry.material).updates.push(e14);
  }), n14;
}
function t12(e14) {
  return e14.geometry.indexCount >= 1;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLMaterials.js
var r11 = class {
  constructor(t15, r14) {
    this._material = t15, this._repository = r14, this._map = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._map.forEach((t15, r14) => {
      null != t15 && this._repository.release(this._material, r14);
    });
  }
  load(r14, s13, e14) {
    if (!this._material.requiresSlot(s13, e14))
      return null;
    this._map.has(e14) || this._map.set(e14, this._repository.acquire(this._material, s13, e14));
    const i12 = this._map.get(e14);
    if (null != i12) {
      if (i12.ensureResources(r14) === N.LOADED)
        return i12;
      this._repository.requestRender();
    }
    return null;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DrawParameters.js
var i10 = class extends v {
  constructor(s13 = n4()) {
    super(), this.origin = s13, this.slicePlaneLocalOrigin = this.origin;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/WaterTechnique.js
var S3 = class _S extends e10 {
  initializeConfiguration(e14, o11) {
    o11.spherical = e14.viewingMode === l4.Global, o11.doublePrecisionRequiresObfuscation = e14.rctx.driverTest.doublePrecisionRequiresObfuscation.result;
  }
  initializeProgram(e14) {
    return new i2(e14.rctx, _S.shader.get().build(this.configuration), E2);
  }
  _setPipelineState(e14) {
    const t15 = this.configuration, r14 = e14 === o4.NONE, i12 = e14 === o4.FrontFace;
    return W({ blending: t15.output !== h3.Normal && t15.output !== h3.Highlight && t15.output !== h3.ObjectAndLayerIdColor && t15.transparent ? r14 ? c4 : A(e14) : null, depthTest: { func: l6(e14) }, depthWrite: r14 ? t15.writeDepth ? a3 : null : E3(e14), colorWrite: _2, polygonOffset: r14 || i12 ? null : a4(t15.enableOffset) });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
};
S3.shader = new t5(x2, () => import("./WaterSurface.glsl-77TOAVCP.js"));
var P = class extends s4 {
  constructor() {
    super(...arguments), this.output = h3.Color, this.transparencyPassType = o4.NONE, this.spherical = false, this.receiveShadows = false, this.hasSlicePlane = false, this.transparent = false, this.enableOffset = true, this.writeDepth = false, this.hasScreenSpaceReflections = false, this.doublePrecisionRequiresObfuscation = false, this.hasCloudsReflections = false, this.objectAndLayerIdColorInstanced = false, this.isDraped = false, this.hasMultipassTerrain = false, this.cullAboveGround = false;
  }
};
e([r6({ count: h3.COUNT })], P.prototype, "output", void 0), e([r6({ count: o4.COUNT })], P.prototype, "transparencyPassType", void 0), e([r6()], P.prototype, "spherical", void 0), e([r6()], P.prototype, "receiveShadows", void 0), e([r6()], P.prototype, "hasSlicePlane", void 0), e([r6()], P.prototype, "transparent", void 0), e([r6()], P.prototype, "enableOffset", void 0), e([r6()], P.prototype, "writeDepth", void 0), e([r6()], P.prototype, "hasScreenSpaceReflections", void 0), e([r6()], P.prototype, "doublePrecisionRequiresObfuscation", void 0), e([r6()], P.prototype, "hasCloudsReflections", void 0), e([r6()], P.prototype, "objectAndLayerIdColorInstanced", void 0), e([r6()], P.prototype, "isDraped", void 0), e([r6()], P.prototype, "hasMultipassTerrain", void 0), e([r6()], P.prototype, "cullAboveGround", void 0), e([r6({ constValue: c2.Water })], P.prototype, "pbrMode", void 0), e([r6({ constValue: true })], P.prototype, "useCustomDTRExponentForWater", void 0), e([r6({ constValue: true })], P.prototype, "highStepCount", void 0), e([r6({ constValue: false })], P.prototype, "useFillLights", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/WaterGLMaterial.js
var s10 = class extends t4 {
  _updateShadowState(e14) {
    e14.shadowMap.enabled !== this._material.parameters.receiveShadows && this._material.setParameters({ receiveShadows: e14.shadowMap.enabled });
  }
  _updateSSRState(e14) {
    e14.ssr.enabled !== this._material.parameters.hasScreenSpaceReflections && this._material.setParameters({ hasScreenSpaceReflections: e14.ssr.enabled });
  }
  _updateCloudsReflectionState(e14) {
    const t15 = null != e14.cloudsFade.data;
    t15 !== this._material.parameters.hasCloudsReflections && this._material.setParameters({ hasCloudsReflections: t15 });
  }
  ensureResources(e14) {
    return this._techniqueRepository.constructionContext.waterTextureRepository.ensureResources(e14);
  }
  beginSlot(t15) {
    return this._output === h3.Color && (this._updateShadowState(t15), this._updateSSRState(t15), this._updateCloudsReflectionState(t15)), this._material.setParameters(this._techniqueRepository.constructionContext.waterTextureRepository.passParameters), this.ensureTechnique(S3, t15);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/WaterMaterial.js
var d3 = class extends e12 {
  constructor(e14) {
    super(e14, new A3()), this._configuration = new P(), this.animation = new e9();
  }
  getConfiguration(e14, t15) {
    return this._configuration.output = e14, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.receiveShadows = this.parameters.receiveShadows, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.transparent = this.parameters.transparent, this._configuration.hasScreenSpaceReflections = this.parameters.hasScreenSpaceReflections, this._configuration.hasCloudsReflections = this.parameters.hasCloudsReflections, this._configuration.isDraped = this.parameters.isDraped, this._configuration.transparencyPassType = t15.transparencyPassType, this._configuration.enableOffset = t15.camera.relativeElevation < S2, this._configuration.hasMultipassTerrain = t15.multipassTerrain.enabled, this._configuration.cullAboveGround = t15.multipassTerrain.cullAboveGround, this._configuration;
  }
  update(t15) {
    const r14 = Math.min(t15.camera.relativeElevation, t15.camera.distance);
    this.animation.enabled = Math.sqrt(this.parameters.waveTextureRepeat / this.parameters.waveStrength) * r14 < T2;
    const a8 = this.animation.advance(t15);
    return this.setParameters({ timeElapsed: u(this.animation.time) * this.parameters.animationSpeed }, false), this.animation.enabled && a8;
  }
  requiresSlot(e14, t15) {
    switch (t15) {
      case h3.Normal:
        return e14 === E4.DRAPED_WATER;
      case h3.Color:
        if (this.parameters.isDraped)
          return e14 === E4.DRAPED_MATERIAL;
        break;
      case h3.Alpha:
        break;
      case h3.Highlight:
      case h3.ObjectAndLayerIdColor:
        return e14 === E4.OPAQUE_MATERIAL || e14 === E4.DRAPED_MATERIAL;
      default:
        return false;
    }
    let r14 = E4.OPAQUE_MATERIAL;
    return this.parameters.transparent && (r14 = this.parameters.writeDepth ? E4.TRANSPARENT_MATERIAL : E4.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL), e14 === r14;
  }
  createGLMaterial(e14) {
    return new s10(e14);
  }
  createBufferWriter() {
    return new r5(has("enable-feature:objectAndLayerId-rendering") ? t9 : c7);
  }
};
var A3 = class extends c3 {
  constructor() {
    super(...arguments), this.waveStrength = 0.06, this.waveTextureRepeat = 32, this.waveDirection = r3(1, 0), this.waveVelocity = 0.05, this.flowStrength = 0.015, this.flowOffset = -0.5, this.animationSpeed = 0.35, this.timeElapsed = 0, this.color = r2(0, 0, 0, 0), this.transparent = true, this.writeDepth = true, this.hasSlicePlane = false, this.isDraped = false, this.receiveShadows = true, this.hasScreenSpaceReflections = false, this.hasCloudsReflections = false, this.origin = n4(), this.modelTransformation = null;
  }
};
var T2 = 35e3;

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/BufferRange.js
var t13 = class {
  constructor(t15 = 0, o11 = 0) {
    this.from = t15, this.to = o11;
  }
  get numElements() {
    return this.to - this.from;
  }
};
function o9(t15) {
  const o11 = /* @__PURE__ */ new Map();
  t15.forAll((t16) => o11.set(t16.from, t16));
  let e14 = true;
  for (; e14; )
    e14 = false, t15.forEach((r14) => {
      const s13 = o11.get(r14.to);
      s13 && (r14.to = s13.to, o11.delete(s13.from), t15.removeUnordered(s13), e14 = true);
    });
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/Instance.js
var s11 = class extends t13 {
  constructor(e14, s13, t15) {
    super(s13, t15), this.geometry = e14;
  }
  get isVisible() {
    return this.geometry.visible;
  }
  get hasHighlights() {
    return null != this.geometry.highlights && this.isVisible;
  }
  get hasOccludees() {
    return null != this.geometry.occludees;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/DrawCommand.js
var t14 = class {
  constructor() {
    this.first = 0, this.count = 0;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/PerBufferData.js
var n12 = class {
  constructor() {
    this._numElements = 0, this._instances = /* @__PURE__ */ new Map(), this.holes = new l2({ allocator: (s13) => s13 || new t13(), deallocator: null }), this.hasHiddenInstances = false, this.hasHighlights = false, this.hasOccludees = false, this.drawCommandsDirty = true, this.drawCommandsDefault = o10(), this.drawCommandsHighlight = o10(), this.drawCommandsOccludees = o10(), this.drawCommandsShadowHighlightRest = o10();
  }
  get numElements() {
    return this._numElements;
  }
  get instances() {
    return this._instances;
  }
  addInstance(s13, t15) {
    this.deleteInstance(s13), this._instances.set(s13, t15), this._numElements += t15.numElements;
  }
  deleteInstance(s13) {
    const t15 = this._instances.get(s13);
    t15 && (this._numElements -= t15.numElements, this._instances.delete(s13));
  }
  updateInstance(s13, t15, e14) {
    const n14 = this._instances.get(s13);
    n14 && (this._numElements -= n14.numElements, n14.from = t15, n14.to = e14, this._numElements += n14.numElements);
  }
  updateDrawState(s13) {
    s13.isVisible ? (s13.hasHighlights && (this.hasHighlights = true), s13.hasOccludees && (this.hasOccludees = true)) : this.hasHiddenInstances = true;
  }
  updateDrawCommands(s13) {
    if (this.drawCommandsDefault.clear(), this.drawCommandsHighlight.clear(), this.drawCommandsOccludees.clear(), this.drawCommandsShadowHighlightRest.clear(), this.drawCommandsDirty = false, 0 === this._instances.size)
      return;
    if (!this.needsMultipleCommands()) {
      const t16 = this.drawCommandsDefault.pushNew(), e14 = this.holes.front();
      return null != this.vao && 1 === this.holes.length && e14.to === Math.floor(this.vao.byteSize / s13) ? (t16.first = 0, void (t16.count = e14.from)) : (t16.first = 1 / 0, t16.count = 0, this._instances.forEach((s14) => {
        t16.first = Math.min(t16.first, s14.from), t16.count = Math.max(t16.count, s14.to);
      }), void (t16.count -= t16.first));
    }
    const t15 = Array.from(this._instances.values()).sort((s14, t16) => s14.from === t16.from ? s14.to - t16.to : s14.from - t16.from);
    for (const e14 of t15)
      e14.isVisible && (h5(e14.hasOccludees ? this.drawCommandsOccludees : this.drawCommandsDefault, e14), h5(e14.hasHighlights ? this.drawCommandsHighlight : this.drawCommandsShadowHighlightRest, e14));
  }
  needsMultipleCommands() {
    return this.hasOccludees || this.hasHighlights || this.hasHiddenInstances;
  }
};
function a7(s13) {
  return null != s13.vao;
}
function o10() {
  return new l2({ allocator: (s13) => s13 || new t14(), deallocator: (s13) => s13 });
}
function h5(s13, t15) {
  const e14 = s13.back();
  if (null == e14) {
    const e15 = s13.pushNew();
    return e15.first = t15.from, void (e15.count = t15.numElements);
  }
  if (r12(e14, t15)) {
    const s14 = t15.from - e14.first + t15.numElements;
    e14.count = s14;
  } else {
    const e15 = s13.pushNew();
    e15.first = t15.from, e15.count = t15.numElements;
  }
}
function r12(s13, t15) {
  return s13.first + s13.count >= t15.from;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/PerOriginData.js
var s12 = class {
  constructor(s13) {
    this.origin = s13, this.buffers = new Array();
  }
  dispose() {
    this.buffers.forEach((s13) => s13.vao.dispose()), this.buffers.length = 0;
  }
  findBuffer(s13) {
    return this.buffers.find((r14) => r14.instances.has(s13));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/VaoCache.js
var c10 = e5 + 1;
var i11 = class {
  constructor(t15, e14, o11) {
    this._rctx = t15, this._locations = e14, this._layout = o11, this._cache = t15.newCache("VaoCache", n13);
  }
  dispose() {
    this._cache.destroy();
  }
  newVao(t15) {
    const e14 = t15.toString(), i12 = this._cache.pop(e14);
    if (null != i12) {
      const o11 = i12.pop();
      return i12.length > 0 && this._cache.put(e14, i12, t15 * i12.length, c10), o11;
    }
    const n14 = new r7(this._rctx, this._locations, { geometry: this._layout }, { geometry: c6.createVertex(this._rctx, F.STATIC_DRAW) });
    return n14.vertexBuffers.geometry.setSize(t15), n14;
  }
  deleteVao(t15) {
    if (null == t15)
      return null;
    const e14 = t15.byteSize, o11 = e14.toString(), r14 = this._cache.pop(o11);
    return null != r14 ? (r14.push(t15), this._cache.put(o11, r14, e14 * r14.length, -1)) : this._cache.put(o11, [t15], e14, -1), null;
  }
};
function n13(e14, o11) {
  if (o11 === i.ALL)
    return void e14.forEach((t15) => t15.dispose());
  const r14 = e14.pop(), s13 = e14.length * r14.byteSize;
  return r14.dispose(), s13;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/MergedRenderer.js
var E6 = class {
  constructor(e14, t15, r14) {
    this._rctx = e14, this._materialRepository = t15, this.material = r14, this._dataByOrigin = /* @__PURE__ */ new Map(), this._hasHighlights = false, this._hasOccludees = false, this._glMaterials = new r11(this.material, this._materialRepository), this._bufferWriter = r14.createBufferWriter(), this._vaoCache = new i11(e14, r14.vertexAttributeLocations, r4(this._bufferWriter.vertexBufferLayout));
  }
  dispose() {
    this._glMaterials.destroy(), this._dataByOrigin.forEach((e14) => e14.dispose()), this._dataByOrigin.clear(), this._vaoCache.dispose();
  }
  get isEmpty() {
    return 0 === this._dataByOrigin.size;
  }
  get hasHighlights() {
    return this._hasHighlights;
  }
  get hasOccludees() {
    return this._hasOccludees;
  }
  get hasWater() {
    return !this.isEmpty && this.material instanceof d3;
  }
  get rendersOccluded() {
    return !this.isEmpty && this.material.renderOccluded !== o3.Occlude;
  }
  get numGeometries() {
    let e14 = 0;
    return this._dataByOrigin.forEach((t15) => e14 += t15.buffers.reduce((e15, t16) => e15 + t16.instances.size, 0)), e14;
  }
  forEachGeometry(e14) {
    this._dataByOrigin.forEach((t15) => t15.buffers.forEach((t16) => t16.instances.forEach((t17) => e14(t17.geometry))));
  }
  modify(e14) {
    this._updateGeometries(e14.updates), this._addAndRemoveGeometries(e14.adds, e14.removes), this._updateDrawCommands();
  }
  _updateGeometries(e14) {
    const t15 = this._bufferWriter, r14 = t15.vertexBufferLayout.stride / 4;
    for (const s13 of e14) {
      const e15 = s13.renderGeometry, i12 = this._dataByOrigin.get(e15.localOrigin.id), a8 = i12 == null ? void 0 : i12.findBuffer(e15.id);
      if (null == a8)
        return;
      const o11 = a8.instances.get(e15.id);
      if (s13.updateType & (I2.GEOMETRY | I2.TRANSFORMATION)) {
        const s14 = W2(t15.elementCount(o11.geometry.geometry) * r14), i13 = t15.vertexBufferLayout.createView(s14.buffer);
        this._writeGeometry(e15, i13, 0), a8.vao.vertexBuffers.geometry.setSubData(s14, o11.from * r14, 0, o11.numElements * r14), P2();
      }
      s13.updateType & (I2.HIGHLIGHT | I2.OCCLUDEE | I2.VISIBILITY) && (a8.drawCommandsDirty = true);
    }
  }
  _computeDeltas(e14, t15) {
    const r14 = new t3();
    for (const s13 of e14) {
      const e15 = s13.localOrigin;
      if (null == e15)
        continue;
      let t16 = r14.get(e15.id, null);
      null == t16 && (t16 = new A4(e15.vec3), r14.set(e15.id, null, t16)), t16.changes.push(s13);
    }
    for (const s13 of t15) {
      const e15 = s13.localOrigin;
      if (null == e15)
        continue;
      const t16 = this._dataByOrigin.get(e15.id), i12 = t16 == null ? void 0 : t16.findBuffer(s13.id);
      if (null == i12)
        continue;
      let a8 = r14.get(e15.id, i12);
      null == a8 && (a8 = new A4(e15.vec3), r14.set(e15.id, i12, a8)), a8.changes.push(s13);
    }
    return r14;
  }
  _addAndRemoveGeometries(t15, r14) {
    const { _bufferWriter: s13, _dataByOrigin: i12 } = this, a8 = s13.vertexBufferLayout.stride / 4, o11 = this._computeDeltas(t15, r14);
    o11.forEach((t16, r15) => {
      const n14 = t16.get(null), l8 = null != n14 ? n14.changes : [];
      o11.delete(r15, null);
      let h6 = i12.get(r15);
      if (t16.forEach((t17, n15) => {
        if (o11.delete(r15, n15), null == n15)
          return void s2(false, "No VAO for removed geometries");
        if (n15.instances.size === t17.changes.length)
          return this._vaoCache.deleteVao(n15.vao), z(h6.buffers, n15), void (0 === h6.buffers.length && 0 === l8.length && i12.delete(r15));
        const u2 = n15.numElements, f5 = n15.vao.byteSize / 4, c11 = l8.reduce((e14, t18) => e14 + s13.elementCount(t18.geometry), 0), d4 = t17.changes.reduce((e14, t18) => e14 + s13.elementCount(t18.geometry), 0), g3 = Math.min((u2 + c11 - d4) * a8, G), p2 = g3 > f5;
        g3 > j && g3 < f5 / 2 ? (t17.changes.forEach(({ id: e14 }) => n15.deleteInstance(e14)), n15.instances.forEach(({ geometry: e14 }) => l8.push(e14)), this._vaoCache.deleteVao(n15.vao), z(h6.buffers, n15)) : p2 ? this._applyAndRebuild(n15, l8, t17) : this._applyRemoves(n15, t17);
      }), l8.length > 0)
        for (null == h6 && (h6 = new s12(n14.origin), i12.set(r15, h6)), h6.buffers.forEach((e14) => this._applyAdds(e14, l8)); l8.length > 0; )
          h6.buffers.push(this._applyAndRebuild(new n12(), l8, null));
    });
  }
  _updateDrawCommands() {
    this._hasHighlights = false, this._hasOccludees = false, this._dataByOrigin.forEach((e14) => {
      e14.buffers.forEach((e15) => {
        e15.drawCommandsDirty && (e15.hasHiddenInstances = false, e15.hasHighlights = false, e15.hasOccludees = false, n3(e15.instances, (t15) => (e15.updateDrawState(t15), e15.hasHiddenInstances && e15.hasHighlights && e15.hasOccludees)), e15.updateDrawCommands(this._bufferWriter.vertexBufferLayout.stride)), this._hasHighlights = this._hasHighlights || e15.hasHighlights, this._hasOccludees = this._hasOccludees || e15.hasOccludees;
      });
    });
  }
  _applyAndRebuild(e14, t15, r14) {
    if (null != r14)
      for (const d4 of r14.changes)
        e14.deleteInstance(d4.id);
    const s13 = this._bufferWriter, i12 = s13.vertexBufferLayout.stride, a8 = i12 / 4, o11 = Math.floor(G / a8);
    let n14 = e14.numElements;
    for (; t15.length > 0; ) {
      const r15 = t15.pop(), i13 = s13.elementCount(r15.geometry);
      if (n14 + i13 > o11 && n14 > 0) {
        t15.push(r15);
        break;
      }
      n14 += i13;
      const a9 = new s11(r15, 0, 0);
      s2(null == e14.instances.get(r15.id)), e14.addInstance(r15.id, a9);
    }
    const l8 = n14 * a8, h6 = W2(l8), u2 = s13.vertexBufferLayout.createView(h6.buffer);
    let f5 = 0;
    e14.hasHiddenInstances = false, e14.hasHighlights = false, e14.hasOccludees = false, e14.instances.forEach((t16, r15) => {
      this._writeGeometry(t16.geometry, u2, f5);
      const i13 = f5;
      f5 += s13.elementCount(t16.geometry.geometry), e14.updateInstance(r15, i13, f5), e14.updateDrawState(t16);
    }), this._vaoCache.deleteVao(e14.vao), e14.vao = this._vaoCache.newVao(V2(l8)), e14.vao.vertexBuffers.geometry.setSubData(h6, 0, 0, f5 * a8), P2(), e14.holes.clear();
    const c11 = e14.holes.pushNew();
    return c11.from = f5, c11.to = Math.floor(e14.vao.byteSize / i12), e14.updateDrawCommands(i12), e14;
  }
  _applyRemoves(e14, t15) {
    if (0 === t15.changes.length)
      return;
    for (const o11 of t15.changes) {
      const t16 = o11.id, r15 = e14.instances.get(t16);
      if (!r15)
        continue;
      e14.deleteInstance(t16);
      const s14 = x3.back();
      if (s14) {
        if (s14.to === r15.from) {
          s14.to = r15.to;
          continue;
        }
        if (s14.from === r15.to) {
          s14.from = r15.from;
          continue;
        }
      }
      const i13 = x3.pushNew();
      i13.from = r15.from, i13.to = r15.to;
    }
    o9(x3);
    const r14 = this._bufferWriter.vertexBufferLayout.stride / 4, s13 = x3.reduce((e15, t16) => Math.max(e15, t16.numElements), 0) * r14, i12 = W2(s13);
    i12.fill(0, 0, s13);
    const a8 = e14.vao.vertexBuffers.geometry;
    x3.forAll((e15) => a8.setSubData(i12, e15.from * r14, 0, e15.numElements * r14)), P2(), e14.holes.pushArray(x3.data, x3.length), x3.forAll((e15, t16) => x3.data[t16] = null), x3.clear(), e14.drawCommandsDirty = true;
  }
  _applyAdds(e14, r14) {
    if (0 === r14.length)
      return;
    if (!a7(e14))
      return void this._applyAndRebuild(e14, r14, null);
    const s13 = this._bufferWriter, i12 = s13.vertexBufferLayout.stride / 4, a8 = e14.numElements, o11 = r14.reduce((e15, t15) => e15 + s13.elementCount(t15.geometry), 0), n14 = Math.min((a8 + o11) * i12, G), l8 = 4 * n14;
    if (e14.vao.byteSize < V2(G - j) && l8 > e14.vao.byteSize)
      return void this._applyAndRebuild(e14, r14, null);
    o9(e14.holes);
    const h6 = new Array();
    for (const t15 of r14) {
      const r15 = s13.elementCount(t15.geometry), i13 = H(e14.holes, r15);
      h6.push(i13);
    }
    const u2 = e14.vao.vertexBuffers.geometry;
    let f5 = 0, c11 = 0, d4 = 0;
    const g3 = W2(n14), p2 = s13.vertexBufferLayout.createView(g3.buffer);
    r14.forEach((t15, r15) => {
      const a9 = h6[r15];
      if (null == a9)
        return;
      if (!(d4 === a9)) {
        const e15 = d4 - c11;
        e15 > 0 && u2.setSubData(g3, c11 * i12, 0, e15 * i12), c11 = a9, f5 = 0;
      }
      const o12 = s13.elementCount(t15.geometry);
      this._writeGeometry(t15, p2, f5), f5 += o12, d4 = a9 + o12;
      const n15 = new s11(t15, a9, a9 + o12);
      s2(null == e14.instances.get(t15.id)), e14.addInstance(t15.id, n15), e14.drawCommandsDirty = true;
    });
    const y3 = d4 - c11;
    y3 > 0 && u2.setSubData(g3, c11 * i12, 0, y3 * i12), S(r14, (e15, t15) => null == h6[t15]), P2();
  }
  _writeGeometry(e14, t15, r14) {
    const s13 = e14.localOrigin.vec3;
    h2(D2, -s13[0], -s13[1], -s13[2]);
    const i12 = c(S4, D2, e14.transformation);
    h(M2, i12), o2(M2, M2), this._bufferWriter.write(i12, M2, e14.geometry, t15, r14);
  }
  updateAnimation(e14) {
    return this.material.update(e14);
  }
  requiresSlot(e14, t15) {
    return this.material.requiresSlot(e14, t15);
  }
  prepareTechnique(e14) {
    const { output: t15, bindParameters: r14 } = e14;
    if (!this.requiresSlot(r14.slot, t15))
      return null;
    const s13 = t15 === h3.Highlight || t15 === h3.ShadowHighlight;
    if (s13 && !this._hasHighlights)
      return null;
    const i12 = t15 === h3.ShadowExcludeHighlight, a8 = !(s13 || i12);
    for (const o11 of this._dataByOrigin.values())
      for (const n14 of o11.buffers) {
        if (s13 && !n14.hasHighlights)
          continue;
        const o12 = (s13 ? n14.drawCommandsHighlight : i12 && n14.needsMultipleCommands() ? n14.drawCommandsShadowHighlightRest : n14.drawCommandsDefault) || null, l8 = a8 && n14.drawCommandsOccludees || null;
        if ((o12 == null ? void 0 : o12.length) || (l8 == null ? void 0 : l8.length)) {
          const s14 = this._glMaterials.load(e14.rctx, r14.slot, t15), i13 = null != s14 ? s14.beginSlot(r14) : null;
          if (null != i13)
            return i13;
        }
      }
    return null;
  }
  render(e14, t15) {
    var _a;
    const { output: r14, bindParameters: s13 } = e14, i12 = r14 === h3.Highlight || r14 === h3.ShadowHighlight, a8 = r14 === h3.ShadowExcludeHighlight, o11 = !(i12 || a8), n14 = this._rctx;
    (_a = n14.appleAmdDriverHelper) == null ? void 0 : _a.resetIndicesType(), n14.bindTechnique(t15, this.material.parameters, s13);
    for (const l8 of this._dataByOrigin.values())
      for (const e15 of l8.buffers) {
        if (i12 && !e15.hasHighlights)
          continue;
        const r15 = (i12 ? e15.drawCommandsHighlight : a8 && e15.needsMultipleCommands() ? e15.drawCommandsShadowHighlightRest : e15.drawCommandsDefault) || null, h6 = o11 && e15.drawCommandsOccludees || null;
        if ((r15 == null ? void 0 : r15.length) || (h6 == null ? void 0 : h6.length)) {
          t15.program.bindDraw(new i10(l8.origin), s13, this.material.parameters), t15.ensureAttributeLocations(e15.vao), n14.bindVAO(e15.vao), (r15 == null ? void 0 : r15.length) && (t15.bindPipelineState(n14, s13.slot, false), r15.forAll((e16) => n14.drawArrays(t15.primitiveType, e16.first, e16.count))), (h6 == null ? void 0 : h6.length) && (t15.bindPipelineState(n14, s13.slot, true), h6.forAll((e16) => n14.drawArrays(t15.primitiveType, e16.first, e16.count)));
        }
      }
  }
  get test() {
    return { material: this.material, glMaterials: this._glMaterials, dataByOrigin: this._dataByOrigin };
  }
};
var A4 = class {
  constructor(e14) {
    this.origin = e14, this.changes = new Array();
  }
};
function H(e14, t15) {
  let r14;
  if (!e14.some((e15) => !(e15.numElements < t15) && (r14 = e15, true)))
    return null;
  const s13 = r14.from;
  return r14.from += t15, r14.from >= r14.to && e14.removeUnordered(r14), s13;
}
var D2 = e6();
var S4 = e6();
var M2 = e6();
var x3 = new l2({ allocator: (e14) => e14 || new t13(), deallocator: null });
var j = 65536;
var I3 = 4 * j;
var L2 = 1024;
var R2 = 16777216;
var G = R2 / 4;
var T3 = new Float32Array(j);
function W2(e14) {
  return T3.length < e14 && (T3 = new Float32Array(e14)), T3;
}
function V2(e14) {
  const t15 = 4 * e14;
  return t15 <= L2 ? L2 : t15 < I3 ? I3 : Math.max(Math.min(Math.ceil(1.5 * t15 / I3) * I3, R2), t15);
}
function P2() {
  T3 = new Float32Array(2);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/SortedRenderGeometryRenderer.js
var _4 = class extends m {
  constructor(e14) {
    super(e14), this._pending = new y2(), this._changes = new s9(), this._materialRenderers = /* @__PURE__ */ new Map(), this._sortedMaterialRenderers = new l2(), this._geometries = /* @__PURE__ */ new Map(), this._hasHighlights = false, this._hasWater = false;
  }
  destroy() {
    this._changes.prune(), this._materialRenderers.forEach((e14) => e14.dispose()), this._materialRenderers.clear(), this._sortedMaterialRenderers.clear(), this._geometries.clear(), this._pending.clear();
  }
  get updating() {
    return !this._pending.empty || this._changes.updates.length > 0;
  }
  get rctx() {
    return this.rendererContext.rctx;
  }
  get _materialRepository() {
    return this.rendererContext.materialRepository;
  }
  get _localOriginFactory() {
    return this.rendererContext.localOriginFactory;
  }
  get hasHighlights() {
    return this._hasHighlights;
  }
  get hasWater() {
    return this._hasWater;
  }
  get rendersOccluded() {
    return n3(this._materialRenderers, (e14) => e14.rendersOccluded);
  }
  get isEmpty() {
    return !this.updating && 0 === this._materialRenderers.size && 0 === this._geometries.size;
  }
  commitChanges() {
    if (!this.updating)
      return false;
    this._processAddsRemoves();
    const e14 = r10(this._changes);
    let r14 = false, s13 = false, i12 = false;
    return e14.forEach((e15, t15) => {
      let n14 = this._materialRenderers.get(t15);
      if (!n14 && e15.adds.length > 0 && (n14 = new E6(this.rctx, this._materialRepository, t15), this._materialRenderers.set(t15, n14), r14 = true, s13 = true, i12 = true), !n14)
        return;
      const a8 = s13 || n14.hasHighlights, o11 = i12 || n14.hasWater;
      n14.modify(e15), s13 = s13 || a8 !== n14.hasHighlights, i12 = i12 || o11 !== n14.hasWater, n14.isEmpty && (this._materialRenderers.delete(t15), n14.dispose(), r14 = true);
    }), this._changes.clear(), r14 && this._updateSortedMaterialRenderers(), s13 && (this._hasHighlights = n3(this._materialRenderers, (e15) => e15.hasHighlights)), i12 && (this._hasWater = n3(this._materialRenderers, (e15) => e15.hasWater)), this.notifyChange("updating"), true;
  }
  addGeometries(e14, r14) {
    if (0 === e14.length)
      return;
    const t15 = this._validateRenderGeometries(e14);
    for (const i12 of t15)
      this._geometries.set(i12.id, i12);
    const s13 = this._pending.empty;
    for (const i12 of t15)
      this._pending.adds.add(i12);
    s13 && this.notifyChange("updating"), r14 === E5.UPDATE && this._notifyGraphicGeometryChanged(e14);
  }
  removeGeometries(e14, r14) {
    const t15 = this._pending.empty, s13 = this._pending.adds;
    for (const i12 of e14)
      s13.has(i12) ? (this._pending.removed.add(i12), s13.delete(i12)) : this._pending.removed.has(i12) || this._pending.removes.add(i12), this._geometries.delete(i12.id);
    t15 && !this._pending.empty && this.notifyChange("updating"), r14 === E5.UPDATE && this._notifyGraphicGeometryChanged(e14);
  }
  modifyGeometries(e14, r14) {
    const t15 = 0 === this._changes.updates.length;
    for (const s13 of e14) {
      const e15 = this._changes.updates.pushNew();
      e15.renderGeometry = this._validateRenderGeometry(s13), e15.updateType = r14;
    }
    switch (t15 && this._changes.updates.length > 0 && this.notifyChange("updating"), r14) {
      case I2.TRANSFORMATION:
      case I2.GEOMETRY:
        return this._notifyGraphicGeometryChanged(e14);
      case I2.VISIBILITY:
        return this._notifyGraphicVisibilityChanged(e14);
    }
  }
  updateAnimation(e14) {
    let r14 = false;
    return this._sortedMaterialRenderers.forAll((t15) => r14 = t15.updateAnimation(e14) || r14), r14;
  }
  render(e14) {
    this._sortedMaterialRenderers.forAll((r14) => {
      if (r14.material.shouldRender(e14)) {
        const t15 = r14.prepareTechnique(e14);
        null != t15 && r14.render(e14, t15);
      }
    });
  }
  intersect(e14, r14, t15, s13, i12) {
    return this._geometries.forEach((n14) => {
      if (s13 && !s13(n14))
        return;
      this._intersectRenderGeometry(n14, t15, r14, 0, e14, i12);
      const a8 = this.rendererContext.longitudeCyclical;
      a8 && (n14.boundingSphere[0] - n14.boundingSphere[3] < a8.min && this._intersectRenderGeometry(n14, t15, r14, a8.range, e14, i12), n14.boundingSphere[0] + n14.boundingSphere[3] > a8.max && this._intersectRenderGeometry(n14, t15, r14, -a8.range, e14, i12)), i12++;
    }), i12;
  }
  _updateSortedMaterialRenderers() {
    this._sortedMaterialRenderers.clear();
    let e14 = 0;
    this._materialRenderers.forEach((r14, t15) => {
      t15.insertOrder = e14++, this._sortedMaterialRenderers.push(r14);
    }), this._sortedMaterialRenderers.sort((e15, r14) => {
      const t15 = r14.material.renderPriority - e15.material.renderPriority;
      return 0 !== t15 ? t15 : e15.material.insertOrder - r14.material.insertOrder;
    });
  }
  _processAddsRemoves() {
    this._changes.adds.clear(), this._changes.removes.clear(), this._changes.adds.pushArray(Array.from(this._pending.adds)), this._changes.removes.pushArray(Array.from(this._pending.removes));
    for (let e14 = 0; e14 < this._changes.updates.length; ) {
      const r14 = this._changes.updates.data[e14];
      this._pending.has(r14.renderGeometry) ? this._changes.updates.removeUnorderedIndex(e14) : e14++;
    }
    this._pending.clear();
  }
  _intersectRenderGeometry(e14, r14, t15, s13, i12, n14) {
    if (!e14.visible)
      return;
    let a8 = 0;
    s13 += e14.transformation[12], a8 = e14.transformation[13], R3[0] = t15[0] - s13, R3[1] = t15[1] - a8, e14.screenToWorldRatio = this.rendererContext.screenToWorldRatio, e14.material.intersectDraped(e14, null, i12, R3, (t16, s14, a9) => {
      f4(r14, a9, e14.material.renderPriority, n14, i12, e14.layerUid, e14.graphicUid);
    }, r14);
  }
  _notifyGraphicGeometryChanged(e14) {
    if (null == this.drapeSource.notifyGraphicGeometryChanged)
      return;
    let r14;
    for (const t15 of e14) {
      const e15 = t15.graphicUid;
      null != e15 && e15 !== r14 && (this.drapeSource.notifyGraphicGeometryChanged(e15), r14 = e15);
    }
  }
  _notifyGraphicVisibilityChanged(e14) {
    if (null == this.drapeSource.notifyGraphicVisibilityChanged)
      return;
    let r14;
    for (const t15 of e14) {
      const e15 = t15.graphicUid;
      null != e15 && e15 !== r14 && (this.drapeSource.notifyGraphicVisibilityChanged(e15), r14 = e15);
    }
  }
  _validateRenderGeometries(e14) {
    for (const r14 of e14)
      this._validateRenderGeometry(r14);
    return e14;
  }
  _validateRenderGeometry(e14) {
    return null == e14.localOrigin && (e14.localOrigin = this._localOriginFactory.getOrigin(e14.boundingSphere)), e14;
  }
  get test() {
    return { sortedMaterialRenderers: this._sortedMaterialRenderers };
  }
};
e([y()], _4.prototype, "drapeSource", void 0), e([y()], _4.prototype, "updating", null), e([y()], _4.prototype, "rctx", null), e([y()], _4.prototype, "rendererContext", void 0), e([y()], _4.prototype, "_materialRepository", null), e([y()], _4.prototype, "_localOriginFactory", null), e([y({ readOnly: true })], _4.prototype, "isEmpty", null), e([y()], _4.prototype, "_materialRenderers", void 0), e([y()], _4.prototype, "_geometries", void 0), _4 = e([a("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")], _4);
var y2 = class {
  constructor() {
    this.adds = /* @__PURE__ */ new Set(), this.removes = /* @__PURE__ */ new Set(), this.removed = /* @__PURE__ */ new Set();
  }
  get empty() {
    return 0 === this.adds.size && 0 === this.removes.size && 0 === this.removed.size;
  }
  has(e14) {
    return this.adds.has(e14) || this.removes.has(e14) || this.removed.has(e14);
  }
  clear() {
    this.adds.clear(), this.removes.clear(), this.removed.clear();
  }
};
function f4(e14, r14, t15, s13, i12, n14, a8) {
  const d4 = new i7(n14, a8, r14), p2 = (r15) => {
    r15.set(i6.OVERLAY, d4, e14.dist, e14.normal, e14.transformation, t15, s13);
  };
  if ((null == i12.results.min.drapedLayerOrder || t15 >= i12.results.min.drapedLayerOrder) && (null == i12.results.min.dist || i12.results.ground.dist <= i12.results.min.dist) && p2(i12.results.min), i12.options.store !== t10.MIN && (null == i12.results.max.drapedLayerOrder || t15 < i12.results.max.drapedLayerOrder) && (null == i12.results.max.dist || i12.results.ground.dist > i12.results.max.dist) && p2(i12.results.max), i12.options.store === t10.ALL) {
    const e15 = M(i12.ray);
    p2(e15), i12.results.all.push(e15);
  }
}
var R3 = n6();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextureTechnique.js
var m2 = class _m extends e10 {
  initializeProgram(e14) {
    return new i2(e14.rctx, _m.shader.get().build(), E2);
  }
  initializePipeline() {
    return this.configuration.hasAlpha ? W({ blending: l5(R.SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE_MINUS_SRC_ALPHA), colorWrite: _2 }) : W({ colorWrite: _2 });
  }
};
m2.shader = new t5(d, () => import("./TextureOnly.glsl-3ZOWU2IV.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextureTechniqueConfiguration.js
var r13 = class extends t6 {
  constructor() {
    super(...arguments), this.hasAlpha = false;
  }
};
e([r6()], r13.prototype, "hasAlpha", void 0);

// node_modules/@arcgis/core/views/3d/terrain/OverlayRenderer.js
var ie = class extends m {
  get _bindParameters() {
    return this._renderContext.bindParameters;
  }
  get _rctx() {
    return this.view._stage.renderView.renderingContext;
  }
  get rctx() {
    return this._rctx;
  }
  get materialRepository() {
    return this._materialRepository;
  }
  get screenToWorldRatio() {
    return this._screenToWorldRatio;
  }
  get localOriginFactory() {
    return this._localOriginFactory;
  }
  constructor(e14) {
    super(e14), this._overlays = null, this._overlayRenderTarget = null, this._hasHighlights = false, this._rendersOccluded = false, this._hasWater = false, this._handles = new t2(), this._renderers = /* @__PURE__ */ new Map(), this._sortedDrapeSourceRenderersDirty = false, this._sortedRenderers = new l2(), this._passParameters = new i4(), this._materialRepository = null, this._screenToWorldRatio = 1, this._localOriginFactory = null, this._camera = new $(), this.worldToPCSRatio = 1, this.events = new n5(), this.longitudeCyclical = null;
  }
  initialize() {
    const e14 = this.view._stage.renderView, { waterTextureRepository: r14, stippleTextureRepository: t15, markerTextureRepository: s13 } = e14;
    this._shaderTechniqueRepository = new r8({ rctx: this._rctx, viewingMode: l4.Local, stippleTextureRepository: t15, markerTextureRepository: s13, waterTextureRepository: r14 }), this._renderContext = new i9(this._rctx, new J(this._rctx, this.view.state.viewingMode), new w2(this.view, this._shaderTechniqueRepository, this._rctx, () => {
    })), this._handles.add([l3(() => r14.updating, () => this.events.emit("content-changed"), w), l3(() => this.spatialReference, (e15) => this._localOriginFactory = new f3(e15), w), a2(() => this.view.allLayerViews, "after-changes", () => this._sortedDrapeSourceRenderersDirty = true)]), this._materialRepository = new s8(e14.textureRepository, this._shaderTechniqueRepository, (e15) => {
      (e15.renderOccluded & he) > 0 !== this._rendersOccluded && this._updateRendersOccluded(), this.events.emit("content-changed"), this.notifyChange("updating"), this.notifyChange("isEmpty");
    }, () => this.events.emit("content-changed")), this._bindParameters.slot = E4.DRAPED_MATERIAL, this._bindParameters.highlightDepthTexture = g2(this._rctx), this._camera.near = 1, this._camera.far = 1e4, this._camera.relativeElevation = null, this._bindParameters.camera = this._camera, this._bindParameters.transparencyPassType = o4.NONE, this._bindParameters.newLighting.noonFactor = 0, this._bindParameters.newLighting.globalFactor = 0, this._bindParameters.newLighting.set([new i3(r(1, 1, 1))]), this._handles.add(this.view.resourceController.scheduler.registerTask(I.STAGE, this));
  }
  destroy() {
    this._handles.destroy(), this._renderers.forEach((e14) => e14.destroy()), this._renderers.clear(), this._debugTextureTechnique = f(this._debugTextureTechnique), this._passParameters.texture = t(this._passParameters.texture), this._bindParameters.highlightDepthTexture = t(this._bindParameters.highlightDepthTexture), this._shaderTechniqueRepository = l(this._shaderTechniqueRepository), this._temporaryFBO = t(this._temporaryFBO), this._quadVAO = t(this._quadVAO), this.disposeOverlays();
  }
  get updating() {
    return this._sortedDrapeSourceRenderersDirty || n3(this._renderers, (e14) => e14.updating);
  }
  get hasOverlays() {
    return null != this._overlays && null != this._overlayRenderTarget;
  }
  get gpuMemoryUsage() {
    return null != this._overlayRenderTarget ? this._overlayRenderTarget.gpuMemoryUsage : 0;
  }
  createGeometryDrapeSourceRenderer(e14) {
    return this.createDrapeSourceRenderer(e14, _4);
  }
  createDrapeSourceRenderer(e14, r14, t15) {
    const s13 = this._renderers.get(e14);
    null != s13 && s13.destroy();
    const i12 = new r14({ ...t15, rendererContext: this, drapeSource: e14 });
    return this._renderers.set(e14, i12), this._sortedDrapeSourceRenderersDirty = true, "fullOpacity" in e14 && this._handles.add(l3(() => e14.fullOpacity, () => this.events.emit("content-changed")), e14), i12;
  }
  removeDrapeSourceRenderer(e14) {
    if (null == e14)
      return;
    const r14 = this._renderers.get(e14);
    null != r14 && (this._sortedDrapeSourceRenderersDirty = true, this._renderers.delete(e14), this._handles.remove(e14), r14.destroy());
  }
  collectUnusedRenderTargetMemory() {
    let e14 = false;
    const r14 = e2();
    if (null != this._overlayRenderTarget)
      for (const t15 of this._overlayRenderTarget.renderTargets) {
        const s13 = this.overlays[O2.INNER].validTargets[t15.type];
        e14 = this._overlayRenderTarget.validateUsageForTarget(s13, t15, r14) || e14;
      }
    return e14;
  }
  get overlays() {
    return this._overlays ?? [];
  }
  ensureDrapeTargets(e14) {
    null != this._overlays && this._overlays.forEach((r14) => r14.hasTargetWithoutRasterImage = n2(e14, (e15) => e15.drapeTargetType === t8.WithoutRasterImage));
  }
  ensureDrapeSources(e14) {
    null != this._overlays && this._overlays.forEach((r14) => {
      r14.hasDrapedFeatureSource = n2(e14, (e15) => e15.drapeSourceType === e11.Features), r14.hasDrapedRasterSource = n2(e14, (e15) => e15.drapeSourceType === e11.RasterImage);
    });
  }
  ensureOverlays(e14, r14) {
    null == this._overlays && (this._overlayRenderTarget = new a6(this._rctx), this._overlays = [new g(O2.INNER, this._overlayRenderTarget), new g(O2.OUTER, this._overlayRenderTarget)]), this.ensureDrapeTargets(e14), this.ensureDrapeSources(r14);
  }
  disposeOverlays() {
    this._overlays = null, this._overlayRenderTarget = t(this._overlayRenderTarget), this.events.emit("textures-disposed");
  }
  get running() {
    return this.updating;
  }
  runTask(e14) {
    this._processDrapeSources(e14, () => true);
  }
  _processDrapeSources(e14, r14) {
    let t15 = false;
    for (const [s13, i12] of this._renderers) {
      if (e14.done)
        break;
      (s13.destroyed || r14(s13)) && (i12.commitChanges() && (t15 = true, e14.madeProgress()));
    }
    this._sortedDrapeSourceRenderersDirty && (this._sortedDrapeSourceRenderersDirty = false, t15 = true, this._updateSortedDrapeSourceRenderers()), t15 && (null != this._overlays && 0 === this._renderers.size && this.disposeOverlays(), this.notifyChange("updating"), this.notifyChange("isEmpty"), this.events.emit("content-changed"), this._updateHasHighlights(), this._updateRendersOccluded(), this._updateHasWater());
  }
  processSyncDrapeSources() {
    this._processDrapeSources(C, (e14) => e14.updatePolicy === C2.SYNC);
  }
  get isEmpty() {
    return !t7.OVERLAY_DRAW_DEBUG_TEXTURE && !n3(this._renderers, (e14) => !e14.isEmpty);
  }
  get hasHighlights() {
    return this._hasHighlights;
  }
  get hasWater() {
    return this._hasWater;
  }
  get rendersOccluded() {
    return this._rendersOccluded;
  }
  updateAnimation(e14) {
    let r14 = false;
    return this._renderers.forEach((t15) => r14 = t15.updateAnimation(e14) || r14), r14;
  }
  updateDrapeSourceOrder() {
    this._sortedDrapeSourceRenderersDirty = true;
  }
  drawTarget(e14, r14, t15) {
    const s13 = e14.canvasGeometries;
    if (0 === s13.numViews)
      return false;
    const { alignPixelEnabled: i12, contentPixelRatio: o11 } = t15;
    this._screenToWorldRatio = o11 * e14.mapUnitsPerPixel / h4;
    const a8 = r14.output;
    if (this.isEmpty || a8 === h3.Highlight && !this.hasHighlights || a8 === h3.Normal && !this.hasWater || !e14.hasSomeSizedView())
      return false;
    const n14 = r14.fbo;
    if (!n14.isValid())
      return false;
    const h6 = 2 * e14.resolution, d4 = e14.resolution;
    n14.resize(h6, d4);
    const l8 = this._rctx;
    if (this._camera.pixelRatio = e14.pixelRatio * o11, this._renderContext.output = a8, this._bindParameters.alignPixelEnabled = i12, this._bindParameters.screenToWorldRatio = this._screenToWorldRatio, this._bindParameters.screenToPCSRatio = this._screenToWorldRatio * this.worldToPCSRatio, this._bindParameters.slot = a8 === h3.Normal ? E4.DRAPED_WATER : E4.DRAPED_MATERIAL, e14.applyViewport(this._rctx), n14.bind(l8), e14.index === O2.INNER && (l8.setClearColor(0, 0, 0, 0), l8.clearSafe(_.COLOR_BUFFER_BIT)), r14.type === A2.Occluded && (this._renderContext.renderOccludedMask = he), t7.OVERLAY_DRAW_DEBUG_TEXTURE && r14.type !== A2.Occluded)
      for (let c11 = 0; c11 < s13.numViews; c11++)
        this._setViewParameters(s13.extents[c11], e14), this._drawDebugTexture(e14.resolution, ae[e14.index]);
    return this._renderers.size > 0 && this._sortedRenderers.forAll(({ drapeSource: t16, renderer: i13 }) => {
      if (r14.type === A2.ColorNoRasterImage && t16.drapeSourceType === e11.RasterImage)
        return;
      const { fullOpacity: o12 } = t16, c11 = null != o12 && o12 < 1 && a8 === h3.Color;
      c11 && (this.bindTemporaryFramebuffer(this._rctx, h6, d4), l8.clearSafe(_.COLOR_BUFFER_BIT));
      for (let r15 = 0; r15 < s13.numViews; r15++)
        this._setViewParameters(s13.extents[r15], e14), i13.render(this._renderContext);
      c11 && null != this._temporaryFBO && (n14.bind(l8), this.view._stage.renderView.compositingHelper.compositeOverlay(this._renderContext.bindParameters, this._temporaryFBO.getTexture(), o12, e14.index));
    }), l8.bindFramebuffer(null), n14.generateMipMap(), this._renderContext.resetRenderOccludedMask(), true;
  }
  bindTemporaryFramebuffer(e14, r14, t15) {
    null == this._temporaryFBO && (this._temporaryFBO = new i8(e14, false)), this._temporaryFBO.resize(r14, t15), this._temporaryFBO.bind(e14);
  }
  async reloadShaders() {
    await this._shaderTechniqueRepository.reloadAll();
  }
  notifyContentChanged() {
    this.events.emit("content-changed");
  }
  intersect(e14, r14, t15, s13) {
    var _a;
    let i12 = 0;
    for (const o11 of this._renderers.values())
      i12 = ((_a = o11.intersect) == null ? void 0 : _a.call(o11, e14, r14, t15, s13, i12)) ?? i12;
  }
  _updateSortedDrapeSourceRenderers() {
    if (this._sortedRenderers.clear(), 0 === this._renderers.size)
      return;
    const e14 = this.view.map.allLayers;
    this._renderers.forEach((r14, t15) => {
      const s13 = e14.indexOf(t15.layer), i12 = s13 >= 0, o11 = this._renderers.size * (t15.renderGroup ?? (i12 ? a5.MapLayer : a5.ViewLayer)) + (i12 ? s13 : 0);
      this._sortedRenderers.push(new oe(t15, r14, o11));
    }), this._sortedRenderers.sort((e15, r14) => e15.index - r14.index);
  }
  _setViewParameters(e14, r14) {
    const t15 = this._camera;
    t15.viewport = [0, 0, r14.resolution, r14.resolution], Q(t15.projectionMatrix, 0, e14[2] - e14[0], 0, e14[3] - e14[1], t15.near, t15.far), q(t15.viewMatrix, [-e14[0], -e14[1], 0]);
  }
  _updateHasWater() {
    const e14 = n3(this._renderers, (e15) => e15.hasWater);
    e14 !== this._hasWater && (this._hasWater = e14, this.events.emit("has-water", e14));
  }
  _updateHasHighlights() {
    const e14 = n3(this._renderers, (e15) => e15.hasHighlights);
    e14 !== this._hasHighlights && (this._hasHighlights = e14, this.events.emit("has-highlights", e14));
  }
  _updateRendersOccluded() {
    const e14 = n3(this._renderers, (e15) => e15.rendersOccluded);
    e14 !== this._rendersOccluded && (this._rendersOccluded = e14, this.events.emit("renders-occluded", e14));
  }
  _drawDebugTexture(e14, r14) {
    this._ensureDebugPatternResources(e14, r14);
    const t15 = this._rctx;
    t15.bindTechnique(this._debugTextureTechnique, this._passParameters, null), t15.bindVAO(this._quadVAO), t15.drawArrays(E.TRIANGLE_STRIP, 0, n7(this._quadVAO, "geometry"));
  }
  _ensureDebugPatternResources(e14, r14) {
    if (o(this._passParameters.color, r14[0], r14[1], r14[2]), this._passParameters.texture)
      return;
    const t15 = new Uint8Array(e14 * e14 * 4);
    let s13 = 0;
    for (let a8 = 0; a8 < e14; a8++)
      for (let r15 = 0; r15 < e14; r15++) {
        const i13 = Math.floor(r15 / 10), o12 = Math.floor(a8 / 10);
        i13 < 2 || o12 < 2 || 10 * i13 > e14 - 20 || 10 * o12 > e14 - 20 ? (t15[s13++] = 255, t15[s13++] = 255, t15[s13++] = 255, t15[s13++] = 255) : (t15[s13++] = 255, t15[s13++] = 255, t15[s13++] = 255, t15[s13++] = 1 & i13 && 1 & o12 ? 1 & r15 ^ 1 & a8 ? 0 : 255 : 1 & i13 ^ 1 & o12 ? 0 : 128);
      }
    const i12 = new e8(e14);
    i12.samplingMode = L.NEAREST, this._passParameters.texture = new T(this._rctx, i12, t15);
    const o11 = new r13();
    o11.hasAlpha = true, this._debugTextureTechnique = this._shaderTechniqueRepository.acquire(m2, o11), this._quadVAO = f2(this._rctx);
  }
  get test() {
    return { drapedRenderers: Array.from(this._renderers.values()), getDrapeSourceRenderer: (e14) => this._renderers.get(e14) };
  }
};
e([y()], ie.prototype, "_sortedDrapeSourceRenderersDirty", void 0), e([y({ autoDestroy: true })], ie.prototype, "_shaderTechniqueRepository", void 0), e([y({ constructOnly: true })], ie.prototype, "view", void 0), e([y()], ie.prototype, "worldToPCSRatio", void 0), e([y()], ie.prototype, "spatialReference", void 0), e([y({ type: Boolean, readOnly: true })], ie.prototype, "updating", null), e([y()], ie.prototype, "isEmpty", null), ie = e([a("esri.views.3d.terrain.OverlayRenderer")], ie);
var oe = class {
  constructor(e14, r14, t15) {
    this.drapeSource = e14, this.renderer = r14, this.index = t15;
  }
};
var ae = [[1, 0.5, 0.5], [0.5, 0.5, 1]];
var ne = -2;
var he = o3.OccludeAndTransparent;

export {
  r8 as r,
  s8 as s,
  e13 as e,
  f3 as f,
  o8 as o,
  n10 as n,
  s9 as s2,
  r10 as r2,
  r11 as r3,
  i10 as i,
  d3 as d,
  A3 as A,
  E6 as E,
  _4 as _,
  m2 as m,
  r13 as r4,
  ie,
  ne,
  he
};
//# sourceMappingURL=chunk-XXN3TEOU.js.map
