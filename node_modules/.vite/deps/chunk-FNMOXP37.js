import {
  s as s2
} from "./chunk-7BSXIYP2.js";
import {
  e as e5
} from "./chunk-ACTOBSLJ.js";
import {
  a,
  c as c2,
  t
} from "./chunk-XUU35WPC.js";
import {
  o as o3,
  r
} from "./chunk-Z2RTGLQI.js";
import {
  l
} from "./chunk-D7YAG5U3.js";
import {
  o as o8
} from "./chunk-LGDKASPG.js";
import {
  r as r2,
  t as t2
} from "./chunk-KFDARCTS.js";
import {
  P
} from "./chunk-SMDDCTGQ.js";
import {
  o as o5
} from "./chunk-VC3BY3DV.js";
import {
  e as e6
} from "./chunk-B4ONZAW2.js";
import {
  g as g2
} from "./chunk-JHDKOKT6.js";
import {
  o as o7
} from "./chunk-CG3URTR2.js";
import {
  d
} from "./chunk-RDWKBYTH.js";
import {
  i as i2
} from "./chunk-LIO6VZRI.js";
import {
  c
} from "./chunk-7DFZCT3D.js";
import {
  e as e3
} from "./chunk-FY4ZONHH.js";
import {
  h
} from "./chunk-73PNWDTS.js";
import {
  P as P2
} from "./chunk-N3RXOITN.js";
import {
  p,
  u
} from "./chunk-DOR4M5EA.js";
import {
  o as o6
} from "./chunk-Z6IKMUOC.js";
import {
  e as e4
} from "./chunk-PV5KBAYL.js";
import {
  s
} from "./chunk-Z3NHJA5D.js";
import {
  o as o4
} from "./chunk-V66LHQVK.js";
import {
  i
} from "./chunk-JP7O2ZWE.js";
import {
  o as o2
} from "./chunk-CW7LIPBH.js";
import {
  e as e2
} from "./chunk-VN2IXVGV.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  g
} from "./chunk-JB7FDW5N.js";
import {
  o
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js
function e7(e8) {
  e8.vertex.code.add(o4`vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {
vec3 camToVert = posWorld - camPosWorld;
bool isBackface = dot(camToVert, normalWorld) > 0.0;
if (isBackface) {
posClip.z += 0.0000003 * posClip.w;
}
return posClip;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js
var v = class extends t2 {
  constructor() {
    super(...arguments), this.instancedDoublePrecision = false;
  }
};
function p2(e8, i4) {
  i4.instanced && i4.instancedDoublePrecision && (e8.attributes.add(O.MODELORIGINHI, "vec3"), e8.attributes.add(O.MODELORIGINLO, "vec3"), e8.attributes.add(O.MODEL, "mat3"), e8.attributes.add(O.MODELNORMAL, "mat3"));
  const c3 = e8.vertex;
  i4.instancedDoublePrecision && (c3.include(c, i4), c3.uniforms.add(new o6("viewOriginHi", (e9, i5) => o3(o(b, i5.camera.viewInverseTransposeMatrix[3], i5.camera.viewInverseTransposeMatrix[7], i5.camera.viewInverseTransposeMatrix[11]), b)), new o6("viewOriginLo", (e9, i5) => r(o(b, i5.camera.viewInverseTransposeMatrix[3], i5.camera.viewInverseTransposeMatrix[7], i5.camera.viewInverseTransposeMatrix[11]), b)))), c3.code.add(o4`
    vec3 calculateVPos() {
      ${i4.instancedDoublePrecision ? "return model * localPosition().xyz;" : "return localPosition().xyz;"}
    }
    `), c3.code.add(o4`
    vec3 subtractOrigin(vec3 _pos) {
      ${i4.instancedDoublePrecision ? o4`
          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);
          return _pos - originDelta;` : "return vpos;"}
    }
    `), c3.code.add(o4`
    vec3 dpNormal(vec4 _normal) {
      ${i4.instancedDoublePrecision ? "return normalize(modelNormal * _normal.xyz);" : "return normalize(_normal.xyz);"}
    }
    `), i4.output === h.Normal && (u(c3), c3.code.add(o4`
    vec3 dpNormalView(vec4 _normal) {
      ${i4.instancedDoublePrecision ? "return normalize((viewNormal * vec4(modelNormal * _normal.xyz, 1.0)).xyz);" : "return normalize((viewNormal * _normal).xyz);"}
    }
    `)), i4.hasVertexTangents && c3.code.add(o4`
    vec4 dpTransformVertexTangent(vec4 _tangent) {
      ${i4.instancedDoublePrecision ? "return vec4(modelNormal * _tangent.xyz, _tangent.w);" : "return _tangent;"}

    }
    `);
}
e([r2()], v.prototype, "instancedDoublePrecision", void 0);
var b = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js
function i3(i4, t3) {
  t3.hasSymbolColors ? (i4.include(e5), i4.attributes.add(O.SYMBOLCOLOR, "vec4"), i4.varyings.add("colorMixMode", "mediump float"), i4.vertex.code.add(o4`int symbolColorMixMode;
vec4 getSymbolColor() {
return decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;
}
void forwardColorMixMode() {
colorMixMode = float(symbolColorMixMode) + 0.5;
}`)) : (i4.fragment.uniforms.add(new e6("colorMixMode", (o9) => P[o9.colorMixMode])), i4.vertex.code.add(o4`vec4 getSymbolColor() { return vec4(1.0); }
void forwardColorMixMode() {}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js
function b2(b3, C) {
  const { vertex: O2, fragment: y } = b3, V = C.hasModelTransformation;
  if (V) {
    const t3 = e2();
    O2.uniforms.add(new e4("model", (o9) => o9.modelTransformation ?? o2)), O2.uniforms.add(new e3("normalTransform", (r3) => (g(t3, r3.modelTransformation ?? o2), t3)));
  }
  const A = C.hasColorTexture && C.alphaDiscardMode !== i.Opaque;
  switch (C.output) {
    case h.Depth:
    case h.Shadow:
    case h.ShadowHighlight:
    case h.ShadowExcludeHighlight:
    case h.ObjectAndLayerIdColor:
      p(O2, C), b3.include(o7, C), b3.include(o5, C), b3.include(l, C), b3.include(o8, C), b3.include(P2, C), b3.include(d, C), i2(b3), b3.varyings.add("depth", "float"), A && y.uniforms.add(new s("tex", (o9) => o9.texture)), O2.code.add(o4`
          void main(void) {
            vpos = calculateVPos();
            ${V ? "vpos = (model * vec4(vpos, 1.0)).xyz;" : ""}
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
            forwardTextureCoordinates();
            forwardObjectAndLayerIdColor();
          }
        `), b3.include(s2, C), y.code.add(o4`
          void main(void) {
            discardBySlice(vpos);
            ${A ? o4`
                    vec4 texColor = texture(tex, ${C.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            ${C.output === h.ObjectAndLayerIdColor ? o4`outputObjectAndLayerIdColor();` : o4`outputDepth(depth);`}
          }
        `);
      break;
    case h.Normal: {
      p(O2, C), b3.include(o7, C), b3.include(t, C), b3.include(c2, C), b3.include(o5, C), b3.include(l, C), A && y.uniforms.add(new s("tex", (o10) => o10.texture)), C.normalType === a.ScreenDerivative && b3.varyings.add("vPositionView", "vec3");
      const o9 = C.normalType === a.Attribute || C.normalType === a.Compressed;
      O2.code.add(o4`
          void main(void) {
            vpos = calculateVPos();
            ${V ? "vpos = (model * vec4(vpos, 1.0)).xyz;" : ""}

            ${o9 ? o4`vNormalWorld = ${V ? "normalize(normalTransform * dpNormal(vvLocalNormal(normalModel())))" : "dpNormalView(vvLocalNormal(normalModel()))"};` : o4`
                  // Get vertex position in camera space for screen-space derivative normals
                  vPositionView = (view * vec4(vpos, 1.0)).xyz;
                `}
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, vpos);
            forwardTextureCoordinates();
          }
        `), b3.include(P2, C), b3.include(s2, C), y.code.add(o4`
          void main() {
            discardBySlice(vpos);
            ${A ? o4`
                    vec4 texColor = texture(tex, ${C.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}

            ${C.normalType === a.ScreenDerivative ? o4`vec3 normal = screenDerivativeNormal(vPositionView);` : o4`
                  vec3 normal = normalize(vNormalWorld);
                  if (gl_FrontFacing == false){
                    normal = -normal;
                  }`}
            fragColor = vec4(0.5 + 0.5 * normal, 1.0);
          }
        `);
      break;
    }
    case h.Highlight:
      p(O2, C), b3.include(o7, C), b3.include(o5, C), b3.include(l, C), A && y.uniforms.add(new s("tex", (o9) => o9.texture)), O2.code.add(o4`
          void main(void) {
            vpos = calculateVPos();
            ${V ? "vpos = (model * vec4(vpos, 1.0)).xyz;" : ""}
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, vpos);
            forwardTextureCoordinates();
          }
        `), b3.include(P2, C), b3.include(s2, C), b3.include(g2, C), y.code.add(o4`
          void main() {
            discardBySlice(vpos);
            ${A ? o4`
                    vec4 texColor = texture(tex, ${C.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            outputHighlight();
          }
        `);
  }
}

export {
  e7 as e,
  p2 as p,
  i3 as i,
  b2 as b
};
//# sourceMappingURL=chunk-FNMOXP37.js.map
