import {
  E
} from "./chunk-NU4UASX6.js";
import {
  n as n3
} from "./chunk-V66LHQVK.js";
import {
  s as s2
} from "./chunk-SGBMUZSF.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  l
} from "./chunk-RVS5HU2K.js";
import {
  A,
  G,
  i as i2
} from "./chunk-AQ7R6V4L.js";
import {
  M,
  i,
  s
} from "./chunk-TEHNQYQD.js";
import {
  _,
  o,
  z
} from "./chunk-TPJLFGOT.js";
import {
  n as n2,
  r
} from "./chunk-CQX57DED.js";
import {
  e2,
  m,
  n3 as n,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  h
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/support/debugFlags.js
var T = class extends m {
  constructor() {
    super(...arguments), this.SCENEVIEW_HITTEST_RETURN_INTERSECTOR = false, this.DECONFLICTOR_SHOW_VISIBLE = false, this.DECONFLICTOR_SHOW_INVISIBLE = false, this.DECONFLICTOR_SHOW_GRID = false, this.LABELS_SHOW_BORDER = false, this.TEXT_SHOW_BASELINE = false, this.TEXT_SHOW_BORDER = false, this.OVERLAY_DRAW_DEBUG_TEXTURE = false, this.OVERLAY_SHOW_CENTER = false, this.SHOW_POI = false, this.TESTS_DISABLE_OPTIMIZATIONS = false, this.TESTS_DISABLE_FAST_UPDATES = false, this.DRAW_MESH_GEOMETRY_NORMALS = false, this.FEATURE_TILE_FETCH_SHOW_TILES = false, this.FEATURE_TILE_TREE_SHOW_TILES = false, this.TERRAIN_TILE_TREE_SHOW_TILES = false, this.I3S_TREE_SHOW_TILES = false, this.I3S_SHOW_MODIFICATIONS = false, this.LOD_INSTANCE_RENDERER_DISABLE_UPDATES = false, this.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL = false, this.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES = false, this.LINE_WIREFRAMES = false;
  }
};
e([y()], T.prototype, "SCENEVIEW_HITTEST_RETURN_INTERSECTOR", void 0), e([y()], T.prototype, "DECONFLICTOR_SHOW_VISIBLE", void 0), e([y()], T.prototype, "DECONFLICTOR_SHOW_INVISIBLE", void 0), e([y()], T.prototype, "DECONFLICTOR_SHOW_GRID", void 0), e([y()], T.prototype, "LABELS_SHOW_BORDER", void 0), e([y()], T.prototype, "TEXT_SHOW_BASELINE", void 0), e([y()], T.prototype, "TEXT_SHOW_BORDER", void 0), e([y()], T.prototype, "OVERLAY_DRAW_DEBUG_TEXTURE", void 0), e([y()], T.prototype, "OVERLAY_SHOW_CENTER", void 0), e([y()], T.prototype, "SHOW_POI", void 0), e([y()], T.prototype, "TESTS_DISABLE_OPTIMIZATIONS", void 0), e([y()], T.prototype, "TESTS_DISABLE_FAST_UPDATES", void 0), e([y()], T.prototype, "DRAW_MESH_GEOMETRY_NORMALS", void 0), e([y()], T.prototype, "FEATURE_TILE_FETCH_SHOW_TILES", void 0), e([y()], T.prototype, "FEATURE_TILE_TREE_SHOW_TILES", void 0), e([y()], T.prototype, "TERRAIN_TILE_TREE_SHOW_TILES", void 0), e([y()], T.prototype, "I3S_TREE_SHOW_TILES", void 0), e([y()], T.prototype, "I3S_SHOW_MODIFICATIONS", void 0), e([y()], T.prototype, "LOD_INSTANCE_RENDERER_DISABLE_UPDATES", void 0), e([y()], T.prototype, "LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL", void 0), e([y()], T.prototype, "EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES", void 0), e([y()], T.prototype, "LINE_WIREFRAMES", void 0), T = e([a("esri.views.3d.support.DebugFlags")], T);
var t = new T();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/ContentObject.js
var r2 = class {
  constructor() {
    this.id = e2();
  }
  unload() {
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/ContentObjectType.js
var e3;
!function(e5) {
  e5[e5.Layer = 0] = "Layer", e5[e5.Object = 1] = "Object", e5[e5.Mesh = 2] = "Mesh", e5[e5.Line = 3] = "Line", e5[e5.Point = 4] = "Point", e5[e5.Material = 5] = "Material", e5[e5.Texture = 6] = "Texture", e5[e5.COUNT = 7] = "COUNT";
}(e3 || (e3 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/screenSizePerspectiveUtils.js
function r3(e5, t2) {
  return new p(e5, h2, t2);
}
function n4(e5, t2) {
  const { curvatureDependent: a2, scaleStart: i4, scaleFallOffRange: r4 } = h2;
  return new p(e5, { curvatureDependent: { min: { curvature: a2.min.curvature, tiltAngle: a2.min.tiltAngle, scaleFallOffFactor: v.curvatureDependent.min.scaleFallOffFactor }, max: { curvature: a2.max.curvature, tiltAngle: a2.max.tiltAngle, scaleFallOffFactor: v.curvatureDependent.max.scaleFallOffFactor } }, scaleStart: i4, scaleFallOffRange: r4, minPixelSize: v.minPixelSize }, t2);
}
function l2(e5) {
  return Math.abs(e5 * e5 * e5);
}
function s3(e5, t2, a2) {
  const i4 = a2.parameters, r4 = a2.paddingPixelsOverride;
  return x.scale = Math.min(i4.divisor / (t2 - i4.offset), 1), x.factor = l2(e5), x.minPixelSize = i4.minPixelSize, x.paddingPixels = r4, x;
}
function c(e5, t2) {
  return 0 === e5 ? t2.minPixelSize : t2.minPixelSize * (1 + 2 * t2.paddingPixels / e5);
}
function o2(t2, a2) {
  return Math.max(s(t2 * a2.scale, t2, a2.factor), c(t2, a2));
}
function u(e5, t2, a2) {
  const i4 = s3(e5, t2, a2);
  return i4.minPixelSize = 0, i4.paddingPixels = 0, o2(1, i4);
}
function d(e5, t2, a2, i4) {
  i4.scale = u(e5, t2, a2), i4.factor = 0, i4.minPixelSize = a2.parameters.minPixelSize, i4.paddingPixels = a2.paddingPixelsOverride;
}
function f(e5, t2, a2 = [0, 0]) {
  const i4 = Math.min(Math.max(t2.scale, c(e5[1], t2) / Math.max(1e-5, e5[1])), 1);
  return a2[0] = e5[0] * i4, a2[1] = e5[1] * i4, a2;
}
function m2(e5, t2, a2, i4) {
  return o2(e5, s3(t2, a2, i4));
}
var p = class _p {
  get paddingPixelsOverride() {
    return this._paddingPixelsOverride || this.parameters.paddingPixels;
  }
  constructor(e5, t2, a2, r4 = g(), n5) {
    this._viewingMode = e5, this._description = t2, this._ellipsoidRadius = a2, this.parameters = r4, this._paddingPixelsOverride = n5, this._viewingMode === l.Local ? (this._coverageCompensation = this._surfaceCoverageCompensationLocal, this._calculateCurvatureDependentParameters = this._calculateCurvatureDependentParametersLocal) : (this._coverageCompensation = this._surfaceCoverageCompensationGlobal, this._calculateCurvatureDependentParameters = this._calculateCurvatureDependentParametersGlobal);
  }
  update(e5) {
    return (!this.parameters || this.parameters.camera.fovY !== e5.fovY || this.parameters.camera.distance !== e5.distance) && (this._calculateParameters(e5, this._ellipsoidRadius, this.parameters), true);
  }
  overridePadding(e5) {
    return e5 !== this.paddingPixelsOverride ? new _p(this._viewingMode, this._description, this._ellipsoidRadius, this.parameters, e5) : this;
  }
  _calculateParameters(e5, t2, a2) {
    const { scaleStart: i4, scaleFallOffRange: r4, minPixelSize: n5 } = this._description, { fovY: l3, distance: s4 } = e5, c3 = this._calculateCurvatureDependentParameters(e5, t2), o4 = this._coverageCompensation(e5, t2, c3), { tiltAngle: u2, scaleFallOffFactor: d4 } = c3, f2 = Math.sin(u2) * s4, m3 = 0.5 * Math.PI - u2 - l3 * (0.5 - i4 * o4), p3 = f2 / Math.cos(m3), h5 = m3 + l3 * r4 * o4, v3 = (p3 - d4 * (f2 / Math.cos(h5))) / (1 - d4);
    return a2.camera.fovY = e5.fovY, a2.camera.distance = e5.distance, a2.offset = v3, a2.divisor = p3 - v3, a2.minPixelSize = n5, a2;
  }
  _calculateCurvatureDependentParametersLocal(e5, t2, a2 = P) {
    return a2.tiltAngle = this._description.curvatureDependent.min.tiltAngle, a2.scaleFallOffFactor = this._description.curvatureDependent.min.scaleFallOffFactor, a2;
  }
  _calculateCurvatureDependentParametersGlobal(t2, i4, r4 = P) {
    const n5 = this._description.curvatureDependent, l3 = 1 + t2.distance / i4, s4 = Math.sqrt(l3 * l3 - 1), [c3, o4] = [n5.min.curvature, n5.max.curvature], u2 = i((s4 - c3) / (o4 - c3), 0, 1), [d4, f2] = [n5.min, n5.max];
    return r4.tiltAngle = s(d4.tiltAngle, f2.tiltAngle, u2), r4.scaleFallOffFactor = s(d4.scaleFallOffFactor, f2.scaleFallOffFactor, u2), r4;
  }
  _surfaceCoverageCompensationLocal(e5, t2, a2) {
    return (e5.fovY - a2.tiltAngle) / e5.fovY;
  }
  _surfaceCoverageCompensationGlobal(e5, t2, a2) {
    const i4 = t2 * t2, r4 = a2.tiltAngle + 0.5 * Math.PI, { fovY: n5, distance: l3 } = e5, s4 = l3 * l3 + i4 - 2 * Math.cos(r4) * l3 * t2, c3 = Math.sqrt(s4), o4 = Math.sqrt(s4 - i4);
    return (Math.acos(o4 / c3) - Math.asin(t2 / (c3 / Math.sin(r4))) + 0.5 * n5) / n5;
  }
};
var h2 = { curvatureDependent: { min: { curvature: M(10), tiltAngle: M(12), scaleFallOffFactor: 0.5 }, max: { curvature: M(70), tiltAngle: M(40), scaleFallOffFactor: 0.8 } }, scaleStart: 0.3, scaleFallOffRange: 0.65, minPixelSize: 0 };
var v = { curvatureDependent: { min: { scaleFallOffFactor: 0.7 }, max: { scaleFallOffFactor: 0.95 } }, minPixelSize: 14 };
function g() {
  return { camera: { distance: 0, fovY: 0 }, divisor: 0, offset: 0, minPixelSize: 0, paddingPixels: 0 };
}
var x = { scale: 0, factor: 0, minPixelSize: 0, paddingPixels: 0 };
var P = { tiltAngle: 0, scaleFallOffFactor: 0 };

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/MaterialUtil.js
var p2 = i2();
function h3(t2, n5, e5, o4, i4, r4) {
  if (t2.visible)
    if (t2.boundingInfo) {
      s2(t2.type === e3.Mesh);
      const s4 = n5.tolerance;
      x2(t2.boundingInfo, e5, o4, s4, i4, r4);
    } else {
      const n6 = t2.indices.get(O.POSITION), s4 = t2.vertexAttributes.get(O.POSITION);
      g2(e5, o4, 0, n6.length / 3, n6, s4, void 0, i4, r4);
    }
}
var b = n2();
function x2(t2, n5, e5, o4, i4, r4) {
  if (null == t2)
    return;
  const s4 = T2(n5, e5, b);
  if (A(p2, t2.bbMin), G(p2, t2.bbMax), null != i4 && i4.applyToAabb(p2), I(p2, n5, s4, o4)) {
    const { primitiveIndices: s5, indices: c3, position: l3 } = t2, f2 = s5 ? s5.length : c3.length / 3;
    if (f2 > S) {
      const s6 = t2.getChildren();
      if (void 0 !== s6) {
        for (const t3 of s6)
          x2(t3, n5, e5, o4, i4, r4);
        return;
      }
    }
    g2(n5, e5, 0, f2, c3, l3, s5, i4, r4);
  }
}
var d2 = n2();
function g2(t2, n5, e5, o4, i4, r4, s4, c3, l3) {
  if (s4)
    return M2(t2, n5, e5, o4, i4, r4, s4, c3, l3);
  const { data: f2, stride: u2 } = r4, a2 = t2[0], m3 = t2[1], p3 = t2[2], h5 = n5[0] - a2, b2 = n5[1] - m3, x3 = n5[2] - p3;
  for (let g3 = e5, M3 = 3 * e5; g3 < o4; ++g3) {
    let t3 = u2 * i4[M3++], n6 = f2[t3++], e6 = f2[t3++], o5 = f2[t3];
    t3 = u2 * i4[M3++];
    let r5 = f2[t3++], s5 = f2[t3++], y3 = f2[t3];
    t3 = u2 * i4[M3++];
    let j2 = f2[t3++], T3 = f2[t3++], I2 = f2[t3];
    null != c3 && ([n6, e6, o5] = c3.applyToVertex(n6, e6, o5, g3), [r5, s5, y3] = c3.applyToVertex(r5, s5, y3, g3), [j2, T3, I2] = c3.applyToVertex(j2, T3, I2, g3));
    const O3 = r5 - n6, V2 = s5 - e6, L2 = y3 - o5, N2 = j2 - n6, A3 = T3 - e6, P3 = I2 - o5, S2 = b2 * P3 - A3 * x3, E2 = x3 * N2 - P3 * h5, U = h5 * A3 - N2 * b2, W = O3 * S2 + V2 * E2 + L2 * U;
    if (Math.abs(W) <= Number.EPSILON)
      continue;
    const k = a2 - n6, B = m3 - e6, C = p3 - o5, z2 = k * S2 + B * E2 + C * U;
    if (W > 0) {
      if (z2 < 0 || z2 > W)
        continue;
    } else if (z2 > 0 || z2 < W)
      continue;
    const H = B * L2 - V2 * C, R = C * O3 - L2 * k, Y = k * V2 - O3 * B, q = h5 * H + b2 * R + x3 * Y;
    if (W > 0) {
      if (q < 0 || z2 + q > W)
        continue;
    } else if (q > 0 || z2 + q < W)
      continue;
    const w = (N2 * H + A3 * R + P3 * Y) / W;
    if (w >= 0) {
      l3(w, v2(O3, V2, L2, N2, A3, P3, d2), g3, false);
    }
  }
}
function M2(t2, n5, e5, o4, i4, r4, s4, c3, l3) {
  const { data: f2, stride: u2 } = r4, a2 = t2[0], m3 = t2[1], p3 = t2[2], h5 = n5[0] - a2, b2 = n5[1] - m3, x3 = n5[2] - p3;
  for (let g3 = e5; g3 < o4; ++g3) {
    const t3 = s4[g3];
    let n6 = 3 * t3, e6 = u2 * i4[n6++], o5 = f2[e6++], r5 = f2[e6++], M3 = f2[e6];
    e6 = u2 * i4[n6++];
    let y3 = f2[e6++], j2 = f2[e6++], T3 = f2[e6];
    e6 = u2 * i4[n6];
    let I2 = f2[e6++], O3 = f2[e6++], V2 = f2[e6];
    null != c3 && ([o5, r5, M3] = c3.applyToVertex(o5, r5, M3, g3), [y3, j2, T3] = c3.applyToVertex(y3, j2, T3, g3), [I2, O3, V2] = c3.applyToVertex(I2, O3, V2, g3));
    const L2 = y3 - o5, N2 = j2 - r5, A3 = T3 - M3, P3 = I2 - o5, S2 = O3 - r5, E2 = V2 - M3, U = b2 * E2 - S2 * x3, W = x3 * P3 - E2 * h5, k = h5 * S2 - P3 * b2, B = L2 * U + N2 * W + A3 * k;
    if (Math.abs(B) <= Number.EPSILON)
      continue;
    const C = a2 - o5, z2 = m3 - r5, H = p3 - M3, R = C * U + z2 * W + H * k;
    if (B > 0) {
      if (R < 0 || R > B)
        continue;
    } else if (R > 0 || R < B)
      continue;
    const Y = z2 * A3 - N2 * H, q = H * L2 - A3 * C, w = C * N2 - L2 * z2, D = h5 * Y + b2 * q + x3 * w;
    if (B > 0) {
      if (D < 0 || R + D > B)
        continue;
    } else if (D > 0 || R + D < B)
      continue;
    const F = (P3 * Y + S2 * q + E2 * w) / B;
    if (F >= 0) {
      l3(F, v2(L2, N2, A3, P3, S2, E2, d2), t3, false);
    }
  }
}
var y2 = n2();
var j = n2();
function v2(t2, n5, r4, s4, c3, l3, f2) {
  return o(y2, t2, n5, r4), o(j, s4, c3, l3), _(f2, y2, j), z(f2, f2), f2;
}
function T2(t2, n5, o4) {
  return o(o4, 1 / (n5[0] - t2[0]), 1 / (n5[1] - t2[1]), 1 / (n5[2] - t2[2]));
}
function I(t2, n5, e5, o4) {
  return O2(t2, n5, e5, o4, 1 / 0);
}
function O2(t2, n5, e5, o4, i4) {
  const r4 = (t2[0] - o4 - n5[0]) * e5[0], s4 = (t2[3] + o4 - n5[0]) * e5[0];
  let c3 = Math.min(r4, s4), l3 = Math.max(r4, s4);
  const f2 = (t2[1] - o4 - n5[1]) * e5[1], u2 = (t2[4] + o4 - n5[1]) * e5[1];
  if (l3 = Math.min(l3, Math.max(f2, u2)), l3 < 0)
    return false;
  if (c3 = Math.max(c3, Math.min(f2, u2)), c3 > l3)
    return false;
  const a2 = (t2[2] - o4 - n5[2]) * e5[2], m3 = (t2[5] + o4 - n5[2]) * e5[2];
  return l3 = Math.min(l3, Math.max(a2, m3)), !(l3 < 0) && (c3 = Math.max(c3, Math.min(a2, m3)), !(c3 > l3) && c3 < i4);
}
function V(t2, e5, o4, i4, r4) {
  let s4 = (o4.screenLength || 0) * t2.pixelRatio;
  null != r4 && (s4 = m2(s4, i4, e5, r4));
  const c3 = s4 * Math.tan(0.5 * t2.fovY) / (0.5 * t2.fullHeight);
  return i(c3 * e5, o4.minWorldLength || 0, null != o4.maxWorldLength ? o4.maxWorldLength : 1 / 0);
}
function L(t2, n5) {
  const e5 = n5 ? L(n5) : {};
  for (const o4 in t2) {
    let n6 = t2[o4];
    n6 && n6.forEach && (n6 = A2(n6)), null == n6 && o4 in e5 || (e5[o4] = n6);
  }
  return e5;
}
function N(n5, e5) {
  let o4 = false;
  for (const i4 in e5) {
    const r4 = e5[i4];
    void 0 !== r4 && (Array.isArray(r4) ? null === n5[i4] ? (n5[i4] = r4.slice(), o4 = true) : h(n5[i4], r4) && (o4 = true) : n5[i4] !== r4 && (o4 = true, n5[i4] = r4));
  }
  return o4;
}
function A2(t2) {
  const n5 = [];
  return t2.forEach((t3) => n5.push(t3)), n5;
}
var P2 = { multiply: 1, ignore: 2, replace: 3, tint: 4 };
var S = 1e3;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/AnimationTimer.js
var e4 = class {
  constructor() {
    this.enabled = true, this._time = n(0);
  }
  get time() {
    return this._time;
  }
  advance({ deltaTime: e5, fixedTime: i4 }) {
    return null != i4 ? this._time !== i4 && (this._time = i4, true) : (this._time = n(this._time + e5), 0 !== e5);
  }
};
var i3 = class {
  constructor(t2, e5) {
    this.deltaTime = t2, this.fixedTime = e5;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Material.js
var d3 = class extends r2 {
  constructor(t2, r4) {
    super(), this.type = e3.Material, this.supportsEdges = false, this._visible = true, this._renderPriority = 0, this._insertOrder = 0, this._vertexAttributeLocations = E, this._pp0 = r(0, 0, 1), this._pp1 = r(0, 0, 0), this._parameters = L(t2, r4), this.validateParameters(this._parameters);
  }
  dispose() {
  }
  get parameters() {
    return this._parameters;
  }
  update(e5) {
    return false;
  }
  setParameters(e5, t2 = true) {
    N(this._parameters, e5) && (this.validateParameters(this._parameters), t2 && this.parametersChanged());
  }
  validateParameters(e5) {
  }
  get visible() {
    return this._visible;
  }
  set visible(e5) {
    e5 !== this._visible && (this._visible = e5, this.parametersChanged());
  }
  shouldRender(e5) {
    return this.isVisible() && this.isVisibleForOutput(e5.output) && 0 != (this.renderOccluded & e5.renderOccludedMask);
  }
  isVisibleForOutput(e5) {
    return true;
  }
  get renderOccluded() {
    return this.parameters.renderOccluded;
  }
  get renderPriority() {
    return this._renderPriority;
  }
  set renderPriority(e5) {
    e5 !== this._renderPriority && (this._renderPriority = e5, this.parametersChanged());
  }
  get insertOrder() {
    return this._insertOrder;
  }
  set insertOrder(e5) {
    e5 !== this._insertOrder && (this._insertOrder = e5, this.parametersChanged());
  }
  get vertexAttributeLocations() {
    return this._vertexAttributeLocations;
  }
  isVisible() {
    return this._visible;
  }
  parametersChanged() {
    null != this.repository && this.repository.materialChanged(this);
  }
  intersectDraped(e5, t2, r4, s4, i4, a2) {
    return this._pp0[0] = this._pp1[0] = s4[0], this._pp0[1] = this._pp1[1] = s4[1], this.intersect(e5, t2, r4, this._pp0, this._pp1, i4);
  }
};
var h4 = class extends i3 {
  constructor(e5, t2, r4) {
    super(t2, r4), this.camera = e5;
  }
};
var o3;
!function(e5) {
  e5[e5.None = 0] = "None", e5[e5.Occlude = 1] = "Occlude", e5[e5.Transparent = 2] = "Transparent", e5[e5.OccludeAndTransparent = 4] = "OccludeAndTransparent", e5[e5.OccludeAndTransparentStencil = 8] = "OccludeAndTransparentStencil", e5[e5.Opaque = 16] = "Opaque";
}(o3 || (o3 = {}));
var c2 = class extends n3 {
  constructor() {
    super(...arguments), this.renderOccluded = o3.Occlude;
  }
};

export {
  r2 as r,
  e3 as e,
  e4 as e2,
  r3 as r2,
  n4 as n,
  o2 as o,
  d,
  f,
  h3 as h,
  g2 as g,
  v2 as v,
  T2 as T,
  I,
  O2 as O,
  V,
  L,
  N,
  P2 as P,
  d3 as d2,
  h4 as h2,
  o3 as o2,
  c2 as c,
  t
};
//# sourceMappingURL=chunk-SMDDCTGQ.js.map
