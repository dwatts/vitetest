import {
  e as e5
} from "./chunk-FKUVQAN6.js";
import {
  t
} from "./chunk-XYJMHUDA.js";
import {
  n
} from "./chunk-BPITJIFG.js";
import {
  o,
  s2 as s
} from "./chunk-3VN6RF6P.js";
import {
  T,
  e2 as e4
} from "./chunk-TRGMWULG.js";
import {
  e as e3,
  t as t2
} from "./chunk-AER5JAFS.js";
import {
  l,
  n as n2,
  r
} from "./chunk-7HZ72XIE.js";
import {
  D,
  G
} from "./chunk-BCDDCNQ2.js";
import {
  h
} from "./chunk-MF3HZ6GV.js";
import {
  r as r2
} from "./chunk-D5NSNTGJ.js";
import {
  e as e2
} from "./chunk-YYTXJF6W.js";
import {
  j as j3
} from "./chunk-DSWGERIY.js";
import {
  f as f2
} from "./chunk-B4D7M7HT.js";
import {
  j as j2
} from "./chunk-43LWRDQS.js";
import {
  kt
} from "./chunk-ZJEWQGHG.js";
import {
  d,
  f,
  j,
  m
} from "./chunk-7I33FAWS.js";
import {
  e
} from "./chunk-DWOEYHKS.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RectangleBinPack.js
var e6 = class {
  constructor(e8, t6) {
    this._width = 0, this._height = 0, this._free = [], this._width = e8, this._height = t6, this._free.push(new t(0, 0, e8, t6));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(e8, t6) {
    if (e8 > this._width || t6 > this._height)
      return new t();
    let i4 = null, s3 = -1;
    for (let h3 = 0; h3 < this._free.length; ++h3) {
      const w = this._free[h3];
      e8 <= w.width && t6 <= w.height && (null === i4 || w.y <= i4.y && w.x <= i4.x) && (i4 = w, s3 = h3);
    }
    return null === i4 ? new t() : (this._free.splice(s3, 1), i4.width < i4.height ? (i4.width > e8 && this._free.push(new t(i4.x + e8, i4.y, i4.width - e8, t6)), i4.height > t6 && this._free.push(new t(i4.x, i4.y + t6, i4.width, i4.height - t6))) : (i4.width > e8 && this._free.push(new t(i4.x + e8, i4.y, i4.width - e8, i4.height)), i4.height > t6 && this._free.push(new t(i4.x, i4.y + t6, e8, i4.height - t6))), new t(i4.x, i4.y, e8, t6));
  }
  release(h3) {
    for (let e8 = 0; e8 < this._free.length; ++e8) {
      const t6 = this._free[e8];
      if (t6.y === h3.y && t6.height === h3.height && t6.x + t6.width === h3.x)
        t6.width += h3.width;
      else if (t6.x === h3.x && t6.width === h3.width && t6.y + t6.height === h3.y)
        t6.height += h3.height;
      else if (h3.y === t6.y && h3.height === t6.height && h3.x + h3.width === t6.x)
        t6.x = h3.x, t6.width += h3.width;
      else {
        if (h3.x !== t6.x || h3.width !== t6.width || h3.y + h3.height !== t6.y)
          continue;
        t6.y = h3.y, t6.height += h3.height;
      }
      this._free.splice(e8, 1), this.release(h3);
    }
    this._free.push(h3);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphMosaic.js
var n3 = class {
  constructor(e8, s3, i4) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphIndex = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this.width = e8, this.height = s3, this._glyphSource = i4, this._binPack = new e6(e8 - 4, s3 - 4), this._glyphData.push(new Uint8Array(e8 * s3)), this._dirties.push(true), this._textures.push(void 0);
  }
  getGlyphItems(s3, i4) {
    const h3 = [], r5 = this._glyphSource, n4 = /* @__PURE__ */ new Set(), o4 = 1 / 256;
    for (const t6 of i4) {
      const e8 = Math.floor(t6 * o4);
      n4.add(e8);
    }
    const a2 = [];
    return n4.forEach((t6) => {
      const e8 = s3 + t6;
      if (this._rangePromises.has(e8))
        a2.push(this._rangePromises.get(e8));
      else {
        const i5 = r5.getRange(s3, t6).then(() => {
          this._rangePromises.delete(e8);
        }, () => {
          this._rangePromises.delete(e8);
        });
        this._rangePromises.set(e8, i5), a2.push(i5);
      }
    }), Promise.all(a2).then(() => {
      let n5 = this._glyphIndex[s3];
      n5 || (n5 = {}, this._glyphIndex[s3] = n5);
      for (const o5 of i4) {
        const i5 = n5[o5];
        if (i5) {
          h3[o5] = { sdf: true, rect: i5.rect, metrics: i5.metrics, page: i5.page, code: o5 };
          continue;
        }
        const a3 = r5.getGlyph(s3, o5);
        if (!a3 || !a3.metrics)
          continue;
        const c = a3.metrics;
        let l4;
        if (0 === c.width)
          l4 = new t(0, 0, 0, 0);
        else {
          const e8 = 3, s4 = c.width + 2 * e8, i6 = c.height + 2 * e8;
          let h4 = s4 % 4 ? 4 - s4 % 4 : 4, r6 = i6 % 4 ? 4 - i6 % 4 : 4;
          1 === h4 && (h4 = 5), 1 === r6 && (r6 = 5), l4 = this._binPack.allocate(s4 + h4, i6 + r6), l4.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(void 0), this._binPack = new e6(this.width - 4, this.height - 4), l4 = this._binPack.allocate(s4 + h4, i6 + r6));
          const n6 = this._glyphData[this._currentPage], o6 = a3.bitmap;
          let g, _;
          if (o6)
            for (let t6 = 0; t6 < i6; t6++) {
              g = s4 * t6, _ = this.width * (l4.y + t6 + 1) + l4.x;
              for (let t7 = 0; t7 < s4; t7++)
                n6[_ + t7 + 1] = o6[g + t7];
            }
        }
        n5[o5] = { rect: l4, metrics: c, tileIDs: null, page: this._currentPage }, h3[o5] = { sdf: true, rect: l4, metrics: c, page: this._currentPage, code: o5 }, this._dirties[this._currentPage] = true;
      }
      return h3;
    });
  }
  removeGlyphs(t6) {
    for (const e8 in this._glyphIndex) {
      const s3 = this._glyphIndex[e8];
      if (!s3)
        continue;
      let i4;
      for (const e9 in s3)
        if (i4 = s3[e9], i4.tileIDs.delete(t6), 0 === i4.tileIDs.size) {
          const t7 = this._glyphData[i4.page], h3 = i4.rect;
          let r5, n4;
          for (let e10 = 0; e10 < h3.height; e10++)
            for (r5 = this.width * (h3.y + e10) + h3.x, n4 = 0; n4 < h3.width; n4++)
              t7[r5 + n4] = 0;
          delete s3[e9], this._dirties[i4.page] = true;
        }
    }
  }
  bind(t6, e8, n4, o4 = 0) {
    if (!this._textures[n4]) {
      const e9 = new e4();
      e9.pixelFormat = G.ALPHA, e9.wrapMode = D.CLAMP_TO_EDGE, e9.width = this.width, e9.height = this.height, this._textures[n4] = new T(t6, e9, new Uint8Array(this.width * this.height));
    }
    const a2 = this._textures[n4];
    a2.setSamplingMode(e8), this._dirties[n4] && a2.setData(this._glyphData[n4]), t6.bindTexture(a2, o4), this._dirties[n4] = false;
  }
  dispose() {
    this._binPack = null;
    for (const t6 of this._textures)
      t6 && t6.dispose();
    this._textures.length = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphSource.js
var s2 = class {
  constructor(e8) {
    if (this._metrics = [], this._bitmaps = [], e8)
      for (; e8.next(); )
        switch (e8.tag()) {
          case 1: {
            const t6 = e8.getMessage();
            for (; t6.next(); )
              switch (t6.tag()) {
                case 3: {
                  const e9 = t6.getMessage();
                  let s3, a2, r5, n4, i4, c, g;
                  for (; e9.next(); )
                    switch (e9.tag()) {
                      case 1:
                        s3 = e9.getUInt32();
                        break;
                      case 2:
                        a2 = e9.getBytes();
                        break;
                      case 3:
                        r5 = e9.getUInt32();
                        break;
                      case 4:
                        n4 = e9.getUInt32();
                        break;
                      case 5:
                        i4 = e9.getSInt32();
                        break;
                      case 6:
                        c = e9.getSInt32();
                        break;
                      case 7:
                        g = e9.getUInt32();
                        break;
                      default:
                        e9.skip();
                    }
                  e9.release(), s3 && (this._metrics[s3] = { width: r5, height: n4, left: i4, top: c, advance: g }, this._bitmaps[s3] = a2);
                  break;
                }
                default:
                  t6.skip();
              }
            t6.release();
            break;
          }
          default:
            e8.skip();
        }
  }
  getMetrics(e8) {
    return this._metrics[e8];
  }
  getBitmap(e8) {
    return this._bitmaps[e8];
  }
};
var a = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e8) {
    return this._ranges[e8];
  }
  addRange(e8, t6) {
    this._ranges[e8] = t6;
  }
};
var r3 = class {
  constructor(e8) {
    this._glyphInfo = {}, this._baseURL = e8;
  }
  getRange(a2, r5) {
    const n4 = this._getFontStack(a2);
    if (n4.getRange(r5))
      return Promise.resolve();
    const i4 = 256 * r5, c = i4 + 255;
    if (this._baseURL) {
      const g = this._baseURL.replace("{fontstack}", a2).replace("{range}", i4 + "-" + c);
      return j2(g, { responseType: "array-buffer" }).then((e8) => {
        n4.addRange(r5, new s2(new n(new Uint8Array(e8.data), new DataView(e8.data))));
      }).catch(() => {
        n4.addRange(r5, new s2());
      });
    }
    return n4.addRange(r5, new s2()), Promise.resolve();
  }
  getGlyph(e8, t6) {
    const s3 = this._getFontStack(e8);
    if (!s3)
      return;
    const a2 = Math.floor(t6 / 256), r5 = s3.getRange(a2);
    return r5 ? { metrics: r5.getMetrics(t6), bitmap: r5.getBitmap(t6) } : void 0;
  }
  _getFontStack(e8) {
    let t6 = this._glyphInfo[e8];
    return t6 || (t6 = this._glyphInfo[e8] = new a()), t6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SpriteMosaic.js
var r4 = "dasharray-";
var o2 = class _o {
  constructor(t6, e8, s3 = 0) {
    this._size = [], this._mosaicsData = [], this._textures = [], this._dirties = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = {}, this.pixelRatio = 1, (t6 <= 0 || e8 <= 0) && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t6, this._pageHeight = e8, s3 > 0 && (this._maxItemSize = s3), this._binPack = new e6(t6 - 4, e8 - 4);
  }
  dispose() {
    this._binPack = null, this._mosaicRects = {};
    for (const t6 of this._textures)
      t6 && t6.dispose();
    this._textures.length = 0;
  }
  getWidth(t6) {
    return t6 >= this._size.length ? -1 : this._size[t6][0];
  }
  getHeight(t6) {
    return t6 >= this._size.length ? -1 : this._size[t6][1];
  }
  getPageSize(t6) {
    return t6 >= this._size.length ? null : this._size[t6];
  }
  setSpriteSource(t6) {
    if (this.dispose(), this.pixelRatio = t6.devicePixelRatio, 0 === this._mosaicsData.length) {
      this._binPack = new e6(this._pageWidth - 4, this._pageHeight - 4);
      const t7 = Math.floor(this._pageWidth), e8 = Math.floor(this._pageHeight), s3 = new Uint32Array(t7 * e8);
      this._mosaicsData[0] = s3, this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0);
    }
    this._sprites = t6;
  }
  getSpriteItem(t6, i4 = false) {
    let e8, s3, h3 = this._mosaicRects[t6];
    if (h3)
      return h3;
    if (!this._sprites || "loaded" !== this._sprites.loadStatus)
      return null;
    if (t6 && t6.startsWith(r4) ? ([e8, s3] = this._rasterizeDash(t6), i4 = true) : e8 = this._sprites.getSpriteInfo(t6), !e8 || !e8.width || !e8.height || e8.width < 0 || e8.height < 0)
      return null;
    const a2 = e8.width, o4 = e8.height, [n4, _, g] = this._allocateImage(a2, o4);
    return n4.width <= 0 ? null : (this._copy(n4, e8, _, g, i4, s3), h3 = { rect: n4, width: a2, height: o4, sdf: e8.sdf, simplePattern: false, pixelRatio: e8.pixelRatio, page: _ }, this._mosaicRects[t6] = h3, h3);
  }
  getSpriteItems(t6) {
    const i4 = {};
    for (const e8 of t6)
      i4[e8.name] = this.getSpriteItem(e8.name, e8.repeat);
    return i4;
  }
  getMosaicItemPosition(t6, i4) {
    const e8 = this.getSpriteItem(t6, i4), s3 = e8 && e8.rect;
    if (!s3)
      return null;
    s3.width = e8.width, s3.height = e8.height;
    const h3 = e8.width, a2 = e8.height, r5 = 2;
    return { tl: [s3.x + r5, s3.y + r5], br: [s3.x + r5 + h3, s3.y + r5 + a2], page: e8.page };
  }
  bind(t6, i4, e8 = 0, r5 = 0) {
    if (e8 >= this._size.length || e8 >= this._mosaicsData.length)
      return;
    if (!this._textures[e8]) {
      const i5 = new e4();
      i5.wrapMode = D.CLAMP_TO_EDGE, i5.width = this._size[e8][0], i5.height = this._size[e8][1], this._textures[e8] = new T(t6, i5, new Uint8Array(this._mosaicsData[e8].buffer));
    }
    const o4 = this._textures[e8];
    o4.setSamplingMode(i4), this._dirties[e8] && o4.setData(new Uint8Array(this._mosaicsData[e8].buffer)), t6.bindTexture(o4, r5), this._dirties[e8] = false;
  }
  static _copyBits(t6, i4, e8, s3, h3, a2, r5, o4, n4, _, g) {
    let c = s3 * i4 + e8, l4 = o4 * a2 + r5;
    if (g) {
      l4 -= a2;
      for (let r6 = -1; r6 <= _; r6++, c = ((r6 + _) % _ + s3) * i4 + e8, l4 += a2)
        for (let i5 = -1; i5 <= n4; i5++)
          h3[l4 + i5] = t6[c + (i5 + n4) % n4];
    } else
      for (let p2 = 0; p2 < _; p2++) {
        for (let i5 = 0; i5 < n4; i5++)
          h3[l4 + i5] = t6[c + i5];
        c += i4, l4 += a2;
      }
  }
  _copy(t6, i4, e8, s3, h3, a2) {
    if (!this._sprites || "loaded" !== this._sprites.loadStatus || e8 >= this._mosaicsData.length)
      return;
    const r5 = new Uint32Array(a2 ? a2.buffer : this._sprites.image.buffer), n4 = this._mosaicsData[e8];
    n4 && r5 || console.error("Source or target images are uninitialized!");
    const _ = 2, g = a2 ? i4.width : this._sprites.width;
    _o._copyBits(r5, g, i4.x, i4.y, n4, s3[0], t6.x + _, t6.y + _, i4.width, i4.height, h3), this._dirties[e8] = true;
  }
  _allocateImage(t6, s3) {
    t6 += 2, s3 += 2;
    const h3 = Math.max(t6, s3);
    if (this._maxItemSize && this._maxItemSize < h3) {
      const i4 = new t(0, 0, t6, s3);
      return this._mosaicsData.push(new Uint32Array(t6 * s3)), this._dirties.push(true), this._size.push([t6, s3]), this._textures.push(void 0), [i4, this._mosaicsData.length - 1, [t6, s3]];
    }
    let a2 = t6 % 4 ? 4 - t6 % 4 : 4, r5 = s3 % 4 ? 4 - s3 % 4 : 4;
    1 === a2 && (a2 = 5), 1 === r5 && (r5 = 5);
    const o4 = this._binPack.allocate(t6 + a2, s3 + r5);
    return o4.width <= 0 ? (this._dirties[this._currentPage] || (this._mosaicsData[this._currentPage] = null), this._currentPage = this._mosaicsData.length, this._mosaicsData.push(new Uint32Array(this._pageWidth * this._pageHeight)), this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0), this._binPack = new e6(this._pageWidth - 4, this._pageHeight - 4), this._allocateImage(t6, s3)) : [o4, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _rasterizeDash(i4) {
    const e8 = /\[(.*?)\]/, s3 = i4.match(e8);
    if (!s3)
      return null;
    const h3 = s3[1].split(",").map(Number), a2 = i4.slice(i4.lastIndexOf("-") + 1), [r5, o4, n4] = e5(h3, a2);
    return [{ x: 0, y: 0, width: o4, height: n4, sdf: true, pixelRatio: 1 }, new Uint8Array(r5.buffer)];
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler.js
var h2 = class {
  constructor(t6, e8, s3) {
    this._layer = t6, this._styleRepository = e8, this.devicePixelRatio = s3, this._spriteMosaic = null, this._glyphMosaic = null, this._connection = null, this._spriteSourceAbortController = null, this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  destroy() {
    var _a, _b;
    (_a = this._connection) == null ? void 0 : _a.close(), this._connection = null, this._styleRepository = null, this._layer = null, this._spriteMosaic = null, this._glyphMosaic = null, this._spriteSourceAbortController = e(this._spriteSourceAbortController), this._spriteSourcePromise = null, this._inputSignalEventListener && ((_b = this._startOptionsInputSignal) == null ? void 0 : _b.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  get spriteMosaic() {
    return this._spriteSourcePromise.then(() => this._spriteMosaic);
  }
  get glyphMosaic() {
    return this._glyphMosaic;
  }
  async start(t6) {
    this._requestSprite(t6);
    const s3 = this._layer.currentStyleInfo.glyphsUrl, r5 = new r3(s3 ? kt(s3, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    this._glyphMosaic = new n3(1024, 1024, r5), this._broadcastPromise = f2("WorkerTileHandler", { client: this, schedule: t6.schedule, signal: t6.signal }).then((s4) => {
      var _a;
      if (this._layer && ((_a = this._connection) == null ? void 0 : _a.close(), this._connection = s4, this._layer && !this._connection.closed)) {
        const r6 = s4.broadcast("setStyle", this._layer.currentStyleInfo.style, t6);
        Promise.all(r6).catch((t7) => m(t7));
      }
    });
  }
  _requestSprite(t6) {
    var _a, _b;
    (_a = this._spriteSourceAbortController) == null ? void 0 : _a.abort();
    const e8 = new AbortController();
    this._spriteSourceAbortController = e8;
    const r5 = t6 == null ? void 0 : t6.signal;
    this._inputSignalEventListener && ((_b = this._startOptionsInputSignal) == null ? void 0 : _b.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, r5 && (this._inputSignalEventListener = p(e8), r5.addEventListener("abort", this._inputSignalEventListener, { once: true }));
    const { signal: i4 } = e8, o4 = { ...t6, signal: i4 };
    this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, o4), this._spriteSourcePromise.then((t7) => {
      f(i4), this._spriteMosaic = new o2(1024, 1024, 250), this._spriteMosaic.setSpriteSource(t7);
    });
  }
  async updateStyle(t6) {
    return await this._broadcastPromise, this._broadcastPromise = Promise.all(this._connection.broadcast("updateStyle", t6)), this._broadcastPromise;
  }
  setSpriteSource(t6) {
    const e8 = new o2(1024, 1024, 250);
    return e8.setSpriteSource(t6), this._spriteMosaic = e8, this._spriteSourcePromise = Promise.resolve(t6), this._spriteSourceAbortController = null, e8;
  }
  async setStyle(t6, e8) {
    await this._broadcastPromise, this._styleRepository = t6, this._requestSprite();
    const s3 = new r3(this._layer.currentStyleInfo.glyphsUrl ? kt(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    return this._glyphMosaic = new n3(1024, 1024, s3), this._broadcastPromise = Promise.all(this._connection.broadcast("setStyle", e8)), this._broadcastPromise;
  }
  fetchTileData(t6, e8) {
    return this._getRefKeys(t6, e8).then((t7) => {
      const s3 = this._layer.sourceNameToSource, r5 = [];
      for (const e9 in s3)
        r5.push(e9);
      return this._getSourcesData(r5, t7, e8);
    });
  }
  parseTileData(t6, e8) {
    const s3 = t6 && t6.data;
    if (!s3)
      return Promise.resolve(null);
    const { sourceName2DataAndRefKey: r5, transferList: i4 } = s3;
    return 0 === Object.keys(r5).length ? Promise.resolve(null) : this._broadcastPromise.then(() => this._connection.invoke("createTileAndParse", { key: t6.key.id, sourceName2DataAndRefKey: r5, styleLayerUIDs: t6.styleLayerUIDs }, { ...e8, transferList: i4 }));
  }
  async getSprites(t6) {
    return await this._spriteSourcePromise, this._spriteMosaic.getSpriteItems(t6);
  }
  getGlyphs(t6) {
    return this._glyphMosaic.getGlyphItems(t6.font, t6.codePoints);
  }
  async _getTilePayload(t6, e8, s3) {
    const i4 = e2.pool.acquire(t6.id), o4 = this._layer.sourceNameToSource[e8], { level: n4, row: l4, col: a2 } = i4;
    e2.pool.release(i4);
    try {
      return { protobuff: await o4.requestTile(n4, l4, a2, s3), sourceName: e8 };
    } catch (c) {
      if (d(c))
        throw c;
      return { protobuff: null, sourceName: e8 };
    }
  }
  _getRefKeys(t6, e8) {
    const s3 = this._layer.sourceNameToSource, r5 = new Array();
    for (const i4 in s3) {
      const o4 = s3[i4].getRefKey(t6, e8);
      r5.push(o4);
    }
    return j(r5);
  }
  _getSourcesData(t6, e8, s3) {
    const r5 = [];
    for (let i4 = 0; i4 < e8.length; i4++)
      if (null == e8[i4].value || null == t6[i4])
        r5.push(null);
      else {
        const o4 = this._getTilePayload(e8[i4].value, t6[i4], s3);
        r5.push(o4);
      }
    return j(r5).then((t7) => {
      const s4 = {}, r6 = [];
      for (let i4 = 0; i4 < t7.length; i4++) {
        const o4 = t7[i4].value;
        if (o4 && (o4.protobuff && o4.protobuff.byteLength > 0)) {
          const t8 = e8[i4].value.id;
          s4[o4.sourceName] = { refKey: t8, protobuff: o4.protobuff }, r6.push(o4.protobuff);
        }
      }
      return { sourceName2DataAndRefKey: s4, transferList: r6 };
    });
  }
};
function p(t6) {
  return () => t6.abort();
}

// node_modules/@arcgis/core/views/2d/tiling/TileInfoViewPOT.js
var t3 = class extends h {
  constructor() {
    super(...arguments), this._fullCacheLodInfos = null, this._levelByScale = {};
  }
  getTileParentId(e8) {
    const l4 = e2.pool.acquire(e8), t6 = 0 === l4.level ? null : e2.getId(l4.level - 1, l4.row >> 1, l4.col >> 1, l4.world);
    return e2.pool.release(l4), t6;
  }
  getTileCoverage(e8, l4, s3 = true, t6) {
    const o4 = super.getTileCoverage(e8, l4, s3, t6);
    if (!o4)
      return o4;
    const i4 = 1 << o4.lodInfo.level;
    return o4.spans = o4.spans.filter((e9) => e9.row >= 0 && e9.row < i4), o4;
  }
  scaleToLevel(e8) {
    if (this._fullCacheLodInfos || this._initializeFullCacheLODs(this._lodInfos), this._levelByScale[e8])
      return this._levelByScale[e8];
    {
      const l4 = this._fullCacheLodInfos;
      if (e8 > l4[0].scale)
        return l4[0].level;
      let s3, t6;
      for (let o4 = 0; o4 < l4.length - 1; o4++)
        if (t6 = l4[o4 + 1], e8 > t6.scale)
          return s3 = l4[o4], s3.level + (s3.scale - e8) / (s3.scale - t6.scale);
      return l4[l4.length - 1].level;
    }
  }
  _initializeFullCacheLODs(l4) {
    let s3;
    if (0 === l4[0].level)
      s3 = l4.map((e8) => ({ level: e8.level, resolution: e8.resolution, scale: e8.scale }));
    else {
      const l5 = this.tileInfo.size[0], t6 = this.tileInfo.spatialReference;
      s3 = j3.create({ size: l5, spatialReference: t6 }).lods.map((e8) => ({ level: e8.level, resolution: e8.resolution, scale: e8.scale }));
    }
    for (let e8 = 0; e8 < s3.length; e8++)
      this._levelByScale[s3[e8].scale] = s3[e8].level;
    this._fullCacheLodInfos = s3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobs.js
function i(e8, t6, n4, o4, i4, l4) {
  const { iconRotationAlignment: a2, textRotationAlignment: c, iconTranslate: h3, iconTranslateAnchor: u, textTranslate: d2, textTranslateAnchor: y } = o4;
  let x = 0;
  for (const g of e8.colliders) {
    const [e9, o5] = 0 === g.partIndex ? h3 : d2, m2 = 0 === g.partIndex ? u : y, f3 = g.minLod <= l4 && l4 <= g.maxLod;
    x += f3 ? 0 : 1, g.enabled = f3, g.xScreen = g.xTile * i4[0] + g.yTile * i4[3] + i4[6], g.yScreen = g.xTile * i4[1] + g.yTile * i4[4] + i4[7], m2 === r.MAP ? (g.xScreen += n4 * e9 - t6 * o5, g.yScreen += t6 * e9 + n4 * o5) : (g.xScreen += e9, g.yScreen += o5), l.VIEWPORT === (0 === g.partIndex ? a2 : c) ? (g.dxScreen = g.dxPixels, g.dyScreen = g.dyPixels) : (g.dxScreen = n4 * (g.dxPixels + g.width / 2) - t6 * (g.dyPixels + g.height / 2) - g.width / 2, g.dyScreen = t6 * (g.dxPixels + g.width / 2) + n4 * (g.dyPixels + g.height / 2) - g.height / 2);
  }
  e8.colliders.length > 0 && x === e8.colliders.length && (e8.unique.show = false);
}
var l2 = class {
  constructor(o4, r5, s3, i4, l4, a2) {
    this._symbols = o4, this._styleRepository = i4, this._zoom = l4, this._currentLayerCursor = 0, this._currentSymbolCursor = 0, this._styleProps = /* @__PURE__ */ new Map(), this._allNeededMatrices = /* @__PURE__ */ new Map(), this._gridIndex = new o(r5, s3, t2), this._si = Math.sin(Math.PI * a2 / 180), this._co = Math.cos(Math.PI * a2 / 180);
    for (const t6 of o4)
      for (const n4 of t6.symbols)
        this._allNeededMatrices.has(n4.tile) || this._allNeededMatrices.set(n4.tile, r2(n4.tile.transforms.tileUnitsToPixels));
  }
  work(e8) {
    const t6 = this._gridIndex;
    function n4(e9) {
      const n5 = e9.xScreen + e9.dxScreen, o5 = e9.yScreen + e9.dyScreen, r5 = n5 + e9.width, s3 = o5 + e9.height, [i4, l4, a2, c] = t6.getCellSpan(n5, o5, r5, s3);
      for (let h3 = l4; h3 <= c; h3++)
        for (let e10 = i4; e10 <= a2; e10++) {
          const i5 = t6.cells[h3][e10];
          for (const e11 of i5) {
            const t7 = e11.xScreen + e11.dxScreen, i6 = e11.yScreen + e11.dyScreen, l5 = t7 + e11.width, a3 = i6 + e11.height;
            if (!(r5 < t7 || n5 > l5 || s3 < i6 || o5 > a3))
              return true;
          }
        }
      return false;
    }
    const o4 = performance.now();
    for (; this._currentLayerCursor < this._symbols.length; this._currentLayerCursor++, this._currentSymbolCursor = 0) {
      const t7 = this._symbols[this._currentLayerCursor], r5 = this._getProperties(t7.styleLayerUID);
      for (; this._currentSymbolCursor < t7.symbols.length; this._currentSymbolCursor++) {
        if (this._currentSymbolCursor % 100 == 99 && performance.now() - o4 > e8)
          return false;
        const s3 = t7.symbols[this._currentSymbolCursor];
        if (!s3.unique.show)
          continue;
        i(s3, this._si, this._co, r5, this._allNeededMatrices.get(s3.tile), this._zoom);
        const l4 = s3.unique;
        if (!l4.show)
          continue;
        const { iconAllowOverlap: a2, iconIgnorePlacement: c, textAllowOverlap: h3, textIgnorePlacement: u } = r5;
        for (const e9 of s3.colliders) {
          if (!e9.enabled)
            continue;
          const t8 = l4.parts[e9.partIndex];
          if (!t8.show)
            continue;
          !(e9.partIndex ? h3 : a2) && n4(e9) && (e9.hard ? l4.show = false : t8.show = false);
        }
        if (l4.show)
          for (const e9 of s3.colliders) {
            if (!e9.enabled)
              continue;
            if (e9.partIndex ? u : c)
              continue;
            if (!l4.parts[e9.partIndex].show)
              continue;
            const t8 = e9.xScreen + e9.dxScreen, n5 = e9.yScreen + e9.dyScreen, o5 = t8 + e9.width, r6 = n5 + e9.height, [s4, i4, a3, h4] = this._gridIndex.getCellSpan(t8, n5, o5, r6);
            for (let l5 = i4; l5 <= h4; l5++)
              for (let t9 = s4; t9 <= a3; t9++) {
                this._gridIndex.cells[l5][t9].push(e9);
              }
          }
      }
    }
    return true;
  }
  _getProperties(e8) {
    const t6 = this._styleProps.get(e8);
    if (t6)
      return t6;
    const n4 = this._zoom, s3 = this._styleRepository.getStyleLayerByUID(e8), i4 = s3.getLayoutValue("symbol-placement", n4) !== n2.POINT;
    let l4 = s3.getLayoutValue("icon-rotation-alignment", n4);
    l4 === l.AUTO && (l4 = i4 ? l.MAP : l.VIEWPORT);
    let a2 = s3.getLayoutValue("text-rotation-alignment", n4);
    a2 === l.AUTO && (a2 = i4 ? l.MAP : l.VIEWPORT);
    const c = s3.getPaintValue("icon-translate", n4), h3 = s3.getPaintValue("icon-translate-anchor", n4), u = s3.getPaintValue("text-translate", n4), d2 = s3.getPaintValue("text-translate-anchor", n4), y = { iconAllowOverlap: s3.getLayoutValue("icon-allow-overlap", n4), iconIgnorePlacement: s3.getLayoutValue("icon-ignore-placement", n4), textAllowOverlap: s3.getLayoutValue("text-allow-overlap", n4), textIgnorePlacement: s3.getLayoutValue("text-ignore-placement", n4), iconRotationAlignment: l4, textRotationAlignment: a2, iconTranslateAnchor: h3, iconTranslate: c, textTranslateAnchor: d2, textTranslate: u };
    return this._styleProps.set(e8, y), y;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolDeclutterer.js
function t4(o4, t6) {
  if (o4.priority - t6.priority)
    return o4.priority - t6.priority;
  const e8 = o4.tile.key, i4 = t6.tile.key;
  return e8.world - i4.world ? e8.world - i4.world : e8.level - i4.level ? e8.level - i4.level : e8.row - i4.row ? e8.row - i4.row : e8.col - i4.col ? e8.col - i4.col : o4.xTile - t6.xTile ? o4.xTile - t6.xTile : o4.yTile - t6.yTile;
}
var e7 = class {
  get running() {
    return this._running;
  }
  constructor(o4, t6, e8, i4, s3, n4) {
    this._visibleTiles = o4, this._symbolRepository = t6, this._createCollisionJob = e8, this._assignTileSymbolsOpacity = i4, this._symbolLayerSorter = s3, this._isLayerVisible = n4, this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  setScreenSize(o4, t6) {
    this._screenWidth === o4 && this._screenHeight === t6 || this.restart(), this._screenWidth = o4, this._screenHeight = t6;
  }
  restart() {
    this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  continue(o4) {
    if (this._selectionJob || (this._selectionJob = this._createSelectionJob()), !this._selectionJobCompleted) {
      const t6 = performance.now();
      if (!this._selectionJob.work(o4))
        return false;
      if (this._selectionJobCompleted = true, 0 === (o4 = Math.max(0, o4 - (performance.now() - t6))))
        return false;
    }
    if (this._collisionJob || (this._collisionJob = this._createCollisionJob(this._selectionJob.sortedSymbols, this._screenWidth, this._screenHeight)), !this._collisionJobCompleted) {
      const t6 = performance.now();
      if (!this._collisionJob.work(o4))
        return false;
      if (this._collisionJobCompleted = true, 0 === (o4 = Math.max(0, o4 - (performance.now() - t6))))
        return false;
    }
    if (this._opacityJob || (this._opacityJob = this._createOpacityJob()), !this._opacityJobCompleted) {
      const t6 = performance.now();
      if (!this._opacityJob.work(o4))
        return false;
      if (this._opacityJobCompleted = true, 0 === (o4 = Math.max(0, o4 - (performance.now() - t6))))
        return false;
    }
    return this._running = false, true;
  }
  _createSelectionJob() {
    const o4 = this._symbolRepository.uniqueSymbols;
    for (let t6 = 0; t6 < o4.length; t6++) {
      const e9 = o4[t6];
      for (let o5 = 0; o5 < e9.uniqueSymbols.length; o5++) {
        const t7 = e9.uniqueSymbols[o5];
        for (const o6 of t7.tileSymbols)
          o6.selectedForRendering = false;
      }
    }
    const e8 = [];
    let i4 = 0, s3 = 0;
    const n4 = this._isLayerVisible;
    function r5(r6) {
      let l5;
      const c = performance.now();
      for (; s3 < o4.length; s3++, i4 = 0) {
        const t6 = o4[s3], h3 = t6.styleLayerUID;
        if (!n4(h3)) {
          e8[s3] || (e8[s3] = { styleLayerUID: h3, symbols: [] });
          continue;
        }
        e8[s3] = e8[s3] || { styleLayerUID: h3, symbols: [] };
        const a2 = e8[s3];
        for (; i4 < t6.uniqueSymbols.length; i4++) {
          if (l5 = t6.uniqueSymbols[i4], i4 % 100 == 99 && performance.now() - c > r6)
            return false;
          let o5 = null, e9 = false, s4 = false;
          for (const t7 of l5.tileSymbols)
            if (!s4 || !e9) {
              const i5 = t7.tile;
              (!o5 || i5.isCoverage || i5.neededForCoverage && !e9) && (o5 = t7, (i5.neededForCoverage || i5.isCoverage) && (s4 = true), i5.isCoverage && (e9 = true));
            }
          if (o5.selectedForRendering = true, s4) {
            a2.symbols.push(o5), l5.show = true;
            for (const o6 of l5.parts)
              o6.show = true;
          } else
            l5.show = false;
        }
      }
      for (const o5 of e8)
        o5.symbols.sort(t4);
      return true;
    }
    const l4 = this._symbolLayerSorter;
    return { work: r5, get sortedSymbols() {
      return e8.sort(l4);
    } };
  }
  _createOpacityJob() {
    const o4 = this._assignTileSymbolsOpacity, t6 = this._visibleTiles;
    let e8 = 0;
    function s3(t7, e9) {
      const n4 = t7.symbols;
      for (const [o5, s4] of n4)
        i2(s4, e9);
      o4(t7, e9);
      for (const o5 of t7.childrenTiles)
        s3(o5, e9);
    }
    return { work(o5) {
      const i4 = performance.now();
      for (; e8 < t6.length; e8++) {
        if (performance.now() - i4 > o5)
          return false;
        const n4 = t6[e8];
        if (null != n4.parentTile)
          continue;
        s3(n4, performance.now());
      }
      return true;
    } };
  }
};
function i2(t6, e8) {
  for (const i4 of t6) {
    const t7 = i4.unique;
    for (const i5 of t7.parts) {
      const s3 = i5.targetOpacity > 0.5 ? 1 : -1;
      i5.startOpacity += s3 * ((e8 - i5.startTime) / e3), i5.startOpacity = Math.min(Math.max(i5.startOpacity, 0), 1), i5.startTime = e8, i5.targetOpacity = t7.show && i5.show ? 1 : 0;
    }
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolRepository.js
var l3 = 32;
var o3 = 8;
var t5 = 64;
var i3 = class {
  constructor(e8, s3, l4) {
    this.tileCoordRange = e8, this._visibleTiles = s3, this._createUnique = l4, this._tiles = /* @__PURE__ */ new Map(), this._uniqueSymbolsReferences = /* @__PURE__ */ new Map();
  }
  get uniqueSymbols() {
    return null == this._uniqueSymbolLayerArray && (this._uniqueSymbolLayerArray = this._createUniqueSymbolLayerArray()), this._uniqueSymbolLayerArray;
  }
  add(s3, i4) {
    this._uniqueSymbolLayerArray = null;
    let n4 = this._tiles.get(s3.id);
    n4 || (n4 = { symbols: /* @__PURE__ */ new Map() }, this._tiles.set(s3.id, n4));
    const r5 = /* @__PURE__ */ new Map();
    if (i4)
      for (const e8 of i4)
        n4.symbols.has(e8) && (r5.set(e8, n4.symbols.get(e8)), n4.symbols.delete(e8));
    else
      for (const [e8, l4] of s3.layerData)
        n4.symbols.has(e8) && (r5.set(e8, n4.symbols.get(e8)), n4.symbols.delete(e8));
    this._removeSymbols(r5);
    const y = s3.symbols, a2 = /* @__PURE__ */ new Map();
    for (const [f3, c] of y) {
      let s4 = c.length;
      if (s4 >= l3) {
        let l4 = this.tileCoordRange;
        do {
          l4 /= 2, s4 /= 4;
        } while (s4 > o3 && l4 > t5);
        const i5 = new o(this.tileCoordRange, this.tileCoordRange, l4);
        a2.set(f3, { flat: c, index: i5 }), n4.symbols.set(f3, { flat: c, index: i5 });
        for (const e8 of c)
          i5.getCell(e8.xTile, e8.yTile).push(e8);
      } else
        a2.set(f3, { flat: c }), n4.symbols.set(f3, { flat: c });
    }
    this._addSymbols(s3.key, y);
  }
  deleteStyleLayers(e8) {
    this._uniqueSymbolLayerArray = null;
    for (const [s3, l4] of this._tiles) {
      const o4 = /* @__PURE__ */ new Map();
      for (const s4 of e8)
        l4.symbols.has(s4) && (o4.set(s4, l4.symbols.get(s4)), l4.symbols.delete(s4));
      this._removeSymbols(o4), 0 === l4.symbols.size && this._tiles.delete(s3);
    }
  }
  removeTile(e8) {
    this._uniqueSymbolLayerArray = null;
    const s3 = this._tiles.get(e8.id);
    if (!s3)
      return;
    const l4 = /* @__PURE__ */ new Map();
    for (const [o4, t6] of e8.symbols)
      s3.symbols.has(o4) && (l4.set(o4, s3.symbols.get(o4)), s3.symbols.delete(o4));
    this._removeSymbols(l4), 0 === s3.symbols.size && this._tiles.delete(e8.id);
  }
  _removeSymbols(e8) {
    for (const [s3, { flat: l4 }] of e8)
      for (const e9 of l4) {
        const l5 = e9.unique, o4 = l5.tileSymbols, t6 = o4.length - 1;
        for (let s4 = 0; s4 < t6; s4++)
          if (o4[s4] === e9) {
            o4[s4] = o4[t6];
            break;
          }
        if (o4.length = t6, 0 === t6) {
          const e10 = this._uniqueSymbolsReferences.get(s3);
          e10.delete(l5), 0 === e10.size && this._uniqueSymbolsReferences.delete(s3);
        }
        e9.unique = null;
      }
  }
  _addSymbols(e8, s3) {
    if (0 === s3.size)
      return;
    const l4 = this._visibleTiles;
    for (const o4 of l4)
      o4.parentTile || o4.key.world !== e8.world || o4.key.level === e8.level && !o4.key.equals(e8) || this._matchSymbols(o4, e8, s3);
    for (const [o4, t6] of s3)
      for (const e9 of t6)
        if (null == e9.unique) {
          const s4 = this._createUnique();
          e9.unique = s4, s4.tileSymbols.push(e9);
          let l5 = this._uniqueSymbolsReferences.get(o4);
          l5 || (l5 = /* @__PURE__ */ new Set(), this._uniqueSymbolsReferences.set(o4, l5)), l5.add(s4);
        }
  }
  _matchSymbols(e8, l4, o4) {
    if (e8.key.level > l4.level) {
      const s3 = e8.key.level - l4.level;
      if (e8.key.row >> s3 !== l4.row || e8.key.col >> s3 !== l4.col)
        return;
    }
    if (l4.level > e8.key.level) {
      const s3 = l4.level - e8.key.level;
      if (l4.row >> s3 !== e8.key.row || l4.col >> s3 !== e8.key.col)
        return;
    }
    if (l4.equals(e8.key)) {
      for (const s3 of e8.childrenTiles)
        this._matchSymbols(s3, l4, o4);
      return;
    }
    const t6 = /* @__PURE__ */ new Map();
    for (const [i4, n4] of o4) {
      const o5 = [];
      for (const t7 of n4) {
        const i5 = s(this.tileCoordRange, t7.xTile, l4.level, l4.col, e8.key.level, e8.key.col), n5 = s(this.tileCoordRange, t7.yTile, l4.level, l4.row, e8.key.level, e8.key.row);
        i5 >= 0 && i5 < this.tileCoordRange && n5 >= 0 && n5 < this.tileCoordRange && o5.push({ symbol: t7, xTransformed: i5, yTransformed: n5 });
      }
      const r5 = [], y = e8.key.level < l4.level ? 1 : 1 << e8.key.level - l4.level, a2 = this._tiles.get(e8.id).symbols.get(i4);
      if (a2) {
        const e9 = a2.flat;
        for (const s3 of o5) {
          let l5, o6 = false;
          const t7 = s3.xTransformed, i5 = s3.yTransformed;
          l5 = null != a2.index ? a2.index.getCell(t7, i5) : e9;
          const n5 = s3.symbol, f3 = n5.hash;
          for (const e10 of l5)
            if (f3 === e10.hash && Math.abs(t7 - e10.xTile) <= y && Math.abs(i5 - e10.yTile) <= y) {
              const s4 = e10.unique;
              n5.unique = s4, s4.tileSymbols.push(n5), o6 = true;
              break;
            }
          o6 || r5.push(n5);
        }
      }
      r5.length > 0 && t6.set(i4, r5);
    }
    for (const s3 of e8.childrenTiles)
      this._matchSymbols(s3, l4, t6);
  }
  _createUniqueSymbolLayerArray() {
    const e8 = this._uniqueSymbolsReferences, s3 = new Array(e8.size);
    let l4, o4 = 0;
    for (const [t6, i4] of e8) {
      const e9 = new Array(i4.size);
      l4 = 0;
      for (const s4 of i4)
        e9[l4++] = s4;
      s3[o4] = { styleLayerUID: t6, uniqueSymbols: e9 }, o4++;
    }
    return s3;
  }
};

export {
  h2 as h,
  l2 as l,
  e7 as e,
  i3 as i,
  t3 as t
};
//# sourceMappingURL=chunk-MLHA2Q2M.js.map
