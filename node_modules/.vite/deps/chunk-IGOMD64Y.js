import {
  n as n2,
  t as t2,
  u
} from "./chunk-6SPYK5IY.js";
import {
  n
} from "./chunk-UK4ZDRLR.js";
import {
  d as d2
} from "./chunk-TYEEWKIN.js";
import {
  d
} from "./chunk-VMTVUE47.js";
import {
  $,
  Cn,
  Y,
  nn
} from "./chunk-BNBT4QTW.js";
import {
  L,
  b,
  g,
  q
} from "./chunk-4BXK4H4L.js";
import {
  j
} from "./chunk-H7RDAEPY.js";
import {
  m as m2,
  t6 as t,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2,
  f
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  f as f2,
  m
} from "./chunk-7I33FAWS.js";
import {
  e as e2
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import {
  a
} from "./chunk-IYZKKFJM.js";
import {
  R
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/featureEditing.js
var n3 = { setAttribute() {
}, setGeometry(t3) {
}, rollback() {
}, commit() {
} };
var o;
function r(e3, r2) {
  const s3 = r2.attributes[e3.objectIdField], l2 = e3.sessions.get(s3);
  if (l2)
    return l2;
  const u3 = a(r2.attributes), i4 = /* @__PURE__ */ new Set();
  if (null == s3)
    return n3;
  const a4 = e3.i3sOverrides.createInteractiveEditSession(s3), c4 = /* @__PURE__ */ new Map(), d6 = (t3, e4) => {
    const n4 = c4.get(t3);
    if (null == n4) {
      const n5 = e4.indexOf(s3);
      return c4.set(t3, n5), n5;
    }
    return n4;
  };
  let f5 = o.EDITING;
  const b3 = { setAttribute(t3, n4) {
    if (f5 !== o.EDITING)
      return;
    const s4 = e3.fieldsIndex.get(t3);
    if (!s4)
      return;
    const l3 = e3.attributeStorageInfo.findIndex((t4) => t4.name === s4.name);
    if (l3 < 0)
      return;
    a4.setAttribute(l3, n4);
    const u4 = e3.attributeStorageInfo[l3];
    let c5 = false;
    i4.add(t3), e3.forEachNode((t4, o2) => {
      const s5 = d6(t4, o2);
      if (-1 === s5)
        return;
      const l4 = e3.getAttributeData(t4.index);
      if (l4) {
        const o3 = l4[u4.name];
        o3 && (o3[s5] = n4, e3.setAttributeData(t4.index, l4, r2), c5 = true);
      }
    }), c5 && e3.clearMemCache();
  }, setGeometry(t3) {
    f5 === o.EDITING && a4.setGeometry(t3);
  }, rollback() {
    if (f5 === o.EDITING) {
      for (const t3 of i4)
        this.setAttribute(t3, u3[t3]);
      a4.rollback(), f5 = o.ROLLED_BACK, e3.sessions.delete(s3);
    }
  }, commit() {
    f5 === o.EDITING && (a4.commit(), f5 = o.COMMITTED, e3.sessions.delete(s3));
  } };
  return e3.sessions.set(s3, b3), b3;
}
function s2(t3, n4) {
  var _a;
  const o2 = t3.fieldsIndex, r2 = t3.objectIdField, s3 = t3.globalIdField;
  if (null == s3)
    return;
  const l2 = /* @__PURE__ */ new Map(), u3 = f3(n4.addedFeatures), i4 = n4.edits.addFeatures, a4 = b2(n4.updatedFeatures), c4 = n4.edits.updateFeatures, I2 = d3(o2, r2, s3, (_a = n4.edits) == null ? void 0 : _a.deleteFeatures), g3 = b2(n4.deletedFeatures, I2), m3 = n4.edits.deleteFeatures;
  if (null != i4 && i4.length > 0)
    for (const d6 of i4) {
      const t4 = n(o2, d6.attributes, s3), n5 = u3.get(t4);
      null != d6.geometry && "mesh" === d6.geometry.type && null != n5 && l2.set(n5, d6.geometry);
    }
  if (null != c4 && c4.length > 0)
    for (const d6 of c4) {
      const t4 = n(o2, d6.attributes, r2);
      null != d6.geometry && "mesh" === d6.geometry.type && a4.has(t4) && l2.set(t4, d6.geometry);
    }
  if (null != m3 && m3.length > 0)
    for (const d6 of m3) {
      let t4 = null;
      t4 = "attributes" in d6 ? n(o2, d6.attributes, r2) : d6.objectId, null != t4 && g3.has(t4) && l2.set(t4, null);
    }
  for (const [e3, d6] of l2)
    t3.i3sOverrides.updateGeometry(e3, d6);
}
function l(t3, e3) {
  var _a;
  const n4 = i(t3, e3), o2 = u2(t3, e3);
  if (0 === n4.size && 0 === o2.size)
    return;
  const r2 = /* @__PURE__ */ new Map();
  for (let u3 = 0; u3 < t3.attributeStorageInfo.length; u3++)
    r2.set(t3.attributeStorageInfo[u3].name, u3);
  let s3 = false;
  n4.forEach((e4, n5) => {
    const o3 = t3.getAttributeData(n5);
    let l3 = false;
    e4.forEach((e5, n6) => {
      const u3 = null != o3 ? o3[n6] : null, i4 = r2.get(n6);
      for (const { featureIndex: o4, value: r3, featureId: a5 } of e5)
        u3 && (u3[o4] = r3, l3 = true, s3 = true), t3.i3sOverrides.updateAttributeValue(a5, i4, r3);
    }), l3 && t3.setAttributeData(n5, o3, null);
  }), s3 && t3.clearMemCache();
  const { fieldsIndex: l2, i3sOverrides: a4, objectIdField: c4, globalIdField: d6 } = t3, f5 = (_a = a4.layer.associatedLayer) == null ? void 0 : _a.infoFor3D, b3 = new Set(f5 ? [...Object.values(f5.assetMapFieldRoles), ...Object.values(f5.transformFieldRoles)] : []);
  for (const [u3, i4] of o2) {
    a4.featureAdded(u3);
    const { attributes: t4 } = i4;
    for (const e4 in t4) {
      if (e4 !== c4 && e4 !== d6 && b3.has(e4))
        continue;
      const n5 = l2.normalizeFieldName(e4), o3 = null != n5 ? r2.get(n5) : null;
      if (null == o3)
        continue;
      const s4 = t4[e4];
      a4.updateAttributeValue(u3, o3, s4);
    }
  }
}
function u2(t3, { edits: n4, addedFeatures: o2 }) {
  const r2 = /* @__PURE__ */ new Map(), s3 = n4.addAssetFeatures, { fieldsIndex: l2, globalIdField: u3 } = t3;
  if (!s3 || 0 === s3.length || null == u3)
    return r2;
  const i4 = f3(o2);
  for (const a4 of s3) {
    const t4 = n(l2, a4.attributes, u3), n5 = i4.get(t4);
    null != a4.geometry && "mesh" === a4.geometry.type && null != n5 && r2.set(n5, a4);
  }
  return r2;
}
function i(t3, n4) {
  const o2 = n4.edits.updateFeatures;
  if (!o2 || 0 === o2.length)
    return new g2();
  const r2 = b2(n4.updatedFeatures), s3 = new g2(), l2 = /* @__PURE__ */ new Map();
  for (let e3 = 0; e3 < t3.attributeStorageInfo.length; e3++)
    l2.set(t3.attributeStorageInfo[e3].name, e3);
  const u3 = t3.fieldsIndex, i4 = t3.objectIdField, c4 = o2.filter((t4) => {
    const n5 = n(u3, t4.attributes, i4);
    return r2.has(n5);
  });
  return t3.forEachNode((n5, o3) => {
    const r3 = new Set(o3);
    for (const l3 of c4) {
      const c5 = n(u3, l3.attributes, i4);
      if (!r3.has(c5))
        continue;
      const d6 = o3.indexOf(c5);
      for (const e3 in l3.attributes) {
        const o4 = t3.fieldsIndex.normalizeFieldName(e3), r4 = a3(s3, n5.index, o4), u4 = l3.attributes[e3];
        r4.push({ featureIndex: d6, featureId: c5, value: u4 });
      }
    }
  }), s3;
}
function a3(t3, e3, n4) {
  const o2 = c(t3, e3), r2 = null != n4 && o2.get(n4);
  if (r2)
    return r2;
  const s3 = new Array();
  return o2.set(n4, s3), s3;
}
function c(t3, e3) {
  const n4 = t3.get(e3);
  if (n4)
    return n4;
  const o2 = new I();
  return t3.set(e3, o2), o2;
}
function d3(t3, n4, o2, r2) {
  const s3 = /* @__PURE__ */ new Map();
  if (!r2)
    return s3;
  for (const l2 of r2) {
    let r3 = null, u3 = null;
    "attributes" in l2 ? (r3 = n(t3, l2.attributes, n4), u3 = n(t3, l2.attributes, o2)) : (r3 = l2.objectId, u3 = l2.globalId), null != u3 && null != r3 && s3.set(u3, r3);
  }
  return s3;
}
function f3(t3) {
  const e3 = /* @__PURE__ */ new Map();
  if (!t3)
    return e3;
  for (const n4 of t3)
    null != n4.globalId && null != n4.objectId && null == n4.error && e3.set(n4.globalId, n4.objectId);
  return e3;
}
function b2(t3, e3 = null) {
  const n4 = /* @__PURE__ */ new Set();
  if (!t3)
    return n4;
  for (const o2 of t3)
    if (null == o2.error) {
      if (null != o2.objectId && -1 !== o2.objectId)
        n4.add(o2.objectId);
      else if (null != o2.globalId && null != e3) {
        const t4 = e3.get(o2.globalId);
        null != t4 && n4.add(t4);
      }
    }
  return n4;
}
!function(t3) {
  t3[t3.EDITING = 0] = "EDITING", t3[t3.ROLLED_BACK = 1] = "ROLLED_BACK", t3[t3.COMMITTED = 2] = "COMMITTED";
}(o || (o = {}));
var I = Map;
var g2 = Map;

// node_modules/@arcgis/core/views/3d/layers/support/fieldProperties.js
function i2() {
  return { requiredFields: { type: [String], readOnly: true }, availableFields: { type: [String], readOnly: true, get: function() {
    const { layer: i4, layer: { fieldsIndex: t3 }, requiredFields: l2 } = this;
    return i4.outFields ? g(t3, [...b(t3, i4.outFields), ...l2]) : g(t3, l2);
  } } };
}

// node_modules/@arcgis/core/core/AsyncUpdate.js
var i3 = (e3) => {
  let n4 = class extends e3 {
    constructor() {
      super(...arguments), this._numUpdating = 0, this._asyncUpdateState = /* @__PURE__ */ new Map();
    }
    get updating() {
      return this._numUpdating > 0;
    }
    autoUpdateAsync(t3, e4) {
      return c2((e5) => this._updateAsync(t3, e5), e4);
    }
    async _updateAsync(t3, e4) {
      if (!this._startAsyncUpdate(t3)) {
        try {
          const s3 = await e4();
          this._set(t3, s3);
        } catch (n5) {
          s.getLogger(this).warn(`Async update of "${String(t3)}" failed. Async update functions should not throw exceptions.`);
        }
        this._endAsyncUpdate(t3) && this._updateAsync(t3, e4);
      }
    }
    _startAsyncUpdate(t3) {
      const e4 = this._asyncUpdateState.get(t3) ?? p.None;
      return e4 & p.Updating ? (this._asyncUpdateState.set(t3, e4 | p.Invalidated), true) : (++this._numUpdating, this._asyncUpdateState.set(t3, e4 | p.Updating), false);
    }
    _endAsyncUpdate(t3) {
      --this._numUpdating;
      const e4 = (this._asyncUpdateState.get(t3) ?? p.None) & ~p.Updating;
      return e4 & p.Invalidated ? (this._asyncUpdateState.set(t3, e4 & ~p.Invalidated), true) : (this._asyncUpdateState.set(t3, e4), false);
    }
  };
  return e([y({ readOnly: true })], n4.prototype, "updating", null), e([y()], n4.prototype, "_numUpdating", void 0), n4 = e([a2("esri.core.AsyncUpdate")], n4), n4;
};
var p;
function c2(t3, e3) {
  const s3 = () => {
    i4 && !p3 && t3(a4);
  }, a4 = () => {
    if (!i4 || p3)
      return e3();
    i4.clear(), p3 = true;
    const t4 = f(i4, e3);
    return p3 = false, t4;
  }, r2 = () => {
    i4 && (i4.destroy(), i4 = null);
  };
  let i4 = new t(s3), p3 = false;
  return t3(a4), { remove: r2 };
}
!function(t3) {
  t3[t3.None = 0] = "None", t3[t3.Updating = 1] = "Updating", t3[t3.Invalidated = 2] = "Invalidated";
}(p || (p = {}));
var d4 = class extends i3(m2) {
};
d4 = e([a2("esri.core.AsyncUpdate")], d4);

// node_modules/@arcgis/core/views/3d/layers/support/SceneLayerViewRequiredFields.js
var d5 = "esri.views.3d.layers.support.SceneLayerViewRequiredFields";
var p2 = class extends i3(d) {
  get layer() {
    return this.layerView.layer;
  }
  get requiredFields() {
    const { layerView: { layer: { fieldsIndex: e3 }, definitionExpressionFields: r2 }, rendererFields: s3, labelingFields: t3, viewFilterFields: i4 } = this;
    return g(e3, [...r2 ?? [], ...s3 ?? [], ...t3 ?? [], ...i4 ?? []]);
  }
  constructor(e3) {
    super(e3);
  }
  initialize() {
    this.handles.add([this.autoUpdateAsync("rendererFields", async () => {
      const { fieldsIndex: e3, renderer: r2 } = this.layer;
      return r2 ? c3((s3) => r2.collectRequiredFields(s3, e3)) : null;
    }), this.autoUpdateAsync("labelingFields", async () => {
      const { layer: e3 } = this;
      return e3.labelsVisible ? c3((r2) => q(r2, e3)) : null;
    }), this.autoUpdateAsync("viewFilterFields", () => {
      const { layer: e3, filter: r2 } = this.layerView;
      return c3((s3) => L(s3, e3, r2));
    })]);
  }
};
async function c3(e3) {
  const r2 = /* @__PURE__ */ new Set();
  try {
    return await e3(r2), Array.from(r2).sort();
  } catch (s3) {
    return s.getLogger(d5).error(s3), null;
  }
}
e([y()], p2.prototype, "layerView", void 0), e([y()], p2.prototype, "layer", null), e([y()], p2.prototype, "requiredFields", null), e([y()], p2.prototype, "rendererFields", void 0), e([y()], p2.prototype, "labelingFields", void 0), e([y()], p2.prototype, "viewFilterFields", void 0), p2 = e([a2(d5)], p2);

// node_modules/@arcgis/core/views/layers/SceneLayerView.js
var f4 = "esri.views.layers.SceneLayerView";
var w = s.getLogger(f4);
var E = class extends d2 {
  constructor() {
    super(...arguments), this.layer = null, this.filter = null, this._geometryEngine = null, this._projectionEngineLoaded = false, this._abortController = new AbortController();
  }
  get availableFields() {
    return [];
  }
  get maximumNumberOfFeatures() {
    return 0;
  }
  set maximumNumberOfFeatures(e3) {
    throw new Error("Not implemented");
  }
  get maximumNumberOfFeaturesExceeded() {
    return false;
  }
  get layerFilter() {
    return t2(this._layerFilter);
  }
  get _layerFilter() {
    const e3 = this.layer.filter;
    if (null == e3 || e3.geometries.length < 1)
      return null;
    const r2 = this._geometryEngine;
    if (null == r2 || !this._projectionEngineLoaded && this._filterNeedsProjectionEngine)
      return n2;
    const o2 = e3.geometries.at(0).spatialReference, i4 = e3.geometries.toArray().map((e4) => {
      try {
        e4 = r2.simplify(e4);
      } catch (t3) {
        return w.warnOncePerTick("Failed to simplify scene filter mask polygon. Polygon will be ignored."), null;
      }
      if (null == e4)
        return null;
      if (e4.spatialReference.equals(o2))
        return e4;
      try {
        return nn(e4, o2);
      } catch (t3) {
        return w.warnOncePerTick("Failed to project scene filter mask polygon. Polygon will be ignored."), null;
      }
    }).filter(R).sort((e4, t3) => e4.extent.xmin - t3.extent.xmin), l2 = /* @__PURE__ */ new Set(), s3 = new Array(), a4 = new Array();
    for (let t3 of i4) {
      const e4 = t3.extent.xmin;
      if (s3.length = 0, l2.forEach((o3) => {
        if (e4 >= o3.extent.xmax)
          return a4.push(o3), void l2.delete(o3);
        t3.extent.ymin <= o3.extent.ymax && t3.extent.ymax >= o3.extent.ymin && r2.intersects(t3, o3) && s3.push(o3);
      }), s3.length > 0) {
        s3.push(t3);
        try {
          t3 = r2.union(s3);
        } catch (m3) {
          w.warnOncePerTick("Failed to unify filter mask polygons. Polygon will be ignored.");
          continue;
        }
        s3.pop(), s3.forEach((e5) => l2.delete(e5));
      }
      l2.add(t3);
    }
    return l2.forEach((e4) => a4.push(e4)), a4.length > 0 ? { spatialRelationship: e3.spatialRelationship, geometries: a4 } : null;
  }
  get _filterNeedsProjectionEngine() {
    const e3 = this.layer.filter;
    if (null == e3 || e3.geometries.length <= 1)
      return false;
    const t3 = e3.geometries.at(0).spatialReference;
    return e3.geometries.some(({ spatialReference: e4 }) => !e4.equals(t3) && !Cn(e4, t3));
  }
  get layerFilterUpdating() {
    return u(this._layerFilter);
  }
  initialize() {
    const { signal: e3 } = this._abortController;
    j(() => {
      var _a, _b, _c;
      return this.destroyed || !this._geometryEngine && ((_c = (_b = (_a = this.layer) == null ? void 0 : _a.filter) == null ? void 0 : _b.geometries) == null ? void 0 : _c.length);
    }, e3).then(async () => {
      f2(e3), this._geometryEngine = await import("./geometryEngine-NWIGJMDQ.js");
    }).catch(m), this._projectionEngineLoaded = Y(), j(() => this.destroyed || !this._projectionEngineLoaded && this._filterNeedsProjectionEngine, e3).then(async () => {
      f2(e3), await $(), this._projectionEngineLoaded = true;
    }).catch(m);
  }
  destroy() {
    this._abortController = e2(this._abortController);
  }
  highlight(e3) {
    throw new Error("Not implemented");
  }
  queryFeatures(e3, t3) {
    throw new Error("Not implemented");
  }
  queryObjectIds(e3, t3) {
    throw new Error("Not implemented");
  }
  queryFeatureCount(e3, t3) {
    throw new Error("Not implemented");
  }
  createQuery() {
    throw new Error("Not implemented");
  }
  queryExtent(e3, t3) {
    throw new Error("Not implemented");
  }
};
e([y()], E.prototype, "layer", void 0), e([y()], E.prototype, "availableFields", null), e([y()], E.prototype, "maximumNumberOfFeatures", null), e([y({ readOnly: true })], E.prototype, "maximumNumberOfFeaturesExceeded", null), e([y()], E.prototype, "filter", void 0), e([y({ readOnly: true })], E.prototype, "layerFilter", null), e([y({ readOnly: true })], E.prototype, "_layerFilter", null), e([y()], E.prototype, "_geometryEngine", void 0), e([y()], E.prototype, "_projectionEngineLoaded", void 0), e([y()], E.prototype, "_filterNeedsProjectionEngine", null), e([y()], E.prototype, "layerFilterUpdating", null), E = e([a2(f4)], E);
var j2 = E;

export {
  r,
  s2 as s,
  l,
  i2 as i,
  p2 as p,
  j2 as j
};
//# sourceMappingURL=chunk-IGOMD64Y.js.map
