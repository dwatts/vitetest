import {
  c,
  f as f2,
  i,
  u
} from "./chunk-WLMHEQN2.js";
import "./chunk-Y4ZO2DJL.js";
import "./chunk-XKENZ7D5.js";
import {
  e
} from "./chunk-XY26YCFX.js";
import {
  n as n2,
  r
} from "./chunk-3TTW7E7W.js";
import {
  S
} from "./chunk-OKABUMQT.js";
import "./chunk-TYOIANOD.js";
import "./chunk-VN2IXVGV.js";
import "./chunk-BN6X2OXK.js";
import "./chunk-NX5NNI52.js";
import "./chunk-G2DTL6AE.js";
import {
  yn
} from "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-RRJGZKNX.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-4OR73Y2R.js";
import "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import {
  E
} from "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-3VUFACNT.js";
import {
  f
} from "./chunk-ZEEBL7ZN.js";
import "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import "./chunk-V76KGJFU.js";
import "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import "./chunk-7I33FAWS.js";
import "./chunk-DWOEYHKS.js";
import "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  R,
  n2 as n
} from "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/3d/layers/PointCloudWorker.js
var c2 = class {
  transform(t) {
    const e2 = this._transform(t), a = [e2.points.buffer, e2.rgb.buffer];
    null != e2.pointIdFilterMap && a.push(e2.pointIdFilterMap.buffer);
    for (const o of e2.attributes)
      "buffer" in o.values && n(o.values.buffer) && o.values.buffer !== e2.rgb.buffer && a.push(o.values.buffer);
    return Promise.resolve({ result: e2, transferList: a });
  }
  _transform(r2) {
    const e2 = u(r2.schema, r2.geometryBuffer);
    let a = e2.length / 3, o = null;
    const n3 = new Array(), f3 = c(r2.primaryAttributeData, e2, a);
    null != r2.primaryAttributeData && f3 && n3.push({ attributeInfo: r2.primaryAttributeData.attributeInfo, values: f3 });
    const i2 = c(r2.modulationAttributeData, e2, a);
    null != r2.modulationAttributeData && i2 && n3.push({ attributeInfo: r2.modulationAttributeData.attributeInfo, values: i2 });
    let c3 = i(r2.rendererInfo, f3, i2, a);
    if (r2.filterInfo && r2.filterInfo.length > 0 && null != r2.filterAttributesData) {
      const f4 = r2.filterAttributesData.filter(R).map((t) => {
        const r3 = c(t, e2, a), o2 = { attributeInfo: t.attributeInfo, values: r3 };
        return n3.push(o2), o2;
      });
      o = new Uint32Array(a), a = f2(e2, c3, o, r2.filterInfo, f4);
    }
    for (const t of r2.userAttributesData) {
      const r3 = c(t, e2, a);
      n3.push({ attributeInfo: t.attributeInfo, values: r3 });
    }
    3 * a < c3.length && (c3 = new Uint8Array(c3.buffer.slice(0, 3 * a))), this._applyElevationOffsetInPlace(e2, a, r2.elevationOffset);
    const p2 = this._transformCoordinates(e2, a, r2.obb, f.fromJSON(r2.inSR), f.fromJSON(r2.outSR));
    return { obb: r2.obb, points: p2, rgb: c3, attributes: n3, pointIdFilterMap: o };
  }
  _transformCoordinates(t, r2, a, s, u2) {
    if (!yn(t, s, 0, t, u2, 0, r2))
      throw new Error("Can't reproject");
    const l = r(a.center[0], a.center[1], a.center[2]), b = n2(), m = n2();
    S(p, a.quaternion);
    const c3 = new Float32Array(3 * r2);
    for (let e2 = 0; e2 < r2; e2++)
      b[0] = t[3 * e2] - l[0], b[1] = t[3 * e2 + 1] - l[1], b[2] = t[3 * e2 + 2] - l[2], E(m, b, p), a.halfSize[0] = Math.max(a.halfSize[0], Math.abs(m[0])), a.halfSize[1] = Math.max(a.halfSize[1], Math.abs(m[1])), a.halfSize[2] = Math.max(a.halfSize[2], Math.abs(m[2])), c3[3 * e2] = b[0], c3[3 * e2 + 1] = b[1], c3[3 * e2 + 2] = b[2];
    return c3;
  }
  _applyElevationOffsetInPlace(t, r2, e2) {
    if (0 !== e2)
      for (let a = 0; a < r2; a++)
        t[3 * a + 2] += e2;
  }
};
var p = e();
function h() {
  return new c2();
}
export {
  h as default
};
//# sourceMappingURL=PointCloudWorker-FRS5GNEI.js.map
