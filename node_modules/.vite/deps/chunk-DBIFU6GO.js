import {
  C
} from "./chunk-2EO2WRP7.js";
import {
  R as R2,
  j,
  r as r6,
  s as s6
} from "./chunk-CERU5LKM.js";
import {
  s as s5
} from "./chunk-JZVYLVFO.js";
import {
  n as n4,
  r as r5
} from "./chunk-BDX5TRUE.js";
import {
  A as A2,
  E as E2,
  _ as _5,
  c as c2,
  l as l6
} from "./chunk-LIXBKTBN.js";
import {
  P as P2,
  e as e5,
  f,
  i as i3,
  l as l7,
  m,
  o as o5,
  r as r4,
  s as s4
} from "./chunk-VDSNHCMM.js";
import {
  E as E3
} from "./chunk-6LC2JTLC.js";
import {
  e as e4,
  i as i2,
  t as t4
} from "./chunk-V6CD66ZZ.js";
import {
  W as W3,
  _ as _4,
  a as a2
} from "./chunk-6FHMQNMS.js";
import {
  t as t5
} from "./chunk-YQDOKTNT.js";
import {
  d2 as d,
  e as e3,
  o2 as o3,
  r as r3
} from "./chunk-SMDDCTGQ.js";
import {
  t as t3
} from "./chunk-FB4A6PBH.js";
import {
  o as o4
} from "./chunk-SADO52IH.js";
import {
  h as h2
} from "./chunk-73PNWDTS.js";
import {
  t as t2
} from "./chunk-JP7O2ZWE.js";
import {
  W as W2
} from "./chunk-Z6R62RNV.js";
import {
  l as l5
} from "./chunk-3LLZ72VA.js";
import {
  M,
  b,
  k,
  v
} from "./chunk-4SIKLJSS.js";
import {
  H as H2
} from "./chunk-Z7LZRT7C.js";
import {
  l as l3,
  s as s3
} from "./chunk-SGBMUZSF.js";
import {
  E
} from "./chunk-BCDDCNQ2.js";
import {
  R,
  W,
  _ as _3,
  h,
  l as l4
} from "./chunk-FOEAKQNX.js";
import {
  _ as _2
} from "./chunk-LEDSC236.js";
import {
  e as e2,
  o as o2
} from "./chunk-CW7LIPBH.js";
import {
  O as O2
} from "./chunk-BN6X2OXK.js";
import {
  _
} from "./chunk-YGUWDSEH.js";
import {
  a
} from "./chunk-NLWV7Q6F.js";
import {
  H,
  c,
  n as n3
} from "./chunk-7EG7BYWF.js";
import {
  x as x2
} from "./chunk-DOQ3SAAR.js";
import {
  i
} from "./chunk-TEHNQYQD.js";
import {
  A,
  F,
  O,
  P,
  e,
  g,
  o,
  r as r2,
  s as s2,
  u,
  x
} from "./chunk-TPJLFGOT.js";
import {
  n,
  r
} from "./chunk-CQX57DED.js";
import {
  n as n2
} from "./chunk-7KH4CLS5.js";
import {
  t2 as t
} from "./chunk-V76KGJFU.js";
import {
  l as l2
} from "./chunk-HB2SQRT2.js";
import {
  l
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import {
  has
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DirtyEvents.js
var e6 = ["layerObjectAdded", "layerObjectRemoved", "layerObjectsAdded", "layerObjectsRemoved", "shaderTransformationChanged", "objectTransformation", "visibilityChanged", "occlusionChanged", "highlightChanged", "objectGeometryAdded", "objectGeometryRemoved", "objectGeometryUpdated"];

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/WebGLLayer.js
var c3 = class extends r3 {
  get objects() {
    return this._objects;
  }
  constructor(s7, i4, h3 = "") {
    super(), this.stage = s7, this.apiLayerUid = h3, this.type = e3.Layer, this.events = new n2(), this.sliceable = false, this._objects = new l2(), this._objectsAdded = new l2(), this._handles = new t(), this.apiLayerUid = h3, this.visible = (i4 == null ? void 0 : i4.visible) ?? true, this.pickable = (i4 == null ? void 0 : i4.pickable) ?? true, this.updatePolicy = (i4 == null ? void 0 : i4.updatePolicy) ?? C.ASYNC, this._disableOctree = (i4 == null ? void 0 : i4.disableOctree) ?? false, s7.add(this);
    for (const e7 of e6)
      this._handles.add(this.events.on(e7, (t6) => s7.handleEvent(e7, t6)));
  }
  destroy() {
    this._handles.size && (this._handles.destroy(), this.stage.remove(this), this.invalidateSpatialQueryAccelerator());
  }
  add(e7) {
    this._objects.push(e7), e7.parentLayer = this, this.events.emit("layerObjectAdded", { layer: this, object: e7 }), null != this._octree && this._objectsAdded.push(e7);
  }
  remove(e7) {
    this._objects.removeUnordered(e7) && (e7.parentLayer = null, this.events.emit("layerObjectRemoved", { layer: this, object: e7 }), null != this._octree && (this._objectsAdded.removeUnordered(e7) || this._octree.remove([e7])));
  }
  addMany(e7) {
    this._objects.pushArray(e7);
    for (const t6 of e7)
      t6.parentLayer = this;
    this.events.emit("layerObjectsAdded", { layer: this, objects: e7 }), null != this._octree && this._objectsAdded.pushArray(e7);
  }
  removeMany(e7) {
    const t6 = new Array();
    if (this._objects.removeUnorderedMany(e7, e7.length, t6), 0 !== t6.length) {
      for (const e8 of t6)
        e8.parentLayer = null;
      if (this.events.emit("layerObjectsRemoved", { layer: this, objects: t6 }), null != this._octree) {
        for (let e8 = 0; e8 < t6.length; )
          this._objectsAdded.removeUnordered(t6[e8]) ? (t6[e8] = t6[t6.length - 1], t6.length -= 1) : ++e8;
        this._octree.remove(t6);
      }
    }
  }
  sync() {
    this.updatePolicy !== C.SYNC && this.stage.syncLayer(this.id);
  }
  notifyObjectBBChanged(e7, t6) {
    null == this._octree || this._objectsAdded.includes(e7) || this._octree.update(e7, t6);
  }
  getSpatialQueryAccelerator() {
    return null == this._octree && this._objects.length > 50 && !this._disableOctree ? (this._octree = new W2((e7) => e7.boundingVolumeWorldSpace.bounds), this._octree.add(this._objects.data, this._objects.length)) : null != this._octree && this._objectsAdded.length > 0 && (this._octree.add(this._objectsAdded.data, this._objectsAdded.length), this._objectsAdded.clear()), this._octree;
  }
  shaderTransformationChanged() {
    this.invalidateSpatialQueryAccelerator(), this.events.emit("shaderTransformationChanged", this);
  }
  invalidateSpatialQueryAccelerator() {
    this._octree = l(this._octree), this._objectsAdded.clear();
  }
};
function n5(e7) {
  return null != e7 && e7.type === e3.Layer;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/RibbonLineTechnique.js
var I = /* @__PURE__ */ new Map([[O2.POSITION, 0], [O2.SUBDIVISIONFACTOR, 1], [O2.UV0, 2], [O2.AUXPOS1, 3], [O2.AUXPOS2, 4], [O2.COLOR, 5], [O2.COLORFEATUREATTRIBUTE, 5], [O2.SIZE, 6], [O2.SIZEFEATUREATTRIBUTE, 6], [O2.OPACITYFEATUREATTRIBUTE, 7], [O2.OBJECTANDLAYERIDCOLOR, 8]]);
var y = class _y extends e4 {
  initializeProgram(e7) {
    return new i2(e7.rctx, _y.shader.get().build(this.configuration), I);
  }
  _makePipelineState(t6, i4) {
    const c4 = this.configuration, a3 = t6 === o4.NONE, d2 = t6 === o4.FrontFace;
    return W3({ blending: c4.output === h2.Color || c4.output === h2.Alpha ? a3 ? c2 : A2(t6) : null, depthTest: { func: l6(t6) }, depthWrite: a3 ? c4.writeDepth ? a2 : null : E2(t6), colorWrite: _4, stencilWrite: c4.hasOccludees ? e5 : null, stencilTest: c4.hasOccludees ? i4 ? o5 : f : null, polygonOffset: a3 || d2 ? c4.hasPolygonOffset ? _6 : null : _5 });
  }
  initializePipeline() {
    const e7 = this.configuration;
    if (e7.occluder) {
      const t6 = e7.hasPolygonOffset ? _6 : null;
      this._occluderPipelineTransparent = W3({ blending: c2, polygonOffset: t6, depthTest: s4, depthWrite: null, colorWrite: _4, stencilWrite: null, stencilTest: m }), this._occluderPipelineOpaque = W3({ blending: c2, polygonOffset: t6, depthTest: s4, depthWrite: null, colorWrite: _4, stencilWrite: l7, stencilTest: P2 }), this._occluderPipelineMaskWrite = W3({ blending: null, polygonOffset: t6, depthTest: i3, depthWrite: null, colorWrite: null, stencilWrite: e5, stencilTest: o5 });
    }
    return this._occludeePipelineState = this._makePipelineState(this.configuration.transparencyPassType, true), this._makePipelineState(this.configuration.transparencyPassType, false);
  }
  get primitiveType() {
    return this.configuration.wireframe ? E.LINES : E.TRIANGLE_STRIP;
  }
  getPipelineState(e7, t6) {
    return t6 ? this._occludeePipelineState : this.configuration.occluder ? e7 === E3.TRANSPARENT_OCCLUDER_MATERIAL ? this._occluderPipelineTransparent : e7 === E3.OCCLUDER_MATERIAL ? this._occluderPipelineOpaque : this._occluderPipelineMaskWrite : super.getPipelineState(e7, t6);
  }
};
y.shader = new t4(R2, () => import("./RibbonLine.glsl-YJCKAF7V.js"));
var _6 = { factor: 0, units: -4 };

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/RibbonLineMaterial.js
var J;
!function(e7) {
  e7[e7.LEFT_JOIN_START = -2] = "LEFT_JOIN_START", e7[e7.LEFT_JOIN_END = -1] = "LEFT_JOIN_END", e7[e7.LEFT_CAP_START = -4] = "LEFT_CAP_START", e7[e7.LEFT_CAP_END = -5] = "LEFT_CAP_END", e7[e7.RIGHT_JOIN_START = 2] = "RIGHT_JOIN_START", e7[e7.RIGHT_JOIN_END = 1] = "RIGHT_JOIN_END", e7[e7.RIGHT_CAP_START = 4] = "RIGHT_CAP_START", e7[e7.RIGHT_CAP_END = 5] = "RIGHT_CAP_END";
}(J || (J = {}));
var B = class extends d {
  constructor(e7) {
    super(e7, new G()), this._configuration = new s6(), this._vertexAttributeLocations = I;
  }
  isClosed(e7, t6) {
    return V(this.parameters, e7, t6);
  }
  getConfiguration(e7, t6) {
    this._configuration.output = e7, this._configuration.draped = t6.slot === E3.DRAPED_MATERIAL;
    const r7 = null != this.parameters.stipplePattern && e7 !== h2.Highlight;
    return this._configuration.stippleEnabled = r7, this._configuration.stippleOffColorEnabled = r7 && null != this.parameters.stippleOffColor, this._configuration.stippleScaleWithLineWidth = r7 && this.parameters.stippleScaleWithLineWidth, this._configuration.stipplePreferContinuous = r7 && this.parameters.stipplePreferContinuous, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.hasOccludees = this.parameters.hasOccludees, this._configuration.roundJoins = "round" === this.parameters.join, this._configuration.capType = this.parameters.cap, this._configuration.applyMarkerOffset = null != this.parameters.markerParameters && Z(this.parameters.markerParameters), this._configuration.hasPolygonOffset = this.parameters.hasPolygonOffset, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.vvSize = !!this.parameters.vvSize, this._configuration.vvColor = !!this.parameters.vvColor, this._configuration.vvOpacity = !!this.parameters.vvOpacity, this._configuration.innerColorEnabled = this.parameters.innerWidth > 0 && null != this.parameters.innerColor, this._configuration.falloffEnabled = this.parameters.falloff > 0, this._configuration.occluder = this.parameters.renderOccluded === o3.OccludeAndTransparentStencil, this._configuration.transparencyPassType = t6.transparencyPassType, this._configuration.hasMultipassTerrain = t6.multipassTerrain.enabled, this._configuration.cullAboveGround = t6.multipassTerrain.cullAboveGround, this._configuration.wireframe = this.parameters.wireframe, this._configuration;
  }
  intersectDraped(e7, r7, i4, s7, a3, n6) {
    if (!i4.options.selectionMode)
      return;
    const o6 = e7.vertexAttributes.get(O2.POSITION).data, l8 = e7.vertexAttributes.get(O2.SIZE);
    let c4 = this.parameters.width;
    if (this.parameters.vvSize) {
      const r8 = e7.vertexAttributes.get(O2.SIZEFEATUREATTRIBUTE).data[0];
      c4 *= i(this.parameters.vvSize.offset[0] + r8 * this.parameters.vvSize.factor[0], this.parameters.vvSize.minSize[0], this.parameters.vvSize.maxSize[0]);
    } else
      l8 && (c4 *= l8.data[0]);
    const h3 = s7[0], u2 = s7[1], p = (c4 / 2 + 4) * e7.screenToWorldRatio;
    let m2 = Number.MAX_VALUE, f2 = 0;
    for (let T2 = 0; T2 < o6.length - 5; T2 += 3) {
      const e8 = o6[T2], r8 = o6[T2 + 1], i5 = h3 - e8, s8 = u2 - r8, a4 = o6[T2 + 3] - e8, n7 = o6[T2 + 4] - r8, l9 = i((a4 * i5 + n7 * s8) / (a4 * a4 + n7 * n7), 0, 1), c5 = a4 * l9 - i5, p2 = n7 * l9 - s8, _7 = c5 * c5 + p2 * p2;
      _7 < m2 && (m2 = _7, f2 = T2 / 3);
    }
    m2 < p * p && a3(n6.dist, n6.normal, f2, false);
  }
  intersect(r7, p, m2, f2, _7, v2) {
    if (!m2.options.selectionMode || !r7.visible)
      return;
    if (!l3(p))
      return void s.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");
    const I2 = r7.vertexAttributes, O4 = I2.get(O2.POSITION).data;
    let b2 = this.parameters.width;
    if (this.parameters.vvSize) {
      const e7 = I2.get(O2.SIZEFEATUREATTRIBUTE).data[0];
      b2 *= i(this.parameters.vvSize.offset[0] + e7 * this.parameters.vvSize.factor[0], this.parameters.vvSize.minSize[0], this.parameters.vvSize.maxSize[0]);
    } else
      I2.has(O2.SIZE) && (b2 *= I2.get(O2.SIZE).data[0]);
    const P3 = m2.camera, L2 = K;
    a(L2, m2.point);
    const N = b2 * P3.pixelRatio / 2 + 4 * P3.pixelRatio;
    o(le[0], L2[0] - N, L2[1] + N, 0), o(le[1], L2[0] + N, L2[1] + N, 0), o(le[2], L2[0] + N, L2[1] - N, 0), o(le[3], L2[0] - N, L2[1] - N, 0);
    for (let e7 = 0; e7 < 4; e7++)
      if (!P3.unprojectFromRenderScreen(le[e7], ce[e7]))
        return;
    _3(P3.eye, ce[0], ce[1], he), _3(P3.eye, ce[1], ce[2], ue), _3(P3.eye, ce[2], ce[3], pe), _3(P3.eye, ce[3], ce[0], me);
    let j2 = Number.MAX_VALUE, D = 0;
    const U2 = W4(this.parameters, I2, r7.indices) ? O4.length - 2 : O4.length - 5;
    for (let e7 = 0; e7 < U2; e7 += 3) {
      q[0] = O4[e7] + p[12], q[1] = O4[e7 + 1] + p[13], q[2] = O4[e7 + 2] + p[14];
      const t6 = (e7 + 3) % O4.length;
      if (X[0] = O4[t6] + p[12], X[1] = O4[t6 + 1] + p[13], X[2] = O4[t6 + 2] + p[14], R(he, q) < 0 && R(he, X) < 0 || R(ue, q) < 0 && R(ue, X) < 0 || R(pe, q) < 0 && R(pe, X) < 0 || R(me, q) < 0 && R(me, X) < 0)
        continue;
      if (P3.projectToRenderScreen(q, $), P3.projectToRenderScreen(X, ee), $[2] < 0 && ee[2] > 0) {
        e(Y, q, X);
        const e8 = P3.frustum, t7 = -R(e8[l5.NEAR], q) / P(Y, W(e8[l5.NEAR]));
        g(Y, Y, t7), u(q, q, Y), P3.projectToRenderScreen(q, $);
      } else if ($[2] > 0 && ee[2] < 0) {
        e(Y, X, q);
        const e8 = P3.frustum, t7 = -R(e8[l5.NEAR], X) / P(Y, W(e8[l5.NEAR]));
        g(Y, Y, t7), u(X, X, Y), P3.projectToRenderScreen(X, ee);
      } else if ($[2] < 0 && ee[2] < 0)
        continue;
      $[2] = 0, ee[2] = 0;
      const r8 = M(b($, ee, ie), L2);
      r8 < j2 && (j2 = r8, r2(te, q), r2(re, X), D = e7 / 3);
    }
    const x4 = m2.rayBegin, F2 = m2.rayEnd;
    if (j2 < N * N) {
      let e7 = Number.MAX_VALUE;
      if (k(b(te, re, ie), b(x4, F2, se), Q)) {
        e(Q, Q, x4);
        const t6 = s2(Q);
        g(Q, Q, 1 / t6), e7 = t6 / x(x4, F2);
      }
      v2(e7, Q, D, false);
    }
  }
  get _layout() {
    const e7 = H2().vec3f(O2.POSITION).f32(O2.SUBDIVISIONFACTOR).vec2f(O2.UV0).vec3f(O2.AUXPOS1).vec3f(O2.AUXPOS2);
    return this.parameters.vvSize ? e7.f32(O2.SIZEFEATUREATTRIBUTE) : e7.f32(O2.SIZE), this.parameters.vvColor ? e7.f32(O2.COLORFEATUREATTRIBUTE) : e7.vec4f(O2.COLOR), this.parameters.vvOpacity && e7.f32(O2.OPACITYFEATUREATTRIBUTE), has("enable-feature:objectAndLayerId-rendering") && e7.vec4u8(O2.OBJECTANDLAYERIDCOLOR), e7;
  }
  createBufferWriter() {
    return new H3(this._layout, this.parameters);
  }
  requiresSlot(e7, t6) {
    if (t6 === h2.Color || t6 === h2.Alpha || t6 === h2.Highlight || t6 === h2.Depth || t6 === h2.ObjectAndLayerIdColor) {
      if (e7 === E3.DRAPED_MATERIAL)
        return true;
      if (this.parameters.renderOccluded === o3.OccludeAndTransparentStencil)
        return e7 === E3.OPAQUE_MATERIAL || e7 === E3.OCCLUDER_MATERIAL || e7 === E3.TRANSPARENT_OCCLUDER_MATERIAL;
      if (t6 === h2.Color || t6 === h2.Alpha) {
        return e7 === (this.parameters.writeDepth ? E3.TRANSPARENT_MATERIAL : E3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL);
      }
      return e7 === E3.OPAQUE_MATERIAL;
    }
    return false;
  }
  createGLMaterial(e7) {
    return new z(e7);
  }
  validateParameters(e7) {
    "miter" !== e7.join && (e7.miterLimit = 0), null != e7.markerParameters && (e7.markerScale = e7.markerParameters.width / e7.width);
  }
};
var z = class extends t3 {
  constructor() {
    super(...arguments), this._stipplePattern = null;
  }
  dispose() {
    super.dispose(), this._stippleTextureRepository.release(this._stipplePattern), this._stipplePattern = null;
  }
  _updateOccludeeState(e7) {
    e7.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e7.hasOccludees });
  }
  beginSlot(e7) {
    this._output !== h2.Color && this._output !== h2.Alpha || this._updateOccludeeState(e7);
    const t6 = this._material.parameters.stipplePattern;
    return this._stipplePattern !== t6 && (this._material.setParameters({ stippleTexture: this._stippleTextureRepository.swap(t6, this._stipplePattern) }), this._stipplePattern = t6), this.ensureTechnique(y, e7);
  }
};
var G = class extends t5 {
  constructor() {
    super(...arguments), this.width = 0, this.color = _, this.join = "miter", this.cap = r6.BUTT, this.miterLimit = 5, this.writeDepth = true, this.hasPolygonOffset = false, this.stippleTexture = null, this.stippleScaleWithLineWidth = false, this.stipplePreferContinuous = true, this.markerParameters = null, this.markerScale = 1, this.hasSlicePlane = false, this.vvFastUpdate = false, this.isClosed = false, this.falloff = 0, this.innerWidth = 0, this.hasOccludees = false, this.wireframe = false;
  }
};
var H3 = class {
  constructor(e7, t6) {
    this._parameters = t6, this.numJoinSubdivisions = 0, this.vertexBufferLayout = e7;
    const r7 = t6.stipplePattern ? 1 : 0;
    switch (this._parameters.join) {
      case "miter":
      case "bevel":
        this.numJoinSubdivisions = r7;
        break;
      case "round":
        this.numJoinSubdivisions = j + r7;
    }
  }
  _isClosed(e7) {
    return W4(this._parameters, e7.vertexAttributes, e7.indices);
  }
  allocate(e7) {
    return this.vertexBufferLayout.createBuffer(e7);
  }
  elementCount(e7) {
    const t6 = 2, r7 = e7.indices.get(O2.POSITION).length / 2 + 1, i4 = this._isClosed(e7);
    let s7 = i4 ? 2 : 2 * t6;
    return s7 += ((i4 ? r7 : r7 - 1) - (i4 ? 0 : 1)) * (2 * this.numJoinSubdivisions + 4), s7 += 2, this._parameters.wireframe && (s7 = 2 + 4 * (s7 - 2)), s7;
  }
  write(e7, t6, r7, i4, a3) {
    var _a;
    const n6 = ae, o6 = ne, l8 = oe, h3 = r7.vertexAttributes.get(O2.POSITION).data, m2 = r7.indices && r7.indices.get(O2.POSITION), f2 = (_a = r7.vertexAttributes.get(O2.DISTANCETOSTART)) == null ? void 0 : _a.data;
    m2 && m2.length !== 2 * (h3.length / 3 - 1) && console.warn("RibbonLineMaterial does not support indices");
    let T2 = 1, _7 = 0;
    this._parameters.vvSize ? _7 = r7.vertexAttributes.get(O2.SIZEFEATUREATTRIBUTE).data[0] : r7.vertexAttributes.has(O2.SIZE) && (T2 = r7.vertexAttributes.get(O2.SIZE).data[0]);
    let d2 = [1, 1, 1, 1], A4 = 0;
    this._parameters.vvColor ? A4 = r7.vertexAttributes.get(O2.COLORFEATUREATTRIBUTE).data[0] : r7.vertexAttributes.has(O2.COLOR) && (d2 = r7.vertexAttributes.get(O2.COLOR).data);
    const E4 = has("enable-feature:objectAndLayerId-rendering") ? r7.objectAndLayerIdColor : null;
    let v2 = 0;
    this._parameters.vvOpacity && (v2 = r7.vertexAttributes.get(O2.OPACITYFEATUREATTRIBUTE).data[0]);
    const R3 = h3.length / 3, S = new Float32Array(i4.buffer), g2 = has("enable-feature:objectAndLayerId-rendering") ? new Uint8Array(i4.buffer) : null, I2 = this.vertexBufferLayout.stride / 4;
    let O4 = a3 * I2;
    const b2 = O4;
    let P3 = 0;
    const L2 = f2 ? (e8, t7, r8) => P3 = f2[r8] : (e8, t7, r8) => P3 += x(e8, t7), N = has("enable-feature:objectAndLayerId-rendering"), C2 = (e8, t7, r8, i5, s7, a4, n7) => {
      if (S[O4++] = t7[0], S[O4++] = t7[1], S[O4++] = t7[2], S[O4++] = i5, S[O4++] = n7, S[O4++] = s7, S[O4++] = e8[0], S[O4++] = e8[1], S[O4++] = e8[2], S[O4++] = r8[0], S[O4++] = r8[1], S[O4++] = r8[2], S[O4++] = this._parameters.vvSize ? _7 : T2, this._parameters.vvColor)
        S[O4++] = A4;
      else {
        const e9 = Math.min(4 * a4, d2.length - 4);
        S[O4++] = d2[e9], S[O4++] = d2[e9 + 1], S[O4++] = d2[e9 + 2], S[O4++] = d2[e9 + 3];
      }
      this._parameters.vvOpacity && (S[O4++] = v2), N && (null != E4 && (g2[4 * O4] = E4[0], g2[4 * O4 + 1] = E4[1], g2[4 * O4 + 2] = E4[2], g2[4 * O4 + 3] = E4[3]), O4++);
    };
    O4 += I2, o(o6, h3[0], h3[1], h3[2]), e7 && O(o6, o6, e7);
    const j2 = this._isClosed(r7);
    if (j2) {
      const t7 = h3.length - 3;
      o(n6, h3[t7], h3[t7 + 1], h3[t7 + 2]), e7 && O(n6, n6, e7);
    } else
      o(l8, h3[3], h3[4], h3[5]), e7 && O(l8, l8, e7), C2(o6, o6, l8, 1, J.LEFT_CAP_START, 0, 0), C2(o6, o6, l8, 1, J.RIGHT_CAP_START, 0, 0), r2(n6, o6), r2(o6, l8);
    const D = j2 ? 0 : 1, U2 = j2 ? R3 : R3 - 1;
    for (let u2 = D; u2 < U2; u2++) {
      const t7 = (u2 + 1) % R3 * 3;
      o(l8, h3[t7], h3[t7 + 1], h3[t7 + 2]), e7 && O(l8, l8, e7), L2(n6, o6, u2), C2(n6, o6, l8, 0, J.LEFT_JOIN_END, u2, P3), C2(n6, o6, l8, 0, J.RIGHT_JOIN_END, u2, P3);
      const r8 = this.numJoinSubdivisions;
      for (let e8 = 0; e8 < r8; ++e8) {
        const t8 = (e8 + 1) / (r8 + 1);
        C2(n6, o6, l8, t8, J.LEFT_JOIN_END, u2, P3), C2(n6, o6, l8, t8, J.RIGHT_JOIN_END, u2, P3);
      }
      C2(n6, o6, l8, 1, J.LEFT_JOIN_START, u2, P3), C2(n6, o6, l8, 1, J.RIGHT_JOIN_START, u2, P3), r2(n6, o6), r2(o6, l8);
    }
    j2 ? (o(l8, h3[3], h3[4], h3[5]), e7 && O(l8, l8, e7), P3 = L2(n6, o6, U2), C2(n6, o6, l8, 0, J.LEFT_JOIN_END, D, P3), C2(n6, o6, l8, 0, J.RIGHT_JOIN_END, D, P3)) : (P3 = L2(n6, o6, U2), C2(n6, o6, o6, 0, J.LEFT_CAP_END, U2, P3), C2(n6, o6, o6, 0, J.RIGHT_CAP_END, U2, P3)), k2(S, b2 + I2, S, b2, I2);
    O4 = k2(S, O4 - I2, S, O4, I2), this._parameters.wireframe && this._addWireframeVertices(i4, b2, O4, I2);
  }
  _addWireframeVertices(e7, t6, r7, i4) {
    const s7 = new Float32Array(e7.buffer, r7 * Float32Array.BYTES_PER_ELEMENT), a3 = new Float32Array(e7.buffer, t6 * Float32Array.BYTES_PER_ELEMENT, r7 - t6);
    let n6 = 0;
    const o6 = (e8) => n6 = k2(a3, e8, s7, n6, i4);
    for (let l8 = 0; l8 < a3.length - 1; l8 += 2 * i4)
      o6(l8), o6(l8 + 2 * i4), o6(l8 + 1 * i4), o6(l8 + 2 * i4), o6(l8 + 1 * i4), o6(l8 + 3 * i4);
  }
};
function k2(e7, t6, r7, i4, s7) {
  for (let a3 = 0; a3 < s7; a3++)
    r7[i4++] = e7[t6++];
  return i4;
}
function W4(e7, t6, r7) {
  return V(e7, t6.get(O2.POSITION).data, r7 ? r7.get(O2.POSITION) : null);
}
function V(e7, t6, r7) {
  return !!e7.isClosed && (r7 ? r7.length > 2 : t6.length > 6);
}
function Z(e7) {
  return e7.anchor === s5.Tip && e7.hideOnShortSegments && "begin-end" === e7.placement && e7.worldSpace;
}
var q = n();
var X = n();
var Y = n();
var Q = n();
var K = n();
var $ = x2();
var ee = x2();
var te = n();
var re = n();
var ie = v();
var se = v();
var ae = n();
var ne = n();
var oe = n();
var le = [x2(), x2(), x2(), x2()];
var ce = [n(), n(), n(), n()];
var he = h();
var ue = h();
var pe = h();
var me = h();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Object3D.js
var V2 = class extends r3 {
  get geometries() {
    return this._geometries;
  }
  get transformation() {
    return this._transformation ?? o2;
  }
  set transformation(e7) {
    this._transformation = n3(this._transformation ?? e2(), e7), this._invalidateBoundingVolume(), this._emit("objectTransformation", this);
  }
  get shaderTransformation() {
    return this._shaderTransformation ?? this.transformation;
  }
  set shaderTransformation(e7) {
    this._shaderTransformation = n3(this._shaderTransformation ?? e2(), e7), this._invalidateBoundingVolume(), this._emit("objectShaderTransformation", this);
  }
  clearShaderTransformation() {
    this._shaderTransformation = void 0, this._invalidateBoundingVolume(), this._emit("objectShaderTransformation", this);
  }
  constructor(t6 = {}) {
    super(), this.type = e3.Object, this._hasVolatileTransformation = false, this._parentLayer = null, this._visible = true, this.castShadow = t6.castShadow ?? true, this.usesVerticalDistanceToGround = t6.usesVerticalDistanceToGround ?? false, this.graphicUid = t6.graphicUid, this.layerUid = t6.layerUid, t6.isElevationSource && (this.lastValidElevationBB = new T()), this._geometries = t6.geometries ? Array.from(t6.geometries) : new Array();
  }
  dispose() {
    this._geometries.length = 0;
  }
  get parentLayer() {
    return this._parentLayer;
  }
  set parentLayer(t6) {
    s3(null == this._parentLayer || null == t6, "Object3D can only be added to a single Layer"), this._parentLayer = t6;
  }
  addGeometry(t6) {
    t6.visible = this._visible, this._geometries.push(t6), this._hasVolatileTransformation = this._hasVolatileTransformation || t6.hasVolatileTransformation, this._emit("objectGeometryAdded", { object: this, geometry: t6 }), this._invalidateBoundingVolume();
  }
  removeGeometry(t6) {
    const e7 = this._geometries.splice(t6, 1)[0];
    e7 && (this._emit("objectGeometryRemoved", { object: this, geometry: e7 }), this._invalidateBoundingVolume());
  }
  removeAllGeometries() {
    for (; this._geometries.length > 0; )
      this.removeGeometry(0);
  }
  geometryVertexAttrsUpdated(t6) {
    this._emit("objectGeometryUpdated", { object: this, geometry: t6 }), this._invalidateBoundingVolume();
  }
  get visible() {
    return this._visible;
  }
  set visible(t6) {
    if (this._visible !== t6) {
      this._visible = t6;
      for (const t7 of this._geometries)
        t7.visible = this._visible;
      this._emit("visibilityChanged", this);
    }
  }
  maskOccludee() {
    const t6 = new r4(t2.MaskOccludee);
    for (const e7 of this._geometries)
      e7.occludees = n4(e7.occludees, t6);
    return this._emit("occlusionChanged", this), t6;
  }
  removeOcclude(t6) {
    for (const e7 of this._geometries)
      e7.occludees = r5(e7.occludees, t6);
    this._emit("occlusionChanged", this);
  }
  highlight() {
    const t6 = new r4(t2.Highlight);
    for (const e7 of this._geometries)
      e7.highlights = n4(e7.highlights, t6);
    return this._emit("highlightChanged", this), t6;
  }
  removeHighlight(t6) {
    for (const e7 of this._geometries)
      e7.highlights = r5(e7.highlights, t6);
    this._emit("highlightChanged", this);
  }
  getCombinedStaticTransformation(t6, i4) {
    return c(i4, this.transformation, t6.transformation);
  }
  getCombinedShaderTransformation(t6, i4 = e2()) {
    return c(i4, this.shaderTransformation, t6.shaderTransformation);
  }
  hasVolativeTransformation() {
    return this._hasVolatileTransformation;
  }
  get boundingVolumeWorldSpace() {
    return this._bvWorldSpace && !this._hasVolatileTransformation || (this._bvWorldSpace = this._bvWorldSpace || new x3(), this._validateBoundingVolume(this._bvWorldSpace, U.WorldSpace)), this._bvWorldSpace;
  }
  get boundingVolumeObjectSpace() {
    return this._bvObjectSpace && !this._hasVolatileTransformation || (this._bvObjectSpace = this._bvObjectSpace || new x3(), this._validateBoundingVolume(this._bvObjectSpace, U.ObjectSpace)), this._bvObjectSpace;
  }
  _validateBoundingVolume(t6, e7) {
    const i4 = e7 === U.ObjectSpace;
    for (const s7 of this._geometries) {
      const e8 = s7.boundingInfo;
      e8 && O3(e8, t6, i4 ? s7.shaderTransformation : this.getCombinedShaderTransformation(s7));
    }
    A(t6.bounds, t6.min, t6.max, 0.5);
    for (const s7 of this._geometries) {
      const e8 = s7.boundingInfo;
      if (null == e8)
        continue;
      const o6 = i4 ? s7.shaderTransformation : this.getCombinedShaderTransformation(s7), r7 = l4(o6);
      O(B2, e8.center, o6);
      const h3 = x(B2, t6.bounds), m2 = e8.radius * r7;
      t6.bounds[3] = Math.max(t6.bounds[3], h3 + m2);
    }
  }
  _invalidateBoundingVolume() {
    var _a;
    const t6 = (_a = this._bvWorldSpace) == null ? void 0 : _a.bounds;
    this._bvObjectSpace = this._bvWorldSpace = void 0, this._parentLayer && t6 && this._parentLayer.notifyObjectBBChanged(this, t6);
  }
  _emit(t6, e7) {
    this._parentLayer && this._parentLayer.events.emit(t6, e7);
  }
  get test() {
    const t6 = this;
    return { hasGeometry: (e7) => t6._geometries.includes(e7), getGeometryIndex: (e7) => t6._geometries.indexOf(e7) };
  }
};
var T = class {
  constructor() {
    this.min = r(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this.max = r(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  }
  isEmpty() {
    return this.max[0] < this.min[0] && this.max[1] < this.min[1] && this.max[2] < this.min[2];
  }
};
var x3 = class extends T {
  constructor() {
    super(...arguments), this.bounds = _2();
  }
};
function O3(t6, e7, s7) {
  const o6 = t6.bbMin, r7 = t6.bbMax;
  if (H(s7)) {
    const t7 = o(M2, s7[12], s7[13], s7[14]);
    u(A3, o6, t7), u(L, r7, t7);
    for (let i4 = 0; i4 < 3; ++i4)
      e7.min[i4] = Math.min(e7.min[i4], A3[i4]), e7.max[i4] = Math.max(e7.max[i4], L[i4]);
  } else if (O(A3, o6, s7), F(o6, r7))
    for (let i4 = 0; i4 < 3; ++i4)
      e7.min[i4] = Math.min(e7.min[i4], A3[i4]), e7.max[i4] = Math.max(e7.max[i4], A3[i4]);
  else {
    O(L, r7, s7);
    for (let t7 = 0; t7 < 3; ++t7)
      e7.min[t7] = Math.min(e7.min[t7], A3[t7], L[t7]), e7.max[t7] = Math.max(e7.max[t7], A3[t7], L[t7]);
    for (let t7 = 0; t7 < 3; ++t7) {
      r2(A3, o6), r2(L, r7), A3[t7] = r7[t7], L[t7] = o6[t7], O(A3, A3, s7), O(L, L, s7);
      for (let t8 = 0; t8 < 3; ++t8)
        e7.min[t8] = Math.min(e7.min[t8], A3[t8], L[t8]), e7.max[t8] = Math.max(e7.max[t8], A3[t8], L[t8]);
    }
  }
}
var M2 = n();
var A3 = n();
var L = n();
var B2 = n();
var U;
!function(t6) {
  t6[t6.WorldSpace = 0] = "WorldSpace", t6[t6.ObjectSpace = 1] = "ObjectSpace";
}(U || (U = {}));

export {
  V2 as V,
  c3 as c,
  n5 as n,
  B
};
//# sourceMappingURL=chunk-DBIFU6GO.js.map
