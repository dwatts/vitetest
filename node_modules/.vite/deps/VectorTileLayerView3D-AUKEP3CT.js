import {
  e as e5,
  h,
  i as i4,
  l as l4,
  t as t3
} from "./chunk-MLHA2Q2M.js";
import {
  o as o3
} from "./chunk-R372VXTK.js";
import "./chunk-K5QQ6UU5.js";
import "./chunk-R7LS3BCI.js";
import {
  _,
  _2,
  d as d3,
  f,
  o as o2
} from "./chunk-3MPC6MVT.js";
import "./chunk-UBY6VMKB.js";
import {
  o
} from "./chunk-IT2KU2XD.js";
import {
  n
} from "./chunk-XGIDQJNQ.js";
import {
  d
} from "./chunk-TYEEWKIN.js";
import "./chunk-FKUVQAN6.js";
import {
  l as l3
} from "./chunk-FXRNYI6X.js";
import "./chunk-2735WBYK.js";
import "./chunk-NVZXNBIH.js";
import "./chunk-XYJMHUDA.js";
import "./chunk-CSLWFQJE.js";
import "./chunk-A4HFWKMU.js";
import "./chunk-TBHRKIAA.js";
import "./chunk-BPITJIFG.js";
import "./chunk-J6SRKANJ.js";
import {
  d as d2,
  i as i3,
  s as s3
} from "./chunk-3VN6RF6P.js";
import "./chunk-7YCGPGGL.js";
import "./chunk-GPABU246.js";
import "./chunk-KILCBNKU.js";
import {
  M,
  k
} from "./chunk-5IRKUUA3.js";
import "./chunk-644IM3NW.js";
import "./chunk-TE7N6C3J.js";
import "./chunk-H3DKDGMJ.js";
import "./chunk-FB6EWBGE.js";
import "./chunk-TRGMWULG.js";
import "./chunk-WTPQKRQM.js";
import "./chunk-AER5JAFS.js";
import "./chunk-FKEHFW5J.js";
import {
  a as a3,
  i as i2
} from "./chunk-7HZ72XIE.js";
import "./chunk-WDZ5AAFL.js";
import "./chunk-TDXHXKUI.js";
import "./chunk-SGBMUZSF.js";
import "./chunk-FF5LS3YE.js";
import {
  I,
  R
} from "./chunk-BCDDCNQ2.js";
import {
  e as e3
} from "./chunk-SHFLRM67.js";
import "./chunk-YGUWDSEH.js";
import "./chunk-O62OS3ME.js";
import "./chunk-MF3HZ6GV.js";
import "./chunk-SNAARWF3.js";
import "./chunk-F4ILXEXC.js";
import {
  t as t2
} from "./chunk-D5NSNTGJ.js";
import "./chunk-63ERNIOV.js";
import "./chunk-5KLICR5E.js";
import {
  e as e4
} from "./chunk-YYTXJF6W.js";
import "./chunk-KRCNIFX2.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-M6OG7C2T.js";
import "./chunk-GOK5MP3B.js";
import "./chunk-DSWGERIY.js";
import "./chunk-Y2ZDD3I4.js";
import "./chunk-RVS5HU2K.js";
import "./chunk-JB7FDW5N.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-NVGPNIR6.js";
import "./chunk-B4D7M7HT.js";
import "./chunk-3T2ETA25.js";
import "./chunk-5IYCCZ54.js";
import "./chunk-VMTVUE47.js";
import "./chunk-GDZM4A6K.js";
import "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import "./chunk-W4KI5YEI.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-SLVNG7FV.js";
import "./chunk-DEZCXTA3.js";
import "./chunk-RRJGZKNX.js";
import "./chunk-A6VKJXIH.js";
import "./chunk-7EQSYZHW.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-HXPVVSLV.js";
import "./chunk-4OR73Y2R.js";
import {
  i
} from "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-3VUFACNT.js";
import "./chunk-ZEEBL7ZN.js";
import "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-57CHUY45.js";
import "./chunk-SJ2GJCS2.js";
import {
  j,
  l as l2,
  w
} from "./chunk-H7RDAEPY.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-S5OISW44.js";
import "./chunk-7KH4CLS5.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-JL3TJGVW.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import {
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import {
  a,
  s as s2
} from "./chunk-7I33FAWS.js";
import {
  e as e2,
  l,
  t
} from "./chunk-DWOEYHKS.js";
import {
  s3 as s
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  has
} from "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SchemaHelper.js
var t4 = class {
  constructor(t5, e6, s4) {
    this._scale = t5, this._shift = e6, this._levelShift = s4;
  }
  getLevelRowColumn(t5) {
    const e6 = this.getLevelShift(t5[0]), s4 = this._shift + e6;
    return s4 ? [t5[0] - e6, t5[1] >> s4, t5[2] >> s4] : t5;
  }
  getLevelShift(t5) {
    return Math.min(t5, this._levelShift);
  }
  getOffset(t5, e6) {
    let s4 = 0, i5 = 0;
    const h2 = this._shift + this.getLevelShift(t5[0]);
    if (h2) {
      const l6 = (1 << h2) - 1, f2 = e6 / (this._scale * (1 << h2 - 1));
      s4 = (t5[2] & l6) * f2, i5 = (t5[1] & l6) * f2;
    }
    return [s4, i5];
  }
  getScale(t5) {
    return this._scale * (1 << this._shift + this.getLevelShift(t5));
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobsUtil.js
function p(p2) {
  const y2 = [], a4 = new i4(4096, y2, () => {
    const e6 = new s3();
    return e6.show = false, e6.parts.push({ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }), e6.parts.push({ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }), e6;
  }), m = new e5(y2, a4, (t5, r, o5) => new l4(t5, r, o5, p2.styleRepository, p2.key.level, 0), (t5, e6) => {
    i3(t5, e6, false);
  }, () => 0, (t5) => {
    const e6 = p2.styleRepository.getStyleLayerByUID(t5).getLayoutProperty("visibility");
    return !e6 || e6.getValue() !== i2.NONE;
  });
  y2.push(p2), a4.add(p2), m.setScreenSize(512, 512), m.continue(1 / 0);
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler3D.js
var g = class extends h {
  constructor(e6, t5, o5, i5) {
    super(e6, t5, o5), this._memCache = i5, this._ongoingTileRequests = /* @__PURE__ */ new Map(), this._ongoingRequestToController = /* @__PURE__ */ new Map(), this._tileInfoView = new t3(e6.tileInfo, e6.fullExtent);
  }
  destroy() {
    super.destroy(), this._ongoingRequestToController.forEach((e6) => e6.abort()), this._ongoingRequestToController.clear(), this._ongoingTileRequests.clear();
  }
  async getVectorTile(s4, l6, g2, h2) {
    const u = new e4(s4, l6, g2, 0);
    let m = this._memCache.get(u.id);
    if (null != m)
      return m.retain(), m;
    const c = await this._getVectorTileData(u);
    if (s2(h2), !this._layer)
      return null;
    if (m = this._memCache.get(u.id), null != m)
      return m.retain(), m;
    const T = this._layer.tileInfo.getTileBounds(i(), u), _3 = this._tileInfoView.getTileResolution(s4);
    return m = new d2(u, _3, T[0], T[3], 512, 512, this._styleRepository, this._memCache), c ? (m.setData(c), m.retain(), this._memCache.put(u.id, m, m.memoryUsed, e3)) : m.setData(null), m.neededForCoverage = true, m.transforms.tileUnitsToPixels = t2(1 / 8, 0, 0, 0, 1 / 8, 0, 0, 0, 1), p(m), m;
  }
  _getVectorTileData(e6) {
    const t5 = e6.id;
    if (this._ongoingTileRequests.has(t5))
      return this._ongoingTileRequests.get(t5);
    const o5 = new AbortController(), i5 = { signal: o5.signal }, s4 = this._getParsedVectorTileData(e6, i5).then((e7) => (this._ongoingTileRequests.delete(t5), this._ongoingRequestToController.delete(t5), e7)).catch(() => (this._ongoingTileRequests.delete(t5), this._ongoingRequestToController.delete(t5), null));
    return this._ongoingTileRequests.set(t5, s4), this._ongoingRequestToController.set(t5, o5), s4;
  }
  _getParsedVectorTileData(e6, t5) {
    return this.fetchTileData(e6, t5).then((o5) => this.parseTileData({ key: e6, data: o5 }, t5));
  }
};

// node_modules/@arcgis/core/views/2d/engine/vtlBrushes.js
var b = { vtlBackground: _, vtlFill: d3, vtlLine: f, vtlCircle: o2, vtlSymbol: _2 };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VTLPainter3D.js
var l5 = 1e-6;
var o4 = class {
  constructor(e6, t5) {
    this.spriteMosaic = e6, this.glyphMosaic = t5, this._brushCache = /* @__PURE__ */ new Map(), this._vtlMaterialManager = new o3();
  }
  dispose() {
    this._brushCache && (this._brushCache.forEach((e6) => e6.dispose()), this._brushCache = null), this._vtlMaterialManager = t(this._vtlMaterialManager), this.spriteMosaic.dispose(), this.glyphMosaic.dispose();
  }
  get vectorTilesMaterialManager() {
    return this._vtlMaterialManager;
  }
  drawTile(e6, t5, r, s4) {
    const { context: a4 } = e6, l6 = r.layers;
    r.backgroundBucketIds.length > 0 && (e6.renderPass = "background", r.backgroundBucketIds.forEach((a5) => {
      const n2 = r.getLayerById(a5);
      null != s4 && s4 !== n2.type || this._renderStyleLayer(n2, e6, t5, true);
    })), a4.setBlendingEnabled(false), a4.setDepthTestEnabled(true), a4.setDepthWriteEnabled(true), a4.setDepthFunction(I.LEQUAL), e6.renderPass = "opaque";
    for (let n2 = l6.length - 1; n2 >= 0; n2--) {
      const r2 = l6[n2];
      null != s4 && s4 !== r2.type || this._renderStyleLayer(r2, e6, t5, false);
    }
    a4.setDepthWriteEnabled(false), a4.setBlendingEnabled(true), a4.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e6.renderPass = "translucent";
    for (let n2 = 0; n2 < l6.length; n2++) {
      const r2 = l6[n2];
      null != s4 && s4 !== r2.type || this._renderStyleLayer(r2, e6, t5, false);
    }
    a4.setDepthTestEnabled(false), a4.bindVAO();
  }
  _renderStyleLayer(e6, t5, r, n2) {
    if (!(n2 || e6 && r.layerData.has(e6.uid)))
      return;
    const i5 = e6.getLayoutProperty("visibility");
    if (i5 && i5.getValue() === i2.NONE)
      return;
    const { renderPass: o5 } = t5;
    let h2;
    switch (e6.type) {
      case a3.BACKGROUND:
        if ("background" !== o5)
          return;
        h2 = "vtlBackground";
        break;
      case a3.FILL:
        if ("opaque" !== o5 && "translucent" !== t5.renderPass)
          return;
        h2 = "vtlFill";
        break;
      case a3.LINE:
        if ("translucent" !== o5)
          return;
        h2 = "vtlLine";
        break;
      case a3.CIRCLE:
        if ("translucent" !== o5)
          return;
        h2 = "vtlCircle";
        break;
      case a3.SYMBOL:
        if ("translucent" !== o5)
          return;
        h2 = "vtlSymbol";
    }
    const c = t5.displayLevel;
    void 0 !== e6.minzoom && e6.minzoom > c + l5 || void 0 !== e6.maxzoom && e6.maxzoom <= c - l5 || (t5.styleLayerUID = e6.uid, t5.styleLayer = e6, this._drawWithBrush(t5, r, h2));
  }
  _drawWithBrush(e6, r, s4) {
    if (!this._brushCache.has(s4)) {
      const e7 = b[s4];
      this._brushCache.set(s4, new e7());
    }
    this._brushCache.get(s4).drawMany(e6, [r]);
  }
};

// node_modules/@arcgis/core/views/3d/layers/VectorTileLayerView3D.js
var C = class extends o(n(d)) {
  constructor() {
    super(...arguments), this._tileHandlerController = null, this.type = "vector-tile-3d", this.levelShift = has("disable-feature:vtl-level-shift") ? 0 : 1, this.contentZoom = has("disable-feature:vtl-level-shift") ? 1 : 1.5;
  }
  initialize() {
    if (null == this.layer.fullExtent)
      return void this.addResolvingPromise(Promise.reject(new s("vectortilelayerview:full-extent-undefined", "This layer view's layer does not define a fullExtent.")));
    const { basemapTerrain: e6, spatialReference: i5, state: l6, viewingMode: r } = this.view, h2 = "local" === r && !M(i5) || k.force512VTL, c = this.layer.tileInfo.spatialReference.isGeographic, y2 = h2 ? this.layer.tileInfo : this.layer.tileInfo.getOrCreateCompatible(256, c ? 1 : 2), g2 = this._getTileInfoSupportError(y2, this.layer.fullExtent);
    if (null != g2)
      return this.addResolvingPromise(Promise.reject(g2));
    const _3 = j(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.basemapTerrain) == null ? void 0 : _b.tilingSchemeLocked;
    }).then(() => {
      var _a, _b, _c;
      const t5 = e6.tilingScheme, i6 = t5.pixelSize, l7 = 256 === i6 ? 1 : 2, r2 = ((_a = e6.spatialReference) == null ? void 0 : _a.isGeographic) && 256 === i6 ? 1 : 0, s4 = ((_b = e6.spatialReference) == null ? void 0 : _b.isGeographic) || 256 !== i6 ? 0 : 1;
      let o5;
      if (this.schemaHelper = new t4(l7, r2, this.levelShift + s4), 256 === i6) {
        const e7 = this.layer.tileInfo.spatialReference.isGeographic;
        o5 = this.layer.tileInfo.getOrCreateCompatible(256, e7 ? 1 : 2);
      } else
        o5 = ((_c = this.view.spatialReference) == null ? void 0 : _c.isGeographic) ? this.layer.tileInfo.getOrCreateCompatible(512, 0.5) : this.layer.tileInfo;
      const a4 = this._getTileInfoCompatibilityError(o5, t5);
      if (a4)
        throw a4;
      this.tileInfo = o5;
    });
    this._tileHandlerController = new AbortController();
    const C2 = this.view.resourceController;
    this._memCache = C2.memoryController.newCache(`vtl-${this.layer.uid}`, (e7) => {
      e7.release();
    }), this.handles.add(l2(() => this.view.qualitySettings.memoryLimit, (e7) => this._memCache.maxSize = Math.ceil(e7 / 10 * 1048576), w));
    const S2 = new l3(this.layer.currentStyleInfo.style);
    this._tileHandler = new g(this.layer, S2, l6.contentPixelRatio, this._memCache);
    const H = this._tileHandlerController.signal, R2 = w2(C2), j2 = this._tileHandler.start({ signal: H, schedule: R2 }), x = this._tileHandler.spriteMosaic;
    x.then((e7) => {
      !a(H) && this._tileHandler && (this.painter = new o4(e7, this._tileHandler.glyphMosaic));
    }), j2.then(() => this._tileHandlerController = null), this.updatingHandles.add(() => {
      var _a;
      return { style: this.layer.currentStyleInfo.style, pixelRatio: (_a = this.view.state) == null ? void 0 : _a.contentPixelRatio };
    }, ({ style: e7, pixelRatio: t5 }) => {
      this._tileHandlerController && this._tileHandlerController.abort(), this._tileHandlerController = new AbortController(), this._memCache.clear();
      const i6 = new l3(e7), l7 = new g(this.layer, i6, t5, this._memCache), r2 = l7.start({ signal: this._tileHandlerController.signal, schedule: R2 }), s4 = l7.spriteMosaic;
      r2.then(() => this._tileHandlerController = null), this.updatingHandles.addPromise(Promise.all([r2, s4]).then(([, e8]) => {
        const t6 = this._tileHandler, i7 = this.painter;
        this.painter = new o4(e8, l7.glyphMosaic), this._tileHandler = l7, this.emit("data-changed"), t6.destroy(), i7 && i7.dispose();
      }));
    });
    const L = Promise.all([_3, j2, x]);
    this.addResolvingPromise(L);
  }
  destroy() {
    this.painter = t(this.painter), this._tileHandlerController = e2(this._tileHandlerController), this._tileHandler = l(this._tileHandler), this._memCache = l(this._memCache);
  }
  get displayLevelRange() {
    const e6 = this.tileInfo.lods, t5 = this.layer.minScale || e6[0].scale, i5 = this.layer.maxScale || e6[e6.length - 1].scale, l6 = this.levelRangeFromScaleRange(t5, i5);
    return this.layer.maxScale ? l6.maxLevel++ : l6.maxLevel += this.levelShift, l6;
  }
  get dataScaleRange() {
    const e6 = this.tileInfo.lods;
    return { minScale: e6[0].scale, maxScale: e6[e6.length - 1].scale };
  }
  get dataLevelRange() {
    const { minScale: e6, maxScale: t5 } = this.dataScaleRange, i5 = this.levelRangeFromScaleRange(e6, t5);
    return 1 === i5.minLevel && 256 === this.tileInfo.size[0] && (i5.minLevel = 0), i5.maxLevel += this.levelShift, i5;
  }
  async fetchTile(e6, t5, i5, l6) {
    return this._tileHandler.getVectorTile(e6, t5, i5, l6);
  }
};
e([y()], C.prototype, "layer", void 0), e([y()], C.prototype, "levelShift", void 0), e([y()], C.prototype, "contentZoom", void 0), e([y()], C.prototype, "displayLevelRange", null), e([y()], C.prototype, "tileInfo", void 0), e([y()], C.prototype, "dataScaleRange", null), e([y()], C.prototype, "dataLevelRange", null), e([y()], C.prototype, "updatingProgressValue", void 0), C = e([a2("esri.views.3d.layers.VectorTileLayerView3D")], C);
var S = C;
function w2(e6) {
  return (t5) => e6.immediate.schedule(t5);
}
export {
  S as default
};
//# sourceMappingURL=VectorTileLayerView3D-AUKEP3CT.js.map
