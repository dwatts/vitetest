import {
  c,
  m
} from "./chunk-SCAYUERS.js";
import {
  e
} from "./chunk-3TDCCT2R.js";
import {
  g
} from "./chunk-JHDKOKT6.js";
import {
  o as o2
} from "./chunk-CG3URTR2.js";
import {
  h
} from "./chunk-73PNWDTS.js";
import {
  t
} from "./chunk-PKS3ZVLN.js";
import {
  P
} from "./chunk-N3RXOITN.js";
import {
  p
} from "./chunk-DOR4M5EA.js";
import {
  e as e2
} from "./chunk-QS45OHBM.js";
import {
  o as o3
} from "./chunk-UUW6REOV.js";
import {
  i2 as i
} from "./chunk-BO2REVMA.js";
import {
  o
} from "./chunk-V66LHQVK.js";
import {
  O
} from "./chunk-BN6X2OXK.js";

// node_modules/@arcgis/core/chunks/NativeLine.glsl.js
function u(u2) {
  const v2 = new i(), { vertex: f, fragment: h2 } = v2;
  return v2.include(o2, u2), v2.include(e, u2), v2.include(c, u2), p(f, u2), u2.stippleEnabled && (v2.attributes.add(O.UV0, "vec2"), v2.attributes.add(O.AUXPOS1, "vec3"), f.uniforms.add(new e2("viewport", (e3, o4) => o4.camera.fullViewport))), v2.attributes.add(O.POSITION, "vec3"), v2.varyings.add("vpos", "vec3"), f.code.add(o`void main(void) {
vpos = position;
forwardNormalizedVertexColor();
gl_Position = transformPosition(proj, view, vpos);`), u2.stippleEnabled && (f.code.add(o`vec4 vpos2 = transformPosition(proj, view, auxpos1);
vec2 ndcToPixel = viewport.zw * 0.5;
float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);`), u2.draped ? f.uniforms.add(new o3("worldToScreenRatio", (e3, o4) => 1 / o4.screenToPCSRatio)) : f.code.add(o`vec3 segmentCenter = (position + auxpos1) * 0.5;
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`), f.code.add(o`float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);`), u2.draped ? f.code.add(o`float startPseudoScreen = uv0.y * discreteWorldToScreenRatio - mix(0.0, lineSegmentPixelSize, uv0.x);
float segmentLengthPseudoScreen = lineSegmentPixelSize;`) : f.code.add(o`float segmentLengthRender = length(position - auxpos1);
float startPseudoScreen = mix(uv0.y, uv0.y - segmentLengthRender, uv0.x) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`), f.uniforms.add(new o3("stipplePatternPixelSize", (e3) => m(e3))), f.code.add(o`vec2 stippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, lineSegmentPixelSize, stipplePatternPixelSize);
vStippleDistance = mix(stippleDistanceLimits.x, stippleDistanceLimits.y, uv0.x);
vStippleDistance *= gl_Position.w;`)), f.code.add(o`}`), u2.output === h.Highlight && v2.include(g, u2), v2.include(P, u2), h2.uniforms.add(new o3("alphaCoverage", (e3, o4) => Math.min(1, e3.width * o4.camera.pixelRatio))), u2.hasVertexColors || h2.uniforms.add(new e2("constantColor", (e3) => e3.color)), h2.code.add(o`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${u2.hasVertexColors ? "vColor" : "constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    ${u2.output === h.ObjectAndLayerIdColor ? o`finalColor.a = 1.0;` : ""}

    if (finalColor.a < ${o.float(t)}) {
      discard;
    }

    ${u2.output === h.Color ? o`fragColor = highlightSlice(finalColor, vpos);` : ""}
    ${u2.output === h.Highlight ? o`outputHighlight();` : ""}
  }
  `), v2;
}
var v = Object.freeze(Object.defineProperty({ __proto__: null, build: u }, Symbol.toStringTag, { value: "Module" }));

export {
  u,
  v
};
//# sourceMappingURL=chunk-PLKG3UR7.js.map
