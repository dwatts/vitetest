import {
  W
} from "./chunk-Z6R62RNV.js";
import "./chunk-3LLZ72VA.js";
import {
  b,
  j,
  v
} from "./chunk-4SIKLJSS.js";
import {
  m
} from "./chunk-SNFNEEDE.js";
import "./chunk-M7PTINEZ.js";
import "./chunk-Z7LZRT7C.js";
import "./chunk-SGBMUZSF.js";
import "./chunk-3TMT4LDG.js";
import "./chunk-OX5TJXHM.js";
import "./chunk-BDWD2ZNU.js";
import "./chunk-FF5LS3YE.js";
import "./chunk-BCDDCNQ2.js";
import "./chunk-FIBWCATC.js";
import "./chunk-FOEAKQNX.js";
import {
  Q,
  _,
  z
} from "./chunk-LEDSC236.js";
import "./chunk-CW7LIPBH.js";
import "./chunk-TYOIANOD.js";
import "./chunk-VN2IXVGV.js";
import "./chunk-WWUAHPIM.js";
import "./chunk-BN6X2OXK.js";
import "./chunk-YGUWDSEH.js";
import "./chunk-NLWV7Q6F.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-TEHNQYQD.js";
import {
  q,
  u,
  x
} from "./chunk-TPJLFGOT.js";
import {
  n,
  t
} from "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-3R7FAT25.js";
import {
  s
} from "./chunk-7I33FAWS.js";
import "./chunk-DWOEYHKS.js";
import "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/sceneLayerSnappingUtils.js
var t2 = 1e3;
function a2(t3, a3, e2) {
  const i = _(), m2 = z(i);
  return q(m2, m2, t3, 0.5), q(m2, m2, a3, 0.5), i[3] = x(m2, t3), u(m2, m2, e2), i;
}

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorker.js
var _2 = class {
  constructor() {
    this._idToComponent = /* @__PURE__ */ new Map(), this._components = new W((e2) => e2.bounds), this._edges = new W((e2) => e2.bounds), this._tmpLineSegment = v(), this._tmpP1 = n(), this._tmpP2 = n(), this._tmpP3 = n(), this.remoteClient = null;
  }
  async fetchCandidates(e2, s2) {
    await Promise.resolve(), s(s2), await this._ensureEdgeLocations(e2, s2);
    const o = [];
    return this._edges.forEachNeighbor((t3) => (this._addCandidates(e2, t3, o), o.length < t2), e2.bounds), { result: { candidates: o } };
  }
  async _ensureEdgeLocations(e2, t3) {
    const s2 = [];
    if (this._components.forEachNeighbor((e3) => {
      if (null == e3.info) {
        const { id: t4, uid: o2 } = e3;
        s2.push({ id: t4, uid: o2 });
      }
      return true;
    }, e2.bounds), !s2.length)
      return;
    const o = { components: s2 }, n2 = await this.remoteClient.invoke("fetchAllEdgeLocations", o, t3 ?? {});
    for (const i of n2.components)
      this._setFetchEdgeLocations(i);
  }
  async add(e2) {
    const t3 = new b2(e2.id, e2.bounds);
    return this._idToComponent.set(t3.id, t3), this._components.add([t3]), { result: {} };
  }
  async remove(e2) {
    const t3 = this._idToComponent.get(e2.id);
    if (t3) {
      const e3 = [];
      this._edges.forEachNeighbor((s2) => (s2.component === t3 && e3.push(s2), true), t3.bounds), this._edges.remove(e3), this._components.remove([t3]), this._idToComponent.delete(t3.id);
    }
    return { result: {} };
  }
  _setFetchEdgeLocations(e2) {
    const t3 = this._idToComponent.get(e2.id);
    if (null == t3 || e2.uid !== t3.uid)
      return;
    const s2 = m.createView(e2.locations), o = new Array(s2.count), n2 = n(), r = n();
    for (let i = 0; i < s2.count; i++) {
      s2.position0.getVec(i, n2), s2.position1.getVec(i, r);
      const d2 = a2(n2, r, e2.origin), c2 = new j2(t3, i, d2);
      o[i] = c2;
    }
    this._edges.add(o);
    const { objectIds: d, origin: c } = e2;
    t3.info = { locations: s2, objectIds: d, origin: c };
  }
  _addCandidates(e2, t3, s2) {
    const { info: n2 } = t3.component, { origin: i, objectIds: r } = n2, d = n2.locations, c = d.position0.getVec(t3.index, this._tmpP1), a3 = d.position1.getVec(t3.index, this._tmpP2);
    u(c, c, i), u(a3, a3, i);
    const p = r[d.componentIndex.get(t3.index)];
    this._addEdgeCandidate(e2, p, c, a3, s2), this._addVertexCandidate(e2, p, c, s2), this._addVertexCandidate(e2, p, a3, s2);
  }
  _addEdgeCandidate(e2, t3, s2, o, i) {
    if (!e2.returnEdge)
      return;
    const d = z(e2.bounds), h = b(s2, o, this._tmpLineSegment), m2 = j(h, d, this._tmpP3);
    Q(e2.bounds, m2) && i.push({ type: "edge", objectId: t3, target: t(m2), distance: x(d, m2), start: t(s2), end: t(o) });
  }
  _addVertexCandidate(e2, t3, s2, o) {
    if (!e2.returnVertex)
      return;
    const i = z(e2.bounds);
    Q(e2.bounds, s2) && o.push({ type: "vertex", objectId: t3, target: t(s2), distance: x(i, s2) });
  }
};
_2 = e([a("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")], _2);
var f = _2;
var b2 = class _b {
  constructor(e2, t3) {
    this.id = e2, this.bounds = t3, this.info = null, this.uid = ++_b.uid;
  }
};
b2.uid = 0;
var j2 = class {
  constructor(e2, t3, s2) {
    this.component = e2, this.index = t3, this.bounds = s2;
  }
};
export {
  f as default
};
//# sourceMappingURL=SceneLayerSnappingSourceWorker-5LYJS4FY.js.map
