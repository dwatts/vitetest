import {
  E,
  N
} from "./chunk-W5D3JTKS.js";
import {
  a as a2,
  t
} from "./chunk-WH76OAIT.js";
import {
  s as s2
} from "./chunk-UX3LCC3X.js";
import {
  e as e3
} from "./chunk-PV5KBAYL.js";
import {
  e as e2
} from "./chunk-YVVROPAO.js";
import {
  o as o2
} from "./chunk-UUW6REOV.js";
import {
  a,
  i as i2
} from "./chunk-BO2REVMA.js";
import {
  o
} from "./chunk-V66LHQVK.js";
import {
  e
} from "./chunk-CW7LIPBH.js";
import {
  i
} from "./chunk-TEHNQYQD.js";
import {
  n
} from "./chunk-CQX57DED.js";
import {
  s
} from "./chunk-GJ7PJ7XG.js";

// node_modules/@arcgis/core/views/3d/environment/CloudsCompositionParameters.js
var i3 = class {
  constructor() {
    this.readChannels = E.RG, this.renderingStage = N.FINISHED, this.startTime = 0, this.startTimeHeightFade = 0, this.cameraPositionLastFrame = n(), this.isCameraPositionFinal = true, this.parallax = new o3(), this.parallaxNew = new o3(), this.crossFade = { enabled: false, factor: 1, distanceThresholdFactor: 0.3 }, this.fadeInOut = { stage: I.FINISHED, factor: 1, distanceThresholdFactor: 0.6 }, this.fadeIn = { stage: r.FINISHED, factor: 1, distanceThresholdFactor: 2 }, this.fadeInOutHeight = { stage: n2.FINISHED, factor: -1 };
  }
  get isFading() {
    return this.fadeInOut.stage === I.FADE_OUT || this.fadeInOut.stage === I.FADE_IN || this.fadeIn.stage === r.FADE_IN || this.fadeInOutHeight.stage !== n2.FINISHED || this.renderingStage === N.FADING_TEXTURE_CHANNELS;
  }
};
var r;
var I;
var n2;
!function(t2) {
  t2[t2.FINISHED = 0] = "FINISHED", t2[t2.CHANGE_ANCHOR = 1] = "CHANGE_ANCHOR", t2[t2.FADE_IN = 2] = "FADE_IN";
}(r || (r = {})), function(t2) {
  t2[t2.FINISHED = 0] = "FINISHED", t2[t2.FADE_OUT = 1] = "FADE_OUT", t2[t2.SWITCH = 2] = "SWITCH", t2[t2.FADE_IN = 3] = "FADE_IN";
}(I || (I = {})), function(t2) {
  t2[t2.FINISHED = 0] = "FINISHED", t2[t2.HEIGHT_FADE = 1] = "HEIGHT_FADE";
}(n2 || (n2 = {}));
var o3 = class {
  constructor() {
    this.anchorPointClouds = n(), this.cloudsHeight = 1e5, this.radiusCurvatureCorrectionFactor = 0, this.transform = e();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/TextureCubePassUniform.js
var s3 = class extends i2 {
  constructor(e4, s4) {
    super(e4, "samplerCube", a.Pass, (r2, o4, t2) => r2.bindTexture(e4, s4(o4, t2)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/CloudsParallaxShading.glsl.js
function m(m2) {
  const v = m2.fragment;
  v.uniforms.add(new e3("rotationMatrixClouds", (o4, a3) => a3.cloudsFade.parallax.transform), new e3("rotationMatrixCloudsCrossFade", (o4, a3) => a3.cloudsFade.parallaxNew.transform), new e2("anchorPosition", (o4, a3) => a3.cloudsFade.parallax.anchorPointClouds), new e2("anchorPositionCrossFade", (o4, a3) => a3.cloudsFade.parallaxNew.anchorPointClouds), new o2("cloudsHeight", (o4, a3) => a3.cloudsFade.parallax.cloudsHeight), new o2("radiusCurvatureCorrectionFactor", (o4, a3) => a3.cloudsFade.parallax.radiusCurvatureCorrectionFactor), new o2("totalFadeInOut", (o4, a3) => a3.cloudsFade.fadeInOut.stage === I.FINISHED ? a3.cloudsFade.fadeInOutHeight.factor + 1 - a3.cloudsFade.fadeIn.factor : a3.cloudsFade.fadeInOutHeight.factor + 1 - a3.cloudsFade.fadeInOut.factor), new o2("crossFadeAnchorFactor", (a3, t2) => i(t2.cloudsFade.crossFade.factor, 0, 1)), new s3("cubeMap", (o4, a3) => {
    var _a;
    return ((_a = a3.cloudsFade.data) == null ? void 0 : _a.cubeMap) ? a3.cloudsFade.data.cubeMap.colorTexture : null;
  }), new s2("crossFade", (o4, a3) => a3.cloudsFade.crossFade.enabled), new s2("readChannelsRG", (o4, a3) => a3.cloudsFade.readChannels === E.RG), new s2("fadeTextureChannels", (o4, a3) => a3.cloudsFade.renderingStage === N.FADING_TEXTURE_CHANNELS)), v.constants.add("planetRadius", "float", s.radius), v.code.add(o`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)
{
float radiusClouds = planetRadius + cloudsHeight;
float B = 2.0 * dot(cameraPosition, dir);
float C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;
float det = B * B - 4.0 * C;
float pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));
vec3 intersectionPont = cameraPosition + dir * pointIntDist;
intersectionPont =  intersectionPont - spherePos;
return intersectionPont;
}`), v.code.add(o`vec3 correctForPlanetCurvature(vec3 dir)
{
dir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;
return dir;
}`), v.code.add(o`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)
{
return (rotMat * vec4(inVec, 0.0)).xyz;
}`), t(v), a2(v), v.code.add(o`const float SUNSET_TRANSITION_FACTOR = 0.3;
const vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);
const float RIM_SCATTERING_FACTOR = 140.0;
const float BACKLIGHT_FACTOR = 0.2;
const float BACKLIGHT_SCATTERING_FACTOR = 10.0;
const float BACKLIGHT_TRANSITION_FACTOR = 0.3;
vec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)
{
float upDotLight = dot(normalize(cameraPosition), normalize(mainLightDirection));
float dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(mainLightDirection)), 0.0);
float sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);
vec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);
vec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);
vec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));
vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));
float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);
float rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);
vec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, RIM_SCATTERING_FACTOR)) * scatteringMod;
float additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;
return vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);
}`), v.code.add(o`vec4 getCloudData(vec3 rayDir, bool readOtherChannel)
{
vec4 cloudData = texture(cubeMap, rayDir);
float mu = dot(rayDir, vec3(0, 0, 1));
bool readChannels = readChannelsRG ^^ readOtherChannel;
if (readChannels) {
cloudData = vec4(vec3(cloudData.r), cloudData.g);
} else {
cloudData = vec4(vec3(cloudData.b), cloudData.a);
}
if (length(cloudData) == 0.0) {
return vec4(cloudData.rgb, 1.0);
}
return cloudData;
}`), v.code.add(o`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
float totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudData.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);
}`), v.code.add(o`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
vec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);
worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));
worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
cloudData = getCloudData(worldRayRotatedCorrected, fadeTextureChannels);
vec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
cloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);
float totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudColor.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(cloudColor.rgb, totalTransmittance);
}`), v.code.add(o`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)
{
return crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);
}`);
}

export {
  i3 as i,
  r,
  I,
  n2 as n,
  m
};
//# sourceMappingURL=chunk-XYSQCP5F.js.map
