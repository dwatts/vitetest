import {
  o2,
  t
} from "./chunk-SMDDCTGQ.js";
import {
  a as a2,
  i as i3
} from "./chunk-BO2REVMA.js";
import {
  n as n3
} from "./chunk-V66LHQVK.js";
import {
  e as e2
} from "./chunk-CW7LIPBH.js";
import {
  e
} from "./chunk-VN2IXVGV.js";
import {
  m as m2
} from "./chunk-EFRTD25L.js";
import {
  a
} from "./chunk-JB7FDW5N.js";
import {
  c,
  f,
  i as i2,
  l,
  m,
  n as n2,
  r,
  s,
  x
} from "./chunk-7EG7BYWF.js";
import {
  i
} from "./chunk-TEHNQYQD.js";
import {
  o
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float4sPassUniform.js
var e3 = class extends i3 {
  constructor(r2, e5, o3) {
    super(r2, "vec4", a2.Pass, (s2, o4, t3) => s2.setUniform4fv(r2, e5(o4, t3)), o3);
  }
};

// node_modules/@arcgis/core/views/3d/layers/support/FastSymbolUpdates.js
var S;
var y;
!function(e5) {
  e5[e5.Undefined = 0] = "Undefined", e5[e5.DefinedSize = 1] = "DefinedSize", e5[e5.DefinedScale = 2] = "DefinedScale";
}(S || (S = {})), function(e5) {
  e5[e5.Undefined = 0] = "Undefined", e5[e5.DefinedAngle = 1] = "DefinedAngle";
}(y || (y = {}));
var x2 = class {
  constructor(e5) {
    this.field = e5;
  }
};
var g = class extends x2 {
  constructor(e5) {
    super(e5), this.minSize = [0, 0, 0], this.maxSize = [0, 0, 0], this.offset = [0, 0, 0], this.factor = [0, 0, 0], this.type = [S.Undefined, S.Undefined, S.Undefined];
  }
};
var b = class extends x2 {
  constructor(e5) {
    super(e5), this.colors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.values = [0, 0, 0, 0, 0, 0, 0, 0];
  }
};
var C = class extends x2 {
  constructor(e5) {
    super(e5), this.values = [0, 0, 0, 0, 0, 0, 0, 0], this.opacityValues = [0, 0, 0, 0, 0, 0, 0, 0];
  }
};
var w = class {
};
function U(e5) {
  return null != e5;
}
function V(e5) {
  return "number" == typeof e5;
}
function M(e5) {
  return "string" == typeof e5;
}
function j(e5) {
  return null == e5 || M(e5);
}
function k(e5, t3) {
  e5 && e5.push(t3);
}
function A(e5, t3, o3, i4 = e2()) {
  const n4 = e5 || 0, s2 = t3 || 0, r2 = o3 || 0;
  return 0 !== n4 && x(i4, i4, -n4 / 180 * Math.PI), 0 !== s2 && l(i4, i4, s2 / 180 * Math.PI), 0 !== r2 && m(i4, i4, r2 / 180 * Math.PI), i4;
}
function I(e5, t3, o3, i4, n4) {
  const s2 = e5.minSize, r2 = e5.maxSize;
  if (e5.expression)
    return k(n4, "Could not convert size info: expression not supported"), false;
  if (e5.useSymbolValue) {
    const e6 = i4.symbolSize[o3];
    return t3.minSize[o3] = e6, t3.maxSize[o3] = e6, t3.offset[o3] = t3.minSize[o3], t3.factor[o3] = 0, t3.type[o3] = S.DefinedSize, true;
  }
  if (U(e5.field))
    return U(e5.stops) ? 2 === e5.stops.length && V(e5.stops[0].size) && V(e5.stops[1].size) ? (T(e5.stops[0].size, e5.stops[1].size, e5.stops[0].value, e5.stops[1].value, t3, o3), t3.type[o3] = S.DefinedSize, true) : (k(n4, "Could not convert size info: stops only supported with 2 elements"), false) : V(s2) && V(r2) && U(e5.minDataValue) && U(e5.maxDataValue) ? (T(s2, r2, e5.minDataValue, e5.maxDataValue, t3, o3), t3.type[o3] = S.DefinedSize, true) : "unknown" === e5.valueUnit ? (k(n4, "Could not convert size info: proportional size not supported"), false) : null != m2[e5.valueUnit] ? (t3.minSize[o3] = -1 / 0, t3.maxSize[o3] = 1 / 0, t3.offset[o3] = 0, t3.factor[o3] = 1 / m2[e5.valueUnit], t3.type[o3] = S.DefinedSize, true) : (k(n4, "Could not convert size info: scale-dependent size not supported"), false);
  if (!U(e5.field)) {
    if (e5.stops && e5.stops[0] && V(e5.stops[0].size))
      return t3.minSize[o3] = e5.stops[0].size, t3.maxSize[o3] = e5.stops[0].size, t3.offset[o3] = t3.minSize[o3], t3.factor[o3] = 0, t3.type[o3] = S.DefinedSize, true;
    if (V(s2))
      return t3.minSize[o3] = s2, t3.maxSize[o3] = s2, t3.offset[o3] = s2, t3.factor[o3] = 0, t3.type[o3] = S.DefinedSize, true;
  }
  return k(n4, "Could not convert size info: unsupported variant of sizeInfo"), false;
}
function T(e5, t3, o3, i4, n4, s2) {
  const r2 = Math.abs(i4 - o3) > 0 ? (t3 - e5) / (i4 - o3) : 0;
  n4.minSize[s2] = r2 > 0 ? e5 : t3, n4.maxSize[s2] = r2 > 0 ? t3 : e5, n4.offset[s2] = e5 - o3 * r2, n4.factor[s2] = r2;
}
function F(e5, t3, o3, i4) {
  if (e5.normalizationField || e5.valueRepresentation)
    return k(i4, "Could not convert size info: unsupported property"), null;
  if (!j(e5.field))
    return k(i4, "Could not convert size info: field is not a string"), null;
  if (t3.size) {
    if (e5.field)
      if (t3.size.field) {
        if (e5.field !== t3.size.field)
          return k(i4, "Could not convert size info: multiple fields in use"), null;
      } else
        t3.size.field = e5.field;
  } else
    t3.size = new g(e5.field);
  let n4;
  switch (e5.axis) {
    case "width":
      return n4 = I(e5, t3.size, 0, o3, i4), n4 ? t3 : null;
    case "height":
      return n4 = I(e5, t3.size, 2, o3, i4), n4 ? t3 : null;
    case "depth":
      return n4 = I(e5, t3.size, 1, o3, i4), n4 ? t3 : null;
    case "width-and-depth":
      return n4 = I(e5, t3.size, 0, o3, i4), n4 && I(e5, t3.size, 1, o3, i4), n4 ? t3 : null;
    case null:
    case void 0:
    case "all":
      return n4 = I(e5, t3.size, 0, o3, i4), n4 = n4 && I(e5, t3.size, 1, o3, i4), n4 = n4 && I(e5, t3.size, 2, o3, i4), n4 ? t3 : null;
    default:
      return k(i4, `Could not convert size info: unknown axis "${e5.axis}""`), null;
  }
}
function P(e5, t3, o3) {
  for (let n4 = 0; n4 < 3; ++n4) {
    let o4 = t3.unitInMeters;
    e5.type[n4] === S.DefinedSize && (o4 *= t3.modelSize[n4], e5.type[n4] = S.DefinedScale), e5.minSize[n4] = e5.minSize[n4] / o4, e5.maxSize[n4] = e5.maxSize[n4] / o4, e5.offset[n4] = e5.offset[n4] / o4, e5.factor[n4] = e5.factor[n4] / o4;
  }
  let i4;
  if (e5.type[0] !== S.Undefined)
    i4 = 0;
  else if (e5.type[1] !== S.Undefined)
    i4 = 1;
  else {
    if (e5.type[2] === S.Undefined)
      return k(o3, "No size axis contains a valid size or scale"), false;
    i4 = 2;
  }
  for (let n4 = 0; n4 < 3; ++n4)
    e5.type[n4] === S.Undefined && (e5.minSize[n4] = e5.minSize[i4], e5.maxSize[n4] = e5.maxSize[i4], e5.offset[n4] = e5.offset[i4], e5.factor[n4] = e5.factor[i4], e5.type[n4] = e5.type[i4]);
  return true;
}
function R(e5, t3, o3) {
  e5[4 * t3] = o3.r / 255, e5[4 * t3 + 1] = o3.g / 255, e5[4 * t3 + 2] = o3.b / 255, e5[4 * t3 + 3] = o3.a;
}
function E(e5, t3, o3) {
  if (e5.normalizationField)
    return k(o3, "Could not convert color info: unsupported property"), null;
  if (M(e5.field)) {
    if (!e5.stops)
      return k(o3, "Could not convert color info: missing stops or colors"), null;
    {
      if (e5.stops.length > 8)
        return k(o3, "Could not convert color info: too many color stops"), null;
      t3.color = new b(e5.field);
      const i4 = e5.stops;
      for (let e6 = 0; e6 < 8; ++e6) {
        const o4 = i4[Math.min(e6, i4.length - 1)];
        t3.color.values[e6] = o4.value, R(t3.color.colors, e6, o4.color);
      }
    }
  } else {
    if (!(e5.stops && e5.stops.length >= 0))
      return k(o3, "Could not convert color info: no field and no colors/stops"), null;
    {
      const o4 = e5.stops && e5.stops.length >= 0 && e5.stops[0].color;
      t3.color = { field: null, values: [0, 0, 0, 0, 0, 0, 0, 0], colors: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
      for (let e6 = 0; e6 < 8; e6++)
        t3.color.values[e6] = 1 / 0, R(t3.color.colors, e6, o4);
    }
  }
  return t3;
}
function _(e5, t3, o3) {
  if (e5.normalizationField)
    return k(o3, "Could not convert opacity info: unsupported property"), null;
  if (M(e5.field)) {
    if (!e5.stops)
      return k(o3, "Could not convert opacity info: missing stops or opacities"), null;
    {
      if (e5.stops.length > 8)
        return k(o3, "Could not convert opacity info: too many opacity stops"), null;
      t3.opacity = new C(e5.field);
      const i4 = e5.stops;
      for (let e6 = 0; e6 < 8; ++e6) {
        const o4 = i4[Math.min(e6, i4.length - 1)];
        t3.opacity.values[e6] = o4.value, t3.opacity.opacityValues[e6] = o4.opacity;
      }
    }
  } else {
    if (!(e5.stops && e5.stops.length >= 0))
      return k(o3, "Could not convert opacity info: no field and no opacities/stops"), null;
    {
      const o4 = e5.stops && e5.stops.length >= 0 ? e5.stops[0].opacity : 0;
      t3.opacity = { field: null, values: [0, 0, 0, 0, 0, 0, 0, 0], opacityValues: [0, 0, 0, 0, 0, 0, 0, 0] };
      for (let e6 = 0; e6 < 8; e6++)
        t3.opacity.values[e6] = 1 / 0, t3.opacity.opacityValues[e6] = o4;
    }
  }
  return t3;
}
function q(e5, t3, o3) {
  const i4 = 2 === o3 && "arithmetic" === e5.rotationType;
  t3.offset[o3] = i4 ? 90 : 0, t3.factor[o3] = i4 ? -1 : 1, t3.type[o3] = 1;
}
function $(e5, t3, o3) {
  if (!M(e5.field))
    return k(o3, "Could not convert rotation info: field is not a string"), null;
  if (t3.rotation) {
    if (e5.field)
      if (t3.rotation.field) {
        if (e5.field !== t3.rotation.field)
          return k(o3, "Could not convert rotation info: multiple fields in use"), null;
      } else
        t3.rotation.field = e5.field;
  } else
    t3.rotation = { field: e5.field, offset: [0, 0, 0], factor: [1, 1, 1], type: [0, 0, 0] };
  switch (e5.axis) {
    case "tilt":
      return q(e5, t3.rotation, 0), t3;
    case "roll":
      return q(e5, t3.rotation, 1), t3;
    case null:
    case void 0:
    case "heading":
      return q(e5, t3.rotation, 2), t3;
    default:
      return k(o3, `Could not convert rotation info: unknown axis "${e5.axis}""`), null;
  }
}
var B = class {
  constructor(e5, t3 = [1, 1, 1], o3 = [1, 1, 1], i4 = 1, n4 = [0, 0, 0], s2 = [1, 1, 1], r2 = [0, 0, 0]) {
    this.supports = e5, this.modelSize = t3, this.symbolSize = o3, this.unitInMeters = i4, this.anchor = n4, this.scale = s2, this.rotation = r2;
  }
};
function L(e5, t3, o3) {
  if (!e5)
    return null;
  const i4 = e5.reduce((e6, i5) => {
    if (!e6)
      return e6;
    if (i5.valueExpression)
      return k(o3, "Could not convert visual variables: arcade expressions not supported"), null;
    switch (i5.type) {
      case "size":
        return t3.supports.size ? F(i5, e6, t3, o3) : e6;
      case "color":
        return t3.supports.color ? E(i5, e6, o3) : e6;
      case "opacity":
        return t3.supports.opacity ? _(i5, e6, o3) : null;
      case "rotation":
        return t3.supports.rotation ? $(i5, e6, o3) : e6;
      default:
        return null;
    }
  }, new w());
  return !(e5.length > 0 && i4) || i4.size || i4.color || i4.opacity || i4.rotation ? i4 && i4.size && !P(i4.size, t3, o3) ? null : i4 : null;
}
var N = class {
  constructor(e5, t3, o3) {
    this.visualVariables = e5, this.materialParameters = t3, this.requiresShaderTransformation = o3;
  }
};
function O(e5, t3) {
  if (!e5)
    return null;
  if (t.TESTS_DISABLE_FAST_UPDATES)
    return null;
  const o3 = L(e5.visualVariables, t3);
  return o3 ? new N(o3, K(o3, t3), !!o3.size) : null;
}
function G(e5, t3, o3) {
  if (!t3 || !e5)
    return false;
  const i4 = e5.visualVariables, n4 = L(t3.visualVariables, o3);
  return !!n4 && (!!(H(i4.size, n4.size, "size") && H(i4.color, n4.color, "color") && H(i4.rotation, n4.rotation, "rotation") && H(i4.opacity, n4.opacity, "opacity")) && (e5.visualVariables = n4, e5.materialParameters = K(n4, o3), e5.requiresShaderTransformation = !!n4.size, true));
}
function H(e5, t3, o3) {
  if (!!e5 != !!t3)
    return false;
  if (e5 && e5.field !== (t3 == null ? void 0 : t3.field))
    return false;
  if (e5 && "rotation" === o3) {
    const o4 = e5, i4 = t3;
    for (let e6 = 0; e6 < 3; e6++)
      if (o4.type[e6] !== i4.type[e6] || o4.offset[e6] !== i4.offset[e6] || o4.factor[e6] !== i4.factor[e6])
        return false;
  }
  return true;
}
var J = class extends n3 {
  constructor(e5) {
    super(), this.vvSize = (e5 == null ? void 0 : e5.size) ?? null, this.vvColor = (e5 == null ? void 0 : e5.color) ?? null, this.vvOpacity = (e5 == null ? void 0 : e5.opacity) ?? null;
  }
};
function K(e5, n4) {
  const s2 = new J(e5);
  return s2.vvSize && (s2.vvSymbolAnchor = n4.anchor, r(ee), A(n4.rotation[2], n4.rotation[0], n4.rotation[1], ee), s2.vvSymbolRotationMatrix = s2.vvSymbolRotationMatrix || e(), a(s2.vvSymbolRotationMatrix, ee)), s2;
}
function Q(t3, o3, i4) {
  if (!t3.vvSize)
    return i4;
  n2(Y, i4);
  const u = t3.vvSymbolRotationMatrix;
  s(ee, u[0], u[1], u[2], 0, u[3], u[4], u[5], 0, u[6], u[7], u[8], 0, 0, 0, 0, 1), c(Y, Y, ee);
  for (let n4 = 0; n4 < 3; ++n4) {
    const i5 = t3.vvSize.offset[n4] + o3[0] * t3.vvSize.factor[n4];
    Z[n4] = i(i5, t3.vvSize.minSize[n4], t3.vvSize.maxSize[n4]);
  }
  return f(Y, Y, Z), i2(Y, Y, t3.vvSymbolAnchor), Y;
}
function W(t3, o3, i4) {
  if (o3.vvSize)
    for (let n4 = 0; n4 < 3; ++n4) {
      const s2 = o3.vvSize.offset[n4] + i4[0] * o3.vvSize.factor[n4];
      t3[n4] = i(s2, o3.vvSize.minSize[n4], o3.vvSize.maxSize[n4]);
    }
  else
    o(t3, 1, 1, 1);
}
function X(e5, t3) {
  const o3 = null == e5 ? 0 : t3.attributes[e5];
  return "number" == typeof o3 && isFinite(o3) ? o3 : 0;
}
var Y = e2();
var Z = n();
var ee = e2();

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/VisualVariablePassParameters.js
var t2 = class extends J {
  constructor() {
    super(...arguments), this.renderOccluded = o2.Occlude;
  }
};
var e4 = 8;

export {
  e3 as e,
  B,
  O,
  G,
  Q,
  W,
  X,
  t2 as t,
  e4 as e2
};
//# sourceMappingURL=chunk-YQDOKTNT.js.map
