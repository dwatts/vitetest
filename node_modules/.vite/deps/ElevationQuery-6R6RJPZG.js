import {
  c,
  t as t2
} from "./chunk-FKARCCEM.js";
import {
  t
} from "./chunk-Y2ZDD3I4.js";
import {
  Rn,
  nn
} from "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import "./chunk-7EG7BYWF.js";
import {
  _
} from "./chunk-SVCGLUNW.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-HXPVVSLV.js";
import {
  m2 as m,
  u
} from "./chunk-4OR73Y2R.js";
import {
  E,
  i,
  o
} from "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-3VUFACNT.js";
import {
  x2 as x
} from "./chunk-ZEEBL7ZN.js";
import {
  H
} from "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import "./chunk-V76KGJFU.js";
import "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import {
  f,
  j,
  p
} from "./chunk-7I33FAWS.js";
import {
  r
} from "./chunk-DWOEYHKS.js";
import {
  s3 as s
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/ElevationTile.js
var t3 = class {
  constructor(t4, l2 = null) {
    if (this.tile = t4, null != l2 && null != t4) {
      const e = t4.extent;
      this._samplerData = new t2(l2, e);
    }
  }
  get zmin() {
    return null != this._samplerData ? this._samplerData.data.minValue : 0;
  }
  get zmax() {
    return null != this._samplerData ? this._samplerData.data.maxValue : 0;
  }
  sample(a, t4) {
    if (null == this._samplerData)
      return;
    const { safeWidth: e, data: r2, dx: s2, dy: n, y1: i2, x0: u2 } = this._samplerData, { width: m2, values: o2, noDataValue: h } = r2, p2 = l(n * (i2 - t4), 0, e), D = l(s2 * (a - u2), 0, e), f2 = Math.floor(p2), c2 = Math.floor(D), d = f2 * m2 + c2, _3 = d + m2, x3 = o2[d], V = o2[_3], g2 = o2[d + 1], v2 = o2[_3 + 1];
    if (x3 !== h && V !== h && g2 !== h && v2 !== h) {
      const a2 = D - c2, t5 = x3 + (g2 - x3) * a2;
      return t5 + (V + (v2 - V) * a2 - t5) * (p2 - f2);
    }
  }
};
function l(a, t4, l2) {
  return a < t4 ? t4 : a > l2 ? l2 : a;
}

// node_modules/@arcgis/core/layers/support/ElevationQuery.js
var v = class {
  async queryAll(e, i2, n) {
    if (!(e = n && n.ignoreInvisibleLayers ? e.filter((e2) => e2.visible) : e.slice()).length)
      throw new s("elevation-query:invalid-layer", "Elevation queries require at least one elevation layer to fetch tiles from");
    const l2 = w.fromGeometry(i2);
    let s2 = false;
    n && n.returnSampleInfo || (s2 = true);
    const o2 = { ...q, ...n, returnSampleInfo: true }, a = await this.query(e[e.length - 1], l2, o2), r2 = await this._queryAllContinue(e, a, o2);
    return r2.geometry = r2.geometry.export(), s2 && delete r2.sampleInfo, r2;
  }
  async query(e, i2, n) {
    if (!e)
      throw new s("elevation-query:invalid-layer", "Elevation queries require an elevation layer to fetch tiles from");
    if (!i2 || !(i2 instanceof w) && "point" !== i2.type && "multipoint" !== i2.type && "polyline" !== i2.type)
      throw new s("elevation-query:invalid-geometry", "Only point, polyline and multipoint geometries can be used to query elevation");
    const l2 = { ...q, ...n }, s2 = new _2(e, i2.spatialReference, l2), o2 = l2.signal;
    return await e.load({ signal: o2 }), await this._createGeometryDescriptor(s2, i2, o2), await this._selectTiles(s2, o2), await this._populateElevationTiles(s2, o2), this._sampleGeometryWithElevation(s2), this._createQueryResult(s2, o2);
  }
  async createSampler(e, i2, n) {
    if (!e)
      throw new s("elevation-query:invalid-layer", "Elevation queries require an elevation layer to fetch tiles from");
    if (!i2 || "extent" !== i2.type)
      throw new s("elevation-query:invalid-extent", "Invalid or undefined extent");
    const l2 = { ...q, ...n };
    return this._createSampler(e, i2, l2);
  }
  async createSamplerAll(e, i2, n) {
    if (!(e = n && n.ignoreInvisibleLayers ? e.filter((e2) => e2.visible) : e.slice()).length)
      throw new s("elevation-query:invalid-layer", "Elevation queries require at least one elevation layer to fetch tiles from");
    if (!i2 || "extent" !== i2.type)
      throw new s("elevation-query:invalid-extent", "Invalid or undefined extent");
    const l2 = { ...q, ...n, returnSampleInfo: true }, s2 = await this._createSampler(e[e.length - 1], i2, l2);
    return this._createSamplerAllContinue(e, i2, s2, l2);
  }
  async _createSampler(e, t4, i2, n) {
    const l2 = i2.signal;
    await e.load({ signal: l2 });
    const s2 = t4.spatialReference, o2 = e.tileInfo.spatialReference;
    s2.equals(o2) || (await Rn([{ source: s2, dest: o2 }], { signal: l2 }), t4 = nn(t4, o2));
    const a = new E2(e, t4, i2, n);
    return await this._selectTiles(a, l2), await this._populateElevationTiles(a, l2), new c(a.elevationTiles, a.layer.tileInfo, a.options.noDataValue);
  }
  async _createSamplerAllContinue(e, t4, i2, n) {
    if (e.pop(), !e.length)
      return i2;
    const l2 = i2.samplers.map((e2) => o(e2.extent)), s2 = await this._createSampler(e[e.length - 1], t4, n, l2);
    if (0 === s2.samplers.length)
      return i2;
    const o2 = i2.samplers.concat(s2.samplers), a = new c(o2, n.noDataValue);
    return this._createSamplerAllContinue(e, t4, a, n);
  }
  async _queryAllContinue(e, t4, n) {
    const l2 = e.pop(), s2 = t4.geometry.coordinates, o2 = t4.sampleInfo;
    r(o2);
    const a = [], r2 = [];
    for (let i2 = 0; i2 < s2.length; i2++) {
      const t5 = o2[i2];
      t5.demResolution >= 0 ? t5.source || (t5.source = l2) : e.length && (a.push(s2[i2]), r2.push(i2));
    }
    if (!e.length || 0 === a.length)
      return t4;
    const c2 = t4.geometry.clone(a), u2 = await this.query(e[e.length - 1], c2, n), h = u2.sampleInfo;
    if (!h)
      throw new Error("no sampleInfo");
    return r2.forEach((e2, t5) => {
      s2[e2].z = u2.geometry.coordinates[t5].z, o2[e2].demResolution = h[t5].demResolution;
    }), this._queryAllContinue(e, t4, n);
  }
  async _createQueryResult(e, t4) {
    const n = await e.geometry.project(e.outSpatialReference, t4);
    r(n);
    const l2 = { geometry: n.export(), noDataValue: e.options.noDataValue };
    return e.options.returnSampleInfo && (l2.sampleInfo = this._extractSampleInfo(e)), e.geometry.coordinates.forEach((e2) => {
      e2.tile = null, e2.elevationTile = null;
    }), l2;
  }
  async _createGeometryDescriptor(e, i2, n) {
    let l2;
    const s2 = e.layer.tileInfo.spatialReference;
    if (i2 instanceof w ? l2 = await i2.project(s2, n) : (await Rn([{ source: i2.spatialReference, dest: s2 }], { signal: n }), l2 = nn(i2, s2)), !l2)
      throw new s("elevation-query:spatial-reference-mismatch", `Cannot query elevation in '${i2.spatialReference.wkid}' on an elevation service in '${s2.wkid}'`);
    e.geometry = w.fromGeometry(l2);
  }
  async _selectTiles(e, i2) {
    "geometry" === e.type && this._preselectOutsideLayerExtent(e);
    const n = e.options.demResolution;
    if ("number" == typeof n)
      this._selectTilesClosestResolution(e, n);
    else if ("finest-contiguous" === n)
      await this._selectTilesFinestContiguous(e, i2);
    else {
      if ("auto" !== n)
        throw new s("elevation-query:invalid-dem-resolution", `Invalid dem resolution value '${n}', expected a number, "finest-contiguous" or "auto"`);
      await this._selectTilesAuto(e, i2);
    }
  }
  _preselectOutsideLayerExtent(e) {
    if (null == e.layer.fullExtent)
      return;
    const t4 = new t3(null);
    t4.sample = () => e.options.noDataValue, e.outsideExtentTile = t4;
    const i2 = e.layer.fullExtent;
    e.geometry.coordinates.forEach((e2) => {
      const n = e2.x, l2 = e2.y;
      (n < i2.xmin || n > i2.xmax || l2 < i2.ymin || l2 > i2.ymax) && (e2.elevationTile = t4);
    });
  }
  _selectTilesClosestResolution(e, t4) {
    const i2 = this._findNearestDemResolutionLODIndex(e, t4);
    e.selectTilesAtLOD(i2);
  }
  _findNearestDemResolutionLODIndex(e, t4) {
    const { tileInfo: i2, tilemapCache: n } = e.layer, l2 = t4 / H(i2.spatialReference), s2 = I(i2, n);
    let a = s2[0], r2 = 0;
    for (let o2 = 1; o2 < s2.length; o2++) {
      const e2 = s2[o2];
      Math.abs(e2.resolution - l2) < Math.abs(a.resolution - l2) && (a = e2, r2 = o2);
    }
    return r2;
  }
  async _selectTilesFinestContiguous(e, t4) {
    const { tileInfo: i2, tilemapCache: n } = e.layer, l2 = R(i2, n, e.options.minDemResolution);
    await this._selectTilesFinestContiguousAt(e, l2, t4);
  }
  async _selectTilesFinestContiguousAt(e, i2, s2) {
    const o2 = e.layer;
    if (e.selectTilesAtLOD(i2), i2 < 0)
      return;
    const a = o2.tilemapCache, r2 = e.getTilesToFetch();
    try {
      if (a && !A(a))
        await p(Promise.all(r2.map((e2) => a.fetchAvailability(e2.level, e2.row, e2.col, { signal: s2 }))), s2);
      else if (await this._populateElevationTiles(e, s2), !e.allElevationTilesFetched())
        throw e.clearElevationTiles(), new s("elevation-query:has-unavailable-tiles");
    } catch (c2) {
      f(c2), await this._selectTilesFinestContiguousAt(e, i2 - 1, s2);
    }
  }
  async _populateElevationTiles(e, t4) {
    const i2 = e.getTilesToFetch(), l2 = {}, o2 = e.options.cache, a = e.options.noDataValue, r2 = i2.map(async (i3) => {
      if (null == i3.id)
        return;
      const n = `${e.layer.uid}:${i3.id}:${a}`, s2 = null != o2 ? o2.get(n) : null, r3 = null != s2 ? s2 : await e.layer.fetchTile(i3.level, i3.row, i3.col, { noDataValue: a, signal: t4 });
      null != o2 && o2.put(n, r3), l2[i3.id] = new t3(i3, r3);
    });
    await p(j(r2), t4), e.populateElevationTiles(l2);
  }
  async _selectTilesAuto(t4, i2) {
    this._selectTilesAutoFinest(t4), this._reduceTilesForMaximumRequests(t4);
    const s2 = t4.layer.tilemapCache;
    if (!s2 || A(s2))
      return this._selectTilesAutoPrefetchUpsample(t4, i2);
    const o2 = t4.getTilesToFetch(), a = {}, r2 = o2.map(async (t5) => {
      const n = new t(null, 0, 0, 0, i()), o3 = await _(s2.fetchAvailabilityUpsample(t5.level, t5.row, t5.col, n, { signal: i2 }));
      false !== o3.ok ? null != t5.id && (a[t5.id] = n) : f(o3.error);
    });
    await p(Promise.all(r2), i2), t4.remapTiles(a);
  }
  _reduceTilesForMaximumRequests(e) {
    const t4 = e.layer.tileInfo;
    let i2 = 0;
    const n = {}, l2 = (e2) => {
      null != e2.id && (e2.id in n ? n[e2.id]++ : (n[e2.id] = 1, i2++));
    }, s2 = (e2) => {
      if (null == e2.id)
        return;
      const t5 = n[e2.id];
      1 === t5 ? (delete n[e2.id], i2--) : n[e2.id] = t5 - 1;
    };
    e.forEachTileToFetch(l2, s2);
    let o2 = true;
    for (; o2 && (o2 = false, e.forEachTileToFetch((n2) => {
      i2 <= e.options.maximumAutoTileRequests || (s2(n2), t4.upsampleTile(n2) && (o2 = true), l2(n2));
    }, s2), o2); )
      ;
  }
  _selectTilesAutoFinest(e) {
    const { tileInfo: t4, tilemapCache: i2 } = e.layer, n = R(t4, i2, e.options.minDemResolution);
    e.selectTilesAtLOD(n, e.options.maximumAutoTileRequests);
  }
  async _selectTilesAutoPrefetchUpsample(e, t4) {
    const i2 = e.layer.tileInfo;
    await this._populateElevationTiles(e, t4);
    let n = false;
    e.forEachTileToFetch((e2, t5) => {
      i2.upsampleTile(e2) ? n = true : t5();
    }), n && await this._selectTilesAutoPrefetchUpsample(e, t4);
  }
  _sampleGeometryWithElevation(e) {
    e.geometry.coordinates.forEach((t4) => {
      const i2 = t4.elevationTile;
      let n = e.options.noDataValue;
      if (i2) {
        const e2 = i2.sample(t4.x, t4.y);
        null != e2 ? n = e2 : t4.elevationTile = null;
      }
      t4.z = n;
    });
  }
  _extractSampleInfo(e) {
    const t4 = e.layer.tileInfo, i2 = H(t4.spatialReference);
    return e.geometry.coordinates.map((n) => {
      let l2 = -1;
      if (n.elevationTile && n.elevationTile !== e.outsideExtentTile) {
        l2 = t4.lodAt(n.elevationTile.tile.level).resolution * i2;
      }
      return { demResolution: l2 };
    });
  }
};
var w = class _w {
  export() {
    return this._exporter(this.coordinates, this.spatialReference);
  }
  clone(e) {
    const t4 = new _w();
    return t4.geometry = this.geometry, t4.spatialReference = this.spatialReference, t4.coordinates = e || this.coordinates.map((e2) => e2.clone()), t4._exporter = this._exporter, t4;
  }
  async project(e, t4) {
    if (this.spatialReference.equals(e))
      return this.clone();
    await Rn([{ source: this.spatialReference, dest: e }], { signal: t4 });
    const i2 = new u({ spatialReference: this.spatialReference, points: this.coordinates.map((e2) => [e2.x, e2.y]) }), n = nn(i2, e);
    if (!n)
      return null;
    const l2 = this.coordinates.map((e2, t5) => {
      const i3 = e2.clone(), l3 = n.points[t5];
      return i3.x = l3[0], i3.y = l3[1], i3;
    }), s2 = this.clone(l2);
    return s2.spatialReference = e, s2;
  }
  static fromGeometry(e) {
    const t4 = new _w();
    if (t4.geometry = e, t4.spatialReference = e.spatialReference, e instanceof _w)
      t4.coordinates = e.coordinates.map((e2) => e2.clone()), t4._exporter = (t5, i2) => {
        const n = e.clone(t5);
        return n.spatialReference = i2, n;
      };
    else
      switch (e.type) {
        case "point": {
          const i2 = e, { hasZ: n, hasM: l2 } = i2;
          t4.coordinates = n && l2 ? [new g(i2.x, i2.y, i2.z, i2.m)] : n ? [new g(i2.x, i2.y, i2.z)] : l2 ? [new g(i2.x, i2.y, null, i2.m)] : [new g(i2.x, i2.y)], t4._exporter = (t5, i3) => e.hasM ? new x(t5[0].x, t5[0].y, t5[0].z, t5[0].m, i3) : new x(t5[0].x, t5[0].y, t5[0].z, i3);
          break;
        }
        case "multipoint": {
          const i2 = e, { hasZ: n, hasM: l2 } = i2;
          t4.coordinates = n && l2 ? i2.points.map((e2) => new g(e2[0], e2[1], e2[2], e2[3])) : n ? i2.points.map((e2) => new g(e2[0], e2[1], e2[2])) : l2 ? i2.points.map((e2) => new g(e2[0], e2[1], null, e2[2])) : i2.points.map((e2) => new g(e2[0], e2[1])), t4._exporter = (t5, i3) => e.hasM ? new u({ points: t5.map((e2) => [e2.x, e2.y, e2.z, e2.m]), hasZ: true, hasM: true, spatiaReference: i3 }) : new u(t5.map((e2) => [e2.x, e2.y, e2.z]), i3);
          break;
        }
        case "polyline": {
          const i2 = e, n = [], l2 = [], { hasZ: s2, hasM: o2 } = e;
          let a = 0;
          for (const e2 of i2.paths)
            if (l2.push([a, a + e2.length]), a += e2.length, s2 && o2)
              for (const t5 of e2)
                n.push(new g(t5[0], t5[1], t5[2], t5[3]));
            else if (s2)
              for (const t5 of e2)
                n.push(new g(t5[0], t5[1], t5[2]));
            else if (o2)
              for (const t5 of e2)
                n.push(new g(t5[0], t5[1], null, t5[2]));
            else
              for (const t5 of e2)
                n.push(new g(t5[0], t5[1]));
          t4.coordinates = n, t4._exporter = (t5, i3) => {
            const n2 = e.hasM ? t5.map((e2) => [e2.x, e2.y, e2.z, e2.m]) : t5.map((e2) => [e2.x, e2.y, e2.z]), s3 = l2.map((e2) => n2.slice(e2[0], e2[1]));
            return new m({ paths: s3, hasM: e.hasM, hasZ: true, spatialReference: i3 });
          };
          break;
        }
      }
    return t4;
  }
};
var g = class _g {
  constructor(e, t4, i2 = null, n = null, l2 = null, s2 = null) {
    this.x = e, this.y = t4, this.z = i2, this.m = n, this.tile = l2, this.elevationTile = s2;
  }
  clone() {
    return new _g(this.x, this.y, this.z, this.m);
  }
};
var x2 = class {
  constructor(e, t4) {
    this.layer = e, this.options = t4;
  }
};
var _2 = class extends x2 {
  constructor(e, t4, i2) {
    super(e, i2), this.outSpatialReference = t4, this.type = "geometry";
  }
  selectTilesAtLOD(e) {
    if (e < 0)
      this.geometry.coordinates.forEach((e2) => e2.tile = null);
    else {
      const { tileInfo: t4, tilemapCache: i2 } = this.layer, n = I(t4, i2)[e].level;
      this.geometry.coordinates.forEach((e2) => e2.tile = t4.tileAt(n, e2.x, e2.y));
    }
  }
  allElevationTilesFetched() {
    return !this.geometry.coordinates.some((e) => !e.elevationTile);
  }
  clearElevationTiles() {
    for (const e of this.geometry.coordinates)
      e.elevationTile !== this.outsideExtentTile && (e.elevationTile = null);
  }
  populateElevationTiles(e) {
    var _a;
    for (const t4 of this.geometry.coordinates)
      !t4.elevationTile && ((_a = t4.tile) == null ? void 0 : _a.id) && (t4.elevationTile = e[t4.tile.id]);
  }
  remapTiles(e) {
    var _a;
    for (const t4 of this.geometry.coordinates) {
      const i2 = (_a = t4.tile) == null ? void 0 : _a.id;
      t4.tile = i2 ? e[i2] : null;
    }
  }
  getTilesToFetch() {
    var _a;
    const e = {}, t4 = [];
    for (const i2 of this.geometry.coordinates) {
      const n = i2.tile;
      if (!n)
        continue;
      const l2 = (_a = i2.tile) == null ? void 0 : _a.id;
      i2.elevationTile || !l2 || e[l2] || (e[l2] = n, t4.push(n));
    }
    return t4;
  }
  forEachTileToFetch(e) {
    for (const t4 of this.geometry.coordinates)
      t4.tile && !t4.elevationTile && e(t4.tile, () => {
        t4.tile = null;
      });
  }
};
var E2 = class extends x2 {
  constructor(e, t4, i2, n) {
    super(e, i2), this.type = "extent", this.elevationTiles = [], this._candidateTiles = [], this._fetchedCandidates = /* @__PURE__ */ new Set(), this.extent = t4.intersection(e.fullExtent), this.maskExtents = n;
  }
  selectTilesAtLOD(e, t4) {
    const i2 = this._maximumLodForRequests(t4), n = Math.min(i2, e);
    n < 0 ? this._candidateTiles.length = 0 : this._selectCandidateTilesCoveringExtentAt(n);
  }
  _maximumLodForRequests(e) {
    const { tileInfo: t4, tilemapCache: i2 } = this.layer, n = I(t4, i2);
    if (!e)
      return n.length - 1;
    const l2 = this.extent;
    if (null == l2)
      return -1;
    for (let s2 = n.length - 1; s2 >= 0; s2--) {
      const i3 = n[s2], o2 = i3.resolution * t4.size[0], a = i3.resolution * t4.size[1];
      if (Math.ceil(l2.width / o2) * Math.ceil(l2.height / a) <= e)
        return s2;
    }
    return -1;
  }
  allElevationTilesFetched() {
    return this._candidateTiles.length === this.elevationTiles.length;
  }
  clearElevationTiles() {
    this.elevationTiles.length = 0, this._fetchedCandidates.clear();
  }
  populateElevationTiles(e) {
    for (const t4 of this._candidateTiles) {
      const i2 = t4.id && e[t4.id];
      i2 && (this._fetchedCandidates.add(t4), this.elevationTiles.push(i2));
    }
  }
  remapTiles(e) {
    this._candidateTiles = this._uniqueNonOverlappingTiles(this._candidateTiles.map((t4) => e[t4.id]));
  }
  getTilesToFetch() {
    return this._candidateTiles;
  }
  forEachTileToFetch(e, t4) {
    const i2 = this._candidateTiles;
    this._candidateTiles = [], i2.forEach((i3) => {
      if (this._fetchedCandidates.has(i3))
        return void (t4 && t4(i3));
      let n = false;
      e(i3, () => n = true), n ? t4 && t4(i3) : this._candidateTiles.push(i3);
    }), this._candidateTiles = this._uniqueNonOverlappingTiles(this._candidateTiles, t4);
  }
  _uniqueNonOverlappingTiles(e, t4) {
    const i2 = {}, n = [];
    for (const s2 of e) {
      const e2 = s2.id;
      e2 && !i2[e2] ? (i2[e2] = s2, n.push(s2)) : t4 && t4(s2);
    }
    const l2 = n.sort((e2, t5) => e2.level - t5.level);
    return l2.filter((e2, i3) => {
      for (let n2 = 0; n2 < i3; n2++) {
        const i4 = l2[n2].extent;
        if (i4 && e2.extent && E(i4, e2.extent))
          return t4 && t4(e2), false;
      }
      return true;
    });
  }
  _selectCandidateTilesCoveringExtentAt(e) {
    this._candidateTiles.length = 0;
    const t4 = this.extent;
    if (null == t4)
      return;
    const { tileInfo: i2, tilemapCache: n } = this.layer, l2 = I(i2, n)[e], s2 = i2.tileAt(l2.level, t4.xmin, t4.ymin), o2 = s2.extent;
    if (null == o2)
      return;
    const a = l2.resolution * i2.size[0], r2 = l2.resolution * i2.size[1], c2 = Math.ceil((t4.xmax - o2[0]) / a), u2 = Math.ceil((t4.ymax - o2[1]) / r2);
    for (let h = 0; h < u2; h++)
      for (let e2 = 0; e2 < c2; e2++) {
        const t5 = new t(null, s2.level, s2.row - h, s2.col + e2);
        i2.updateTileInfo(t5), this._tileIsMasked(t5) || this._candidateTiles.push(t5);
      }
  }
  _tileIsMasked(e) {
    return !!this.maskExtents && this.maskExtents.some((t4) => e.extent && E(t4, e.extent));
  }
};
function R(e, t4, i2 = 0) {
  const n = I(e, t4);
  let l2 = n.length - 1;
  if (i2 > 0) {
    const t5 = i2 / H(e.spatialReference), s2 = n.findIndex((e2) => e2.resolution < t5);
    0 === s2 ? l2 = 0 : s2 > 0 && (l2 = s2 - 1);
  }
  return l2;
}
var q = { maximumAutoTileRequests: 20, noDataValue: 0, returnSampleInfo: false, demResolution: "auto", minDemResolution: 0 };
function I(e, t4) {
  const i2 = e.lods;
  if (A(t4)) {
    const { effectiveMinLOD: e2, effectiveMaxLOD: n } = t4;
    return i2.filter((t5) => t5.level >= e2 && t5.level <= n);
  }
  return i2;
}
function A(e) {
  return null != (e == null ? void 0 : e.tileInfo);
}
export {
  v as ElevationQuery,
  w as GeometryDescriptor,
  R as getFinestLodIndex
};
//# sourceMappingURL=ElevationQuery-6R6RJPZG.js.map
