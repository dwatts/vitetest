import {
  F,
  c,
  i
} from "./chunk-EKJ2DJIR.js";
import {
  g,
  x2 as x
} from "./chunk-ZEEBL7ZN.js";
import {
  H
} from "./chunk-RTDN6KAT.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";

// node_modules/@arcgis/core/layers/support/ElevationSampler.js
var r = s.getLogger("esri.layers.support.ElevationSampler");
var l = class {
  queryElevation(e) {
    return u(e.clone(), this);
  }
  on() {
    return d;
  }
  projectIfRequired(e, t2) {
    return p(e, t2);
  }
};
var m = class extends l {
  get spatialReference() {
    return this.extent.spatialReference;
  }
  constructor(e, s2, i2) {
    super(), this.tile = e, this.noDataValue = i2;
    const o = e.tile.extent;
    this.extent = c(o, s2.spatialReference), this.extent.zmin = e.zmin, this.extent.zmax = e.zmax, this._aaExtent = o;
    const a = H(s2.spatialReference), r2 = s2.lodAt(e.tile.level).resolution * a;
    this.demResolution = { min: r2, max: r2 };
  }
  contains(e) {
    const t2 = this.projectIfRequired(e, this.spatialReference);
    return null != t2 && this.containsAt(t2.x, t2.y);
  }
  containsAt(e, t2) {
    return F(this._aaExtent, e, t2);
  }
  elevationAt(e, t2) {
    if (!this.containsAt(e, t2)) {
      const n = this.extent, s2 = `${n.xmin}, ${n.ymin}, ${n.xmax}, ${n.ymax}`;
      return r.warn("#elevationAt()", `Point used to sample elevation (${e}, ${t2}) is outside of the sampler extent (${s2})`), this.noDataValue;
    }
    return this.tile.sample(e, t2) ?? this.noDataValue;
  }
};
var c2 = class extends l {
  get spatialReference() {
    return this.extent.spatialReference;
  }
  constructor(e, t2, s2) {
    let o;
    super(), "number" == typeof t2 ? (this.noDataValue = t2, o = null) : (o = t2, this.noDataValue = s2), this.samplers = o ? e.map((e2) => new m(e2, o, this.noDataValue)) : e;
    const a = this.samplers[0];
    if (a) {
      this.extent = a.extent.clone();
      const { min: e2, max: t3 } = a.demResolution;
      this.demResolution = { min: e2, max: t3 };
      for (let n = 1; n < this.samplers.length; n++) {
        const e3 = this.samplers[n];
        this.extent.union(e3.extent), this.demResolution.min = Math.min(this.demResolution.min, e3.demResolution.min), this.demResolution.max = Math.max(this.demResolution.max, e3.demResolution.max);
      }
    } else
      this.extent = c(i(), o.spatialReference), this.demResolution = { min: 0, max: 0 };
  }
  elevationAt(e, t2) {
    for (const n of this.samplers)
      if (n.containsAt(e, t2))
        return n.elevationAt(e, t2);
    return r.warn("#elevationAt()", `Point used to sample elevation (${e}, ${t2}) is outside of the sampler`), this.noDataValue;
  }
};
function u(e, t2) {
  const n = p(e, t2.spatialReference);
  if (!n)
    return null;
  switch (e.type) {
    case "point":
      h(e, n, t2);
      break;
    case "polyline":
      f(e, n, t2);
      break;
    case "multipoint":
      x2(e, n, t2);
  }
  return e;
}
function p(e, t2) {
  if (null == e)
    return null;
  const n = e.spatialReference;
  if (n.equals(t2))
    return e;
  const s2 = g(e, t2);
  return s2 || r.error(`Cannot project geometry spatial reference (wkid:${n.wkid}) to elevation sampler spatial reference (wkid:${t2.wkid})`), s2;
}
function h(e, t2, n) {
  e.z = n.elevationAt(t2.x, t2.y);
}
function f(e, t2, n) {
  R.spatialReference = t2.spatialReference;
  const s2 = e.hasM && !e.hasZ;
  for (let i2 = 0; i2 < e.paths.length; i2++) {
    const o = e.paths[i2], a = t2.paths[i2];
    for (let e2 = 0; e2 < o.length; e2++) {
      const t3 = o[e2], i3 = a[e2];
      R.x = i3[0], R.y = i3[1], s2 && (t3[3] = t3[2]), t3[2] = n.elevationAt(R.x, R.y);
    }
  }
  e.hasZ = true;
}
function x2(e, t2, n) {
  R.spatialReference = t2.spatialReference;
  const s2 = e.hasM && !e.hasZ;
  for (let i2 = 0; i2 < e.points.length; i2++) {
    const o = e.points[i2], a = t2.points[i2];
    R.x = a[0], R.y = a[1], s2 && (o[3] = o[2]), o[2] = n.elevationAt(R.x, R.y);
  }
  e.hasZ = true;
}
var R = new x();
var d = { remove() {
} };

// node_modules/@arcgis/core/layers/support/ElevationSamplerData.js
var t = class {
  constructor(t2, h2) {
    this.data = t2, this.safeWidth = 0.99999999 * (t2.width - 1), this.dx = (t2.width - 1) / (h2[2] - h2[0]), this.dy = (t2.width - 1) / (h2[3] - h2[1]), this.x0 = h2[0], this.y1 = h2[3];
  }
};

export {
  c2 as c,
  u,
  t
};
//# sourceMappingURL=chunk-FKARCCEM.js.map
