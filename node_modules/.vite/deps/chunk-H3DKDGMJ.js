import {
  R,
  o
} from "./chunk-WTPQKRQM.js";
import {
  V
} from "./chunk-BCDDCNQ2.js";
import {
  i,
  t
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import {
  y
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/webgl/VertexArrayObject.js
var f = s.getLogger("esri.views.webgl.VertexArrayObject");
var u = class {
  constructor(t2, e, i2, r, n = null) {
    this._context = t2, this._locations = e, this._layout = i2, this._buffers = r, this._indexBuffer = n, this._glName = null, this._initialized = false, t2.instanceCounter.increment(V.VertexArrayObject, this);
  }
  get glName() {
    return this._glName;
  }
  get context() {
    return this._context;
  }
  get vertexBuffers() {
    return this._buffers;
  }
  get indexBuffer() {
    return this._indexBuffer;
  }
  get byteSize() {
    return Object.keys(this._buffers).reduce((t2, e) => t2 + this._buffers[e].byteLength, null != this._indexBuffer ? this._indexBuffer.byteLength : 0);
  }
  get layout() {
    return this._layout;
  }
  get locations() {
    return this._locations;
  }
  get memoryEstimate() {
    return this.byteSize + (Object.keys(this._buffers).length + (this._indexBuffer ? 1 : 0)) * y;
  }
  dispose() {
    var _a;
    if (this._context) {
      this._context.getBoundVAO() === this && this._context.bindVAO(null);
      for (const t2 in this._buffers)
        (_a = this._buffers[t2]) == null ? void 0 : _a.dispose(), delete this._buffers[t2];
      this._indexBuffer = t(this._indexBuffer), this.disposeVAOOnly();
    } else
      (this._glName || Object.getOwnPropertyNames(this._buffers).length > 0) && f.warn("Leaked WebGL VAO");
  }
  disposeVAOOnly() {
    var _a, _b;
    if (this._glName) {
      const t2 = (_b = (_a = this._context) == null ? void 0 : _a.capabilities) == null ? void 0 : _b.vao;
      t2.deleteVertexArray(this._glName), this._glName = null;
    }
    this._context.instanceCounter.decrement(V.VertexArrayObject, this), this._context = i(this._context);
  }
  initialize() {
    if (this._initialized)
      return;
    const t2 = this._context.capabilities.vao;
    if (t2) {
      const e = t2.createVertexArray();
      t2.bindVertexArray(e), this._bindLayout(), t2.bindVertexArray(null), this._glName = e;
    }
    this._initialized = true;
  }
  bind() {
    this.initialize();
    const t2 = this._context.capabilities.vao;
    t2 ? t2.bindVertexArray(this.glName) : (this._context.bindVAO(null), this._bindLayout());
  }
  _bindLayout() {
    const { _buffers: t2, _layout: e, _indexBuffer: i2 } = this;
    t2 || f.error("Vertex buffer dictionary is empty!");
    const r = this._context.gl;
    for (const s2 in t2) {
      const i3 = t2[s2];
      i3 || f.error("Vertex buffer is uninitialized!");
      const r2 = e[s2];
      r2 || f.error("Vertex element descriptor is empty!"), R(this._context, this._locations, i3, r2);
    }
    if (null != i2) {
      !!this._context.capabilities.vao ? r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, i2.glName) : this._context.bindBuffer(i2);
    }
  }
  unbind() {
    this.initialize();
    const t2 = this._context.capabilities.vao;
    t2 ? t2.bindVertexArray(null) : this._unbindLayout();
  }
  _unbindLayout() {
    const { _buffers: t2, _layout: e } = this;
    t2 || f.error("Vertex buffer dictionary is empty!");
    for (const i2 in t2) {
      const r = t2[i2];
      r || f.error("Vertex buffer is uninitialized!");
      const s2 = e[i2];
      o(this._context, this._locations, r, s2);
    }
    null != this._indexBuffer && this._context.unbindBuffer(this._indexBuffer.bufferType);
  }
};

export {
  u
};
//# sourceMappingURL=chunk-H3DKDGMJ.js.map
