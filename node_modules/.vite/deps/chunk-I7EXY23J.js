import {
  t as t3
} from "./chunk-SCHIU6CT.js";
import {
  t as t2
} from "./chunk-N4JKQR77.js";
import {
  b
} from "./chunk-BDX5TRUE.js";
import {
  e
} from "./chunk-SMDDCTGQ.js";
import {
  t
} from "./chunk-UM64E5NS.js";
import {
  l
} from "./chunk-BDWD2ZNU.js";
import {
  s
} from "./chunk-6S2FCH6S.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  _
} from "./chunk-YGUWDSEH.js";
import {
  H
} from "./chunk-NLWV7Q6F.js";
import {
  l as l2
} from "./chunk-RVS5HU2K.js";
import {
  Yn
} from "./chunk-BNBT4QTW.js";
import {
  o
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import {
  A2 as A
} from "./chunk-RTDN6KAT.js";

// node_modules/@arcgis/core/views/3d/support/ElevationProvider.js
var r = class {
  constructor(e2, r2 = null, t5 = 0) {
    this.array = e2, this.spatialReference = r2, this.offset = t5;
  }
};
function t4(e2) {
  return "array" in e2;
}
function a(r2, a2, n2 = "ground") {
  if (t3(a2))
    return r2.getElevation(a2.x, a2.y, a2.z || 0, a2.spatialReference, n2);
  if (t4(a2)) {
    let e2 = a2.offset;
    return r2.getElevation(a2.array[e2++], a2.array[e2++], a2.array[e2] || 0, a2.spatialReference ?? r2.spatialReference, n2);
  }
  return r2.getElevation(a2[0], a2[1], a2[2] || 0, r2.spatialReference, n2);
}

// node_modules/@arcgis/core/views/3d/support/engineContent/line.js
function h(t5, e2, r2 = null) {
  const o2 = [], n2 = [], i = e2.mapPositions;
  T(e2, n2, o2);
  const a2 = n2[0][1].data, u = o2[0][1].length, l3 = l(u);
  return b2(e2, n2, o2, l3), A2(e2, n2, o2, l3), g(e2, n2, o2, l3), E(e2, n2, o2, l3), I(e2, n2, o2, l3), O2(e2, n2, o2, l3), R(e2, n2, o2, a2), new b(t5, n2, o2, i, e.Line, r2);
}
function T(t5, e2, r2) {
  const { attributeData: { position: o2 }, removeDuplicateStartEnd: n2 } = t5, i = D(o2) && n2, a2 = o2.length / 3 - (i ? 1 : 0), u = new Array(2 * (a2 - 1)), s2 = i ? o2.slice(0, o2.length - 3) : o2;
  let l3 = 0;
  for (let p = 0; p < a2 - 1; p++)
    u[l3++] = p, u[l3++] = p + 1;
  e2.push([O.POSITION, new s(s2, 3, i)]), r2.push([O.POSITION, u]);
}
function b2(t5, e2, r2, n2) {
  if (null != t5.attributeData.colorFeature)
    return;
  const i = t5.attributeData.color;
  e2.push([O.COLOR, new s(i ?? _, 4)]), r2.push([O.COLOR, n2]);
}
function g(t5, e2, r2, o2) {
  if (null == t5.attributeData.normal)
    return;
  const n2 = t5.attributeData.normal;
  e2.push([O.NORMAL, new s(n2, 3)]), r2.push([O.NORMAL, o2]);
}
function E(t5, e2, r2, o2) {
  null != t5.attributeData.colorFeature && (e2.push([O.COLORFEATUREATTRIBUTE, new s([t5.attributeData.colorFeature], 1, true)]), r2.push([O.COLOR, o2]));
}
function A2(t5, e2, r2, o2) {
  null == t5.attributeData.sizeFeature && (e2.push([O.SIZE, new s([t5.attributeData.size ?? 1], 1, true)]), r2.push([O.SIZE, o2]));
}
function I(t5, e2, r2, o2) {
  null != t5.attributeData.sizeFeature && (e2.push([O.SIZEFEATUREATTRIBUTE, new s([t5.attributeData.sizeFeature], 1, true)]), r2.push([O.SIZEFEATUREATTRIBUTE, o2]));
}
function O2(t5, e2, r2, o2) {
  const n2 = t5.attributeData.opacityFeature;
  null != n2 && (e2.push([O.OPACITYFEATUREATTRIBUTE, new s([n2], 1, true)]), r2.push([O.OPACITYFEATUREATTRIBUTE, o2]));
}
function R(r2, o2, s2, c) {
  if (null == r2.overlayInfo || r2.overlayInfo.renderCoordsHelper.viewingMode !== l2.Global || !r2.overlayInfo.spatialReference.isGeographic)
    return;
  const f = t(c.length), h2 = A(r2.overlayInfo.spatialReference);
  for (let t5 = 0; t5 < f.length; t5 += 3)
    Yn(c, t5, f, t5, h2);
  const T2 = c.length / 3, b3 = t2(T2 + 1);
  let g2 = j, E2 = w, A3 = 0, I2 = 0;
  o(g2, f[I2++], f[I2++], f[I2++]), b3[0] = 0;
  for (let n2 = 1; n2 < T2 + 1; ++n2)
    n2 === T2 && (I2 = 0), o(E2, f[I2++], f[I2++], f[I2++]), A3 += H(g2, E2), b3[n2] = A3, [g2, E2] = [E2, g2];
  o2.push([O.DISTANCETOSTART, new s(b3, 1, true)]), s2.push([O.DISTANCETOSTART, s2[0][1]]);
}
function D(t5) {
  const e2 = t5.length;
  return t5[0] === t5[e2 - 3] && t5[1] === t5[e2 - 2] && t5[2] === t5[e2 - 1];
}
var j = n();
var w = n();
function y(t5, e2) {
  if (null == t5 || 0 === t5.length)
    return [];
  const r2 = [];
  return t5.forEach((t6) => {
    const o2 = t6.length, n2 = t(3 * o2);
    t6.forEach((t7, e3) => {
      n2[3 * e3] = t7[0], n2[3 * e3 + 1] = t7[1], n2[3 * e3 + 2] = t7[2];
    });
    const i = { attributeData: { position: n2, normal: e2 }, removeDuplicateStartEnd: false };
    r2.push(i);
  }), r2;
}

export {
  r,
  t4 as t,
  a,
  h,
  y
};
//# sourceMappingURL=chunk-I7EXY23J.js.map
