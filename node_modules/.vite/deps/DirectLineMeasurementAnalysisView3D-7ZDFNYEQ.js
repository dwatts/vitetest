import {
  M as M2,
  R as R2,
  b,
  e as e5,
  e2 as e6,
  f as f5,
  t2 as t5,
  y as y3
} from "./chunk-SY3LKERQ.js";
import {
  s as s7
} from "./chunk-HFS3WATU.js";
import {
  P
} from "./chunk-UX7SMS2W.js";
import {
  C,
  L,
  R,
  d as d2,
  f as f3,
  f2 as f4,
  g as g2,
  h as h5,
  i as i2,
  m as m3,
  y as y2
} from "./chunk-KF45Y73U.js";
import "./chunk-AWHGPLMH.js";
import {
  a as a4,
  a2 as a5,
  i as i3,
  r as r3,
  s as s5,
  s2 as s6,
  t2 as t4,
  u as u2,
  u2 as u3
} from "./chunk-W2MFIVLD.js";
import "./chunk-V6RPZZQL.js";
import "./chunk-2NUCTFTS.js";
import "./chunk-67UNUI4B.js";
import {
  q
} from "./chunk-RX622OY6.js";
import "./chunk-2735WBYK.js";
import "./chunk-VJPLCQI5.js";
import "./chunk-KEWRTE2K.js";
import {
  h as h4
} from "./chunk-JQKL7AD5.js";
import "./chunk-YZTKL3LQ.js";
import "./chunk-I7EXY23J.js";
import "./chunk-SCHIU6CT.js";
import "./chunk-XXN3TEOU.js";
import "./chunk-FIJZ6LYC.js";
import "./chunk-MUANV6E3.js";
import "./chunk-SFIT2AUF.js";
import "./chunk-DBIFU6GO.js";
import "./chunk-V33FVMPT.js";
import "./chunk-U67EYFX3.js";
import "./chunk-4BA5YJ7C.js";
import {
  pt
} from "./chunk-WRC5WFEM.js";
import "./chunk-UYTAZUBJ.js";
import "./chunk-2EO2WRP7.js";
import "./chunk-NBYHM3OO.js";
import "./chunk-CERU5LKM.js";
import "./chunk-JZVYLVFO.js";
import "./chunk-FAOMDC3K.js";
import "./chunk-SCAYUERS.js";
import "./chunk-B76MSEZ4.js";
import "./chunk-ZYHVS2T2.js";
import "./chunk-XYSQCP5F.js";
import "./chunk-W5D3JTKS.js";
import "./chunk-XACNEHDM.js";
import "./chunk-IRBH32SX.js";
import "./chunk-MPIXWRXJ.js";
import "./chunk-XKYCNHCM.js";
import "./chunk-YEDW7SLL.js";
import "./chunk-N4JKQR77.js";
import "./chunk-BDX5TRUE.js";
import {
  A,
  c as c4
} from "./chunk-LIXBKTBN.js";
import "./chunk-VDSNHCMM.js";
import {
  E as E3
} from "./chunk-6LC2JTLC.js";
import {
  s as s4
} from "./chunk-XM3YSFN6.js";
import "./chunk-NIZWDAMQ.js";
import "./chunk-DU3C7D26.js";
import "./chunk-XUU35WPC.js";
import "./chunk-KSA6GV6M.js";
import "./chunk-K4WBDIIJ.js";
import "./chunk-ROPKVK6V.js";
import "./chunk-KM375BNF.js";
import "./chunk-H3DKDGMJ.js";
import "./chunk-FB6EWBGE.js";
import "./chunk-3TDCCT2R.js";
import "./chunk-Z2RTGLQI.js";
import {
  e as e4,
  i,
  t as t3
} from "./chunk-V6CD66ZZ.js";
import {
  W,
  _ as _2,
  a as a3
} from "./chunk-6FHMQNMS.js";
import "./chunk-D7YAG5U3.js";
import "./chunk-LGDKASPG.js";
import "./chunk-YQDOKTNT.js";
import "./chunk-SH6HJSS2.js";
import {
  r as r2
} from "./chunk-KFDARCTS.js";
import "./chunk-TRGMWULG.js";
import "./chunk-WTPQKRQM.js";
import {
  c as c3,
  d2 as d,
  o2
} from "./chunk-SMDDCTGQ.js";
import {
  E as E2
} from "./chunk-NU4UASX6.js";
import "./chunk-PKCLTDZO.js";
import "./chunk-4YXJLES6.js";
import "./chunk-EHQZFPMP.js";
import "./chunk-VC3BY3DV.js";
import "./chunk-WH76OAIT.js";
import "./chunk-B4ONZAW2.js";
import "./chunk-JHDKOKT6.js";
import "./chunk-YLTVH2K4.js";
import {
  t as t2
} from "./chunk-FB4A6PBH.js";
import "./chunk-CG3URTR2.js";
import "./chunk-UX3LCC3X.js";
import "./chunk-AB23UNQC.js";
import "./chunk-RDWKBYTH.js";
import "./chunk-IBJTEQQG.js";
import {
  o as o3
} from "./chunk-SADO52IH.js";
import "./chunk-WVOBJDWI.js";
import "./chunk-LIO6VZRI.js";
import "./chunk-7DFZCT3D.js";
import "./chunk-ASBUA7EG.js";
import "./chunk-FY4ZONHH.js";
import {
  h as h3
} from "./chunk-73PNWDTS.js";
import "./chunk-PKS3ZVLN.js";
import "./chunk-N3RXOITN.js";
import "./chunk-DOR4M5EA.js";
import "./chunk-3ROGWJVH.js";
import "./chunk-BUCIQGFS.js";
import "./chunk-CR5XNTAP.js";
import "./chunk-Z6IKMUOC.js";
import "./chunk-PV5KBAYL.js";
import "./chunk-YVVROPAO.js";
import "./chunk-4KPDZI74.js";
import "./chunk-WA4HIOYR.js";
import "./chunk-BFVOSCOB.js";
import "./chunk-QALEHGSZ.js";
import "./chunk-GYNE34WO.js";
import "./chunk-QS45OHBM.js";
import "./chunk-IVMJPIWO.js";
import "./chunk-3I3GE5YW.js";
import "./chunk-WRFNQB7U.js";
import "./chunk-UUW6REOV.js";
import "./chunk-2US5EKDI.js";
import "./chunk-Z3NHJA5D.js";
import "./chunk-BO2REVMA.js";
import "./chunk-V66LHQVK.js";
import "./chunk-JP7O2ZWE.js";
import "./chunk-Z6R62RNV.js";
import "./chunk-3LLZ72VA.js";
import "./chunk-4SIKLJSS.js";
import "./chunk-WDZ5AAFL.js";
import "./chunk-UM64E5NS.js";
import "./chunk-2XKILFME.js";
import "./chunk-G4LSNP77.js";
import "./chunk-BA6PBZHC.js";
import "./chunk-M7PTINEZ.js";
import {
  H
} from "./chunk-Z7LZRT7C.js";
import "./chunk-SGBMUZSF.js";
import "./chunk-3TMT4LDG.js";
import "./chunk-BDWD2ZNU.js";
import "./chunk-FF5LS3YE.js";
import {
  E,
  I
} from "./chunk-BCDDCNQ2.js";
import "./chunk-FIBWCATC.js";
import "./chunk-6S2FCH6S.js";
import "./chunk-3TTW7E7W.js";
import "./chunk-FOEAKQNX.js";
import {
  c as c2
} from "./chunk-LEDSC236.js";
import {
  a as a2,
  c,
  f as f2
} from "./chunk-NETCTS4Y.js";
import "./chunk-OKABUMQT.js";
import {
  e as e3
} from "./chunk-CW7LIPBH.js";
import "./chunk-TYOIANOD.js";
import "./chunk-VN2IXVGV.js";
import "./chunk-WWUAHPIM.js";
import {
  O as O2
} from "./chunk-BN6X2OXK.js";
import "./chunk-SHFLRM67.js";
import {
  n as n2,
  r
} from "./chunk-YGUWDSEH.js";
import "./chunk-ZWFMUHG3.js";
import "./chunk-EFRTD25L.js";
import "./chunk-GSS6WNQU.js";
import "./chunk-C2EHS6UI.js";
import "./chunk-63ERNIOV.js";
import "./chunk-XABSD6D5.js";
import "./chunk-KRCNIFX2.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-M6OG7C2T.js";
import "./chunk-GOK5MP3B.js";
import {
  j as j2
} from "./chunk-NLWV7Q6F.js";
import "./chunk-RVS5HU2K.js";
import "./chunk-JB7FDW5N.js";
import "./chunk-SS3YG6J3.js";
import {
  Cn,
  In,
  gn
} from "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-AQ7R6V4L.js";
import {
  s as s3,
  x as x2
} from "./chunk-DOQ3SAAR.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-4CZO65BK.js";
import "./chunk-DEZCXTA3.js";
import {
  h as h2
} from "./chunk-RRJGZKNX.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import {
  m2
} from "./chunk-4OR73Y2R.js";
import "./chunk-EKJ2DJIR.js";
import {
  M,
  T,
  f
} from "./chunk-TEHNQYQD.js";
import {
  O,
  _,
  e as e2,
  g,
  o,
  u,
  x,
  z
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-Z2ZUNW5S.js";
import "./chunk-7L7Z2HXM.js";
import "./chunk-75NKPXTR.js";
import "./chunk-EUVARFSM.js";
import "./chunk-3VUFACNT.js";
import "./chunk-ZEEBL7ZN.js";
import {
  F,
  j
} from "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-RLLQRKO4.js";
import "./chunk-57CHUY45.js";
import "./chunk-SJ2GJCS2.js";
import {
  l as l2,
  w
} from "./chunk-H7RDAEPY.js";
import "./chunk-ODFH3BSN.js";
import {
  h
} from "./chunk-S5OISW44.js";
import "./chunk-7KH4CLS5.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-JL3TJGVW.js";
import {
  s as s2
} from "./chunk-JZM5YUHA.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import {
  m,
  t2 as t,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import "./chunk-7I33FAWS.js";
import {
  l
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurement/DirectLineMeasurementController.js
var b2 = "esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementController";
var S = s.getLogger(b2);
var U = 1e5;
var k = class extends m {
  constructor(e8) {
    super(e8), this._unitNormalizer = new t5(), this._handles = new t(), this._tempStartPosition = n(), this._tempEndPosition = n(), this._tempCornerPosition = n();
  }
  initialize() {
    const e8 = this.view.spatialReference, t6 = c(e8), i4 = t6 === f2 ? a2 : t6;
    this._sphericalPCPF = i4;
    const s8 = Cn(e8, i4);
    this._unitNormalizer.spatialReference = s8 ? i4 : e8, this._handles.add([l2(() => ({ viewData: this.viewData, startPoint: this.analysis.startPoint }), ({ viewData: e9, startPoint: t7 }) => {
      e9.elevationAlignedStartPoint = this._applyProjectionAndElevationAlignment(t7);
    }, w), l2(() => ({ viewData: this.viewData, endPoint: this.analysis.endPoint }), ({ viewData: e9, endPoint: t7 }) => {
      e9.elevationAlignedEndPoint = this._applyProjectionAndElevationAlignment(t7);
    }, w), l2(() => ({ result: this._computedResult, viewData: this.viewData }), ({ result: e9, viewData: t7 }) => {
      t7.result = e9;
    }, w)]);
  }
  destroy() {
    this._handles = l(this._handles);
  }
  _applyProjectionAndElevationAlignment(e8) {
    if (null == e8)
      return e8;
    const { spatialReference: t6, elevationProvider: i4 } = this.view, s8 = r3(e8, t6, i4);
    return s8 ?? (t4(this.analysis, e8.spatialReference, S), null);
  }
  get _computedResult() {
    const { elevationAlignedStartPoint: e8, elevationAlignedEndPoint: t6, measurementMode: i4 } = this.viewData;
    if (null == e8 || null == t6)
      return null;
    const s8 = this._euclideanDistances(e8, t6), o5 = this._geodesicDistance(e8, t6, s8.horizontal.value), r4 = i4 === e6.Geodesic || i4 === e6.Auto && s8.horizontal.value > U ? "geodesic" : "euclidean";
    return { mode: r4, distance: "euclidean" === r4 ? s8.direct : o5, directDistance: s8.direct, horizontalDistance: s8.horizontal, verticalDistance: s8.vertical, geodesicDistance: o5 };
  }
  _euclideanDistances(e8, t6) {
    const i4 = e8.clone();
    i4.z = t6.z;
    const s8 = this._tempStartPosition, o5 = this._tempEndPosition, n3 = this._tempCornerPosition, a6 = this.view.spatialReference, c5 = this._sphericalPCPF, l3 = Cn(a6, c5) ? c5 : a6;
    In(e8, s8, l3), In(t6, o5, l3), In(i4, n3, l3);
    const p2 = x(s8, o5), d3 = x(n3, o5), u5 = Math.abs(t6.z - e8.z), f6 = (e9) => this._unitNormalizer.normalizeDistance(e9), _4 = f6(p2), j4 = f6(d3), g5 = f6(u5);
    return { direct: i2(_4, "meters"), horizontal: i2(j4, "meters"), vertical: i2(g5, "meters") };
  }
  _geodesicDistance(e8, t6, i4) {
    const s8 = e8.spatialReference, o5 = new m2({ spatialReference: s8 });
    o5.addPath([e8, t6]);
    const n3 = s8.isGeographic && M2(s8) ? y3([o5], "meters")[0] : s8.isWebMercator ? q(o5, "meters") : null, a6 = null != n3 ? n3 : this._fallbackGeodesicDistance(e8, t6, i4);
    return i2(a6, "meters");
  }
  _fallbackGeodesicDistance(e8, t6, i4) {
    if (gn(e8, C2) && gn(t6, M3)) {
      const e9 = new R2();
      return b(e9, C2, M3), e9.distance;
    }
    return i4;
  }
};
e([y()], k.prototype, "view", void 0), e([y()], k.prototype, "analysis", void 0), e([y()], k.prototype, "viewData", void 0), e([y()], k.prototype, "_computedResult", null), k = e([a(b2)], k);
var C2 = n();
var M3 = n();

// node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurement/interfaces.js
var e7;
var o4;
!function(e8) {
  e8[e8.None = 0] = "None", e8[e8.Direct = 1] = "Direct", e8[e8.Triangle = 2] = "Triangle", e8[e8.ProjectedGeodesic = 3] = "ProjectedGeodesic";
}(e7 || (e7 = {})), function(e8) {
  e8[e8.Auto = 0] = "Auto", e8[e8.AboveSegment = 1] = "AboveSegment", e8[e8.BelowSegment = 2] = "BelowSegment";
}(o4 || (o4 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/MeasurementArrowTechnique.js
var g3 = class _g extends e4 {
  constructor(e8, r4, t6) {
    super(e8, r4, t6);
  }
  initializeProgram(e8) {
    return new i(e8.rctx, _g.shader.get().build(this.configuration), E2);
  }
  _setPipelineState(e8) {
    const r4 = e8 === o3.NONE, t6 = this.configuration;
    return W({ blending: t6.transparent ? r4 ? c4 : A(e8) : null, polygonOffset: this.configuration.polygonOffsetEnabled ? { factor: 0, units: -4 } : null, depthTest: { func: I.LESS }, depthWrite: a3, colorWrite: _2 });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
  get primitiveType() {
    return E.TRIANGLE_STRIP;
  }
};
g3.shader = new t3(s7, () => import("./MeasurementArrow.glsl-7W5I5VQD.js"));
var y4 = class extends s4 {
  constructor() {
    super(...arguments), this.polygonOffsetEnabled = false, this.transparent = false, this.transparencyPassType = o3.NONE;
  }
};
e([r2()], y4.prototype, "polygonOffsetEnabled", void 0), e([r2()], y4.prototype, "transparent", void 0), e([r2({ count: o3.COUNT })], y4.prototype, "transparencyPassType", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/MeasurementArrowMaterial.js
var O3 = class extends d {
  constructor(t6) {
    super(t6, new T2()), this._configuration = new y4();
  }
  getConfiguration(t6, e8) {
    return this._configuration.polygonOffsetEnabled = this.parameters.polygonOffset, this._configuration.transparent = this._transparent, this._configuration.transparencyPassType = e8.transparencyPassType, this._configuration;
  }
  dispose() {
  }
  intersect() {
  }
  requiresSlot(t6, e8) {
    if (e8 === h3.Color || e8 === h3.Alpha) {
      return t6 === (this._transparent ? E3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL : E3.OPAQUE_MATERIAL);
    }
    return false;
  }
  createGLMaterial(t6) {
    return new A2(t6);
  }
  createBufferWriter() {
    return new j3();
  }
  get _transparent() {
    const { parameters: t6 } = this;
    return t6.outlineColor[3] < 1 || t6.stripeEvenColor[3] < 1 || t6.stripeOddColor[3] < 1;
  }
};
var A2 = class extends t2 {
  beginSlot(t6) {
    return this.ensureTechnique(g3, t6);
  }
};
var T2 = class extends c3 {
  constructor() {
    super(...arguments), this.width = 32, this.outlineSize = 0.2, this.outlineColor = r(1, 0.5, 0, 1), this.stripeEvenColor = r(1, 1, 1, 1), this.stripeOddColor = r(1, 0.5, 0, 1), this.stripeLength = 1, this.polygonOffset = false;
  }
};
var v = H().vec3f(O2.POSITION).vec3f(O2.NORMAL).vec2f(O2.UV0).f32(O2.AUXPOS1);
var I2 = n();
var _3 = n();
var b3 = n();
var S2 = n();
var L2 = n();
var j3 = class {
  constructor() {
    this.vertexBufferLayout = v;
  }
  elementCount(t6) {
    return 2 * (t6.indices.get(O2.POSITION).length / 2 + 1);
  }
  write(i4, a6, c5, u5, f6) {
    const l3 = c5.vertexAttributes.get(O2.POSITION).data, p2 = c5.vertexAttributes.get(O2.NORMAL).data, h6 = l3.length / 3, d3 = c5 && c5.indices && c5.indices.get(O2.POSITION);
    d3 && d3.length !== 2 * (h6 - 1) && console.warn("MeasurementArrowMaterial does not support indices");
    const g5 = I2, O4 = _3, A3 = b3, T3 = S2, v2 = L2, j4 = u5.position, y7 = u5.normal, E4 = u5.uv0;
    let M4 = 0;
    for (let m4 = 0; m4 < h6; ++m4) {
      const c6 = 3 * m4;
      if (o(g5, l3[c6], l3[c6 + 1], l3[c6 + 2]), m4 < h6 - 1) {
        const o5 = 3 * (m4 + 1);
        o(O4, l3[o5], l3[o5 + 1], l3[o5 + 2]), o(v2, p2[o5], p2[o5 + 1], p2[o5 + 2]), z(v2, v2), e2(A3, O4, g5), z(A3, A3), _(T3, v2, A3), z(T3, T3);
      }
      const u6 = x(g5, O4);
      i4 && a6 && (O(g5, g5, i4), O(O4, O4, i4), O(T3, T3, a6));
      const d4 = f6 + 2 * m4, I4 = d4 + 1;
      j4.setVec(d4, g5), j4.setVec(I4, g5), y7.setVec(d4, T3), y7.setVec(I4, T3), E4.set(d4, 0, M4), E4.set(d4, 1, -1), E4.set(I4, 0, M4), E4.set(I4, 1, 1), m4 < h6 - 1 && (M4 += u6);
    }
    const P2 = u5.auxpos1;
    for (let t6 = 0; t6 < 2 * h6; ++t6)
      P2.set(f6 + t6, M4);
  }
};

// node_modules/@arcgis/core/views/3d/interactive/visualElements/MeasurementArrowVisualElement.js
var g4 = class extends a5 {
  constructor(s8) {
    super(s8), this._parameters = { arrowWidth: 16, arrowOutlineColor: h2.toUnitRGBA(i3()), arrowStripeEvenColor: h2.toUnitRGBA(u2()), arrowStripeOddColor: h2.toUnitRGBA(i3()), arrowSubdivisions: 128 }, this._origin = n(), this._originTransform = e3(), this._arrowCenter = n(), this._renderOccluded = o2.OccludeAndTransparent, this._geometry = null, this._stripeLength = 1, this._stripesEnabled = true, this._opacity = 1, this.applyProps(s8);
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(e8) {
    e8 !== this._renderOccluded && (this._renderOccluded = e8, this._arrowMaterial && this._arrowMaterial.setParameters({ renderOccluded: e8 }));
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e8) {
    this._geometry = e8, this._geometryChanged();
  }
  get stripeLength() {
    return this._stripeLength;
  }
  set stripeLength(e8) {
    this._stripeLength = e8, this.attached && this._arrowMaterial.setParameters({ stripeLength: this._stripeLength });
  }
  get stripesEnabled() {
    return this._stripesEnabled;
  }
  set stripesEnabled(e8) {
    if (this._stripesEnabled = e8, this.attached) {
      const e9 = this.opacity, { arrowStripeEvenColor: r4, arrowStripeOddColor: t6 } = this._parameters, s8 = T(u4, this._stripesEnabled ? r4 : t6, e9);
      this._arrowMaterial.setParameters({ stripeEvenColor: s8 });
    }
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(e8) {
    e8 !== this._opacity && (this._opacity = e8, this._updateArrowOpacity());
  }
  createExternalResources() {
    const { arrowStripeEvenColor: e8, arrowStripeOddColor: r4, arrowOutlineColor: t6 } = this._parameters, i4 = this._stripesEnabled ? e8 : r4;
    this._arrowMaterial = new O3({ outlineColor: t6, stripeEvenColor: i4, stripeOddColor: r4, renderOccluded: this.renderOccluded, polygonOffset: true }), this._handles = new t(), this._handles.add(l2(() => this.view.state.camera, () => {
      this._viewChanged();
    }));
  }
  destroyExternalResources() {
    this._arrowMaterial = null, this._handles = l(this._handles);
  }
  forEachExternalMaterial(e8) {
    e8(this._arrowMaterial);
  }
  createGeometries(e8) {
    if (null == this._geometry || null == this._geometry.startRenderSpace || null == this._geometry.endRenderSpace)
      return;
    const r4 = this._createArrowGeometry(this._geometry.startRenderSpace, this._geometry.endRenderSpace, this._origin, this._geometry);
    r4.transformation = this._originTransform, e8.addGeometry(r4), this._viewChanged();
  }
  _createArrowGeometry(e8, r4, t6, s8) {
    const i4 = this.view.renderCoordsHelper, o5 = [], a6 = [], n3 = (e9, r5) => {
      const s9 = c2.get();
      e2(s9, e9, t6), o5.push(s9), a6.push(r5);
    };
    if ("euclidean" === s8.type) {
      s8.eval(0.5, this._arrowCenter);
      const t7 = c2.get();
      i4.worldUpAtPosition(this._arrowCenter, t7), n3(e8, t7), n3(r4, t7);
    } else {
      s8.eval(0.5, this._arrowCenter);
      const e9 = this._parameters.arrowSubdivisions + 1 & -2;
      for (let r5 = 0; r5 < e9; ++r5) {
        const t7 = r5 / (e9 - 1), o6 = c2.get(), a7 = c2.get();
        s8.eval(t7, o6), i4.worldUpAtPosition(o6, a7), n3(o6, a7);
      }
    }
    return pt(this._arrowMaterial, o5, a6);
  }
  _geometryChanged() {
    this.recreateGeometry();
  }
  _viewChanged() {
    if (this.view.ready && this.attached && null != this._geometry) {
      const e8 = this.view.state.camera.computeScreenPixelSizeAt(this._arrowCenter);
      this._arrowMaterial.setParameters({ width: this._parameters.arrowWidth * e8 });
    }
  }
  _updateArrowOpacity() {
    const e8 = this.opacity, { arrowStripeEvenColor: r4, arrowStripeOddColor: t6, arrowOutlineColor: s8 } = this._parameters, o5 = T(u4, this._stripesEnabled ? r4 : t6, e8), a6 = T(y5, s8, e8), n3 = T(C3, t6, e8);
    this._arrowMaterial.setParameters({ stripeEvenColor: o5, outlineColor: a6, stripeOddColor: n3 });
  }
};
var u4 = n2();
var y5 = n2();
var C3 = n2();

// node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurement/DirectLineMeasurementVisualization.js
var Q = class extends m {
  get visible() {
    return this.analysisView.visible;
  }
  get viewMode() {
    const { elevationAlignedStartPoint: e8, elevationAlignedEndPoint: t6 } = this.analysisView;
    if (null == e8 || null == t6 || e8.equals(t6))
      return e7.None;
    const i4 = this.analysisView.result;
    if (null == i4)
      return e7.Direct;
    if ("geodesic" === i4.mode)
      return this._requiresGeodesicGuideAt(this._startPosition) || this._requiresGeodesicGuideAt(this._endPosition) ? e7.ProjectedGeodesic : e7.Direct;
    const { verticalDistance: s8, horizontalDistance: n3 } = i4, o5 = s8.value, l3 = n3.value;
    return Math.min(o5 / l3, l3 / o5) < this.triangleCollapseRatioThreshold ? e7.Direct : e7.Triangle;
  }
  get actualVisualizedMeasurement() {
    if (null == this.analysisView.result)
      switch (this.analysisView.measurementMode) {
        case e6.Auto:
        case e6.Euclidean:
        default:
          return "euclidean";
        case e6.Geodesic:
          return "geodesic";
      }
    return this.analysisView.result.mode;
  }
  get allowVisualElementsOrientationChange() {
    return null == this._triangleOrientationOverride;
  }
  set allowVisualElementsOrientationChange(e8) {
    null == this._triangleOrientationOverride !== e8 && (null == this._triangleOrientationOverride ? this._triangleOrientationOverride = this._actualVisualElementsOrientation : this._triangleOrientationOverride = null);
  }
  get labels() {
    const e8 = "geodesic" === this.actualVisualizedMeasurement;
    return { direct: this._segmentLabel, horizontal: e8 ? this._segmentLabel : this._horizontalLabel, vertical: this._verticalLabel };
  }
  constructor(e8) {
    super(e8), this._params = { triangleColor: h2.toUnitRGBA(i3(0.75)), triangleLineWidth: 3, geodesicProjectionLineWidth: 2, geodesicProjectionLineColor: h2.toUnitRGBA(i3(0.75)), guideLineWidth: 2, guideStippleLengthPixels: 6, directLabelFontSize: 16, horizontalLabelFontSize: 12, verticalLabelFontSize: 12 }, this._handles = new t(), this._segmentVisualElement = null, this._triangleVisualElement = null, this._rightAngleQuad = null, this._projectedGeodesicLine = null, this._geodesicStartHint = null, this._geodesicEndHint = null, this._segmentLabel = null, this._verticalLabel = null, this._horizontalLabel = null, this._startPosition = n(), this._endPosition = n(), this._cornerPosition = n(), this._startPositionAtSeaLevel = n(), this._endPositionAtSeaLevel = n(), this._triangleOrientationOverride = null, this.messages = null, this.loadingMessages = true, this.visualElementOrientation = o4.Auto, this.triangleCollapseRatioThreshold = 0.03;
  }
  initialize() {
    const e8 = this._params, i4 = { attached: true, view: this.view };
    this._segmentVisualElement = new g4({ ...i4, geometry: null, renderOccluded: o2.OccludeAndTransparent }), this._triangleVisualElement = new u3({ ...i4, width: e8.triangleLineWidth, color: e8.triangleColor, renderOccluded: o2.OccludeAndTransparent }), this._rightAngleQuad = new P({ ...i4, color: h2.toUnitRGBA(i3(0.75)), renderOccluded: o2.OccludeAndTransparent });
    const l3 = { ...i4, polygonOffset: true, renderOccluded: o2.OccludeAndTransparent };
    this._projectedGeodesicLine = new u3({ ...l3, width: e8.geodesicProjectionLineWidth, color: e8.geodesicProjectionLineColor, stipplePattern: h4(e8.guideStippleLengthPixels) }), this._geodesicStartHint = new u3({ ...l3, width: e8.guideLineWidth, color: e8.geodesicProjectionLineColor, stipplePattern: h4(e8.guideStippleLengthPixels) }), this._geodesicEndHint = new u3({ ...l3, width: e8.guideLineWidth, color: e8.geodesicProjectionLineColor, stipplePattern: h4(e8.guideStippleLengthPixels) });
    const a6 = { ...i4, backgroundColor: s6(0.6), calloutColor: s6(0.5), textColor: a4() };
    this._segmentLabel = new g2({ ...a6, fontSize: e8.directLabelFontSize }), this._verticalLabel = new g2({ ...a6, fontSize: e8.verticalLabelFontSize }), this._horizontalLabel = new g2({ ...a6, fontSize: e8.horizontalLabelFontSize }), this._handles.add([l2(() => {
      const { elevationAlignedStartPoint: e9, elevationAlignedEndPoint: t6 } = this.analysisView, i5 = this.view;
      return { view: i5, camera: i5.state.camera, viewMode: this.viewMode, elevationAlignedStartPoint: e9, elevationAlignedEndPoint: t6, orientation: this._actualVisualElementsOrientation, visualizedMeasurement: this.actualVisualizedMeasurement, stripeLength: this._measurementArrowStripeLength };
    }, (e9) => this._updateGeometryAndViewMode(e9), w), l2(() => ({ visible: this.visible, viewMode: this.viewMode }), (e9) => this._updateVisualElementVisibility(e9), w), l2(() => ({ text: this._labelsText, visualizedMeasurement: this.actualVisualizedMeasurement }), (e9) => this._updateLabelText(e9), w), l2(() => ({ visible: this.visible, viewMode: this.viewMode }), (e9) => this._updateLabelVisibility(e9), w), l2(() => this._measurementArrowStripeLength, (e9) => this._updateSegmentStripeLength(e9), w), s2(async () => this._updateMessageBundle())]), this._updateMessageBundle();
  }
  destroy() {
    this._handles = l(this._handles), this._segmentVisualElement = l(this._segmentVisualElement), this._triangleVisualElement = l(this._triangleVisualElement), this._rightAngleQuad = l(this._rightAngleQuad), this._projectedGeodesicLine = l(this._projectedGeodesicLine), this._geodesicStartHint = l(this._geodesicStartHint), this._geodesicEndHint = l(this._geodesicEndHint), this._segmentLabel = l(this._segmentLabel), this._verticalLabel = l(this._verticalLabel), this._horizontalLabel = l(this._horizontalLabel), this.set("view", null);
  }
  _updateVisualElementVisibility({ visible: e8, viewMode: t6 }) {
    if (this._segmentVisualElement.visible = false, this._triangleVisualElement.visible = false, this._rightAngleQuad.visible = false, this._projectedGeodesicLine.visible = false, this._geodesicStartHint.visible = false, this._geodesicEndHint.visible = false, e8)
      switch (t6) {
        case e7.None:
          break;
        case e7.Direct:
          this._segmentVisualElement.visible = true;
          break;
        case e7.Triangle:
          this._segmentVisualElement.visible = true, this._triangleVisualElement.visible = true, this._rightAngleQuad.visible = true;
          break;
        case e7.ProjectedGeodesic:
          this._segmentVisualElement.visible = true, this._projectedGeodesicLine.visible = true, this._geodesicStartHint.visible = true, this._geodesicEndHint.visible = true;
      }
  }
  _updateGeometryAndViewMode({ view: e8, camera: t6, viewMode: i4, elevationAlignedStartPoint: s8, elevationAlignedEndPoint: n3, orientation: o5, visualizedMeasurement: l3, stripeLength: a6 }) {
    const r4 = e8.renderCoordsHelper;
    if (null == r4 || null == s8 || null == n3 || s8.equals(n3))
      return;
    let c5 = this._startPosition, d3 = this._endPosition;
    r4.toRenderCoords(s8, c5), r4.toRenderCoords(n3, d3);
    const h6 = o5 === o4.AboveSegment ? 1 : -1, u5 = h6 * (r4.getAltitude(d3) - r4.getAltitude(c5));
    u5 < 0 && (c5 = this._endPosition, d3 = this._startPosition);
    const m4 = "geodesic" === l3 ? new m3(this._startPosition, this._endPosition, r4.spatialReference) : new f4(this._startPosition, this._endPosition);
    switch (this._segmentVisualElement.geometry = m4, this._updateSegmentStripeLength(a6), i4) {
      case e7.Direct:
        this._updateSegment(m4, o5);
        break;
      case e7.Triangle:
        this._updateSegmentAndTriangle({ view: e8, camera: t6, segment: m4, orientation: o5, startPosition: c5, endPosition: d3, deltaSign: h6, altitudeDelta: u5 });
        break;
      case e7.ProjectedGeodesic:
        this._updateSegmentAndProjection({ view: e8, orientation: o5, startPosition: c5, endPosition: d3 });
    }
  }
  _updateSegment(e8, t6) {
    this._segmentLabel.anchor = t6 === o4.AboveSegment ? "top" : "bottom", this._segmentLabel.geometry = { type: "segment", segment: e8, sampleLocation: "center" };
  }
  _updateSegmentAndTriangle({ view: { renderCoordsHelper: e8 }, camera: t6, segment: i4, orientation: s8, startPosition: n3, endPosition: o5, deltaSign: l3, altitudeDelta: a6 }) {
    const r4 = this._cornerPosition;
    e8.worldUpAtPosition(n3, r4), g(r4, r4, l3 * Math.abs(a6)), u(r4, r4, n3), this._triangleVisualElement.geometry = [[[n3[0], n3[1], n3[2]], [r4[0], r4[1], r4[2]], [o5[0], o5[1], o5[2]]]], this._rightAngleQuad.geometry = { previous: n3, center: r4, next: o5 };
    const c5 = new f4(n3, r4), d3 = new f4(r4, o5), h6 = q2(n3, o5, r4, s8, t6);
    this._segmentLabel.anchor = h6.segment, this._segmentLabel.geometry = { type: "segment", segment: i4, sampleLocation: "center" }, this._verticalLabel.geometry = { type: "segment", segment: c5, sampleLocation: "center" }, this._verticalLabel.anchor = h6.vertical, this._horizontalLabel.geometry = { type: "segment", segment: d3, sampleLocation: "center" }, this._horizontalLabel.anchor = h6.horizontal;
  }
  _updateSegmentAndProjection({ view: { renderCoordsHelper: e8 }, orientation: t6, startPosition: i4, endPosition: s8 }) {
    e8.setAltitude(this._startPositionAtSeaLevel, 0, i4), e8.setAltitude(this._endPositionAtSeaLevel, 0, s8);
    const n3 = new m3(this._startPositionAtSeaLevel, this._endPositionAtSeaLevel, e8.spatialReference);
    this._projectedGeodesicLine.setGeometryFromSegment(n3), this._geodesicStartHint.setGeometryFromSegment(new f4(this._startPositionAtSeaLevel, i4)), this._geodesicEndHint.setGeometryFromSegment(new f4(this._endPositionAtSeaLevel, s8)), this._segmentLabel.geometry = { type: "segment", segment: n3, sampleLocation: "center" }, this._segmentLabel.anchor = t6 === o4.AboveSegment ? "top" : "bottom";
  }
  _updateLabelText({ text: e8, visualizedMeasurement: t6 }) {
    null != e8 ? (this._segmentLabel.text = "euclidean" === t6 ? e8.euclideanDistance : e8.geodesicDistance, this._horizontalLabel.text = e8.horizontalDistance, this._verticalLabel.text = e8.verticalDistance) : (this._segmentLabel.text = null, this._horizontalLabel.text = null, this._verticalLabel.text = null), this.notifyChange("labels");
  }
  _updateLabelVisibility({ visible: e8, viewMode: t6 }) {
    const i4 = this._segmentLabel, s8 = this._horizontalLabel, n3 = this._verticalLabel;
    if (i4.visible = false, s8.visible = false, n3.visible = false, e8)
      switch (t6) {
        case e7.Direct:
          i4.visible = true;
          break;
        case e7.Triangle:
          i4.visible = true, s8.visible = true, n3.visible = true;
          break;
        case e7.ProjectedGeodesic:
          i4.visible = true;
        case e7.None:
      }
  }
  get _labelsText() {
    if (this.destroyed)
      return null;
    const e8 = this.messages, t6 = this.analysisView.result;
    if (null == t6 || null == e8)
      return null;
    const { directDistance: i4, horizontalDistance: s8, verticalDistance: n3, geodesicDistance: o5 } = t6, l3 = this.analysisView.unit, a6 = (e9) => ({ euclideanDistance: "", geodesicDistance: "", horizontalDistance: "", verticalDistance: "", ...e9 });
    switch (l3) {
      case "metric":
        return a6({ euclideanDistance: i4 && L(e8, i4), geodesicDistance: o5 && L(e8, o5), horizontalDistance: s8 && L(e8, s8), verticalDistance: n3 && d2(e8, n3) });
      case "imperial":
        return a6({ euclideanDistance: i4 && R(e8, i4), geodesicDistance: o5 && R(e8, o5), horizontalDistance: s8 && R(e8, s8), verticalDistance: n3 && y2(e8, n3) });
      default:
        return a6({ euclideanDistance: i4 && h5(e8, i4, l3), geodesicDistance: o5 && h5(e8, o5, l3), horizontalDistance: s8 && h5(e8, s8, l3), verticalDistance: n3 && h5(e8, n3, l3) });
    }
  }
  _updateSegmentStripeLength(e8) {
    const t6 = this._segmentVisualElement;
    null != e8 ? (t6.stripeLength = e8, t6.stripesEnabled = true) : t6.stripesEnabled = false;
  }
  get _actualVisualElementsOrientation() {
    if (null != this._triangleOrientationOverride)
      return this._triangleOrientationOverride;
    const e8 = this.visualElementOrientation;
    return e8 === o4.Auto ? this.view.state.camera.aboveGround ? o4.AboveSegment : o4.BelowSegment : e8;
  }
  _requiresGeodesicGuideAt(e8) {
    const t6 = this.view;
    if (!(t6 == null ? void 0 : t6.state))
      return false;
    const i4 = t6.state.camera, s8 = t6.renderCoordsHelper;
    if (!s8)
      return false;
    const n3 = i4.computeScreenPixelSizeAt(e8);
    return s8.getAltitude(e8) / n3 >= 10;
  }
  get _measurementArrowStripeLength() {
    const { result: e8, unit: t6 } = this.analysisView;
    if (null == e8)
      return null;
    let i4 = null;
    const s8 = e8.directDistance;
    switch (t6) {
      case "metric":
        i4 = s8 && f3(s8, "meters");
        break;
      case "imperial":
        i4 = s8 && f3(s8, F(s8.value, s8.unit));
        break;
      default:
        i4 = s8 && f3(s8, t6);
    }
    if (null == i4)
      return null;
    return f(i4.value / 30) * j(1, i4.unit, "meters");
  }
  _updateMessageBundle() {
    this.loadingMessages = true, h("esri/core/t9n/Units").then((e8) => {
      this.messages = e8;
    }).finally(() => {
      this.loadingMessages = false;
    });
  }
  get testData() {
    var _a;
    return { labels: this.labels, stripeLength: (_a = this._segmentVisualElement) == null ? void 0 : _a.stripeLength };
  }
};
function q2(e8, t6, i4, s8, n3) {
  const o5 = N, l3 = I3;
  n3.projectToRenderScreen(i4, o5), n3.projectToRenderScreen(t6, l3);
  const a6 = { segment: "bottom", horizontal: "top", vertical: o5[0] < l3[0] ? "left" : "right" };
  {
    const s9 = J, o6 = K;
    if (f5(e8, i4, s9, n3), f5(e8, t6, o6, n3), j2(s9, o6) >= W2) {
      const e9 = Math.sign(s9[1]) === Math.sign(o6[1]);
      a6.segment = e9 ? C(a6.vertical) : a6.vertical;
    } else {
      const e9 = X;
      f5(i4, t6, e9, n3), j2(e9, o6) >= W2 && (a6.segment = Math.sign(e9[0]) === Math.sign(o6[0]) ? C(a6.horizontal) : a6.horizontal);
    }
  }
  if (s8 === o4.BelowSegment) {
    const e9 = (e10) => "top" === e10 ? "bottom" : "top";
    a6.segment = e9(a6.segment), a6.horizontal = e9(a6.horizontal), a6.vertical = e9(a6.vertical);
  }
  return a6;
}
e([y()], Q.prototype, "_triangleOrientationOverride", void 0), e([y()], Q.prototype, "messages", void 0), e([y()], Q.prototype, "view", void 0), e([y()], Q.prototype, "analysis", void 0), e([y()], Q.prototype, "analysisView", void 0), e([y()], Q.prototype, "loadingMessages", void 0), e([y()], Q.prototype, "visible", null), e([y()], Q.prototype, "viewMode", null), e([y()], Q.prototype, "actualVisualizedMeasurement", null), e([y()], Q.prototype, "visualElementOrientation", void 0), e([y()], Q.prototype, "triangleCollapseRatioThreshold", void 0), e([y()], Q.prototype, "allowVisualElementsOrientationChange", null), e([y()], Q.prototype, "labels", null), e([y()], Q.prototype, "_labelsText", null), e([y()], Q.prototype, "_actualVisualElementsOrientation", null), e([y()], Q.prototype, "_measurementArrowStripeLength", null), Q = e([a("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementVisualization")], Q);
var W2 = Math.cos(M(12));
var N = x2();
var I3 = x2();
var J = s3();
var K = s3();
var X = s3();

// node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurementAnalysisView3D.js
var p = class extends s5(m) {
  constructor(t6) {
    super(t6), this.type = "direct-line-measurement-view-3d", this.analysis = null, this.result = null, this.measurementMode = e6.Auto, this.elevationAlignedStartPoint = null, this.elevationAlignedEndPoint = null;
  }
  initialize() {
    const t6 = this.view, i4 = this.analysis;
    this._analysisVisualization = new Q({ view: t6, analysis: i4, analysisView: this }), this._analysisController = new k({ view: t6, analysis: i4, viewData: this });
  }
  destroy() {
    this._analysisController = l(this._analysisController), this._analysisVisualization = l(this._analysisVisualization);
  }
  get updating() {
    var _a;
    return !!((_a = this._analysisVisualization) == null ? void 0 : _a.loadingMessages);
  }
  get viewMode() {
    return this._analysisVisualization.viewMode;
  }
  get actualVisualizedMeasurement() {
    return this._analysisVisualization.actualVisualizedMeasurement;
  }
  get visualElementOrientation() {
    return this._analysisVisualization.visualElementOrientation;
  }
  set visualElementOrientation(t6) {
    this._analysisVisualization.visualElementOrientation = t6;
  }
  get allowVisualElementsOrientationChange() {
    return this._analysisVisualization.allowVisualElementsOrientationChange;
  }
  set allowVisualElementsOrientationChange(t6) {
    this._analysisVisualization.allowVisualElementsOrientationChange = t6;
  }
  get triangleCollapseRatioThreshold() {
    return this._analysisVisualization.triangleCollapseRatioThreshold;
  }
  set triangleCollapseRatioThreshold(t6) {
    this._analysisVisualization.triangleCollapseRatioThreshold = t6;
  }
  get directLabelText() {
    var _a;
    return ((_a = this._analysisVisualization.labels.direct) == null ? void 0 : _a.text) ?? "";
  }
  get horizontalLabelText() {
    var _a;
    return ((_a = this._analysisVisualization.labels.horizontal) == null ? void 0 : _a.text) ?? "";
  }
  get verticalLabelText() {
    var _a;
    return ((_a = this._analysisVisualization.labels.vertical) == null ? void 0 : _a.text) ?? "";
  }
  get unit() {
    return this.analysis.unit ?? this._defaultUnit;
  }
  get testData() {
    var _a;
    return this.destroyed ? { labels: null, stripeLength: null, visualization: null, controller: null } : { ...(_a = this._analysisVisualization) == null ? void 0 : _a.testData, visualization: this._analysisVisualization, controller: this._analysisController };
  }
};
e([y()], p.prototype, "updating", null), e([y({ readOnly: true })], p.prototype, "type", void 0), e([y({ constructOnly: true, nonNullable: true })], p.prototype, "analysis", void 0), e([y()], p.prototype, "result", void 0), e([y()], p.prototype, "measurementMode", void 0), e([y()], p.prototype, "elevationAlignedStartPoint", void 0), e([y()], p.prototype, "elevationAlignedEndPoint", void 0), e([y({ readOnly: true })], p.prototype, "viewMode", null), e([y({ readOnly: true })], p.prototype, "actualVisualizedMeasurement", null), e([y()], p.prototype, "visualElementOrientation", null), e([y()], p.prototype, "allowVisualElementsOrientationChange", null), e([y()], p.prototype, "triangleCollapseRatioThreshold", null), e([y({ readOnly: true })], p.prototype, "directLabelText", null), e([y({ readOnly: true })], p.prototype, "horizontalLabelText", null), e([y({ readOnly: true })], p.prototype, "verticalLabelText", null), e([y()], p.prototype, "_analysisVisualization", void 0), e([y()], p.prototype, "_analysisController", void 0), e([y()], p.prototype, "unit", null), e([y(e5)], p.prototype, "_defaultUnit", void 0), p = e([a("esri.views.3d.analysis.DirectLineMeasurementAnalysisView3D")], p);
var y6 = p;
export {
  y6 as default
};
//# sourceMappingURL=DirectLineMeasurementAnalysisView3D-7ZDFNYEQ.js.map
