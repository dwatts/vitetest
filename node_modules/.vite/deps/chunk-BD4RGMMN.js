import {
  r as r2
} from "./chunk-IRBH32SX.js";
import {
  e
} from "./chunk-UPDSQXLR.js";
import {
  h as h2,
  p as p2,
  t as t2,
  u as u2
} from "./chunk-6QR5R4JX.js";
import {
  o as o6
} from "./chunk-LGDKASPG.js";
import {
  e as e4,
  e2 as e5,
  t
} from "./chunk-YQDOKTNT.js";
import {
  o as o7
} from "./chunk-SH6HJSS2.js";
import {
  u as u3
} from "./chunk-4YXJLES6.js";
import {
  a
} from "./chunk-WH76OAIT.js";
import {
  g
} from "./chunk-JHDKOKT6.js";
import {
  o as o4
} from "./chunk-CG3URTR2.js";
import {
  n
} from "./chunk-IBJTEQQG.js";
import {
  o as o2
} from "./chunk-SADO52IH.js";
import {
  e as e6
} from "./chunk-WVOBJDWI.js";
import {
  d,
  i,
  o as o3
} from "./chunk-LIO6VZRI.js";
import {
  h
} from "./chunk-73PNWDTS.js";
import {
  P
} from "./chunk-N3RXOITN.js";
import {
  f,
  p,
  u
} from "./chunk-DOR4M5EA.js";
import {
  e as e2
} from "./chunk-YVVROPAO.js";
import {
  e as e3
} from "./chunk-WRFNQB7U.js";
import {
  o as o5
} from "./chunk-UUW6REOV.js";
import {
  i2
} from "./chunk-BO2REVMA.js";
import {
  o
} from "./chunk-V66LHQVK.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  r
} from "./chunk-SS3YG6J3.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl.js
var p3 = 8;
function f2(e7, c) {
  const f3 = O.FEATUREVALUE;
  e7.attributes.add(f3, "vec4");
  const n3 = e7.vertex;
  n3.code.add(o`
  bool isCapVertex() {
    return ${f3}.w == 1.0;
  }
  `), n3.uniforms.add(new e3("size", (e8) => e8.size)), c.vvSize ? (n3.uniforms.add(new e2("vvSizeMinSize", (e8) => e8.vvSize.minSize), new e2("vvSizeMaxSize", (e8) => e8.vvSize.maxSize), new e2("vvSizeOffset", (e8) => e8.vvSize.offset), new e2("vvSizeFactor", (e8) => e8.vvSize.factor)), n3.code.add(o`
    vec2 getSize() {
      return size * clamp(vvSizeOffset + ${f3}.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xz;
    }
    `)) : n3.code.add(o`vec2 getSize(){
return size;
}`), c.vvOpacity ? (n3.constants.add("vvOpacityNumber", "int", p3), n3.uniforms.add(new o7("vvOpacityValues", (e8) => e8.vvOpacity.values, p3), new o7("vvOpacityOpacities", (e8) => e8.vvOpacity.opacityValues, p3)), n3.code.add(o`
    vec4 applyOpacity(vec4 color) {
      float value = ${f3}.z;
      if (value <= vvOpacityValues[0]) {
        return vec4( color.xyz, vvOpacityOpacities[0]);
      }

      for (int i = 1; i < vvOpacityNumber; ++i) {
        if (vvOpacityValues[i] >= value) {
          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
          return vec4( color.xyz, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));
        }
      }

      return vec4( color.xyz, vvOpacityOpacities[vvOpacityNumber - 1]);
    }
    `)) : n3.code.add(o`vec4 applyOpacity(vec4 color){
return color;
}`), c.vvColor ? (n3.constants.add("vvColorNumber", "int", e5), n3.uniforms.add(new o7("vvColorValues", (e8) => e8.vvColor.values, e5), new e4("vvColorColors", (e8) => e8.vvColor.colors, e5)), n3.code.add(o`
    vec4 getColor() {
      float value = ${f3}.y;
      if (value <= vvColorValues[0]) {
        return applyOpacity(vvColorColors[0]);
      }

      for (int i = 1; i < vvColorNumber; ++i) {
        if (vvColorValues[i] >= value) {
          float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
          return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));
        }
      }

      return applyOpacity(vvColorColors[vvColorNumber - 1]);
    }
    `)) : n3.code.add(o`vec4 getColor(){
return applyOpacity(vec4(1, 1, 1, 1));
}`), e7.include(o3), e7.attributes.add(O.PROFILERIGHT, "vec4"), e7.attributes.add(O.PROFILEUP, "vec4"), e7.attributes.add(O.PROFILEVERTEXANDNORMAL, "vec4"), n3.code.add(o`vec3 calculateVPos() {
vec2 size = getSize();
vec3 origin = position;
vec3 right = profileRight.xyz;
vec3 up = profileUp.xyz;
vec3 forward = cross(up, right);
vec2 profileVertex = profileVertexAndNormal.xy * size;
vec2 profileNormal = profileVertexAndNormal.zw;
float positionOffsetAlongProfilePlaneNormal = 0.0;
float normalOffsetAlongProfilePlaneNormal = 0.0;`), n3.code.add(o`if(!isCapVertex()) {
vec2 rotationRight = vec2(profileRight.w, profileUp.w);
float maxDistance = length(rotationRight);`), n3.code.add(o`rotationRight = maxDistance > 0.0 ? normalize(rotationRight) : vec2(0, 0);
float rx = dot(profileVertex, rotationRight);
if (abs(rx) > maxDistance) {
vec2 rotationUp = vec2(-rotationRight.y, rotationRight.x);
float ry = dot(profileVertex, rotationUp);
profileVertex = rotationRight * maxDistance * sign(rx) + rotationUp * ry;
}
}else{
positionOffsetAlongProfilePlaneNormal = profileRight.w * size[0];
normalOffsetAlongProfilePlaneNormal = profileUp.w;
}
vec3 offset = right * profileVertex.x + up * profileVertex.y + forward * positionOffsetAlongProfilePlaneNormal;
return origin + offset;
}`), n3.code.add(o`vec3 localNormal() {
vec3 right = profileRight.xyz;
vec3 up = profileUp.xyz;
vec3 forward = cross(up, right);
vec2 profileNormal = profileVertexAndNormal.zw;
vec3 normal = right * profileNormal.x + up * profileNormal.y;
if(isCapVertex()) {
normal += forward * profileUp.w;
}
return normal;
}`);
}
var n2 = class extends t {
  constructor() {
    super(...arguments), this.size = r(1, 1);
  }
};

// node_modules/@arcgis/core/chunks/Path.glsl.js
function M(M2) {
  const O3 = new i2(), { vertex: T, fragment: D } = O3;
  switch (p(T, M2), O3.varyings.add("vpos", "vec3"), O3.include(f2, M2), M2.output !== h.Color && M2.output !== h.Alpha || (O3.include(o4, M2), O3.include(u3, M2), O3.include(d, M2), O3.varyings.add("vnormal", "vec3"), O3.varyings.add("vcolor", "vec4"), M2.hasMultipassTerrain && O3.varyings.add("depth", "float"), T.code.add(o`
      void main() {
        vpos = calculateVPos();
        vnormal = normalize(localNormal());

        ${M2.hasMultipassTerrain ? "depth = (view * vec4(vpos, 1.0)).z;" : ""}
        gl_Position = transformPosition(proj, view, vpos);

        ${M2.output === h.Color ? "forwardLinearDepth();" : ""}

        vcolor = getColor();
      }
    `)), O3.include(n, M2), M2.output) {
    case h.Alpha:
      O3.include(P, M2), D.uniforms.add(new o5("opacity", (e7) => e7.opacity)), D.code.add(o`
      void main() {
        discardBySlice(vpos);
        ${M2.hasMultipassTerrain ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
        float combinedOpacity = vcolor.a * opacity;
        fragColor = vec4(combinedOpacity);
      }
    `);
      break;
    case h.Color:
      O3.include(P, M2), O3.include(p2, M2), O3.include(t2, M2), O3.include(u3, M2), O3.include(e, M2), f(D, M2), h2(D), u2(D), D.uniforms.add(T.uniforms.get("localOrigin"), new e2("ambient", (e7) => e7.ambient), new e2("diffuse", (e7) => e7.diffuse), new e2("specular", (e7) => e7.specular), new o5("opacity", (e7) => e7.opacity)), D.include(e6), a(D), D.code.add(o`
        void main() {
          discardBySlice(vpos);
          ${M2.hasMultipassTerrain ? "terrainDepthTest(gl_FragCoord, depth);" : ""}

          shadingParams.viewDirection = normalize(vpos - cameraPosition);
          shadingParams.normalView = vnormal;
          vec3 normal = shadingNormal(shadingParams);
          float ssao = evaluateAmbientOcclusionInverse();

          float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
          vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
          ${M2.receiveShadows ? "float shadow = readShadowMap(vpos, linearDepth);" : M2.spherical ? "float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);" : "float shadow = 0.0;"}
          vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one
          float combinedOpacity = vcolor.a * opacity;
          albedo += 0.25 * specular; // don't completely ignore specular for now

          vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);
          fragColor = vec4(shadedColor, combinedOpacity);
          fragColor = highlightSlice(fragColor, vpos);
          ${M2.transparencyPassType === o2.Color ? "fragColor = premultiplyAlpha(fragColor);" : ""}
        }
      `);
      break;
    case h.Depth:
    case h.Shadow:
    case h.ShadowHighlight:
    case h.ShadowExcludeHighlight:
      O3.include(o4, M2), i(O3), O3.varyings.add("depth", "float"), T.code.add(o`void main() {
vpos = calculateVPos();
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
}`), O3.include(P, M2), O3.include(o6, M2), D.code.add(o`void main() {
discardBySlice(vpos);
outputDepth(depth);
}`);
      break;
    case h.Normal:
      O3.include(o4, M2), O3.include(r2, M2), u(T), O3.varyings.add("vnormal", "vec3"), T.code.add(o`void main(void) {
vpos = calculateVPos();
vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);
gl_Position = transformPosition(proj, view, vpos);
}`), O3.include(P, M2), D.code.add(o`void main() {
discardBySlice(vpos);
vec3 normal = normalize(vnormal);
if (gl_FrontFacing == false) normal = -normal;
fragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);
}`);
      break;
    case h.Highlight:
      O3.include(o4, M2), O3.include(r2, M2), O3.varyings.add("vnormal", "vec3"), T.code.add(o`void main(void) {
vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);
}`), O3.include(P, M2), O3.include(g, M2), D.code.add(o`void main() {
discardBySlice(vpos);
outputHighlight();
}`);
  }
  return O3;
}
var O2 = Object.freeze(Object.defineProperty({ __proto__: null, build: M }, Symbol.toStringTag, { value: "Module" }));

export {
  n2 as n,
  M,
  O2 as O
};
//# sourceMappingURL=chunk-BD4RGMMN.js.map
