import {
  h as h7
} from "./chunk-2O3MFNAT.js";
import {
  c as c5
} from "./chunk-BTHQ4EZE.js";
import {
  i as i4
} from "./chunk-2KRMZDXT.js";
import {
  M as M3,
  X,
  x as x3
} from "./chunk-CS6BZGQO.js";
import {
  f as f3
} from "./chunk-YZTKL3LQ.js";
import {
  a as a5
} from "./chunk-I7EXY23J.js";
import {
  $
} from "./chunk-SFIT2AUF.js";
import {
  B as B2,
  V as V2,
  c as c6
} from "./chunk-DBIFU6GO.js";
import {
  nt,
  pt
} from "./chunk-WRC5WFEM.js";
import {
  C as C2
} from "./chunk-2EO2WRP7.js";
import {
  A as A3,
  b as b3,
  b2 as b4
} from "./chunk-BDX5TRUE.js";
import {
  A as A2,
  E as E2,
  _ as _4,
  c as c4
} from "./chunk-LIXBKTBN.js";
import {
  E as E3
} from "./chunk-6LC2JTLC.js";
import {
  s as s5
} from "./chunk-XM3YSFN6.js";
import {
  e as e5,
  i as i3,
  t as t2
} from "./chunk-V6CD66ZZ.js";
import {
  W,
  _ as _3,
  a as a4,
  h as h6
} from "./chunk-6FHMQNMS.js";
import {
  r as r4
} from "./chunk-KFDARCTS.js";
import {
  c as c3,
  d2 as d4,
  h as h5,
  o2 as o3
} from "./chunk-SMDDCTGQ.js";
import {
  t
} from "./chunk-FB4A6PBH.js";
import {
  o as o4
} from "./chunk-SADO52IH.js";
import {
  h as h4
} from "./chunk-73PNWDTS.js";
import {
  n as n5
} from "./chunk-JP7O2ZWE.js";
import {
  B,
  M as M2,
  b as b2,
  v
} from "./chunk-4SIKLJSS.js";
import {
  H
} from "./chunk-Z7LZRT7C.js";
import {
  s as s3
} from "./chunk-SGBMUZSF.js";
import {
  I
} from "./chunk-BCDDCNQ2.js";
import {
  i as i2
} from "./chunk-FIBWCATC.js";
import {
  s as s4
} from "./chunk-6S2FCH6S.js";
import {
  T,
  h as h3,
  q2 as q
} from "./chunk-FOEAKQNX.js";
import {
  c as c2,
  d as d3,
  f as f2
} from "./chunk-LEDSC236.js";
import {
  e as e4
} from "./chunk-CW7LIPBH.js";
import {
  e as e3
} from "./chunk-VN2IXVGV.js";
import {
  O as O2
} from "./chunk-BN6X2OXK.js";
import {
  r as r3
} from "./chunk-YGUWDSEH.js";
import {
  o as o5,
  t as t3,
  u as u2
} from "./chunk-NEBQZ6AZ.js";
import {
  b
} from "./chunk-NLWV7Q6F.js";
import {
  a as a3
} from "./chunk-JB7FDW5N.js";
import {
  Cn,
  _e,
  _n,
  qn
} from "./chunk-BNBT4QTW.js";
import {
  c,
  h as h2,
  n as n3,
  r as r2,
  s as s2
} from "./chunk-7EG7BYWF.js";
import {
  E,
  _ as _2
} from "./chunk-AQ7R6V4L.js";
import {
  d as d2,
  i,
  x as x2,
  y as y2
} from "./chunk-DOQ3SAAR.js";
import {
  n as n4
} from "./chunk-4CZO65BK.js";
import {
  d
} from "./chunk-SVCGLUNW.js";
import {
  V
} from "./chunk-7EQSYZHW.js";
import {
  j
} from "./chunk-EKJ2DJIR.js";
import {
  M
} from "./chunk-TEHNQYQD.js";
import {
  O,
  S,
  _,
  e as e2,
  g,
  o as o2,
  p,
  r,
  u,
  z
} from "./chunk-TPJLFGOT.js";
import {
  f,
  n
} from "./chunk-CQX57DED.js";
import {
  x2 as x
} from "./chunk-ZEEBL7ZN.js";
import {
  A2 as A
} from "./chunk-RTDN6KAT.js";
import {
  j as j2,
  l as l2,
  w as w2
} from "./chunk-H7RDAEPY.js";
import {
  n as n2
} from "./chunk-7KH4CLS5.js";
import {
  m,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2,
  h
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  C,
  w
} from "./chunk-7I33FAWS.js";
import {
  l,
  o
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import {
  a
} from "./chunk-IYZKKFJM.js";

// node_modules/@arcgis/core/views/analysis/analysisViewUtils.js
function l3(n6, r6) {
  n6.interactive = true;
  const { tool: l6, view: a10 } = n6;
  a10.activeTool = l6;
  let c9 = w(r6, () => {
    a10.activeTool === l6 && (a10.activeTool = null);
  });
  return d(async (o6) => {
    await j2(() => null == l6 || !l6.active, o6), c9 = o(c9);
  }, r6);
}
function a6(o6, t5) {
  return l2(() => o6.interactive, () => c7(o6, t5), w2);
}
function c7(o6, t5) {
  o6.interactive ? s6(o6, t5) : v2(o6);
}
function s6(o6, t5) {
  v2(o6);
  const { view: i8, analysis: e8 } = o6, n6 = new t5({ view: i8, analysis: e8, analysisViewData: o6 });
  return o6.tool = n6, i8.tools.add(n6), n6;
}
function v2(o6) {
  const { view: t5, tool: i8 } = o6;
  null != i8 && (t5.tools.remove(i8), o6.tool = null);
}

// node_modules/@arcgis/core/views/3d/interactive/Manipulator3D.js
var $2 = class {
  constructor(e8) {
    var _a;
    this.metadata = void 0, this._camera = new $(), this._elevation = { offset: 0, override: null }, this.collisionType = { type: "point" }, this.collisionPriority = 0, this._renderObjects = new Array(), this.autoScaleRenderObjects = true, this._available = true, this._noDisplayCount = 0, this._radius = 10, this._worldSized = false, this.focusMultiplier = 2, this.touchMultiplier = 2.5, this.worldOriented = false, this._modelTransform = e4(), this._worldFrame = null, this._renderLocation = n(), this._renderLocationDirty = true, this._location = new x({ x: 0, y: 0, z: 0 }), this._elevationAlignedLocation = new x(), this._elevationAlignedLocationDirty = true, this.interactive = true, this.selectable = false, this.grabbable = true, this.cursor = null, this.grabCursor = null, this._grabbing = false, this.dragging = false, this._hovering = false, this._selected = false, this._state = u2.None, this._focused = false, this.events = new n2.EventEmitter(), this._screenLocation = { screenPointArray: i(), renderScreenPointArray: x2(), pixelSize: 0 }, this._screenLocationDirty = true, this._engineResourcesAddedToStage = false, this._attached = false, this._location.spatialReference = e8.view.spatialReference, Object.assign(this, e8);
    const i8 = (_a = this.view.state) == null ? void 0 : _a.camera;
    i8 && this._camera.copyFrom(i8);
  }
  destroy() {
    this._applyObjectTransform = fe, this._removeResourcesFromStage(), this._engineResources = null, this.view = null, this._camera = null;
  }
  get _stage() {
    var _a;
    return (_a = this.view) == null ? void 0 : _a._stage;
  }
  get elevationInfo() {
    return this._elevationInfo;
  }
  set elevationInfo(e8) {
    this._elevationInfo = e8, this._elevationAlignedLocationDirty = true, this._renderLocationDirty = true, this._updateEngineObject();
  }
  get renderObjects() {
    return this._renderObjects;
  }
  set renderObjects(e8) {
    this._removeResourcesFromStage(), this._engineResources = null, this._renderObjects = e8.slice(), this._updateEngineObject();
  }
  set available(e8) {
    e8 !== this._available && (this._available = e8, this._updateEngineObject());
  }
  get available() {
    return this._available;
  }
  disableDisplay() {
    return this._noDisplayCount++, 1 === this._noDisplayCount && this._updateEngineObject(), { remove: h(() => {
      this._noDisplayCount--, 0 === this._noDisplayCount && this._updateEngineObject();
    }) };
  }
  set radius(e8) {
    e8 !== this._radius && (this._radius = e8, this._updateEngineObject());
  }
  get radius() {
    return this._radius;
  }
  set worldSized(e8) {
    e8 !== this._worldSized && (this._worldSized = e8, this._updateEngineObject());
  }
  get worldSized() {
    return this._worldSized;
  }
  get modelTransform() {
    return this._modelTransform;
  }
  set modelTransform(e8) {
    ee(e8) && (this._screenLocationDirty = true), n3(this._modelTransform, e8), this._updateEngineObject();
  }
  get renderLocation() {
    return this._renderLocationDirty && (this._renderLocationDirty = false, this.view.renderCoordsHelper.toRenderCoords(this.elevationAlignedLocation, this._renderLocation), this.worldOriented ? (this._worldFrame || (this._worldFrame = e4()), te(this.view, this._renderLocation, this._worldFrame)) : this._worldFrame && (this._worldFrame = null)), this._renderLocation;
  }
  set renderLocation(e8) {
    this.view.renderCoordsHelper.fromRenderCoords(e8, this._location), this.elevationAlignedLocation = this._location;
  }
  get location() {
    return this._location;
  }
  set location(e8) {
    x3(e8, this._location), this._notifyLocationChanged();
  }
  _notifyLocationChanged() {
    this._renderLocationDirty = true, this._screenLocationDirty = true, this._elevationAlignedLocationDirty = true, this._updateEngineObject(), this.events.emit("location-update", { location: this._location });
  }
  get elevationAlignedLocation() {
    return this._elevationAlignedLocationDirty ? (this._evaluateElevationAlignment(), this._updateElevationAlignedLocation(), this._elevationAlignedLocation) : this._elevationAlignedLocation;
  }
  set elevationAlignedLocation(e8) {
    x3(e8, this._location), this._evaluateElevationAlignment(), this._location.z -= this._elevation.offset, this._updateElevationAlignedLocation(), this._updateEngineObject(), this.events.emit("location-update", { location: this._location });
  }
  _updateElevationAlignedLocation() {
    const e8 = null != this._elevation.override ? this._elevation.override : this.location.z || 0;
    this._elevationAlignedLocation.x = this.location.x, this._elevationAlignedLocation.y = this.location.y, this._elevationAlignedLocation.z = e8 + this._elevation.offset, this._elevationAlignedLocation.spatialReference = M3(this.location.spatialReference), this._renderLocationDirty = true, this._screenLocationDirty = true, this._elevationAlignedLocationDirty = false;
  }
  grabbableForEvent() {
    return true;
  }
  get grabbing() {
    return this._grabbing;
  }
  set grabbing(e8) {
    e8 !== this._grabbing && (this._grabbing = e8, this._setFocused(this._hovering || this._grabbing), this._updateEngineObject());
  }
  get hovering() {
    return this._hovering;
  }
  set hovering(e8) {
    e8 !== this._hovering && (this._hovering = e8, this._setFocused(this._hovering || this._grabbing), this._updateEngineObject());
  }
  get selected() {
    return this._selected;
  }
  set selected(e8) {
    e8 !== this._selected && (this._selected = e8, this._updateEngineObject(), this.events.emit("select-changed", { action: e8 ? "select" : "deselect" }));
  }
  get state() {
    return this._state;
  }
  set state(e8) {
    e8 !== this._state && (this._state = e8, this._updateEngineObject());
  }
  updateStateEnabled(e8, t5) {
    t5 ? this.state |= e8 : this.state &= ~e8;
  }
  _setFocused(e8) {
    e8 !== this._focused && (this._focused = e8, this.events.emit("focus-changed", { action: true === e8 ? "focus" : "unfocus" }));
  }
  get focused() {
    return this._focused;
  }
  get screenLocation() {
    return this._ensureScreenLocation(), this._screenLocation;
  }
  _ensureScreenLocation() {
    if (!this._screenLocationDirty)
      return;
    this._screenLocation.pixelSize = this._camera.computeScreenPixelSizeAt(this.renderLocation), this._screenLocationDirty = false;
    let e8;
    if (ee(this._modelTransform)) {
      const t5 = this._calculateModelTransformOffset(ge);
      e8 = u(t5, t5, this.renderLocation);
    } else
      e8 = this.renderLocation;
    this._camera.projectToRenderScreen(e8, this._screenLocation.renderScreenPointArray), this._camera.renderToScreen(this._screenLocation.renderScreenPointArray, this._screenLocation.screenPointArray);
  }
  get applyObjectTransform() {
    return this._applyObjectTransform;
  }
  set applyObjectTransform(e8) {
    this._applyObjectTransform = e8, this._screenLocationDirty = true, this._updateEngineObject();
  }
  get attached() {
    return this._attached;
  }
  intersectionDistance(t5, i8) {
    if (!this.available)
      return null;
    const s7 = d2(t5, ie), n6 = this._getCollisionRadius(i8), o6 = -1 * this.collisionPriority;
    switch (this.collisionType.type) {
      case "point":
        if (b(this.screenLocation.screenPointArray, s7) < n6 * n6)
          return this.screenLocation.renderScreenPointArray[2] + o6;
        break;
      case "line": {
        const e8 = this.collisionType.paths, t6 = this._getWorldToScreenObjectScale(), i9 = this._calculateObjectTransform(t6, ae), r6 = n6 * this.screenLocation.pixelSize, c9 = i4(this._camera, s7, ne);
        if (null == c9)
          return null;
        for (const s8 of e8) {
          if (0 === s8.length)
            continue;
          const e9 = O(le, s8[0], i9);
          for (let t7 = 1; t7 < s8.length; t7++) {
            const n7 = O(he, s8[t7], i9), l6 = B(b2(e9, n7, se), c9);
            if (null != l6 && l6 < r6 * r6) {
              const t8 = u(c2.get(), e9, n7);
              g(t8, t8, 0.5);
              const i10 = y2(c2.get());
              return this._camera.projectToRenderScreen(t8, i10), i10[2] + o6;
            }
            r(e9, n7);
          }
        }
        break;
      }
      case "disc": {
        const e8 = this.collisionType.direction, t6 = this.collisionType.offset ?? f, i9 = this._getWorldToScreenObjectScale(), r6 = this._calculateObjectTransform(i9, ae), a10 = n6 * this.screenLocation.pixelSize, c9 = i4(this._camera, s7, ne);
        if (null == c9)
          return null;
        const h8 = a3(oe, r6), d6 = S(_e2, e8, h8), _5 = O(ue, t6, r6);
        T(_5, d6, ce);
        const u4 = de;
        if (q(ce, c9, u4) && p(u4, _5) < a10 * a10)
          return this.screenLocation.renderScreenPointArray[2] + o6;
        break;
      }
      case "ribbon": {
        const { paths: e8, direction: t6 } = this.collisionType, i9 = this._getWorldToScreenObjectScale(), r6 = this._calculateObjectTransform(i9, ae), c9 = n6 * this._camera.computeScreenPixelSizeAt(this.renderLocation), h8 = i4(this._camera, s7, ne);
        if (null == h8)
          return null;
        const d6 = a3(oe, r6), _5 = S(_e2, t6, d6), u4 = this._calculateModelTransformPosition(ue);
        T(u4, _5, ce);
        const g3 = de;
        if (!q(ce, h8, g3))
          break;
        for (const s8 of e8) {
          if (0 === s8.length)
            continue;
          const e9 = O(le, s8[0], r6);
          for (let t7 = 1; t7 < s8.length; t7++) {
            const i10 = O(he, s8[t7], r6), n7 = M2(b2(e9, i10, se), g3);
            if (null != n7 && n7 < c9 * c9) {
              const t8 = u(c2.get(), e9, i10);
              g(t8, t8, 0.5);
              const s9 = y2(c2.get());
              return this._camera.projectToRenderScreen(t8, s9), s9[2] + o6;
            }
            r(e9, i10);
          }
        }
        break;
      }
      default:
        n4(this.collisionType);
    }
    return null;
  }
  attach(e8 = { manipulator3D: {} }) {
    const t5 = this._stage;
    if (!t5)
      return;
    const i8 = e8.manipulator3D;
    null == i8.engineLayerId ? (this._engineLayer = new c6(t5, { pickable: false, updatePolicy: C2.SYNC }), i8.engineLayerId = this._engineLayer.id) : (t5 == null ? void 0 : t5.getObject) && (this._engineLayer = t5.getObject(i8.engineLayerId)), i8.engineLayerReferences = (i8.engineLayerReferences || 0) + 1, this._materialIdReferences = i8.materialIdReferences, null == this._materialIdReferences && (this._materialIdReferences = /* @__PURE__ */ new Map(), i8.materialIdReferences = this._materialIdReferences), this._camera.copyFrom(this.view.state.camera), this._attached = true, this._updateEngineObject(), Cn(this._location.spatialReference, this.view.spatialReference) || (this.location = new x({ x: 0, y: 0, z: 0, spatialReference: this.view.spatialReference }));
  }
  detach(e8 = { manipulator3D: {} }) {
    const t5 = e8.manipulator3D;
    t5.engineLayerReferences--;
    const i8 = 0 === t5.engineLayerReferences;
    this._removeResourcesFromStage(), i8 && (t5.engineLayerId = null, l(this._engineLayer)), this._engineResources = null, this._engineLayer = null, this._materialIdReferences = null, this._attached = false;
  }
  onViewChange() {
    this._camera.copyFrom(this.view.state.camera), this._screenLocationDirty = true, this._updateEngineObject();
  }
  onElevationChange(e8) {
    _n(this.location, me, e8.spatialReference) && j(e8.extent, me) && this._notifyLocationChanged();
  }
  _evaluateElevationAlignment() {
    if (null == this.elevationInfo)
      return;
    let e8 = null, t5 = 0;
    const i8 = this.elevationInfo.offset ?? 0;
    switch (this.elevationInfo.mode) {
      case "on-the-ground":
        e8 = a5(this.view.elevationProvider, this.location, "ground") ?? 0;
        break;
      case "relative-to-ground":
        t5 = (a5(this.view.elevationProvider, this.location, "ground") ?? 0) + i8;
        break;
      case "relative-to-scene":
        t5 = (a5(this.view.elevationProvider, this.location, "scene") ?? 0) + i8;
        break;
      case "absolute-height":
        t5 = i8;
    }
    return t5 !== this._elevation.offset || e8 !== this._elevation.override ? (this._elevation.offset = t5, void (this._elevation.override = e8)) : void 0;
  }
  _updateEngineObject() {
    if (!this._attached)
      return;
    if (!this.available)
      return void this._removeResourcesFromStage();
    const e8 = this._getWorldToScreenObjectScale(), t5 = ae;
    if (true === this.autoScaleRenderObjects) {
      const i9 = this._getFocusedSize(this._radius, this.focused) * e8;
      this._calculateObjectTransform(i9, t5);
    } else
      this._calculateObjectTransform(e8, t5);
    const { objectsByState: i8 } = this._ensureEngineResources(), s7 = (this.focused ? t3.Focused : t3.Unfocused) | (this.selected ? t3.Selected : t3.Unselected), n6 = this._noDisplayCount > 0;
    for (const { stateMask: o6, objects: r6 } of i8) {
      if (n6) {
        for (const e10 of r6)
          e10.visible = false;
        continue;
      }
      const e9 = (o6 & t3.All) !== t3.None, i9 = (o6 & u2.All) !== u2.None, a10 = !e9 || (s7 & o6) == (o6 & t3.All), c9 = !i9 || (this.state & o6) == (o6 & u2.All);
      if (a10 && c9)
        for (const s8 of r6)
          s8.visible = true, s8.transformation = t5;
      else
        for (const t6 of r6)
          t6.visible = false;
    }
  }
  _ensureEngineResources() {
    if (null == this._engineResources) {
      const e8 = this._engineLayer, t5 = [], i8 = /* @__PURE__ */ new Set();
      this.renderObjects.forEach(({ geometry: { material: e9 } }) => {
        i8.has(e9) || (t5.push(e9), i8.add(e9));
      });
      const s7 = /* @__PURE__ */ new Map();
      this._renderObjects.forEach((e9) => {
        const t6 = new V2({ castShadow: false, geometries: [e9.geometry] }), i9 = s7.get(e9.stateMask) || [];
        i9.push(t6), s7.set(e9.stateMask, i9);
      });
      const n6 = [];
      s7.forEach((e9, t6) => n6.push({ stateMask: t6, objects: e9 })), this._engineResources = { objectsByState: n6, layer: e8, materials: t5 };
    }
    return this._addResourcesToStage(), this._engineResources;
  }
  _addResourcesToStage() {
    const e8 = this._stage;
    if (this._engineResourcesAddedToStage || null == this._engineResources || !e8)
      return;
    const { objectsByState: t5, layer: i8, materials: s7 } = this._engineResources;
    s7.forEach((t6) => {
      const i9 = this._materialIdReferences, s8 = i9.get(t6.id) || 0;
      0 === s8 && e8.add(t6), i9.set(t6.id, s8 + 1);
    }), t5.forEach(({ objects: t6 }) => {
      i8.addMany(t6), e8.addMany(t6);
    }), this._engineResourcesAddedToStage = true;
  }
  _removeResourcesFromStage() {
    const e8 = this._stage;
    if (!this._engineResourcesAddedToStage || null == this._engineResources || !e8)
      return;
    const { objectsByState: t5, layer: i8, materials: s7 } = this._engineResources;
    t5.forEach(({ objects: t6 }) => {
      i8.removeMany(t6), e8.removeMany(t6);
    }), s7.forEach((t6) => {
      const i9 = this._materialIdReferences, s8 = i9.get(t6.id);
      1 === s8 ? (e8.remove(t6), i9.delete(t6.id)) : i9.set(t6.id, s8 - 1);
    }), this._engineResourcesAddedToStage = false;
  }
  _getCollisionRadius(e8) {
    return this._getFocusedSize(this.radius, true) * ("touch" === e8 ? this.touchMultiplier : 1);
  }
  _getFocusedSize(e8, t5) {
    return e8 * (t5 ? this.focusMultiplier : 1);
  }
  _getWorldToScreenObjectScale() {
    return this._worldSized ? 1 : this.screenLocation.pixelSize;
  }
  _calculateModelTransformPosition(e8) {
    const t5 = this._getWorldToScreenObjectScale(), i8 = this._calculateObjectTransform(t5, re);
    return o2(e8, i8[12], i8[13], i8[14]);
  }
  _calculateModelTransformOffset(e8) {
    const t5 = this._calculateModelTransformPosition(e8);
    return e2(e8, t5, this.renderLocation);
  }
  _calculateObjectTransform(e8, t5) {
    return s2(t5, e8, 0, 0, 0, 0, e8, 0, 0, 0, 0, e8, 0, 0, 0, 0, 1), this._worldFrame && c(t5, t5, this._worldFrame), c(t5, t5, this._modelTransform), t5[12] += this.renderLocation[0], t5[13] += this.renderLocation[1], t5[14] += this.renderLocation[2], t5[15] = 1, null != this._applyObjectTransform && this._applyObjectTransform(t5), t5;
  }
  get test() {
    let e8 = false;
    if (null != this._engineResources)
      for (const t5 in this._engineResources.objectsByState) {
        const i8 = this._engineResources.objectsByState[t5];
        for (const t6 of i8.objects)
          if (t6.visible) {
            e8 = true;
            break;
          }
        if (e8)
          break;
      }
    return { areAnyResourcesVisible: e8 };
  }
};
function ee(e8) {
  return 0 !== e8[12] || 0 !== e8[13] || 0 !== e8[14];
}
function te(e8, t5, s7) {
  switch (e8.viewingMode) {
    case "local":
      return r2(s7), true;
    case "global": {
      const n6 = A(e8.renderCoordsHelper.spatialReference);
      return _e(t5, 0, le, 0, n6.radius), qn(M(le[0]), M(le[1]), s7), true;
    }
  }
}
var ie = i();
var se = v();
var ne = d3();
var oe = e3();
var re = e4();
var ae = e4();
var ce = h3();
var le = n();
var he = n();
var de = n();
var _e2 = n();
var ue = n();
var ge = n();
var me = new x({ x: 0, y: 0, z: 0, spatialReference: null });
var fe = () => {
};

// node_modules/@arcgis/core/views/3d/interactive/RenderObject.js
var e6 = class {
  constructor(e8, s7 = t3.None) {
    this.geometry = e8, this.stateMask = s7;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/ShadedColorMaterialTechnique.js
var g2 = class _g extends e5 {
  initializeProgram(e8) {
    return new i3(e8.rctx, _g.shader.get().build(this.configuration), v3);
  }
  _setPipelineState(e8) {
    const r6 = this.configuration, o6 = e8 === o4.NONE, i8 = e8 === o4.FrontFace;
    return W({ blending: r6.output !== h4.Color && r6.output !== h4.Alpha || !r6.transparent ? null : o6 ? c4 : A2(e8), culling: h6(r6.cullFace), depthTest: { func: i8 ? I.LESS : r6.shadingEnabled ? I.LEQUAL : I.LESS }, depthWrite: o6 ? r6.writeDepth ? a4 : null : E2(e8), colorWrite: _3, polygonOffset: o6 || i8 ? null : _4 });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
};
g2.shader = new t2(h7, () => import("./ShadedColorMaterial.glsl-NWV6FOVL.js"));
var j3 = class extends s5 {
  constructor() {
    super(...arguments), this.output = h4.Color, this.cullFace = n5.None, this.transparencyPassType = o4.NONE, this.hasSlicePlane = false, this.transparent = false, this.writeDepth = true, this.screenSizeEnabled = true, this.shadingEnabled = true, this.hasMultipassTerrain = false, this.cullAboveGround = false;
  }
};
e([r4({ count: h4.COUNT })], j3.prototype, "output", void 0), e([r4({ count: n5.COUNT })], j3.prototype, "cullFace", void 0), e([r4({ count: o4.COUNT })], j3.prototype, "transparencyPassType", void 0), e([r4()], j3.prototype, "hasSlicePlane", void 0), e([r4()], j3.prototype, "transparent", void 0), e([r4()], j3.prototype, "writeDepth", void 0), e([r4()], j3.prototype, "screenSizeEnabled", void 0), e([r4()], j3.prototype, "shadingEnabled", void 0), e([r4()], j3.prototype, "hasMultipassTerrain", void 0), e([r4()], j3.prototype, "cullAboveGround", void 0);
var v3 = /* @__PURE__ */ new Map([[O2.POSITION, 0], [O2.NORMAL, 1], [O2.OFFSET, 2]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/ShadedColorMaterial.js
var v4 = class extends d4 {
  constructor(e8) {
    super(e8, new O3()), this.supportsEdges = true, this._configuration = new j3(), this._vertexAttributeLocations = v3;
  }
  getConfiguration(e8, t5) {
    return this._configuration.output = e8, this._configuration.cullFace = this.parameters.cullFace, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.transparent = this.parameters.transparent, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.screenSizeEnabled = this.parameters.screenSizeEnabled, this._configuration.shadingEnabled = this.parameters.shadingEnabled, this._configuration.transparencyPassType = t5.transparencyPassType, this._configuration.hasMultipassTerrain = t5.multipassTerrain.enabled, this._configuration.cullAboveGround = t5.multipassTerrain.cullAboveGround, this._configuration;
  }
  intersect(e8, s7, a10, c9, l6, u4) {
    if (this.parameters.screenSizeEnabled) {
      const s8 = e8.vertexAttributes.get(O2.OFFSET), h8 = { applyToVertex: (e9, n6, o6, c10) => {
        const l7 = o2(w3, s8.data[3 * c10], s8.data[3 * c10 + 1], s8.data[3 * c10 + 2]), u5 = o2(z2, e9, n6, o6);
        return g(l7, l7, this.parameters.screenSizeScale * a10.camera.computeRenderPixelSizeAt(l7)), u(u5, u5, l7), [u5[0], u5[1], u5[2]];
      }, applyToAabb: (e9) => {
        const t5 = E(e9, w3);
        return _2(e9, this.parameters.screenSizeScale * a10.camera.computeRenderPixelSizeAt(t5));
      } };
      h5(e8, a10, c9, l6, h8, u4);
    } else
      h5(e8, a10, c9, l6, void 0, u4);
  }
  requiresSlot(e8, t5) {
    if (t5 === h4.Highlight)
      return e8 === E3.OPAQUE_MATERIAL;
    if (t5 === h4.Color || t5 === h4.Alpha || t5 === h4.ObjectAndLayerIdColor) {
      let t6 = E3.OPAQUE_MATERIAL;
      return this.parameters.transparent && (t6 = this.parameters.writeDepth ? E3.TRANSPARENT_MATERIAL : E3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL), e8 === t6 || e8 === E3.DRAPED_MATERIAL;
    }
    return false;
  }
  createGLMaterial(e8) {
    return new j4(e8);
  }
  createBufferWriter() {
    return new x4(this.parameters.screenSizeEnabled);
  }
};
var j4 = class extends t {
  beginSlot(e8) {
    return this.ensureTechnique(g2, e8);
  }
};
var O3 = class extends c3 {
  constructor() {
    super(...arguments), this.color = r3(1, 1, 1, 1), this.shadingTint = r3(0, 0, 0, 0.25), this.shadingDirection = z(n(), [0.5, -0.5, -0.5]), this.screenSizeScale = 14, this.transparent = false, this.writeDepth = true, this.hasSlicePlane = false, this.cullFace = n5.None, this.screenSizeEnabled = false, this.shadingEnabled = true;
  }
};
var x4 = class {
  constructor(e8) {
    this.screenSizeEnabled = e8;
    const t5 = H().vec3f(O2.POSITION).vec3f(O2.NORMAL);
    this.screenSizeEnabled && t5.vec3f(O2.OFFSET), this.vertexBufferLayout = t5;
  }
  elementCount(e8) {
    return e8.indices.get(O2.POSITION).length;
  }
  write(e8, t5, r6, i8, s7) {
    if (A3(r6, this.vertexBufferLayout, e8, t5, i8, s7), this.screenSizeEnabled) {
      if (!r6.vertexAttributes.has(O2.OFFSET))
        throw new Error(`${O2.OFFSET} vertex attribute required for screenSizeEnabled ShadedColorMaterial`);
      {
        const e9 = r6.vertexAttributes.get(O2.OFFSET), a10 = r6.indices.get(O2.OFFSET);
        s3(3 === e9.size);
        const n6 = i8.getField(O2.OFFSET, i2);
        if (!n6)
          throw new Error("unable to acquire view for " + O2.OFFSET);
        b4(a10, e9.data, t5, n6, s7);
      }
    }
  }
};
var w3 = n();
var z2 = n();

// node_modules/@arcgis/core/views/3d/interactive/manipulatorUtils.js
function F(e8, t5 = o3.OccludeAndTransparent, r6 = true) {
  const n6 = r3(e8[0], e8[1], e8[2], e8.length > 3 ? e8[3] : 1), o6 = e8[3] < 1, a10 = !o6;
  return r6 ? new v4({ color: n6, transparent: o6, writeDepth: a10, cullFace: n5.Back, renderOccluded: t5 }) : new f3({ color: n6, transparent: o6, writeDepth: a10, cullFace: n5.Back, renderOccluded: t5 });
}
var I2 = Object.freeze({ calloutLength: 40, calloutWidth: 1, discRadius: 27, focusMultiplier: 1.1 });
function R(e8, t5) {
  const r6 = new $2({ view: e8, autoScaleRenderObjects: false, collisionPriority: 1, metadata: t5.metadata });
  return L(r6, t5), r6;
}
function L(e8, t5) {
  var _a;
  const r6 = t5.material ?? new c5({ transparent: true, writeDepth: false, textureId: (_a = t5.texture) == null ? void 0 : _a.id, renderOccluded: o3.Opaque }), n6 = t5.focusMultiplier ?? I2.focusMultiplier, o6 = t5.calloutLength ?? I2.calloutLength, i8 = I2.discRadius * (t5.discScale ?? 1), a10 = i8 * n6, c9 = (e9, t6) => {
    const r7 = [0, 1, 2, 2, 3, 0];
    return new b3(t6, [[O2.POSITION, new s4([o6 - e9, -e9, 0, o6 + e9, -e9, 0, o6 + e9, e9, 0, o6 - e9, e9, 0], 3, true)], [O2.UV0, new s4([0, 0, 1, 0, 1, 1, 0, 1], 2, true)]], [[O2.POSITION, r7], [O2.UV0, r7]]);
  }, l6 = t5.calloutWidth ?? I2.calloutWidth, s7 = new (l6 > 1 ? B2 : X)({ width: l6, color: t5.calloutColor, renderOccluded: o3.OccludeAndTransparent }), m3 = pt(s7, [[0, 0, 0], [o6 - i8, 0, 0]]), p2 = pt(s7, [[0, 0, 0], [o6 - a10, 0, 0]]), w5 = t5.customStateMask ?? u2.None;
  e8.collisionType = { type: "disc", direction: [0, 0, 1], offset: [o6, 0, 0] }, e8.focusMultiplier = n6, e8.metadata = t5.metadata, e8.radius = i8, e8.renderObjects = [new e6(c9(i8, r6), t3.Unfocused | w5), new e6(m3, t3.Unfocused | w5), new e6(c9(a10, r6), t3.Focused | w5), new e6(p2, t3.Focused | w5)];
}
function T2(e8, t5, r6 = u2.None) {
  const n6 = F(t5), o6 = [new e6(nt(n6, 1, 32, 32), r6)];
  return new $2({ view: e8, renderObjects: o6 });
}
var U = Object.freeze({ autoScaleRenderObjects: false, worldSized: true });
function D(o6, i8, l6, s7) {
  const u4 = e2(c2.get(), o6, l6), m3 = N(u4, _(c2.get(), s7, u4), l6, f2.get());
  h2(m3, m3);
  const d6 = O(c2.get(), i8, m3);
  return Math.atan2(d6[1], d6[0]);
}
function N(e8, t5, n6, i8) {
  const c9 = z(c2.get(), e8), l6 = z(c2.get(), t5), s7 = _(c2.get(), c9, l6);
  return i8[0] = c9[0], i8[1] = c9[1], i8[2] = c9[2], i8[3] = 0, i8[4] = l6[0], i8[5] = l6[1], i8[6] = l6[2], i8[7] = 0, i8[8] = s7[0], i8[9] = s7[1], i8[10] = s7[2], i8[11] = 0, i8[12] = n6[0], i8[13] = n6[1], i8[14] = n6[2], i8[15] = 1, i8;
}

// node_modules/@arcgis/core/views/interactive/dragEventPipeline.js
function f5(e8, t5) {
  let n6 = null, r6 = null;
  return (a10) => {
    if ("cancel" === a10.action)
      return void (null != r6 && (r6.execute({ action: "cancel" }), n6 = null, r6 = null));
    const o6 = { action: a10.action, screenStart: a10.start, screenEnd: a10.screenPoint };
    "start" === a10.action && null == n6 && (n6 = new U2(), r6 = new U2(), t5(e8, n6, r6, a10.pointerType, o6)), null != n6 && n6.execute(o6), "end" === a10.action && null != n6 && (n6 = null, r6 = null);
  };
}
function d5(e8, t5) {
  return e8.events.on("drag", f5(e8, t5));
}
function R3(e8, n6) {
  const r6 = /* @__PURE__ */ new Map();
  for (const a10 of n6)
    r6.set(a10, a(e8[a10]));
  return (t5) => (r6.forEach((t6, n7) => {
    e8[n7] = t6;
  }), t5);
}
var G = () => {
};
var U2 = class _U {
  constructor() {
    this.execute = G;
  }
  next(e8, t5 = new _U()) {
    return null != e8 && (this.execute = (n6) => {
      const r6 = e8(n6);
      null != r6 && t5.execute(r6);
    }), t5;
  }
};

// node_modules/@arcgis/core/views/interactive/ManipulatorCollection.js
var a8;
!function(t5) {
  t5[t5.WhenToolEditable = 0] = "WhenToolEditable", t5[t5.WhenToolNotEditable = 1] = "WhenToolNotEditable", t5[t5.Always = 2] = "Always";
}(a8 || (a8 = {}));
var i7 = class {
  constructor() {
    this._isToolEditable = true, this._manipulators = new V(), this._resourceContexts = { manipulator3D: {} }, this._attached = false;
  }
  set isToolEditable(t5) {
    this._isToolEditable = t5;
  }
  get length() {
    return this._manipulators.length;
  }
  add(t5, i8 = a8.WhenToolEditable) {
    this.addMany([t5], i8);
  }
  addMany(t5, i8 = a8.WhenToolEditable) {
    for (const a10 of t5) {
      const t6 = { manipulator: a10, visibilityPredicate: i8, attached: false };
      this._manipulators.add(t6), this._attached && this._updateManipulatorAttachment(t6);
    }
  }
  remove(t5) {
    for (let a10 = 0; a10 < this._manipulators.length; a10++)
      if (this._manipulators.at(a10).manipulator === t5) {
        const t6 = this._manipulators.splice(a10, 1)[0];
        this._detachManipulator(t6);
        break;
      }
  }
  removeAll() {
    this._manipulators.forEach((t5) => {
      this._detachManipulator(t5);
    }), this._manipulators.removeAll();
  }
  attach() {
    this._manipulators.forEach((t5) => {
      this._updateManipulatorAttachment(t5);
    }), this._attached = true;
  }
  detach() {
    this._manipulators.forEach((t5) => {
      this._detachManipulator(t5);
    }), this._attached = false;
  }
  destroy() {
    this.detach(), this._manipulators.forEach(({ manipulator: t5 }) => {
      t5.destroy && t5.destroy();
    }), this._manipulators.destroy(), this._resourceContexts = null;
  }
  on(t5, a10) {
    return this._manipulators.on(t5, (t6) => {
      a10(t6);
    });
  }
  forEach(t5) {
    for (const a10 of this._manipulators.items)
      t5(a10);
  }
  some(t5) {
    return this._manipulators.items.some(t5);
  }
  toArray() {
    const t5 = [];
    return this.forEach((a10) => t5.push(a10.manipulator)), t5;
  }
  intersect(t5, a10) {
    let i8 = null, e8 = Number.MAX_VALUE;
    return this._manipulators.forEach(({ manipulator: o6, attached: s7 }) => {
      if (!s7 || !o6.interactive)
        return;
      const r6 = o6.intersectionDistance(t5, a10);
      null != r6 && r6 < e8 && (e8 = r6, i8 = o6);
    }), i8;
  }
  _updateManipulatorAttachment(t5) {
    this._isManipulatorItemVisible(t5) ? this._attachManipulator(t5) : this._detachManipulator(t5);
  }
  _attachManipulator(t5) {
    t5.attached || (t5.manipulator.attach && t5.manipulator.attach(this._resourceContexts), t5.attached = true);
  }
  _detachManipulator(t5) {
    if (!t5.attached)
      return;
    const a10 = t5.manipulator;
    a10.grabbing = false, a10.dragging = false, a10.hovering = false, a10.selected = false, a10.detach && a10.detach(this._resourceContexts), t5.attached = false;
  }
  _isManipulatorItemVisible(t5) {
    return t5.visibilityPredicate === a8.Always || (this._isToolEditable ? t5.visibilityPredicate === a8.WhenToolEditable : t5.visibilityPredicate === a8.WhenToolNotEditable);
  }
};

// node_modules/@arcgis/core/views/interactive/InteractiveToolBase.js
var l5 = class extends m {
  constructor(t5) {
    super(t5), this.manipulators = new i7(), this.automaticManipulatorSelection = true, this.hasGrabbedManipulators = false, this.hasHoveredManipulators = false, this.firstGrabbedManipulator = null, this.created = false, this.removeIncompleteOnCancel = true, this._editableFlags = /* @__PURE__ */ new Map([[o5.MANAGER, true], [o5.USER, true]]), this._creationFinishedResolver = C();
  }
  get active() {
    return null != this.view && this.view.activeTool === this;
  }
  set visible(t5) {
    this._get("visible") !== t5 && (this._set("visible", t5), this._syncVisible());
  }
  get editable() {
    return this.getEditableFlag(o5.USER);
  }
  set editable(t5) {
    this.setEditableFlag(o5.USER, t5);
  }
  get updating() {
    return false;
  }
  get cursor() {
    return null;
  }
  get hasFocusedManipulators() {
    return this.hasGrabbedManipulators || this.hasHoveredManipulators;
  }
  destroy() {
    this.manipulators.destroy(), this._set("view", null);
  }
  onAdd() {
    this._syncVisible();
  }
  activate() {
    null != this.view ? (this.view.focus(), this.onActivate()) : s.getLogger(this).error("Can't activate tool if view is not defined.");
  }
  deactivate() {
    this.onDeactivate();
  }
  handleInputEvent(t5) {
    this.onInputEvent(t5);
  }
  handleInputEventAfter(t5) {
    this.onInputEventAfter(t5);
  }
  setEditableFlag(t5, e8) {
    this._editableFlags.set(t5, e8), this.manipulators.isToolEditable = this.internallyEditable, this._updateManipulatorAttachment(), t5 === o5.USER && this.notifyChange("editable"), this.onEditableChange(), this.onManipulatorSelectionChanged();
  }
  getEditableFlag(t5) {
    return this._editableFlags.get(t5) ?? false;
  }
  whenCreated() {
    return this._creationFinishedResolver.promise;
  }
  onManipulatorSelectionChanged() {
  }
  onActivate() {
  }
  onDeactivate() {
  }
  onShow() {
  }
  onHide() {
  }
  onEditableChange() {
  }
  onInputEvent(t5) {
  }
  onInputEventAfter(t5) {
  }
  get internallyEditable() {
    return this.getEditableFlag(o5.USER) && this.getEditableFlag(o5.MANAGER);
  }
  finishToolCreation() {
    this.created || this._creationFinishedResolver.resolve(this), this._set("created", true);
  }
  _syncVisible() {
    if (this.initialized) {
      if (this.visible)
        this._show();
      else if (this._hide(), this.active)
        return void (this.view.activeTool = null);
    }
  }
  _show() {
    this._updateManipulatorAttachment(), this.onShow();
  }
  _hide() {
    this._updateManipulatorAttachment(), this.onHide();
  }
  _updateManipulatorAttachment() {
    this.visible ? this.manipulators.attach() : this.manipulators.detach();
  }
};
e([y({ constructOnly: true })], l5.prototype, "view", void 0), e([y({ readOnly: true })], l5.prototype, "active", null), e([y({ value: true })], l5.prototype, "visible", null), e([y({ value: true })], l5.prototype, "editable", null), e([y({ readOnly: true })], l5.prototype, "manipulators", void 0), e([y({ readOnly: true })], l5.prototype, "updating", null), e([y()], l5.prototype, "cursor", null), e([y({ readOnly: true })], l5.prototype, "automaticManipulatorSelection", void 0), e([y()], l5.prototype, "hasFocusedManipulators", null), e([y()], l5.prototype, "hasGrabbedManipulators", void 0), e([y()], l5.prototype, "hasHoveredManipulators", void 0), e([y()], l5.prototype, "firstGrabbedManipulator", void 0), e([y({ readOnly: true })], l5.prototype, "created", void 0), e([y({ readOnly: true })], l5.prototype, "removeIncompleteOnCancel", void 0), l5 = e([a2("esri.views.interactive.InteractiveToolBase")], l5);

// node_modules/@arcgis/core/views/interactive/AnalysisToolBase.js
var a9 = class extends l5 {
  constructor(s7) {
    super(s7);
  }
  initialize() {
    this.addHandles(l2(() => this.analysisViewData.visible, (s7) => this.visible = s7, w2));
  }
  deactivate() {
    this.onDeactivate(), this.created || this.analysis.clear();
  }
  resetCreated() {
    this._set("created", false);
  }
};
e([y({ constructOnly: true })], a9.prototype, "analysis", void 0), e([y()], a9.prototype, "analysisViewData", void 0), a9 = e([a2("esri.views.interactive.AnalysisToolBase")], a9);

export {
  $2 as $,
  e6 as e,
  v4 as v,
  F,
  R,
  L,
  T2 as T,
  U,
  D,
  N,
  d5 as d,
  R3 as R2,
  U2,
  a9 as a,
  l3 as l,
  a6 as a2,
  v2
};
//# sourceMappingURL=chunk-SUS6FVXM.js.map
