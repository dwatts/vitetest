import {
  i as i2,
  o
} from "./chunk-IEYHFJSJ.js";
import "./chunk-SX7Y47S2.js";
import "./chunk-KMWAP7WW.js";
import {
  E2 as E,
  l2
} from "./chunk-FEOJNOKF.js";
import "./chunk-VIDC736D.js";
import {
  m as m2
} from "./chunk-67UNUI4B.js";
import {
  i,
  n,
  r
} from "./chunk-SAAQQDRS.js";
import "./chunk-2XKILFME.js";
import "./chunk-G4LSNP77.js";
import "./chunk-BA6PBZHC.js";
import "./chunk-467UETSR.js";
import "./chunk-SHFLRM67.js";
import "./chunk-ZWFMUHG3.js";
import "./chunk-EFRTD25L.js";
import "./chunk-GSS6WNQU.js";
import "./chunk-C2EHS6UI.js";
import "./chunk-7JB7RSO7.js";
import "./chunk-CEUJOC5P.js";
import "./chunk-GOK5MP3B.js";
import "./chunk-NLWV7Q6F.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-5IYCCZ54.js";
import "./chunk-AQ7R6V4L.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import "./chunk-4OR73Y2R.js";
import "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-3VUFACNT.js";
import "./chunk-ZEEBL7ZN.js";
import "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import {
  a as a2,
  h,
  l
} from "./chunk-H7RDAEPY.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import {
  m,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import {
  p,
  s
} from "./chunk-7I33FAWS.js";
import "./chunk-DWOEYHKS.js";
import "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/FeatureCollectionSnappingSource.js
var v = class extends m {
  get availability() {
    return 1;
  }
  get updating() {
    return this.layerSource.updating;
  }
  get _snappingElevationAligner() {
    const { view: e2 } = this, { layer: t } = this.layerSource, i3 = null != e2 && "3d" === e2.type;
    if (!i3 || "subtype-group" === t.type)
      return i();
    const r2 = async (i4, r3) => (await p(e2.whenLayerView(t), r3)).elevationAlignPointsInFeatures(i4, r3);
    return i(i3, { elevationInfo: t.elevationInfo, alignPointsInFeatures: r2, spatialReference: e2.spatialReference });
  }
  get _snappingElevationFilter() {
    const { view: e2 } = this, t = null != e2 && "3d" === e2.type && "subtype-group" !== this.layerSource.layer.type;
    return r(t);
  }
  get _symbologySnappingFetcher() {
    const { view: e2 } = this, { layer: t } = this.layerSource;
    return null != e2 && "3d" === e2.type && "subtype-group" !== t.type ? n(this._symbologySnappingSupported, async (n2, r2) => {
      const o2 = await e2.whenLayerView(t);
      return s(r2), o2.queryForSymbologySnapping({ candidates: n2, spatialReference: e2.spatialReference }, r2);
    }) : n();
  }
  get _symbologySnappingSupported() {
    return null != this._layerView3D && this._layerView3D.symbologySnappingSupported;
  }
  initialize() {
    const { view: e2 } = this, { layer: t } = this.layerSource;
    null != e2 && "3d" === e2.type && "subtype-group" !== t.type && (e2.whenLayerView(t).then((e3) => this._layerView3D = e3), this.addHandles([e2.elevationProvider.on("elevation-change", ({ context: e3 }) => {
      const { elevationInfo: i3 } = t;
      m2(e3, i3) && this._snappingElevationAligner.notifyElevationSourceChange();
    }), l(() => t.elevationInfo, () => this._snappingElevationAligner.notifyElevationSourceChange(), h), l(() => {
      var _a;
      return null != this._layerView3D ? (_a = this._layerView3D.processor) == null ? void 0 : _a.renderer : null;
    }, () => this._symbologySnappingFetcher.notifySymbologyChange(), h), a2(() => {
      var _a;
      return (_a = this._layerView3D) == null ? void 0 : _a.layer;
    }, ["edits", "apply-edits", "graphic-update"], () => this._symbologySnappingFetcher.notifySymbologyChange())]));
  }
  constructor(e2) {
    super(e2), this.view = null, this._layerView3D = null;
  }
  refresh() {
  }
  async fetchCandidates(e2, t) {
    var _a;
    const { layer: n2 } = this.layerSource, r2 = n2.source;
    if (!(r2 == null ? void 0 : r2.querySnapping))
      return [];
    const o2 = E(n2), a3 = l2(e2, ((_a = this.view) == null ? void 0 : _a.type) ?? "2d", o2), s2 = await r2.querySnapping(a3, { signal: t });
    s(t);
    const p2 = await this._snappingElevationAligner.alignCandidates(s2.candidates, t);
    s(t);
    const l3 = await this._symbologySnappingFetcher.fetch(p2, t);
    s(t);
    const g = 0 === l3.length ? p2 : [...p2, ...l3], h2 = this._snappingElevationFilter.filter(a3, g), m3 = this._getGroundElevation;
    return h2.map((e3) => i2(e3, m3));
  }
  get _getGroundElevation() {
    return o(this.view);
  }
};
e([y({ constructOnly: true })], v.prototype, "layerSource", void 0), e([y({ constructOnly: true })], v.prototype, "view", void 0), e([y()], v.prototype, "_snappingElevationAligner", null), e([y()], v.prototype, "_snappingElevationFilter", null), e([y()], v.prototype, "_symbologySnappingFetcher", null), e([y()], v.prototype, "_layerView3D", void 0), e([y()], v.prototype, "_symbologySnappingSupported", null), e([y()], v.prototype, "_getGroundElevation", null), v = e([a("esri.views.interactive.snapping.featureSources.FeatureCollectionSnappingSource")], v);
export {
  v as FeatureCollectionSnappingSource
};
//# sourceMappingURL=FeatureCollectionSnappingSource-2VXUES4D.js.map
