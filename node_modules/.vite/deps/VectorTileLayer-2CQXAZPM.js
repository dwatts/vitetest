import {
  p as p2
} from "./chunk-CWMMFL5F.js";
import "./chunk-OZANOPIE.js";
import {
  T
} from "./chunk-7TIX3FJC.js";
import {
  l as l2
} from "./chunk-FXRNYI6X.js";
import "./chunk-2735WBYK.js";
import "./chunk-CSLWFQJE.js";
import "./chunk-J6SRKANJ.js";
import {
  e as e2
} from "./chunk-EJM2AJGV.js";
import "./chunk-FKEHFW5J.js";
import "./chunk-7HZ72XIE.js";
import "./chunk-TDXHXKUI.js";
import "./chunk-FF5LS3YE.js";
import "./chunk-BCDDCNQ2.js";
import "./chunk-WWUAHPIM.js";
import {
  i
} from "./chunk-LCS4FL4K.js";
import {
  l as l3
} from "./chunk-4JFWLHWB.js";
import {
  o as o2
} from "./chunk-5GE3CZPD.js";
import {
  j as j2
} from "./chunk-ZX45U24W.js";
import "./chunk-KYWX7M3R.js";
import {
  a as a5
} from "./chunk-7H2AXTDH.js";
import {
  t
} from "./chunk-QC2JMJXZ.js";
import {
  c
} from "./chunk-GFPASUQP.js";
import {
  O
} from "./chunk-KDACHJ5G.js";
import "./chunk-IQRLZSBX.js";
import "./chunk-OZL6Q7O2.js";
import "./chunk-467UETSR.js";
import "./chunk-SHFLRM67.js";
import "./chunk-GOK4EI36.js";
import "./chunk-LO3LAMAS.js";
import "./chunk-ZWFMUHG3.js";
import "./chunk-EFRTD25L.js";
import "./chunk-O62OS3ME.js";
import {
  n as n2
} from "./chunk-G3Q2URFK.js";
import "./chunk-63ERNIOV.js";
import {
  e as e3
} from "./chunk-YYTXJF6W.js";
import {
  j as j3,
  p
} from "./chunk-DSWGERIY.js";
import "./chunk-Y2ZDD3I4.js";
import "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import "./chunk-W4KI5YEI.js";
import "./chunk-CAFGOFIE.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-DOQ3SAAR.js";
import "./chunk-4BXK4H4L.js";
import {
  d as d3
} from "./chunk-SLVNG7FV.js";
import "./chunk-OZXJDVTE.js";
import {
  d as d2
} from "./chunk-SVCGLUNW.js";
import {
  b as b2
} from "./chunk-3KEIFTQ6.js";
import "./chunk-DEZCXTA3.js";
import "./chunk-RRJGZKNX.js";
import "./chunk-A6VKJXIH.js";
import "./chunk-KFSY6ZZH.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-HXPVVSLV.js";
import "./chunk-4OR73Y2R.js";
import "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-2CTB7MKH.js";
import "./chunk-Z2ZUNW5S.js";
import "./chunk-7L7Z2HXM.js";
import "./chunk-75NKPXTR.js";
import "./chunk-EUVARFSM.js";
import {
  M
} from "./chunk-3VUFACNT.js";
import {
  f as f2,
  x2 as x
} from "./chunk-ZEEBL7ZN.js";
import {
  o,
  r as r2
} from "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-H7RDAEPY.js";
import "./chunk-7KH4CLS5.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-JL3TJGVW.js";
import "./chunk-JZM5YUHA.js";
import {
  j
} from "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import {
  K,
  L,
  Ut,
  V,
  Y,
  a as a4,
  at,
  b,
  bt,
  kt,
  v
} from "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import {
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a3
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import {
  r
} from "./chunk-3R7FAT25.js";
import {
  a as a2,
  d,
  f,
  s as s3,
  w
} from "./chunk-7I33FAWS.js";
import {
  l
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import {
  a
} from "./chunk-IYZKKFJM.js";
import {
  n2 as n,
  u
} from "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/imageUtils.js
var A = null;
function o3(o5) {
  if (A)
    return A;
  const l7 = { lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==", alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==", animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA" };
  return A = new Promise((A2) => {
    const n4 = new Image();
    n4.onload = () => {
      n4.onload = n4.onerror = null, A2(n4.width > 0 && n4.height > 0);
    }, n4.onerror = () => {
      n4.onload = n4.onerror = null, A2(false);
    }, n4.src = "data:image/webp;base64," + l7[o5];
  }), A;
}

// node_modules/@arcgis/core/layers/support/SpriteSource.js
var h = 1.15;
var n3 = class {
  constructor(t2, e4) {
    this._spriteSource = t2, this._maxTextureSize = e4, this.devicePixelRatio = 1, this._spriteImageFormat = "png", this._isRetina = false, this._spritesData = {}, this.image = null, this.width = null, this.height = null, this.loadStatus = "not-loaded", "url" === t2.type && t2.spriteFormat && (this._spriteImageFormat = t2.spriteFormat), t2.pixelRatio && (this.devicePixelRatio = t2.pixelRatio), this.baseURL = t2.spriteUrl;
  }
  get spriteNames() {
    const t2 = [];
    for (const e4 in this._spritesData)
      t2.push(e4);
    return t2.sort(), t2;
  }
  getSpriteInfo(t2) {
    return this._spritesData ? this._spritesData[t2] : null;
  }
  async load(t2) {
    if (this.baseURL) {
      this.loadStatus = "loading";
      try {
        await this._loadSprites(t2), this.loadStatus = "loaded";
      } catch {
        this.loadStatus = "failed";
      }
    } else
      this.loadStatus = "failed";
  }
  async _loadSprites(t2) {
    this._isRetina = this.devicePixelRatio > h;
    const { width: s5, height: r4, data: a7, json: o5 } = await this._getSpriteData(this._spriteSource, t2), n4 = Object.keys(o5);
    if (!n4 || 0 === n4.length || !a7)
      return this._spritesData = this.image = null, void (this.width = this.height = 0);
    this._spritesData = o5, this.width = s5, this.height = r4;
    const d6 = Math.max(this._maxTextureSize, 4096);
    if (s5 > d6 || r4 > d6) {
      const t3 = `Sprite resource for style ${this.baseURL} is bigger than the maximum allowed of ${d6} pixels}`;
      throw s.getLogger("esri.layers.support.SpriteSource").error(t3), new s2("SpriteSource", t3);
    }
    let p5;
    for (let e4 = 0; e4 < a7.length; e4 += 4)
      p5 = a7[e4 + 3] / 255, a7[e4] = a7[e4] * p5, a7[e4 + 1] = a7[e4 + 1] * p5, a7[e4 + 2] = a7[e4 + 2] * p5;
    this.image = a7;
  }
  async _getSpriteData(i2, n4) {
    if ("image" === i2.type) {
      let t2, a7;
      if (this.devicePixelRatio < h) {
        if (!i2.spriteSource1x)
          throw new s2("SpriteSource", "no image data provided for low resolution sprites!");
        t2 = i2.spriteSource1x.image, a7 = i2.spriteSource1x.json;
      } else {
        if (!i2.spriteSource2x)
          throw new s2("SpriteSource", "no image data provided for high resolution sprites!");
        t2 = i2.spriteSource2x.image, a7 = i2.spriteSource2x.json;
      }
      return "width" in t2 && "height" in t2 && "data" in t2 && (n(t2.data) || u(t2.data)) ? { width: t2.width, height: t2.height, data: new Uint8Array(t2.data), json: a7 } : { ...d4(t2), json: a7 };
    }
    const p5 = L(this.baseURL), l7 = p5.query ? "?" + v(p5.query) : "", g = this._isRetina ? "@2x" : "", u3 = `${p5.path}${g}.${this._spriteImageFormat}${l7}`, c3 = `${p5.path}${g}.json${l7}`, [m2, S2] = await Promise.all([j(c3, n4), j(u3, { responseType: "image", ...n4 })]);
    return { ...d4(S2.data), json: m2.data };
  }
};
function d4(t2) {
  const e4 = document.createElement("canvas"), i2 = e4.getContext("2d");
  e4.width = t2.width, e4.height = t2.height, i2.drawImage(t2, 0, 0, t2.width, t2.height);
  const s5 = i2.getImageData(0, 0, t2.width, t2.height);
  return { width: t2.width, height: t2.height, data: new Uint8Array(s5.data) };
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TilemapIndex.js
var l4 = class {
  constructor(e4) {
    this.url = e4;
  }
  destroy() {
    this._tileIndexPromise = null;
  }
  async fetchTileIndex() {
    return this._tileIndexPromise || (this._tileIndexPromise = j(this.url).then((e4) => e4.data.index)), this._tileIndexPromise;
  }
  async dataKey(e4, r4) {
    const l7 = await this.fetchTileIndex();
    return s3(r4), this._getIndexedDataKey(l7, e4);
  }
  _getIndexedDataKey(e4, t2) {
    const l7 = [t2];
    if (t2.level < 0 || t2.row < 0 || t2.col < 0 || t2.row >> t2.level > 0 || t2.col >> t2.level > 0)
      return null;
    let i2 = t2;
    for (; 0 !== i2.level; )
      i2 = new e3(i2.level - 1, i2.row >> 1, i2.col >> 1, i2.world), l7.push(i2);
    let o5, s5, n4 = e4, a7 = l7.pop();
    if (1 === n4)
      return a7;
    for (; l7.length; )
      if (o5 = l7.pop(), s5 = (1 & o5.col) + ((1 & o5.row) << 1), n4) {
        if (0 === n4[s5]) {
          a7 = null;
          break;
        }
        if (1 === n4[s5]) {
          a7 = o5;
          break;
        }
        a7 = o5, n4 = n4[s5];
      }
    return a7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TilemapRequest.js
var l5 = class {
  constructor(e4, t2) {
    this._tilemap = e4, this._tileIndexUrl = t2;
  }
  destroy() {
    this._tilemap = l(this._tilemap), this._tileIndexPromise = null;
  }
  async fetchTileIndex(t2) {
    return this._tileIndexPromise || (this._tileIndexPromise = j(this._tileIndexUrl, { query: { ...t2 == null ? void 0 : t2.query } }).then((e4) => e4.data.index)), this._tileIndexPromise;
  }
  dataKey(e4, t2) {
    const { level: l7, row: s5, col: o5 } = e4, n4 = new e3(e4);
    return this._tilemap.fetchAvailabilityUpsample(l7, s5, o5, n4, t2).then(() => (n4.world = e4.world, n4)).catch((e5) => {
      if (d(e5))
        throw e5;
      return null;
    });
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/VectorTilesRequestManager.js
var l6 = class {
  constructor(t2) {
    this._tileUrl = t2, this._promise = null, this._abortController = null, this._abortOptions = [];
  }
  getData(t2) {
    null === this._promise && (this._abortController = new AbortController(), this._promise = this._makeRequest(this._tileUrl, this._abortController.signal));
    const e4 = this._abortOptions;
    return e4.push(t2), w(t2, () => {
      e4.every((t3) => a2(t3)) && this._abortController.abort();
    }), this._promise.then((t3) => a(t3));
  }
  async _makeRequest(r4, e4) {
    const { data: o5 } = await j(r4, { responseType: "array-buffer", signal: e4 });
    return o5;
  }
};
var a6 = /* @__PURE__ */ new Map();
function c2(t2, r4, e4, o5, s5) {
  const l7 = L(t2), a7 = l7.query;
  if (a7)
    for (const [i2, n4] of Object.entries(a7))
      switch (n4) {
        case "{x}":
          a7[i2] = o5.toString();
          break;
        case "{y}":
          a7[i2] = e4.toString();
          break;
        case "{z}":
          a7[i2] = r4.toString();
      }
  const c3 = l7.path;
  return p3(kt(c3.replaceAll(/\{z\}/gi, r4.toString()).replaceAll(/\{y\}/gi, e4.toString()).replaceAll(/\{x\}/gi, o5.toString()), { ...l7.query }), s5);
}
function p3(t2, r4) {
  return r(a6, t2, () => new l6(t2)).getData(r4).then((r5) => (a6.delete(t2), r5)).catch((r5) => {
    throw a6.delete(t2), r5;
  });
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/VectorTileSource.js
var u2 = class {
  constructor(h3, u3, m2) {
    this.tilemap = null, this.tileInfo = null, this.capabilities = null, this.fullExtent = null, this.name = h3, this.sourceUrl = u3;
    const f4 = L(this.sourceUrl), c3 = a(m2), d6 = c3.tiles;
    if (f4)
      for (let t2 = 0; t2 < d6.length; t2++) {
        const r4 = L(d6[t2]);
        r4 && (Y(r4.path) || (r4.path = V(f4.path, r4.path)), d6[t2] = kt(r4.path, { ...f4.query, ...r4.query }));
      }
    this.tileServers = d6;
    const x2 = m2.capabilities && m2.capabilities.split(",").map((t2) => t2.toLowerCase().trim()), y3 = true === (m2 == null ? void 0 : m2.exportTilesAllowed), T2 = true === (x2 == null ? void 0 : x2.includes("tilemap")), I = y3 && m2.hasOwnProperty("maxExportTilesCount") ? m2.maxExportTilesCount : 0;
    this.capabilities = { operations: { supportsExportTiles: y3, supportsTileMap: T2 }, exportTiles: y3 ? { maxExportTilesCount: +I } : null }, this.tileInfo = j3.fromJSON(c3.tileInfo);
    const g = m2.tileMap ? kt(V(f4.path, m2.tileMap), f4.query ?? {}) : null;
    T2 ? (this.type = "vector-tile", this.tilemap = new l5(new T({ layer: { parsedUrl: f4, tileInfo: this.tileInfo }, minLOD: c3.minLOD ?? this.tileInfo.lods[0].level, maxLOD: c3.maxLOD ?? this.tileInfo.lods[this.tileInfo.lods.length - 1].level }), g)) : g && (this.tilemap = new l4(g)), this.fullExtent = M.fromJSON(m2.fullExtent);
  }
  destroy() {
    var _a;
    (_a = this.tilemap) == null ? void 0 : _a.destroy();
  }
  async getRefKey(t2, e4) {
    var _a;
    return await ((_a = this.tilemap) == null ? void 0 : _a.dataKey(t2, e4)) ?? t2;
  }
  requestTile(t2, e4, i2, l7) {
    const s5 = this.tileServers[e4 % this.tileServers.length];
    return c2(s5, t2, e4, i2, l7);
  }
  isCompatibleWith(t2) {
    const e4 = this.tileInfo, i2 = t2.tileInfo;
    if (!e4.spatialReference.equals(i2.spatialReference))
      return false;
    if (!e4.origin.equals(i2.origin))
      return false;
    if (Math.round(e4.dpi) !== Math.round(i2.dpi))
      return false;
    const l7 = e4.lods, s5 = i2.lods, r4 = Math.min(l7.length, s5.length);
    for (let o5 = 0; o5 < r4; o5++) {
      const t3 = l7[o5], e5 = s5[o5];
      if (t3.level !== e5.level || Math.round(t3.scale) !== Math.round(e5.scale))
        return false;
    }
    return true;
  }
};

// node_modules/@arcgis/core/layers/support/vectorTileLayerLoader.js
async function f3(e4, r4) {
  const t2 = { source: null, sourceBase: null, sourceUrl: null, validatedSource: null, style: null, styleBase: null, styleUrl: null, sourceNameToSource: {}, primarySourceName: "", spriteFormat: "png" }, [s5, o5] = "string" == typeof e4 ? [e4, null] : [null, e4.jsonUrl];
  await y2(t2, "esri", e4, o5, r4);
  return { layerDefinition: t2.validatedSource, url: s5, serviceUrl: t2.sourceUrl, style: t2.style, styleUrl: t2.styleUrl, spriteUrl: t2.style.sprite && p4(t2.styleBase, t2.style.sprite), spriteFormat: t2.spriteFormat, glyphsUrl: t2.style.glyphs && p4(t2.styleBase, t2.style.glyphs), sourceNameToSource: t2.sourceNameToSource, primarySourceName: t2.primarySourceName };
}
function p4(...e4) {
  let r4;
  for (const l7 of e4)
    if (null != l7)
      if (at(l7)) {
        if (r4) {
          const e5 = r4.split("://")[0];
          r4 = e5 + ":" + l7.trim();
        }
      } else
        r4 = Y(l7) ? l7 : V(r4, l7);
  return r4 ? bt(r4) : void 0;
}
async function y2(t2, s5, o5, l7, i2) {
  let u3, c3, a7;
  if (s3(i2), "string" == typeof o5) {
    const r4 = K(o5);
    a7 = await j(r4, { ...i2, responseType: "json", query: { f: "json", ...i2 == null ? void 0 : i2.query } }), a7.ssl && (u3 && (u3 = u3.replace(/^http:/i, "https:")), c3 && (c3 = c3.replace(/^http:/i, "https:"))), u3 = r4, c3 = r4;
  } else
    null != o5 && (a7 = { data: o5 }, u3 = o5.jsonUrl || null, c3 = l7);
  const f4 = a7 == null ? void 0 : a7.data;
  if (m(f4))
    return t2.styleUrl = u3 || null, S(t2, f4, c3, i2);
  if (d5(f4))
    return t2.sourceUrl ? h2(t2, f4, c3, false, s5, i2) : (t2.sourceUrl = u3 || null, h2(t2, f4, c3, true, s5, i2));
  throw new Error("You must specify the URL or the JSON for a service or for a style.");
}
function m(e4) {
  return !!e4 && "sources" in e4 && !!e4.sources;
}
function d5(e4) {
  return !m(e4);
}
async function S(e4, r4, t2, s5) {
  const o5 = t2 ? Ut(t2) : b();
  e4.styleBase = o5, e4.style = r4, r4["sprite-format"] && "webp" === r4["sprite-format"].toLowerCase() && (e4.spriteFormat = "webp");
  const l7 = [];
  if (r4.sources && r4.sources.esri) {
    const t3 = r4.sources.esri;
    t3.url ? await y2(e4, "esri", p4(o5, t3.url), void 0, s5) : l7.push(y2(e4, "esri", t3, o5, s5));
  }
  for (const n4 of Object.keys(r4.sources))
    "esri" !== n4 && "vector" === r4.sources[n4].type && (r4.sources[n4].url ? l7.push(y2(e4, n4, p4(o5, r4.sources[n4].url), void 0, s5)) : r4.sources[n4].tiles && l7.push(y2(e4, n4, r4.sources[n4], o5, s5)));
  await Promise.all(l7);
}
async function h2(e4, r4, t2, s5, o5, n4) {
  const i2 = t2 ? bt(t2) + "/" : b(), f4 = w2(r4), m2 = new u2(o5, kt(i2, (n4 == null ? void 0 : n4.query) ?? {}), f4);
  if (!s5 && e4.primarySourceName in e4.sourceNameToSource) {
    const r5 = e4.sourceNameToSource[e4.primarySourceName];
    if (!r5.isCompatibleWith(m2))
      return;
    null != m2.fullExtent && (null != r5.fullExtent ? r5.fullExtent.union(m2.fullExtent) : r5.fullExtent = m2.fullExtent.clone()), r5.tileInfo && m2.tileInfo && r5.tileInfo.lods.length < m2.tileInfo.lods.length && (r5.tileInfo = m2.tileInfo);
  }
  if (s5 && (e4.sourceBase = i2, e4.source = r4, e4.validatedSource = f4, e4.primarySourceName = o5), e4.sourceNameToSource[o5] = m2, !e4.style) {
    if (null == r4.defaultStyles)
      throw new Error();
    return "string" == typeof r4.defaultStyles ? y2(e4, "", p4(i2, r4.defaultStyles, "root.json"), void 0, n4) : y2(e4, "", r4.defaultStyles, p4(i2, "root.json"), n4);
  }
}
function w2(e4) {
  if (e4.hasOwnProperty("tileInfo"))
    return e4;
  const r4 = { xmin: -20037507067161843e-9, ymin: -20037507067161843e-9, xmax: 20037507067161843e-9, ymax: 20037507067161843e-9, spatialReference: { wkid: 102100 } }, t2 = 512;
  let s5 = 78271.51696400007, o5 = 2958287637957775e-7;
  const l7 = [], n4 = e4.hasOwnProperty("minzoom") ? +e4.minzoom : 0, i2 = e4.hasOwnProperty("maxzoom") ? +e4.maxzoom : 22;
  for (let u3 = 0; u3 <= i2; u3++)
    u3 >= n4 && l7.push({ level: u3, scale: o5, resolution: s5 }), s5 /= 2, o5 /= 2;
  return { capabilities: "TilesOnly", initialExtent: r4, fullExtent: r4, minScale: 0, maxScale: 0, tiles: e4.tiles, tileInfo: { rows: t2, cols: t2, dpi: 96, format: "pbf", origin: { x: -20037508342787e-6, y: 20037508342787e-6 }, lods: l7, spatialReference: { wkid: 102100 } } };
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/tileInfoUtils.js
var s4 = 1e-6;
function r3(l7, e4) {
  if (l7 === e4)
    return true;
  if (null == l7 && null != e4)
    return false;
  if (null != l7 && null == e4)
    return false;
  if (null == l7 || null == e4)
    return false;
  if (!l7.spatialReference.equals(e4.spatialReference) || l7.dpi !== e4.dpi)
    return false;
  const n4 = l7.origin, r4 = e4.origin;
  if (Math.abs(n4.x - r4.x) >= s4 || Math.abs(n4.y - r4.y) >= s4)
    return false;
  let o5, t2;
  l7.lods[0].scale > e4.lods[0].scale ? (o5 = l7, t2 = e4) : (t2 = l7, o5 = e4);
  for (let i2 = o5.lods[0].scale; i2 >= t2.lods[t2.lods.length - 1].scale - s4; i2 /= 2)
    if (Math.abs(i2 - t2.lods[0].scale) < s4)
      return true;
  return false;
}
function o4(s5, r4) {
  if (s5 === r4)
    return s5;
  if (null == s5 && null != r4)
    return r4;
  if (null != s5 && null == r4)
    return s5;
  if (null == s5 || null == r4)
    return null;
  const o5 = s5.size[0], t2 = s5.format, i2 = s5.dpi, u3 = new x({ x: s5.origin.x, y: s5.origin.y }), a7 = s5.spatialReference, f4 = s5.lods[0].scale > r4.lods[0].scale ? s5.lods[0] : r4.lods[0], d6 = s5.lods[s5.lods.length - 1].scale <= r4.lods[r4.lods.length - 1].scale ? s5.lods[s5.lods.length - 1] : r4.lods[r4.lods.length - 1], c3 = f4.scale, p5 = f4.resolution, g = d6.scale, h3 = [];
  let m2 = c3, y3 = p5, x2 = 0;
  for (; m2 > g; )
    h3.push(new p({ level: x2, resolution: y3, scale: m2 })), x2++, m2 /= 2, y3 /= 2;
  return new j3({ size: [o5, o5], dpi: i2, format: t2 || "pbf", origin: u3, lods: h3, spatialReference: a7 });
}

// node_modules/@arcgis/core/layers/VectorTileLayer.js
var B = class extends a5(t(p2(l3(c(j2(o2(i(O(b2))))))))) {
  constructor(...e4) {
    super(...e4), this._spriteSourceMap = /* @__PURE__ */ new Map(), this.currentStyleInfo = null, this.style = null, this.isReference = null, this.operationalLayerType = "VectorTileLayer", this.tilemapCache = null, this.type = "vector-tile", this.url = null, this.showCollisionBoxes = "none", this.path = null;
  }
  normalizeCtorArgs(e4, t2) {
    return "string" == typeof e4 ? { url: e4, ...t2 } : e4;
  }
  destroy() {
    var _a;
    if (this.sourceNameToSource)
      for (const e4 of Object.values(this.sourceNameToSource))
        e4 == null ? void 0 : e4.destroy();
    (_a = this.primarySource) == null ? void 0 : _a.destroy(), this._spriteSourceMap.clear();
  }
  async prefetchResources(e4) {
    await this.loadSpriteSource(globalThis.devicePixelRatio || 1, e4);
  }
  load(e4) {
    const r4 = this.loadFromPortal({ supportedTypes: ["Vector Tile Service"], supportsData: false }, e4).catch(f).then(async () => {
      if (!this.portalItem || !this.portalItem.id)
        return;
      const r5 = `${this.portalItem.itemCdnUrl}/resources/styles/root.json`;
      (await j(r5, { ...e4, query: { f: "json", ...this.customParameters, token: this.apiKey } })).data && this.read({ url: r5 }, e2(this.portalItem));
    }).catch(f).then(() => this._loadStyle(e4));
    return this.addResolvingPromise(r4), Promise.resolve(this);
  }
  get attributionDataUrl() {
    const e4 = this.currentStyleInfo, t2 = e4 && e4.serviceUrl && L(e4.serviceUrl);
    if (!t2)
      return null;
    const r4 = this._getDefaultAttribution(t2.path);
    return r4 ? kt(r4, { ...this.customParameters, token: this.apiKey }) : null;
  }
  get capabilities() {
    const e4 = this.primarySource;
    return e4 ? e4.capabilities : { operations: { supportsExportTiles: false, supportsTileMap: false }, exportTiles: null };
  }
  get fullExtent() {
    var _a;
    return ((_a = this.primarySource) == null ? void 0 : _a.fullExtent) || null;
  }
  get parsedUrl() {
    return this.serviceUrl ? L(this.serviceUrl) : null;
  }
  get serviceUrl() {
    return this.currentStyleInfo && this.currentStyleInfo.serviceUrl || null;
  }
  get spatialReference() {
    var _a;
    return ((_a = this.tileInfo) == null ? void 0 : _a.spatialReference) ?? null;
  }
  get styleUrl() {
    return this.currentStyleInfo && this.currentStyleInfo.styleUrl || null;
  }
  writeStyleUrl(e4, t2) {
    e4 && at(e4) && (e4 = `https:${e4}`);
    const r4 = a4(e4);
    t2.styleUrl = d3(e4, r4);
  }
  get tileInfo() {
    var _a;
    const e4 = [];
    for (const r4 in this.sourceNameToSource)
      e4.push(this.sourceNameToSource[r4]);
    let t2 = ((_a = this.primarySource) == null ? void 0 : _a.tileInfo) || new j3();
    if (e4.length > 1)
      for (let r4 = 0; r4 < e4.length; r4++)
        r3(t2, e4[r4].tileInfo) && (t2 = o4(t2, e4[r4].tileInfo));
    return t2;
  }
  readTilemapCache(e4, t2) {
    var _a;
    const r4 = (_a = t2.capabilities) == null ? void 0 : _a.includes("Tilemap");
    return r4 ? new T({ layer: this }) : null;
  }
  readVersion(e4, t2) {
    return t2.version ? parseFloat(t2.version) : parseFloat(t2.currentVersion);
  }
  async loadSpriteSource(e4 = 1, t2) {
    var _a, _b;
    if (!this._spriteSourceMap.has(e4)) {
      const r4 = n2("2d").maxTextureSize, i2 = ((_a = this.currentStyleInfo) == null ? void 0 : _a.spriteUrl) ? kt(this.currentStyleInfo.spriteUrl, { ...this.customParameters, token: this.apiKey }) : null, o5 = new n3({ type: "url", spriteUrl: i2, pixelRatio: e4, spriteFormat: (_b = this.currentStyleInfo) == null ? void 0 : _b.spriteFormat }, r4);
      await o5.load(t2), this._spriteSourceMap.set(e4, o5);
    }
    return this._spriteSourceMap.get(e4);
  }
  async setSpriteSource(e4, t2) {
    if (!e4)
      return null;
    const r4 = n2("2d").maxTextureSize, i2 = e4.spriteUrl, o5 = i2 ? kt(i2, { ...this.customParameters, token: this.apiKey }) : null;
    if (!o5 && "url" === e4.type)
      return null;
    const s5 = new n3(e4, r4);
    try {
      await s5.load(t2);
      const r5 = e4.pixelRatio || 1;
      return this._spriteSourceMap.clear(), this._spriteSourceMap.set(r5, s5), o5 && this.currentStyleInfo && (this.currentStyleInfo.spriteUrl = o5), this.emit("spriteSource-change", { spriteSource: s5 }), s5;
    } catch (a7) {
      f(a7);
    }
    return null;
  }
  async loadStyle(e4, t2) {
    var _a;
    const i2 = e4 || this.style || this.url;
    return this._loadingTask && "string" == typeof i2 && this.url === i2 || ((_a = this._loadingTask) == null ? void 0 : _a.abort(), this._loadingTask = d2((e5) => (this._spriteSourceMap.clear(), this._getSourceAndStyle(i2, { signal: e5 })), t2)), this._loadingTask.promise;
  }
  getStyleLayerId(e4) {
    return this.styleRepository.getStyleLayerId(e4);
  }
  getStyleLayerIndex(e4) {
    return this.styleRepository.getStyleLayerIndex(e4);
  }
  getPaintProperties(e4) {
    return a(this.styleRepository.getPaintProperties(e4));
  }
  setPaintProperties(e4, t2) {
    const r4 = this.styleRepository.isPainterDataDriven(e4);
    this.styleRepository.setPaintProperties(e4, t2);
    const i2 = this.styleRepository.isPainterDataDriven(e4);
    this.emit("paint-change", { layer: e4, paint: t2, isDataDriven: r4 || i2 });
  }
  getStyleLayer(e4) {
    return a(this.styleRepository.getStyleLayer(e4));
  }
  setStyleLayer(e4, t2) {
    this.styleRepository.setStyleLayer(e4, t2), this.emit("style-layer-change", { layer: e4, index: t2 });
  }
  deleteStyleLayer(e4) {
    this.styleRepository.deleteStyleLayer(e4), this.emit("delete-style-layer", { layer: e4 });
  }
  getLayoutProperties(e4) {
    return a(this.styleRepository.getLayoutProperties(e4));
  }
  setLayoutProperties(e4, t2) {
    this.styleRepository.setLayoutProperties(e4, t2), this.emit("layout-change", { layer: e4, layout: t2 });
  }
  setStyleLayerVisibility(e4, t2) {
    this.styleRepository.setStyleLayerVisibility(e4, t2), this.emit("style-layer-visibility-change", { layer: e4, visibility: t2 });
  }
  getStyleLayerVisibility(e4) {
    return this.styleRepository.getStyleLayerVisibility(e4);
  }
  write(e4, t2) {
    return (t2 == null ? void 0 : t2.origin) && !this.styleUrl ? (t2.messages && t2.messages.push(new s2("vectortilelayer:unsupported", `VectorTileLayer (${this.title}, ${this.id}) with style defined by JSON only are not supported`, { layer: this })), null) : super.write(e4, t2);
  }
  getTileUrl(e4, t2, r4) {
    return null;
  }
  async _getSourceAndStyle(e4, t2) {
    if (!e4)
      throw new Error("invalid style!");
    const r4 = await f3(e4, { ...t2, query: { ...this.customParameters, token: this.apiKey } });
    if ("webp" === r4.spriteFormat) {
      await o3("lossy") || (r4.spriteFormat = "png");
    }
    this._set("currentStyleInfo", { ...r4 }), "string" == typeof e4 ? (this.url = e4, this.style = null) : (this.url = null, this.style = e4), this._set("sourceNameToSource", r4.sourceNameToSource), this._set("primarySource", r4.sourceNameToSource[r4.primarySourceName]), this._set("styleRepository", new l2(r4.style)), this.read(r4.layerDefinition, { origin: "service" }), this.emit("load-style");
  }
  _getDefaultAttribution(e4) {
    const t2 = e4.match(/^https?:\/\/(?:basemaps|basemapsbeta|basemapsdev)(?:-api)?\.arcgis\.com(\/[^\/]+)?\/arcgis\/rest\/services\/([^\/]+(\/[^\/]+)*)\/vectortileserver/i), r4 = ["OpenStreetMap_v2", "OpenStreetMap_Daylight_v2", "OpenStreetMap_Export_v2", "OpenStreetMap_FTS_v2", "OpenStreetMap_GCS_v2", "World_Basemap", "World_Basemap_v2", "World_Basemap_Export_v2", "World_Basemap_GCS_v2", "World_Basemap_WGS84", "World_Contours_v2"];
    if (!t2)
      return;
    const i2 = t2[2] && t2[2].toLowerCase();
    if (!i2)
      return;
    const o5 = t2[1] || "";
    for (const s5 of r4)
      if (s5.toLowerCase().includes(i2))
        return K(`//static.arcgis.com/attribution/Vector${o5}/${s5}`);
  }
  async _loadStyle(e4) {
    var _a;
    return ((_a = this._loadingTask) == null ? void 0 : _a.promise) ?? this.loadStyle(null, e4);
  }
};
e([y({ readOnly: true })], B.prototype, "attributionDataUrl", null), e([y({ type: ["show", "hide"] })], B.prototype, "listMode", void 0), e([y({ json: { read: true, write: true } })], B.prototype, "blendMode", void 0), e([y({ readOnly: true, json: { read: false } })], B.prototype, "capabilities", null), e([y({ readOnly: true })], B.prototype, "currentStyleInfo", void 0), e([y({ json: { read: false }, readOnly: true, type: M })], B.prototype, "fullExtent", null), e([y()], B.prototype, "style", void 0), e([y({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], B.prototype, "isReference", void 0), e([y({ type: ["VectorTileLayer"] })], B.prototype, "operationalLayerType", void 0), e([y({ readOnly: true })], B.prototype, "parsedUrl", null), e([y({ readOnly: true })], B.prototype, "serviceUrl", null), e([y({ type: f2, readOnly: true })], B.prototype, "spatialReference", null), e([y({ readOnly: true })], B.prototype, "styleRepository", void 0), e([y({ readOnly: true })], B.prototype, "sourceNameToSource", void 0), e([y({ readOnly: true })], B.prototype, "primarySource", void 0), e([y({ type: String, readOnly: true, json: { write: { ignoreOrigin: true }, origins: { "web-document": { write: { ignoreOrigin: true, isRequired: true } } } } })], B.prototype, "styleUrl", null), e([r2(["portal-item", "web-document"], "styleUrl")], B.prototype, "writeStyleUrl", null), e([y({ json: { read: false, origins: { service: { read: false } } }, readOnly: true, type: j3 })], B.prototype, "tileInfo", null), e([y()], B.prototype, "tilemapCache", void 0), e([o("service", "tilemapCache", ["capabilities", "tileInfo"])], B.prototype, "readTilemapCache", null), e([y({ json: { read: false }, readOnly: true, value: "vector-tile" })], B.prototype, "type", void 0), e([y({ json: { origins: { "web-document": { read: { source: "styleUrl" } }, "portal-item": { read: { source: "url" } } }, write: false, read: false } })], B.prototype, "url", void 0), e([y({ readOnly: true })], B.prototype, "version", void 0), e([o("version", ["version", "currentVersion"])], B.prototype, "readVersion", null), e([y({ type: String })], B.prototype, "showCollisionBoxes", void 0), e([y({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], B.prototype, "path", void 0), B = e([a3("esri.layers.VectorTileLayer")], B);
var E = B;
export {
  E as default
};
//# sourceMappingURL=VectorTileLayer-2CQXAZPM.js.map
