import {
  A,
  L as L2,
  L2 as L3,
  S,
  c as c3,
  e3 as e6,
  i2,
  i3,
  m as m2,
  n3 as n8,
  s2 as s4,
  s3 as s5,
  t as t3
} from "./chunk-YOWAMJJI.js";
import {
  K
} from "./chunk-6WY3ZZYN.js";
import {
  c
} from "./chunk-CS6BZGQO.js";
import {
  e as e7
} from "./chunk-XXN3TEOU.js";
import {
  n as n7
} from "./chunk-FIJZ6LYC.js";
import {
  c as c2
} from "./chunk-DBIFU6GO.js";
import {
  T,
  e2 as e5
} from "./chunk-TRGMWULG.js";
import {
  e as e4
} from "./chunk-SMDDCTGQ.js";
import {
  d as d2
} from "./chunk-VC3BY3DV.js";
import {
  p
} from "./chunk-67BT7WH5.js";
import {
  H
} from "./chunk-Z7LZRT7C.js";
import {
  D,
  L
} from "./chunk-BCDDCNQ2.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  n as n5,
  r as r3
} from "./chunk-YGUWDSEH.js";
import {
  C,
  I,
  g
} from "./chunk-KRCNIFX2.js";
import {
  n as n6
} from "./chunk-SS3YG6J3.js";
import {
  o as o3
} from "./chunk-JNDFAMXY.js";
import {
  E,
  N,
  i
} from "./chunk-AQ7R6V4L.js";
import {
  _,
  a as a2
} from "./chunk-SVCGLUNW.js";
import {
  o as o2,
  s as s3
} from "./chunk-TPJLFGOT.js";
import {
  n as n3,
  r
} from "./chunk-CQX57DED.js";
import {
  r2
} from "./chunk-3CQBBMMD.js";
import {
  l as l2
} from "./chunk-H7RDAEPY.js";
import {
  n as n4
} from "./chunk-7KH4CLS5.js";
import {
  e2 as e3,
  m,
  t2,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  n as n2
} from "./chunk-3R7FAT25.js";
import {
  d,
  s as s2
} from "./chunk-7I33FAWS.js";
import {
  e as e2,
  l,
  n,
  o,
  t
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/graphicSymbolUtils.js
function i4(i5) {
  return i5 instanceof i3 ? i5.graphics3DSymbol : i5 instanceof m2 ? i5 : null;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/labelPlacement.js
var p2 = s.getLogger("esri.views.3d.layers.graphics.labelPlacement");
function h(e8) {
  const t5 = D2(e8);
  if (null == t5)
    return null;
  const r4 = b(e8, t5);
  if (null == r4)
    return null;
  const l3 = r4.anchor, a3 = !!t5.hasLabelVerticalOffset;
  return y2({ anchor: l3, verticalOffset: t5.verticalOffset, screenOffset: n6(), centerOffset: r3(0, 0, 0, -1), centerOffsetUnits: "world", translation: n3(), elevationOffset: 0, hasLabelVerticalOffset: a3 }, r4, e8);
}
function b(e8, t5) {
  if (t5.anchor)
    return t5;
  const n9 = e8.labelClass.labelPlacement, r4 = C2[n9], l3 = r4 || v(e8);
  return n9 && !r4 && p2.warnOncePerTick(`the requested label placement '${n9}' is currently unsupported in SceneView.`), O2(l3, e8);
}
function g2(e8) {
  const t5 = e8.graphics3DGraphic.graphics3DSymbol, n9 = i4(t5);
  return null != n9 ? n9.symbol.symbolLayers.at(0) : null;
}
function O2(e8, t5) {
  const n9 = t5.graphics3DGraphic.graphic.geometry;
  if (null == n9)
    return null;
  if (null != t5.disablePlacement) {
    return t5.labelClass.labelPlacement ? (p2.warnOncePerTick(d3(e8 == null ? void 0 : e8.placement, t5.disablePlacement.logEntityDescription)), v(t5)) : e8;
  }
  const r4 = n9.type;
  switch (r4) {
    case "polyline":
    case "polygon":
    case "extent":
    case "multipoint":
      if (t5.labelClass.labelPlacement)
        return p2.warnOncePerTick(d3(e8 == null ? void 0 : e8.placement, `'${r4}' geometries`)), v(t5);
      break;
    case "point":
    case "mesh":
      return e8;
  }
  return e8;
}
function d3(e8, t5) {
  return `the requested label placement '${e8}' is currently unsupported for ${t5} in SceneView.`;
}
function v(e8) {
  const t5 = e8.graphics3DGraphic.graphic.geometry;
  if (null == t5)
    return null;
  switch (t5.type) {
    case "polyline":
    case "extent":
    case "multipoint":
      return { placement: "center-center", normalizedOffset: null, anchor: "center" };
    case "polygon": {
      const t6 = g2(e8);
      return null != t6 && "extrude" === t6.type ? C2["above-center"] : { placement: "center-center", normalizedOffset: null, anchor: "center" };
    }
    case "point":
    case "mesh":
      return C2["above-center"];
    default:
      return;
  }
}
function y2(e8, t5, n9) {
  const r4 = n9.graphics3DGraphic.graphic.geometry;
  if (null == r4)
    return null;
  switch (r4.type) {
    case "point":
      w(e8, t5, n9);
      break;
    case "polygon":
      P(e8, t5, n9);
      break;
    case "mesh":
      j(e8, t5, n9.graphics3DGraphic.layers[0]);
  }
  return e8;
}
function P(e8, t5, n9) {
  const l3 = g2(n9);
  if (null != l3)
    switch (l3.type) {
      case "extrude": {
        const l4 = n9.graphics3DGraphic.layers[0];
        null != l4 ? (l4.getBoundingBoxObjectSpace(G), E(G, e8.translation), e8.translation[2] = N(G) / 2) : o2(e8.translation, 0, 0, 0), j(e8, t5, l4);
        break;
      }
    }
}
function w(e8, t5, n9) {
  const l3 = g2(n9);
  if (null == l3)
    return;
  const a3 = n9.graphics3DGraphic.layers[0];
  switch (null != a3 ? a3.getCenterObjectSpace(e8.translation) : o2(e8.translation, 0, 0, 0), l3.type) {
    case "icon":
    case "text":
      L4(e8, t5, n9, a3);
      break;
    case "object":
      j(e8, t5, a3);
  }
}
function L4(e8, t5, n9, r4) {
  const { graphics3DGraphic: l3 } = n9, a3 = null != r4 ? r4.getScreenSize() : null;
  if (l3.isDraped || null == a3)
    e8.hasLabelVerticalOffset || "center" === e8.anchor || (C2[n9.labelClass.labelPlacement] && p2.warnOncePerTick(`the requested placement '${t5.placement}' is currently unsupported for draped graphics`), e8.anchor = "center");
  else {
    const r5 = z(n9);
    e8.screenOffset[0] = a3[0] / 2 * (t5.normalizedOffset[0] - r5[0]);
    const l4 = a3[1] / 2 * (t5.normalizedOffset[1] - r5[1]);
    e8.hasLabelVerticalOffset ? (e8.centerOffset[1] = l4, e8.centerOffsetUnits = "screen") : e8.screenOffset[1] = l4;
  }
}
function z(e8, t5 = x) {
  const { graphics3DGraphic: n9 } = e8, r4 = n9.layers[0], l3 = null != r4 ? r4.stageObject.geometries[0].material : null;
  if (l3 && l3 instanceof K) {
    const e9 = l3.parameters.anchorPosition;
    t5[0] = 2 * (e9[0] - 0.5), t5[1] = 2 * (e9[1] - 0.5);
  } else
    t5[0] = 0, t5[1] = 0;
  return t5;
}
function j(e8, t5, n9) {
  const r4 = null != n9 ? n9.getBoundingBoxObjectSpace(G) : G, c5 = r(r4[3] - r4[0], r4[4] - r4[1], r4[5] - r4[2]), o5 = Math.sqrt(c5[0] * c5[0] + c5[1] * c5[1]);
  e8.centerOffset[0] = o5 / 2 * t5.normalizedOffset[0];
  const s7 = e8.translation[2], i5 = c5[2] / 2 * t5.normalizedOffset[1];
  e8.translation[2] = 0, e8.elevationOffset = s7 + i5;
  const f = s3(c5);
  e8.centerOffset[2] = f / 2 * t5.normalizedOffset[2];
}
function S2(e8) {
  return "above-center" === e8;
}
function D2(e8) {
  const n9 = e8.labelClass.labelPlacement, { labelSymbol: r4, graphics3DGraphic: l3 } = e8, a3 = i4(l3.graphics3DSymbol), c5 = n(a3, (e9) => "point-3d" === e9.symbol.type ? e9.symbol : null), o5 = C2[n9] || v(e8);
  return null != c5 && c5.supportsCallout() && c5.hasVisibleVerticalOffset() && !l3.isDraped ? { placement: null, hasLabelVerticalOffset: false, verticalOffset: k(c5.verticalOffset), anchor: null, normalizedOffset: null } : !r4 || !r4.hasVisibleVerticalOffset() || null != c5 && c5.supportsCallout() && c5.verticalOffset && !l3.isDraped ? { placement: null, verticalOffset: null, anchor: null, normalizedOffset: null, hasLabelVerticalOffset: false } : o5 && S2(o5.placement) ? { placement: "above-center", verticalOffset: k(r4.verticalOffset), anchor: "bottom", normalizedOffset: [0, o5.normalizedOffset[1], 0], hasLabelVerticalOffset: true } : (p2.errorOncePerTick("Callouts and vertical offset on labels are currently only supported with 'above-center' label placement (not with " + n9 + " placement)"), null);
}
function k(e8) {
  const { screenLength: t5, minWorldLength: n9, maxWorldLength: r4 } = e8;
  return { screenLength: t5, minWorldLength: n9, maxWorldLength: r4 };
}
var C2 = { "above-center": { placement: "above-center", normalizedOffset: [0, 1, 0], anchor: "bottom" }, "above-left": { placement: "above-left", normalizedOffset: [-1, 1, 0], anchor: "bottom-right" }, "above-right": { placement: "above-right", normalizedOffset: [1, 1, 0], anchor: "bottom-left" }, "below-center": { placement: "below-center", normalizedOffset: [0, -1, 2], anchor: "top" }, "below-left": { placement: "below-left", normalizedOffset: [-1, -1, 0], anchor: "top-right" }, "below-right": { placement: "below-right", normalizedOffset: [1, -1, 0], anchor: "top-left" }, "center-center": { placement: "center-center", normalizedOffset: [0, 0, 1], anchor: "center" }, "center-left": { placement: "center-left", normalizedOffset: [-1, 0, 0], anchor: "right" }, "center-right": { placement: "center-right", normalizedOffset: [1, 0, 0], anchor: "left" } };
var V = { "above-center": ["default", "esriServerPointLabelPlacementAboveCenter"], "above-left": ["esriServerPointLabelPlacementAboveLeft"], "above-right": ["esriServerPointLabelPlacementAboveRight"], "below-center": ["esriServerPointLabelPlacementBelowCenter"], "below-left": ["esriServerPointLabelPlacementBelowLeft"], "below-right": ["esriServerPointLabelPlacementBelowRight"], "center-center": ["esriServerPointLabelPlacementCenterCenter"], "center-left": ["esriServerPointLabelPlacementCenterLeft"], "center-right": ["esriServerPointLabelPlacementCenterRight"] };
for (const B2 in V) {
  const e8 = V[B2], t5 = C2[B2];
  e8.forEach((e9) => {
    C2[e9] = t5;
  });
}
Object.freeze && (Object.freeze(C2), Object.keys(C2).forEach((e8) => {
  var _a;
  Object.freeze(C2[e8]), Object.freeze((_a = C2[e8]) == null ? void 0 : _a.normalizedOffset);
}));
var x = [0, 0];
var G = i();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/MaterialCollection.js
var s6 = class {
  constructor(s7) {
    this._stage = s7, this._materials = /* @__PURE__ */ new Map();
  }
  get(s7) {
    return this._materials.get(s7);
  }
  add(s7, t5) {
    this._materials.set(s7, t5), this._stage.add(t5);
  }
  dispose() {
    this._stage.removeMany(Array.from(this._materials.values())), this._materials.clear();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextTextureAtlas.js
var y3 = 4096;
var R = class {
  constructor() {
    this.offset = { x: 0, y: 0 }, this.uvMinMax = n5();
  }
};
var j2 = class {
  constructor(e8, t5) {
    this.textId = e8, this.textRenderer = t5, this.placement = new R(), this.rendered = false;
  }
};
var z2 = class {
  constructor(e8, t5, s7) {
    this.size = e8, this.cursor = t5, this.lineHeight = s7;
  }
  resize(e8) {
    this.size.height = e8;
  }
  resetCursor() {
    this.cursor.x = O3, this.cursor.y = O3 + w2, this.lineHeight = 0;
  }
  getUsage() {
    return (this.cursor.x + this.cursor.y * this.size.width) / (this.size.width * this.size.height);
  }
};
var b2 = class extends m {
  constructor(e8) {
    super(e8), this.type = e4.Texture, this.id = e3(), this.events = new n4(), this._glTexture = null, this._needsClear = false, this._elementsToAddOrUpdate = /* @__PURE__ */ new Map(), this._elementsToRemove = /* @__PURE__ */ new Map(), this._elementsToRender = /* @__PURE__ */ new Map(), this._elements = /* @__PURE__ */ new Map(), this._stageObjects = /* @__PURE__ */ new Map(), this.updating = false;
  }
  initialize() {
    this._canvas = document.createElement("canvas"), this._canvas.setAttribute("id", "textAtlasCanvas"), this._canvas.setAttribute("style", "display:none"), this._ctx = this._canvas.getContext("2d"), this._stage = this.view._stage, this._stage.add(this), this._atlas = new z2({ width: y3, height: 256 }, { x: 0, y: 0 }, 0), this._updateCanvasElementSize(this._atlas), this._resetAtlasCursor();
  }
  unload() {
    this._glTexture = t(this._glTexture), this.updating = false, this.events.emit("unloaded");
  }
  get requiresFrameUpdates() {
    return false;
  }
  _createDescriptor(e8) {
    const t5 = new e5();
    return t5.wrapMode = D.CLAMP_TO_EDGE, t5.flipped = true, t5.samplingMode = L.LINEAR_MIPMAP_LINEAR, t5.hasMipmap = true, t5.preMultiplyAlpha = true, t5.maxAnisotropy = e8.parameters.maxMaxAnisotropy, t5;
  }
  get glTexture() {
    return this._glTexture;
  }
  load(e8) {
    return null != this._glTexture || (this._glTexture = new T(e8, this._createDescriptor(e8), this._canvas), this._frameWorker = this.view.resourceController.scheduler.registerTask(I.TEXT_TEXTURE_ATLAS, this), this.setDirty()), this._glTexture;
  }
  dispose() {
    this._elements = null, this._elementsToAddOrUpdate = null, this._elementsToRemove = null, this._elementsToRender = null, this._frameWorker = o(this._frameWorker), this._glTexture && (this._stage.remove(this), this._glTexture = t(this._glTexture)), this._canvas.width = 0, this._canvas.height = 0, this._canvas = null, this._ctx = null;
  }
  _updateCanvasElementSize(e8) {
    this._canvas.setAttribute("width", e8.size.width.toString()), this._canvas.setAttribute("height", e8.size.height.toString());
  }
  _resizeAtlas(e8) {
    this._atlas.resize(e8), null != this._glTexture && this._glTexture.resize(this._atlas.size.width, e8), this._updateCanvasElementSize(this._atlas);
  }
  _resetAtlasCursor() {
    this._atlas.resetCursor(), this._needsClear = true;
  }
  _addAtlasElement(e8, t5, s7, r4) {
    const i5 = this._atlas, { renderedWidth: n9, renderedHeight: a3 } = e8.textRenderer;
    e8.placement.offset.x = i5.cursor.x, e8.placement.offset.y = i5.cursor.y, r2(e8.placement.uvMinMax, e8.placement.offset.x / i5.size.width, 1 - (e8.placement.offset.y + a3) / i5.size.height, (e8.placement.offset.x + n9) / i5.size.width, 1 - e8.placement.offset.y / i5.size.height), i5.cursor.x += s7, i5.lineHeight = Math.max(i5.lineHeight, r4), this._elements.set(t5, e8);
  }
  _removeAtlasElement(e8) {
    if (e8 && this._elements.has(e8.textId)) {
      const t5 = e8.placement.offset;
      this._ctx.clearRect(t5.x, t5.y, e8.textRenderer.renderedWidth, e8.textRenderer.renderedHeight), this._elements.delete(e8.textId);
    }
  }
  _ensureStageObjects(e8) {
    const t5 = this._stageObjects.get(e8);
    if (t5)
      return t5;
    const s7 = /* @__PURE__ */ new Set();
    return this._stageObjects.set(e8, s7), s7;
  }
  _addStageObject(e8, t5) {
    this._ensureStageObjects(e8).add(t5);
  }
  _removeStageObject(e8, t5) {
    const s7 = this._stageObjects.get(e8);
    s7 && s7.delete(t5) && (t5.geometries[0].setAttributeData(O.SIZE, [0, 0]), t5.geometryVertexAttrsUpdated(t5.geometries[0]));
  }
  _processAddition(e8, t5) {
    const s7 = this._atlas, r4 = e8.textId, i5 = e8.textRenderer.renderedWidth, n9 = e8.textRenderer.renderedHeight, a3 = i5 + O3, h2 = n9 + O3 + w2;
    if (s7.cursor.x + a3 < s7.size.width && s7.cursor.y + h2 < s7.size.height)
      this._addAtlasElement(e8, r4, a3, h2), this._elementsToRender.set(r4, e8), this._elementsToAddOrUpdate.delete(r4);
    else {
      if (!(s7.cursor.y + h2 + s7.lineHeight < s7.size.height)) {
        const e9 = s7.cursor.y + h2 + s7.lineHeight - s7.size.height, r5 = s7.size.height + e9 < y3;
        if (r5) {
          const t6 = Math.ceil(s7.size.height * Math.max(1.3, (e9 + s7.size.height) / s7.size.height));
          this._resizeAtlas(Math.min(n7(t6), y3));
        }
        return !t5 || !r5 && s7.size.height === y3 ? (this._processRemovals(), E2.OK) : (this._repack(), E2.REPACK);
      }
      s7.cursor.x = O3, s7.cursor.y += s7.lineHeight, s7.lineHeight = 0, this._addAtlasElement(e8, r4, a3, h2), this._elementsToRender.set(r4, e8), this._elementsToAddOrUpdate.delete(r4);
    }
    return E2.OK;
  }
  _processRemovals() {
    this._elementsToRemove.forEach((e8, t5) => {
      const s7 = this._stageObjects.get(t5);
      s7 && 0 !== s7.size || this._removeAtlasElement(e8), s7 && 0 === s7.size && this._stageObjects.delete(t5);
    }), this._elementsToRemove.clear();
  }
  _repack() {
    this._processRemovals(), this._elements.forEach((e8, t5) => {
      e8.rendered = false, this._elementsToAddOrUpdate.set(t5, e8);
    }), this._elements.clear(), this._resetAtlasCursor(), this._elementsToRender.clear();
  }
  _processRenderingRequest(e8) {
    this._ctx.clearRect(e8.placement.offset.x, e8.placement.offset.y, e8.textRenderer.renderedWidth, e8.textRenderer.renderedHeight), e8.textRenderer.render(this._ctx, e8.placement.offset.x, e8.placement.offset.y);
    const t5 = this._stageObjects.get(e8.textId);
    t5 && t5.forEach((t6) => {
      t6.geometries[0].setAttributeData(O.UV0, e8.placement.uvMinMax), t6.geometries[0].setAttributeData(O.SIZE, [e8.textRenderer.displayWidth, e8.textRenderer.displayHeight]), t6.geometryVertexAttrsUpdated(t6.geometries[0]);
    }), e8.rendered = true;
  }
  get running() {
    return this.updating;
  }
  runTask(e8, t5 = true) {
    if (null == this._glTexture)
      return g.YIELD;
    let s7 = false;
    if (n2(this._elementsToAddOrUpdate, (r4, i6) => {
      const n9 = this._elements.get(i6);
      if (n9 == null ? void 0 : n9.rendered) {
        const t6 = this._stageObjects.get(i6);
        return t6 && t6.forEach((e9) => {
          const t7 = e9.geometries[0], s8 = this._elements.get(i6);
          t7.setAttributeData(O.UV0, s8.placement.uvMinMax), t7.setAttributeData(O.SIZE, [s8.textRenderer.displayWidth, s8.textRenderer.displayHeight]), e9.geometryVertexAttrsUpdated(e9.geometries[0]);
        }), this._elementsToAddOrUpdate.delete(i6), e8.madeProgress(), false;
      }
      return this._processAddition(this._elementsToAddOrUpdate.get(i6), t5) === E2.REPACK && (s7 = true, true);
    }), s7)
      return this.runTask(C, false), void e8.madeProgress();
    let i5 = false;
    this._elementsToRender.size > 0 && this._needsClear && (this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._needsClear = false), n2(this._elementsToRender, (t6, s8) => (this._processRenderingRequest(t6), this._elementsToRender.delete(s8), i5 = true, e8.madeProgress(), e8.done)), i5 && this._glTexture.setData(this._canvas), this.updating = this._elementsToRender.size > 0, !this.updating && e7.orderedRepackingEnabled && (this.repackOrdered(), e8.madeProgress());
  }
  addTextTexture(e8, t5) {
    const s7 = e8.key;
    this._elementsToAddOrUpdate.has(s7) || this._elementsToAddOrUpdate.set(s7, new j2(s7, e8)), this._addStageObject(s7, t5), this._elementsToRemove.delete(s7), this.setDirty();
  }
  removeTextTexture(e8, t5) {
    const s7 = e8.key;
    this._elementsToRemove.set(s7, this._elements.get(s7)), this._removeStageObject(s7, t5);
  }
  setDirty() {
    this._glTexture && (this.updating = true);
  }
  repackOrdered() {
    if (0 === this._elements.size)
      return;
    const e8 = [];
    this._elements.forEach((t6, s7) => e8.push({ element: t6, key: s7 }));
    let t5 = true;
    for (let s7 = 0; s7 < e8.length - 1; s7++)
      if (e8[s7].key.localeCompare(e8[s7 + 1].key) > 0) {
        t5 = false;
        break;
      }
    if (!t5 || this._elementsToRemove.size) {
      e8.sort((e9, t6) => e9.key.localeCompare(t6.key)), this._elements.clear();
      for (const { element: t6, key: s7 } of e8)
        this._elements.set(s7, t6);
      this._repack(), this.setDirty();
    }
  }
  get test() {
    const { _elements: e8, _stageObjects: t5, _elementsToRemove: s7, _atlas: r4 } = this, i5 = this;
    return { elements: e8, stageObjects: t5, elementsToRemove: s7, atlas: r4, resizeAtlas: (e9) => i5._resizeAtlas(e9), run: (e9, t6) => i5.runTask(e9, t6) };
  }
};
e([y({ constructOnly: true })], b2.prototype, "view", void 0), e([y({ type: Boolean })], b2.prototype, "updating", void 0), b2 = e([a("esri.views.3d.webgl-engine.lib.TextTextureAtlas")], b2);
var O3 = 2;
var w2 = 2;
var E2;
!function(e8) {
  e8[e8.OK = 0] = "OK", e8[e8.REPACK = 1] = "REPACK";
}(E2 || (E2 = {}));

// node_modules/@arcgis/core/views/3d/layers/graphics/Labeler.js
var z3 = class {
  constructor(e8, t5) {
    this.labelingContext = e8, this.graphics3DGraphic = t5, this.hasGraphics3DResources = false, this.visible = false, this.rendered = false, this.textInitialized = false, this.textRenderers = new Array(), this.textLabelPlacements = new Array();
  }
};
var M = class {
  constructor(e8, t5, s7, l3, i5) {
    this.labelClass = e8, this.graphics3DSymbol = t5, this.graphics3DCalloutSymbolLayer = s7, this.textRenderParameters = l3, this.labelFunction = i5, this.calloutSymbolLayerIndex = 0;
  }
};
var V2 = class {
  constructor(e8, t5, s7, l3, i5, a3, r4, o5) {
    this.layer = t5, this.graphics3DCore = s7, this.scaleVisibility = l3, this.emptySymbolLabelSupported = i5, this.elevationInfoOverride = a3, this.disablePlacement = r4, this.active = o5, this.labelClassAbortController = new AbortController(), this.labelClassContexts = new Array(), this.graphics = /* @__PURE__ */ new Map(), this.labelsToInitialize = /* @__PURE__ */ new Map(), this.stageLayer = new c2(e8, { pickable: true, disableOctree: true }, t5.uid);
  }
  destroy() {
    this.stageLayer.destroy();
  }
};
var F = class extends m {
  constructor(e8) {
    super(e8), this._dirty = false, this._labels = /* @__PURE__ */ new Map(), this._labelsToAdd = /* @__PURE__ */ new Map(), this._labelsToRemove = /* @__PURE__ */ new Map(), this._labelingContexts = new Array();
  }
  setup() {
    this.dispose(), this._handles = new t2(), this._handles.add([l2(() => {
      var _a;
      return (_a = this.view.state) == null ? void 0 : _a.camera;
    }, () => this.setDirty()), l2(() => {
      var _a;
      return (_a = this.view.state) == null ? void 0 : _a.rasterPixelRatio;
    }, () => this._resetAllLabels()), this.view.resourceController.scheduler.registerTask(I.LABELER, this)]), this._textTextureAtlas = new b2({ view: this.view }), this._hudMaterialCollection = new s6(this.view._stage), this._calloutMaterialCollection = new s6(this.view._stage);
  }
  dispose() {
    this._handles = l(this._handles), this._textTextureAtlas = t(this._textTextureAtlas), this._hudMaterialCollection = t(this._hudMaterialCollection), this._calloutMaterialCollection = t(this._calloutMaterialCollection), this._labelingContexts.length = 0, this._labels.clear(), this._labelsToAdd.clear(), this._labelsToRemove.clear();
  }
  destroy() {
    this.dispose(), N2.graphic = null, N2.renderingInfo = null, N2.layer = null;
  }
  _activateLabelingContext(e8) {
    e8.graphics.forEach((t5, s7) => {
      const l3 = new z3(e8, t5);
      this._labels.set(s7, l3), e8.labelsToInitialize.set(s7, l3), t5.setVisibilityFlag(A.LABEL, L2.USER, true);
    }), e8.active = true;
  }
  _deactivateLabelingContext(e8) {
    e8.graphics.forEach((e9, t5) => {
      e9.setVisibilityFlag(A.LABEL, L2.USER, false), this.setLabelGraphicVisibility(e9, false), this._labels.delete(t5);
    }), e8.active = false;
  }
  _addLabelTextureToAtlas(e8) {
    for (const t5 of e8.graphics3DGraphic.labelLayers) {
      if (!t5._labelClass)
        continue;
      const s7 = e8.textRenderers[t5._labelIndex];
      s7 && this._textTextureAtlas.addTextTexture(s7, t5.stageObject);
    }
    e8.rendered = true;
  }
  _removeLabelTextureFromAtlas(e8) {
    for (const t5 of e8.graphics3DGraphic.labelLayers) {
      if (!t5._labelClass)
        continue;
      const s7 = e8.textRenderers[t5._labelIndex];
      null != s7 && this._textTextureAtlas.removeTextTexture(s7, t5.stageObject);
    }
    e8.rendered = false;
  }
  get running() {
    return this.view.ready && (this._dirty || this.deconflictor.running);
  }
  runTask(e8) {
    return this._updateLabels(e8), !this._dirty && this.deconflictor.running && this.deconflictor.runTask(e8), g.YIELD;
  }
  _updateLabels(e8) {
    if (this._dirty) {
      this._dirty = false;
      for (const t5 of this._labelingContexts)
        if (t5.active) {
          if (!k2(t5)) {
            if (B(t5)) {
              this._deactivateLabelingContext(t5);
              continue;
            }
            if (this._createLabelClassContext(t5), U(t5)) {
              this._dirty = true;
              continue;
            }
            if (!k2(t5))
              continue;
          }
          n2(t5.labelsToInitialize, (s7, l3) => (this._ensureGraphics3DResources(s7) && (this._labels.set(l3, s7), this.deconflictor.setDirty(), e8.madeProgress()), (s7.visible && s7.textInitialized || !s7.visible && s7.hasGraphics3DResources) && (t5.labelsToInitialize.delete(l3), e8.madeProgress()), e8.done)) && (this._dirty = true);
        }
      this._labelsToRemove.forEach((e9) => this._removeLabelTextureFromAtlas(e9)), this._labelsToAdd.forEach((e9) => this._addLabelTextureToAtlas(e9)), this._labelsToRemove.clear(), this._labelsToAdd.clear(), this._dirty || this.notifyChange("updating");
    }
  }
  async _createLabelClassContextAsync(e8) {
    var _a, _b, _c;
    const t5 = (_a = e8.labelClassAbortController) == null ? void 0 : _a.signal;
    await ((_c = (_b = e8.layer).when) == null ? void 0 : _c.call(_b)), s2(t5), e8.scaleVisibility && e8.scaleVisibility.updateScaleRangeActive();
    const i5 = e8.graphics3DCore, r4 = i5.layer, o5 = r4.labelingInfo && r4.labelingInfo.filter((e9) => !!e9.symbol);
    if (!o5 || 0 === o5.length)
      return;
    let n9 = false;
    await a2(o5, async (s7, r5) => {
      const o6 = s7.symbol, c5 = i4(i5.getOrCreateGraphics3DSymbol(o6));
      if (null == c5)
        return void s.getLogger(this).error("Failed to create Graphics3DSymbol for label");
      await c5.load(), s2(t5);
      let b3 = null;
      o3(o6) && o6.hasVisibleCallout() && (b3 = e6(o6, i5.symbolCreationContext), await b3.load(), s2(t5));
      const d4 = await _(p(s7, e8.layer.fieldsIndex, this.view.spatialReference));
      if (s2(t5), true === d4.ok) {
        const l3 = await this._createTextRenderParameters(c5.symbol);
        s2(t5), e8.labelClassContexts[r5] = new M(s7, c5, b3, l3, d4.value);
      } else
        s.getLogger(this).error(`Label expression failed to evaluate: ${d4.error}`), n9 = true;
    }), s2(t5);
  }
  async _createLabelClassContext(e8) {
    return null == e8.labelClassPromise && (e8.labelClassPromise = this._createLabelClassContextAsync(e8).catch((t5) => {
      if (d(t5))
        throw t5;
      e8.labelClassContexts.length = 0;
    }).then(() => {
      e8.labelClassAbortController = null, this.notifyChange("updating");
    }).catch(() => {
    }), this.notifyChange("updating")), e8.labelClassPromise;
  }
  async _createTextRenderParameters(e8) {
    const t5 = e8.symbolLayers.at(0);
    return "text" !== (t5 == null ? void 0 : t5.type) ? null : s5.fromSymbol(t5, this.view.state.rasterPixelRatio);
  }
  _destroyLabelClassContext(e8) {
    for (const s7 of e8.labelClassContexts)
      --s7.graphics3DSymbol.referenced;
    const t5 = e8.labelClassAbortController;
    e8.labelClassAbortController = new AbortController(), e2(t5), e8.labelClassContexts.length = 0, e8.labelClassPromise = null, this.notifyChange("updating");
  }
  _createTextSymbolGraphic(e8, t5, s7, l3, i5) {
    const a3 = new t3(s7.verticalOffset, n8(s7.anchor), s4(s7.anchor), e8.text, s7.translation, s7.elevationOffset, s7.centerOffset, s7.screenOffset, s7.centerOffsetUnits, e8.displayWidth, e8.displayHeight);
    return N2.graphic = t5, N2.renderingInfo = null, N2.layer = l3, i5.createLabel(N2, a3, this._hudMaterialCollection, this._textTextureAtlas);
  }
  _createLineCalloutGraphic(e8, t5, s7, l3, i5) {
    return N2.graphic = e8, N2.layer = i5, N2.renderingInfo = new L3(null, t5, l3.translation, l3.centerOffset, l3.screenOffset, l3.centerOffsetUnits, l3.elevationOffset, this._calloutMaterialCollection), s7.createGraphics3DGraphic(N2);
  }
  _ensureGraphics3DResources(e8) {
    var _a;
    if (e8.hasGraphics3DResources)
      return false;
    const t5 = e8.graphics3DGraphic;
    if (t5.destroyed)
      return false;
    this._ensureTextTextureResources(e8);
    const s7 = e8.labelingContext, l3 = s7.labelClassContexts;
    if (!l3 || 0 === l3.length || !s7.emptySymbolLabelSupported && 0 === t5.layers.length)
      return false;
    let i5 = false;
    const a3 = t5.graphic, r4 = s7.layer, o5 = H2(s7.layer);
    for (let n9 = 0; n9 < l3.length; n9++) {
      const c5 = e8.textRenderers[n9], h2 = e8.textLabelPlacements[n9];
      if (null == c5 || null == h2)
        continue;
      const b3 = l3[n9], d4 = b3.graphics3DSymbol, u = d4.symbol && "label-3d" === d4.symbol.type ? d4.symbol : null, p3 = d4.symbolLayers[0];
      if (!p3)
        continue;
      p3.setElevationInfoOverride(s7.elevationInfoOverride);
      const y4 = this._createTextSymbolGraphic(c5, a3, h2, r4, p3);
      if (null == y4)
        return false;
      y4._labelClass = b3.labelClass, y4._labelIndex = n9, t5.addLabelGraphic(y4, s7.stageLayer), t5.deconflictionPriority = ((_a = b3.textRenderParameters) == null ? void 0 : _a.definition.size) ?? 0, t5.setVisibilityFlag(A.LABEL, L2.USER, o5), t5.setVisibilityFlag(A.LABEL, L2.SCALE_RANGE, true), t5.setVisibilityFlag(A.LABEL, L2.DECONFLICTION, false), i5 = true;
      const g3 = b3.graphics3DCalloutSymbolLayer;
      if (g3 && h2.hasLabelVerticalOffset) {
        g3.setElevationInfoOverride(s7.elevationInfoOverride);
        const e9 = this._createLineCalloutGraphic(a3, u, g3, h2, r4);
        null != e9 && (b3.calloutSymbolLayerIndex = t5.labelLayers.length, t5.addLabelGraphic(e9, s7.stageLayer));
      }
      break;
    }
    return s7.scaleVisibility && i5 && s7.scaleVisibility.updateGraphicLabelScaleVisibility(t5), e8.hasGraphics3DResources = true, true;
  }
  _destroyGraphics3DResources(e8) {
    const t5 = e8.labelingContext.labelClassContexts;
    for (const s7 of e8.graphics3DGraphic.labelLayers) {
      if (null == s7._labelClass)
        continue;
      const e9 = t5[s7._labelIndex].graphics3DSymbol.symbolLayers[0];
      null != e9 && e9.onRemoveGraphic(s7);
    }
    e8.graphics3DGraphic.deconflictionPriority = 0, e8.graphics3DGraphic.clearLabelGraphics(), e8.hasGraphics3DResources = false;
  }
  _ensureTextTextureResources(e8) {
    var _a;
    if (e8.textInitialized)
      return;
    const t5 = e8.labelingContext, s7 = t5.labelClassContexts;
    if (!s7 || 0 === s7.length)
      return;
    const l3 = e8.graphics3DGraphic.graphic;
    for (let a3 = 0; a3 < s7.length; a3++) {
      const r4 = s7[a3];
      if (e8.textRenderers[a3] = null, e8.textLabelPlacements[a3] = null, null == (r4 == null ? void 0 : r4.textRenderParameters))
        continue;
      const o5 = r4.labelFunction;
      let n9;
      if ("arcade" === o5.type)
        try {
          const e9 = o5.needsHydrationToEvaluate() ? c(l3, t5.layer) : l3;
          n9 = o5.evaluate(e9);
        } catch (i5) {
          n9 = null;
        }
      else
        n9 = o5.evaluate(l3);
      if (null == n9 || "" === n9 || /^\s+$/.test(n9))
        continue;
      const c5 = r4.graphics3DSymbol, h2 = "label-3d" === ((_a = c5.symbol) == null ? void 0 : _a.type) ? c5.symbol : null;
      if (!c5.symbolLayers[0])
        continue;
      const b3 = e8.graphics3DGraphic, d4 = r4.labelClass, u = t5.disablePlacement, p3 = h({ graphics3DGraphic: b3, labelSymbol: h2, labelClass: d4, disablePlacement: u });
      if (null == p3)
        continue;
      const g3 = n8(p3.anchor), f = c3(g3);
      e8.textRenderers[a3] = new i2(n9, f, r4.textRenderParameters), e8.textLabelPlacements[a3] = p3;
    }
    e8.textInitialized = true;
  }
  _destroyTextTextureResources(e8) {
    e8.textInitialized = false, e8.textRenderers.length = 0, e8.textLabelPlacements.length = 0;
  }
  _addGraphic(e8, t5) {
    const s7 = t5.graphic.uid;
    if (e8.graphics.set(s7, t5), e8.active) {
      const l3 = new z3(e8, t5);
      this._labels.set(s7, l3), e8.labelsToInitialize.set(s7, l3);
    }
    this.setDirty(), this.deconflictor.setDirty();
  }
  _removeGraphic(e8, t5) {
    const s7 = t5.graphic.uid, l3 = this._labels.get(s7);
    e8.graphics.delete(s7), l3 && (this._destroyGraphic(l3, s7), e8.labelsToInitialize.delete(s7), this.setDirty(), this.deconflictor.setDirty());
  }
  _destroyGraphic(e8, t5) {
    this._labels.has(t5) && (this._labels.delete(t5), this._labelsToAdd.delete(t5), this._labelsToRemove.delete(t5)), e8.textInitialized && (this._removeLabelTextureFromAtlas(e8), this._destroyTextTextureResources(e8)), e8.hasGraphics3DResources && this._destroyGraphics3DResources(e8);
  }
  async _labelingInfoChange(e8, t5) {
    if (!t5)
      return this._visibilityInfoChange(e8), this._resetLabels(e8), this._createLabelClassContext(e8);
    for (const s7 of t5) {
      const t6 = e8.graphics.get(s7);
      t6 && (this._removeGraphic(e8, t6), this._addGraphic(e8, t6));
    }
  }
  _globalPropertyChanged(e8, t5) {
    for (const s7 of t5.labelClassContexts) {
      const l3 = /* @__PURE__ */ new Map();
      t5.graphics.forEach((e9) => l3.set(e9.graphic.uid, e9));
      const i5 = (e9) => e9.labelLayers[0];
      if (s7.graphics3DSymbol.symbolLayers[0].globalPropertyChanged(e8, l3, i5), s7.graphics3DCalloutSymbolLayer) {
        const t6 = (e9) => e9.labelLayers[s7.calloutSymbolLayerIndex];
        s7.graphics3DCalloutSymbolLayer.globalPropertyChanged(e8, l3, t6);
      }
    }
  }
  _visibilityInfoChange(e8) {
    const t5 = H2(e8.layer);
    t5 && !e8.active && this._activateLabelingContext(e8), !t5 && e8.active && this._deactivateLabelingContext(e8), this.setDirty();
  }
  _resetAllLabels() {
    for (const e8 of this._labelingContexts)
      this._resetLabels(e8);
  }
  _resetLabels(e8) {
    e8.graphics.forEach((t5, s7) => {
      const l3 = this._labels.get(s7);
      l3 && (this._destroyGraphic(l3, s7), l3.visible = false, l3.rendered = false, e8.labelsToInitialize.set(s7, l3));
    }), this._destroyLabelClassContext(e8), this.setDirty(), this.deconflictor.setDirty();
  }
  _findLabelingContext(e8) {
    for (const t5 of this._labelingContexts)
      if (t5.graphics3DCore === e8)
        return t5;
    return null;
  }
  addGraphicsOwner(e8, t5, s7) {
    const l3 = s7 && s7.emptySymbolLabelSupported || false, i5 = s7 && s7.elevationInfoOverride || null, a3 = s7 && s7.disablePlacement || null;
    if (this._findLabelingContext(e8))
      return;
    const r4 = e8.layer, o5 = new V2(this.view._stage, r4, e8, t5, l3, i5, a3, H2(r4));
    return this._labelingContexts.push(o5), this.setDirty(), { addGraphic: (e9) => this._addGraphic(o5, e9), removeGraphic: (e9) => this._removeGraphic(o5, e9), featureReductionChange: () => {
    }, layerLabelsEnabled: () => H2(o5.layer), labelingInfoChange: (e9) => this._labelingInfoChange(o5, e9), elevationInfoChange: () => this._globalPropertyChanged("elevationInfo", o5), slicePlaneEnabledChange: () => this._globalPropertyChanged("slicePlaneEnabled", o5), visibilityInfoChange: () => this._visibilityInfoChange(o5), reset: () => this._resetLabels(o5), clear: () => {
    } };
  }
  removeGraphicsOwner(e8) {
    const t5 = this._findLabelingContext(e8);
    if (!t5)
      return;
    const s7 = this._labelingContexts.indexOf(t5);
    this._labelingContexts.splice(s7, 1), t5.graphics.forEach((e9) => this._removeGraphic(t5, e9)), t5.destroy(), this.setDirty();
  }
  setLabelGraphicVisibility(e8, t5) {
    const s7 = e8.graphic.uid, l3 = this._labels.get(s7);
    l3 && l3.visible !== t5 && (t5 && !l3.rendered ? (this._labelsToAdd.set(s7, l3), this._labelsToRemove.delete(s7), l3.textInitialized || l3.labelingContext.labelsToInitialize.set(s7, l3)) : !t5 && l3.rendered && (this._labelsToRemove.set(s7, l3), this._labelsToAdd.delete(s7)), l3.visible = t5, this.setDirty());
  }
  setDirty() {
    !this._dirty && this._labelingContexts.length > 0 && (this._dirty = true, this.notifyChange("updating"));
  }
  get updating() {
    var _a;
    return this._dirty || ((_a = this._textTextureAtlas) == null ? void 0 : _a.updating) || this.deconflictor.updating || this._labelingContexts.some((e8) => U(e8));
  }
  get updatingProgress() {
    if (!this.updating || !this._textTextureAtlas)
      return 1;
    const e8 = this._labelingContexts.length > 0 ? this._labelingContexts.reduce((e9, t5) => e9 + (U(t5) ? 0 : 1), 0) / this._labelingContexts.length : 1;
    return (this._dirty ? 0 : 0.3) + (this._textTextureAtlas.updating ? 0 : 0.1) + 0.1 * e8 + 0.5 * this.deconflictor.updatingProgress;
  }
  get test() {
    return { textTextureAtlas: this._textTextureAtlas, resetAllLabels: () => this._resetAllLabels() };
  }
};
function U(e8) {
  return !!e8.labelClassPromise && !!e8.labelClassAbortController;
}
function k2(e8) {
  return e8.labelClassContexts && e8.labelClassContexts.length;
}
function B(e8) {
  return null === e8.labelClassContexts;
}
function H2(e8) {
  var _a;
  return true === e8.labelsVisible && !!((_a = e8.labelingInfo) == null ? void 0 : _a.some((e9) => !!e9.symbol));
}
e([y({ constructOnly: true })], F.prototype, "view", void 0), e([y({ constructOnly: true })], F.prototype, "deconflictor", void 0), e([y()], F.prototype, "_textTextureAtlas", void 0), e([y({ type: Boolean, readOnly: true })], F.prototype, "updating", null), F = e([a("esri.views.3d.layers.graphics.Labeler")], F);
var N2 = new S(null, null, null);

// node_modules/@arcgis/core/views/3d/webgl-engine/collections/Component/ComponentObject.js
var t4 = class extends m {
  constructor() {
    super(...arguments), this.visible = c4.Hidden;
  }
};
var c4;
e([y({ autoDestroy: true })], t4.prototype, "renderable", void 0), e([y({ autoDestroy: true })], t4.prototype, "components", void 0), t4 = e([a("esri.views.3d.webgl-engine.collections.Component.ComponentObject")], t4), function(o5) {
  o5[o5.Hidden = 0] = "Hidden", o5[o5.Visible = 1] = "Visible";
}(c4 || (c4 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/collections/Component/SourceGeometry.js
function o4(o5) {
  const i5 = H().vec3f(O.POSITION);
  return o5.normals && i5.vec2i16(O.NORMALCOMPRESSED, { glNormalized: true }), o5.textureCoordinates === d2.Default ? i5.vec2f(O.UV0) : o5.textureCoordinates === d2.Atlas && (i5.vec2f(O.UV0), i5.vec4u16(O.UVREGION, { glNormalized: true })), o5.colors && i5.vec4u8(O.COLOR, { glNormalized: true }), i5;
}

export {
  F,
  H2 as H,
  t4 as t,
  c4 as c,
  o4 as o
};
//# sourceMappingURL=chunk-BLRS5QI4.js.map
