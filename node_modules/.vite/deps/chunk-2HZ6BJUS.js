import {
  l as l6
} from "./chunk-CKDYQJAJ.js";
import {
  M,
  S
} from "./chunk-BM4PSBXP.js";
import {
  a as a5,
  c as c3,
  d as d2,
  h as h4,
  i as i5,
  n as n6,
  o,
  s as s7,
  t as t2
} from "./chunk-IMCUA6JI.js";
import {
  a as a6
} from "./chunk-23N5B2NF.js";
import {
  A as A2,
  I as I4
} from "./chunk-BUKSB3RJ.js";
import {
  u as u6
} from "./chunk-PFDC65N2.js";
import {
  d2 as d3,
  f as f2,
  o as o4,
  u2 as u5
} from "./chunk-6WY3ZZYN.js";
import {
  t as t3,
  u as u4
} from "./chunk-VYGC2LVC.js";
import {
  n as n9,
  r2 as r4,
  u as u3
} from "./chunk-AN3WFAN2.js";
import {
  w as w2
} from "./chunk-NIZWDAMQ.js";
import {
  o as o3
} from "./chunk-PKS3ZVLN.js";
import {
  n as n8
} from "./chunk-2CKXYQCA.js";
import {
  i as i6,
  n as n7,
  u as u2
} from "./chunk-JP7O2ZWE.js";
import {
  I as I3,
  P as P2,
  s as s6
} from "./chunk-3LLZ72VA.js";
import {
  Z
} from "./chunk-2XKILFME.js";
import {
  n as n5,
  r as r3
} from "./chunk-G4LSNP77.js";
import {
  D
} from "./chunk-BCDDCNQ2.js";
import {
  $e,
  Be,
  Ce,
  H,
  Pe,
  Qe,
  ee,
  ke,
  me,
  pe,
  te
} from "./chunk-SLMR4CTS.js";
import {
  I as I2,
  p as p4
} from "./chunk-XKENZ7D5.js";
import {
  O,
  P as P3,
  Z as Z2,
  se
} from "./chunk-GZTS5346.js";
import {
  C as C3,
  E,
  W,
  _ as _3,
  q,
  w
} from "./chunk-LEDSC236.js";
import {
  c as c2
} from "./chunk-NETCTS4Y.js";
import {
  e as e5
} from "./chunk-VN2IXVGV.js";
import {
  b as b3
} from "./chunk-O443WBFA.js";
import {
  e as e4
} from "./chunk-SHFLRM67.js";
import {
  a2 as a4,
  n as n3,
  r as r2
} from "./chunk-EAGDM3GO.js";
import {
  C as C2,
  I,
  n as n4
} from "./chunk-KRCNIFX2.js";
import {
  l as l5,
  o as o2
} from "./chunk-RVS5HU2K.js";
import {
  g as g2
} from "./chunk-JB7FDW5N.js";
import {
  kn,
  xn
} from "./chunk-BNBT4QTW.js";
import {
  _ as _2,
  b as b2,
  y as y3
} from "./chunk-SVCGLUNW.js";
import {
  h as h3
} from "./chunk-RRJGZKNX.js";
import {
  V
} from "./chunk-7EQSYZHW.js";
import {
  s as s5
} from "./chunk-WLWP35G2.js";
import {
  b,
  i as i3
} from "./chunk-EKJ2DJIR.js";
import {
  i as i2
} from "./chunk-TEHNQYQD.js";
import {
  F,
  P,
  e as e3,
  g,
  p as p3,
  s as s4,
  u,
  v,
  x
} from "./chunk-TPJLFGOT.js";
import {
  l as l3,
  n
} from "./chunk-CQX57DED.js";
import {
  a2 as a3
} from "./chunk-3CQBBMMD.js";
import {
  A2 as A,
  G
} from "./chunk-RTDN6KAT.js";
import {
  n as n2
} from "./chunk-5EXFDBQJ.js";
import {
  c2 as c
} from "./chunk-SJ2GJCS2.js";
import {
  U,
  h as h2,
  l as l4
} from "./chunk-H7RDAEPY.js";
import {
  m as m3
} from "./chunk-JL3TJGVW.js";
import {
  i as i4,
  j as j2,
  m as m2
} from "./chunk-43LWRDQS.js";
import {
  _
} from "./chunk-ZJEWQGHG.js";
import {
  m,
  t2 as t,
  y3 as y2
} from "./chunk-V76KGJFU.js";
import {
  a2,
  i3 as i,
  l as l2
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  C,
  L,
  T,
  d,
  h,
  j,
  p as p2,
  s as s3,
  y
} from "./chunk-7I33FAWS.js";
import {
  e as e2,
  f,
  l,
  r
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import {
  a
} from "./chunk-IYZKKFJM.js";
import {
  has,
  p,
  z
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/enums.js
var e6;
var s8;
!function(e7) {
  e7[e7.KTX2 = 1] = "KTX2", e7[e7.Basis = 2] = "Basis", e7[e7.DDS_S3TC = 4] = "DDS_S3TC", e7[e7.PNG = 8] = "PNG", e7[e7.JPG = 16] = "JPG", e7[e7.KTX_ETC2 = 32] = "KTX_ETC2";
}(e6 || (e6 = {})), function(e7) {
  e7[e7.None = 0] = "None", e7[e7.Color = 1] = "Color", e7[e7.MetallicRoughness = 2] = "MetallicRoughness", e7[e7.Normal = 4] = "Normal", e7[e7.Occlusion = 8] = "Occlusion", e7[e7.Emissive = 16] = "Emissive", e7[e7.AlphaMask = 32] = "AlphaMask", e7[e7.ColorTextures = 19] = "ColorTextures", e7[e7.GeometryTextures = 36] = "GeometryTextures", e7[e7.GeometryTexturesPBR = 44] = "GeometryTexturesPBR", e7[e7.AllTextures = 37] = "AllTextures", e7[e7.AllTexturesPBR = 63] = "AllTexturesPBR";
}(s8 || (s8 = {}));

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SClientMaterialUtil.js
async function i7(t5) {
  const o5 = [], r7 = [];
  if (null == t5) {
    return { material: { alphaMode: "opaque", alphaCutoff: 0.1, doubleSided: true, cullFace: 0, normalTextureId: -1, emissiveTextureId: -1, occlusionTextureId: -1, emissiveFactor: [0, 0, 0], metallicRoughness: { baseColorFactor: [1, 1, 1, 1], baseColorTextureId: -1, metallicRoughnessTextureId: -1, metallicFactor: 0, roughnessFactor: 0.6000000238418579 }, wrapTextures: false, hasParametersFromSource: true }, requiredTextures: o5, textureData: r7 };
  }
  const s12 = d4(t5);
  "auto" === t5.alphaMode && console.warn('alphaMode "auto" not supported by I3S PBRMaterial - defaulting to "blend".');
  return { material: { alphaMode: "auto" === t5.alphaMode ? "blend" : t5.alphaMode, alphaCutoff: t5.alphaCutoff, doubleSided: t5.doubleSided, cullFace: t5.doubleSided ? n7.None : n7.Back, normalTextureId: await u7(t5.normalTexture, o5, r7, s8.Normal), emissiveTextureId: s12 ? await u7(t5.emissiveTexture, o5, r7, s8.Emissive) : -1, occlusionTextureId: s12 ? await u7(t5.occlusionTexture, o5, r7, s8.Occlusion) : -1, emissiveFactor: s12 && null != t5.emissiveColor ? h3.toUnitRGB(t5.emissiveColor) : [0, 0, 0], metallicRoughness: { baseColorFactor: null != t5.color ? h3.toUnitRGBA(t5.color) : [1, 1, 1, 1], baseColorTextureId: await u7(t5.colorTexture, o5, r7, s8.Color), metallicRoughnessTextureId: s12 ? await u7(t5.metallicRoughnessTexture, o5, r7, s8.MetallicRoughness) : -1, metallicFactor: s12 ? t5.metallic : 0, roughnessFactor: s12 ? t5.roughness : 0 }, wrapTextures: true, hasParametersFromSource: u3({ normalTexture: t5.normalTexture, emissiveTexture: s12 ? t5.emissiveTexture : null, emissiveFactor: s12 ? h3.toUnitRGB(t5.emissiveColor) : null, occlusionTexture: s12 ? t5.occlusionTexture : null, metallicRoughnessTexture: s12 ? t5.metallicRoughnessTexture : null, metallicFactor: s12 ? t5.metallic : null, roughnessFactor: s12 ? t5.roughness : null }) }, requiredTextures: o5, textureData: r7 };
}
async function u7(e7, a10, n10, l8) {
  if (null == e7)
    return -1;
  const i9 = n10.length, u9 = e7.data, d6 = e7.url;
  if (null != u9) {
    if (u9 instanceof HTMLImageElement || u9 instanceof HTMLCanvasElement) {
      const e8 = c4(u9);
      return n10.push({ id: i9, usage: l8, data: e8, encoding: e6.PNG, downsampled: false }), a10.push({ id: i9, usage: l8, encodings: [{ name: void 0, encoding: e6.PNG }] }), i9;
    }
    if (u9 instanceof HTMLVideoElement)
      return -1;
    if (u9 instanceof ImageData)
      throw new s2("ImageData textures not supported yet for client side I3S nodes");
    if (u9 instanceof n8)
      throw new s2("EncodedMeshTexture textures not supported yet for client side I3S nodes");
  } else if (null != d6) {
    const e8 = new Image();
    e8.src = d6;
    const t5 = c4(await i4(e8, e8.src, false, void 0));
    return n10.push({ id: i9, usage: l8, data: t5, encoding: e6.PNG, downsampled: false }), a10.push({ id: i9, usage: l8, encodings: [{ name: void 0, encoding: e6.PNG }] }), i9;
  }
  return -1;
}
function c4(e7) {
  const t5 = 1048576, o5 = 4096, r7 = 2;
  let a10 = e7.width * e7.height;
  if (a10 >= o5) {
    let o6 = e7.width, s12 = e7.height;
    do {
      o6 = Math.ceil(o6 / r7), s12 = Math.ceil(s12 / r7), a10 = o6 * s12;
    } while (a10 > t5);
    const n10 = document.createElement("canvas");
    n10.width = o6, n10.height = s12;
    return n10.getContext("2d").drawImage(e7, 0, 0, o6, s12), n10;
  }
  return e7;
}
function d4(e7) {
  return e7.hasOwnProperty("metallicRoughnessTexture");
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SClientNodeLoader.js
var h5 = class {
  constructor(e7, t5, o5, n10, r7, s12) {
    this._uid = e7, this._indexSR = t5, this._renderSR = o5, this._viewingMode = n10, this._worker = s12, this._id2Meta = /* @__PURE__ */ new Map(), this._oid2Meta = /* @__PURE__ */ new Map(), this._memCache = r7.newCache(`sl-client-mesh-data-${this._uid}`);
  }
  get indexSR() {
    return this._indexSR;
  }
  get renderSR() {
    return this._renderSR;
  }
  createMeshNodeInfo(e7, t5) {
    const o5 = `mesh${t5}`, n10 = e7.extent, r7 = n10.spatialReference, s12 = this._indexSR, a10 = f3(n10, e7.origin);
    xn(a10, r7, a10, s12);
    return { type: "mesh", id: o5, version: M2(e7), oid: t5, mbs: a10, componentNodeIds: [], unloadedMesh: e7, nodeIndex: null, loadMeshPromise: null };
  }
  addMeshNode(t5, o5) {
    if (null != this.getMeshNodeIndex(o5.oid))
      throw new s2(`I3SClientNodeLoader: client side mesh for feature oid=${o5.oid} already exists`);
    o5.nodeIndex = t5, this._id2Meta.set(o5.id, o5), this._oid2Meta.set(o5.oid, o5);
  }
  getMeshNodeIndex(e7) {
    const t5 = this._oid2Meta.get(e7);
    return null == t5 || "mesh" !== t5.type ? null : t5.nodeIndex;
  }
  removeNode(e7) {
    if (null == e7)
      return;
    const t5 = this._id2Meta.get(e7);
    null != t5 && (this._id2Meta.delete(e7), "mesh" === t5.type && this._oid2Meta.delete(t5.oid));
  }
  async loadNodeJSON(t5) {
    const o5 = this._id2Meta.get(t5);
    if (null == o5)
      throw new s2(`I3SClientNodeLoader::loadNodeJSON unable to find node ${t5}`);
    switch (o5.type) {
      case "mesh":
        return this._loadMeshNodeJSON(o5);
      case "mesh-component":
        return this._loadMeshComponentNodeJSON(o5);
      default:
        throw new s2(`I3SClientNodeLoader::loadNodeJSON unable to handle node ${t5}`);
    }
  }
  async _loadMeshNodeJSON(e7) {
    const t5 = e7.id, o5 = (await this._getMeshData(e7)).loadedMesh;
    if (null == o5.components || 0 === o5.components.length)
      return { id: t5, version: null, mbs: e7.mbs, obb: null, sharedResource: null, geometryData: null, attributeData: null, featureData: null, children: null };
    const n10 = [], r7 = o5.components;
    for (let s12 = 0; s12 < r7.length; ++s12) {
      const o6 = `${t5}-component${s12}`, r8 = { type: "mesh-component", id: o6, mbs: e7.mbs, componentIndex: s12, meshNodeInfo: e7, textureData: /* @__PURE__ */ new Map() };
      this._id2Meta.set(r8.id, r8), e7.componentNodeIds.push(o6), n10.push({ id: r8.id, href: null, mbs: r8.mbs, obb: null });
    }
    return { id: t5, version: null, mbs: e7.mbs, obb: null, sharedResource: null, geometryData: null, attributeData: null, featureData: null, children: n10 };
  }
  updateNodeIndex(e7, t5, o5) {
    if (null == e7)
      return;
    const n10 = this._id2Meta.get(e7);
    n10 && "mesh" === n10.type && (n10.nodeIndex = o5);
  }
  async _loadMeshComponentNodeJSON(e7) {
    return { id: e7.id, version: e7.meshNodeInfo.version, mbs: e7.mbs, obb: null, sharedResource: null, geometryData: null, attributeData: null, featureData: null, children: null, isEmpty: false };
  }
  async loadNodeData(o5, r7) {
    const s12 = o5.id, a10 = this._id2Meta.get(s12);
    if (null == a10 || "mesh-component" !== a10.type)
      throw new s2(`Failed to load client node data for node ${o5.id} (unexpected node info)`);
    const i9 = a10.meshNodeInfo, l8 = await this._getMeshData(i9), d6 = l8.loadedMesh, u9 = i9.oid;
    if (null == d6.components)
      throw new s2(`Failed to load client node data for node ${o5.id} (unexpected null reference)`);
    const h8 = d6.components[a10.componentIndex], { material: f5, requiredTextures: x5, textureData: M6 } = await i7(h8.material);
    if (null != M6)
      for (const e7 of M6)
        null != e7 && a10.textureData.set(e7.id, e7);
    const g6 = { params: { material: f5 }, type: "ArrayBufferView" }, { vertexSpace: w6, origin: _6, transform: b7 } = d6, N2 = [_6.x, _6.y, _6.z ?? 0], S5 = { featureDataPosition: N2, featureIds: [], geometries: [g6] }, D5 = { attributeData: {}, loadedAttributes: [] };
    l8.projectionPromise || (r(this._worker, "SceneLayerWorker is needed to project mesh"), l8.projectionPromise = this._worker.project({ positions: d6.vertexAttributes.position, localMatrix: b7 == null ? void 0 : b7.localMatrix, vertexSpace: w6.toJSON(), origin: N2, inSpatialReference: d6.spatialReference.toJSON(), outSpatialReference: this._indexSR.toJSON(), local: this._viewingMode === l5.Local }, r7));
    const { projected: v2, original: I6 } = await l8.projectionPromise;
    d6.vertexAttributes.position = I6;
    const { transformed: j4, original: A4 } = await p5(h8, l8, this._worker, r7);
    d6.vertexAttributes.normal = A4, s3(r7);
    const { geometryBuffer: R4, geometryDescriptor: P6 } = y4(v2, h8.faces, j4, d6.vertexAttributes.uv, d6.vertexAttributes.color, u9);
    return { geometryData: S5, attributeDataInfo: D5, geometryBuffer: R4, geometryDescriptor: P6, requiredTextures: x5, textureData: M6 };
  }
  async loadAttributes(e7, t5, o5) {
    const n10 = e7.numFeatures, r7 = {};
    for (const { field: { name: s12 } } of t5)
      r7[s12] = new Array(n10);
    return r7;
  }
  async loadTextures(e7, t5, o5) {
    const n10 = e7.id, r7 = this._id2Meta.get(n10);
    if (null == r7 || "mesh-component" !== r7.type)
      throw new Error(`Failed to load textures for node ${e7.id} (unexpected node info)`);
    const s12 = [];
    for (const a10 of t5)
      s12.push(r7.textureData.get(a10.id) || null);
    return s12;
  }
  async _getMeshData(e7) {
    const t5 = e7.version, n10 = this._memCache.get(t5);
    if (null == n10) {
      if (null != e7.loadMeshPromise)
        return e7.loadMeshPromise;
      const n11 = async (n12, r7) => {
        const s12 = e7.unloadedMesh.clone();
        try {
          await s12.load();
        } catch (l8) {
          r7(l8);
        }
        const a10 = s12.memoryUsage, i9 = { loadedMesh: s12, projectionPromise: null, normalsTransformPromise: null, usedMemoryInBytes: a10 };
        this._memCache.put(t5, i9, a10, e4), e7.loadMeshPromise = null, n12(i9);
      };
      return e7.loadMeshPromise = new Promise((e8, t6) => n11(e8, t6)), e7.loadMeshPromise;
    }
    return n10;
  }
};
function f3(e7, t5) {
  const { spatialReference: o5 } = e7, n10 = [1, -1], r7 = [0.5 * e7.width, 0.5 * e7.height, e7.hasZ ? 0.5 * (e7.zmax - e7.zmin) : 0], s12 = o5.isGeographic ? o5.metersPerUnit : 1, a10 = e7.center;
  let i9 = 0;
  if (e7.hasZ)
    for (let l8 = 0; l8 < 2; ++l8)
      for (let e8 = 0; e8 < 2; ++e8)
        for (let o6 = 0; o6 < 2; ++o6) {
          const d6 = (a10.x + n10[l8] * r7[0] - t5.x) * s12, u9 = (a10.y + n10[e8] * r7[1] - t5.y) * s12, c7 = a10.z + n10[o6] * r7[2] - t5.z;
          i9 = Math.max(d6 * d6 + u9 * u9 + c7 * c7, i9);
        }
  else
    for (let l8 = 0; l8 < 2; ++l8)
      for (let e8 = 0; e8 < 2; ++e8) {
        const o6 = (a10.x + n10[l8] * r7[0] - t5.x) * s12, d6 = (a10.y + n10[e8] * r7[1] - t5.y) * s12;
        i9 = Math.max(o6 * o6 + d6 * d6, i9);
      }
  return w([t5.x, t5.y, t5.z], Math.sqrt(i9));
}
async function p5(e7, o5, n10, r7) {
  const { transform: d6, vertexAttributes: u9 } = o5.loadedMesh, c7 = "source" === e7.shading ? u9.normal : null;
  if (!(null != c7 && null != d6 && (0 !== d6.rotationAngle || !F(d6.scale, l3))))
    return { transformed: c7, original: u9.normal };
  if (!o5.normalsTransformPromise) {
    r(n10, "SceneLayerWorker is needed to transform mesh normals");
    const e8 = e5();
    g2(e8, d6.localMatrix), o5.normalsTransformPromise = n10.transformNormals({ normalMatrix: e8, normals: c7 }, r7);
  }
  return o5.normalsTransformPromise;
}
function y4(e7, t5, o5, n10, r7, s12) {
  const a10 = 1, i9 = t5.length / 3, l8 = 3 * i9;
  let d6 = 0, u9 = 0, c7 = false, m5 = 0, h8 = false, f5 = 0, p6 = false, y7 = 0, M6 = 0, N2 = 0;
  d6 += g3, d6 += g3, u9 = d6, d6 += 3 * l8 * w3, null != o5 && (c7 = true, m5 = d6, d6 += 3 * l8 * w3), null != n10 && (h8 = true, f5 = d6, d6 += 2 * l8 * w3), null != r7 && (p6 = true, y7 = d6, d6 += 4 * l8 * _4), M6 = d6, d6 += a10 * b4, N2 = d6, d6 += 2 * a10 * g3;
  const S5 = new ArrayBuffer(d6), D5 = new Uint8Array(S5);
  x2(D5, 0, l8), x2(D5, g3, a10);
  const v2 = new Float32Array(S5, u9), I6 = null != o5 ? new Float32Array(S5, m5) : null, j4 = null != n10 ? new Float32Array(S5, f5) : null, A4 = null != r7 ? new Uint8Array(S5, y7) : null;
  for (let x5 = 0; x5 < i9; ++x5) {
    const s13 = 3 * x5;
    for (let a11 = 0; a11 < 3; ++a11) {
      const i10 = t5[s13 + a11], l9 = 3 * i10, d7 = 9 * x5 + 3 * a11;
      if (v2[d7] = e7[l9], v2[d7 + 1] = e7[l9 + 1], v2[d7 + 2] = e7[l9 + 2], null != I6 && (I6[d7] = o5[l9], I6[d7 + 1] = o5[l9 + 1], I6[d7 + 2] = o5[l9 + 2]), null != j4) {
        const e8 = 2 * i10, t6 = 6 * x5 + 2 * a11;
        j4[t6] = n10[e8], j4[t6 + 1] = n10[e8 + 1];
      }
      if (null != A4) {
        const e8 = 4 * i10, t6 = 12 * x5 + 4 * a11;
        A4[t6] = r7[e8], A4[t6 + 1] = r7[e8 + 1], A4[t6 + 2] = r7[e8 + 2], A4[t6 + 3] = r7[e8 + 3];
      }
    }
  }
  x2(D5, M6, s12), x2(D5, M6 + g3, s12 / 2 ** 32), x2(D5, N2, 0), x2(D5, N2 + g3, i9 - 1);
  return { geometryBuffer: S5, geometryDescriptor: { isDraco: false, isLegacy: true, color: p6, normal: c7, uv0: h8, uvRegion: false, featureIndex: true } };
}
function x2(e7, t5, o5) {
  e7[t5] = 255 & o5, e7[t5 + 1] = 255 & o5 >> 8, e7[t5 + 2] = 255 & o5 >> 16, e7[t5 + 3] = 255 & o5 >> 24;
}
function M2(e7) {
  var _a;
  const t5 = (_a = e7.metadata.displaySource) == null ? void 0 : _a.source;
  if (null == t5 || !Array.isArray(t5) || !t5.length || t5[0] instanceof File)
    return n2();
  const o5 = t5;
  let n10 = "";
  for (const r7 of o5)
    n10 += r7.makeHash();
  return n10 + JSON.stringify(null != e7.transform ? e7.transform.toJSON() : "") + (e7.vertexSpace.isRelative ? JSON.stringify(e7.vertexSpace.origin) : "");
}
var g3 = 4;
var w3 = 4;
var _4 = 1;
var b4 = 8;

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SFrameTask.js
var i8 = class extends m {
  constructor() {
    super(), this.referenceCount = 0, this.callbacks = new Array(), this.runIndex = 0;
  }
  get running() {
    return this.callbacks.some((r7) => r7.running);
  }
  runTask(r7) {
    this._sort();
    const s12 = this.callbacks, t5 = { numIndexLoading: 0, numNodesLoading: 0 };
    for (let e7 = 0; e7 < s12.length && !r7.done; ++e7)
      s12[e7].priority = s12[e7].runTask(r7, t5), this.runIndex = e7;
  }
  _sort() {
    const r7 = this.callbacks;
    let s12 = r7.length;
    for (let t5 = this.runIndex; t5 > 0; t5--) {
      const e7 = r7[t5 - 1];
      let o5 = t5;
      for (; o5 < r7.length && e7.priority <= r7[o5].priority && (o5 !== s12 || e7.priority < r7[o5].priority); )
        r7[o5 - 1] = r7[o5], o5++;
      r7[o5 - 1] = e7, s12 = o5 - 1;
    }
    this.runIndex = 0;
  }
  add(r7) {
    this._sort(), r7.priority = 1 / 0, this.callbacks.unshift(r7), this.notifyChange("running");
  }
  remove(r7) {
    z(this.callbacks, r7), this.runIndex = this.callbacks.length, this._sort(), this.notifyChange("running");
  }
};
e([y2({ readOnly: true })], i8.prototype, "running", null), i8 = e([a2("esri.views.3d.layers.i3s.I3SFrameTask")], i8);
var a7 = class {
  constructor(r7, s12) {
    this.task = r7, this.handle = s12;
  }
};
var c5 = /* @__PURE__ */ new Map();
function l7(r7, s12) {
  let t5 = c5.get(r7);
  if (null == t5) {
    const s13 = new i8(), e7 = r7.registerTask(I.I3S_CONTROLLER, s13);
    t5 = new a7(s13, e7), c5.set(r7, t5);
  }
  return t5.task.add(s12), { remove: () => {
    if (null == t5)
      return;
    t5.task.remove(s12);
    t5.task.callbacks.length > 0 || (c5.delete(r7), t5.handle.remove(), t5.task.destroy()), t5 = null;
  } };
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SIndex.js
var y5 = class {
  constructor(e7, t5, i9, n10, s12) {
    this.childOffset = e7, this.childCount = t5, this.visibilityCache = i9, this.ref = n10, this.node = s12, this.useAsHole = 0, this.filterImpact = n6.NotChecked;
  }
};
var N = class {
  constructor(t5, i9, n10, s12, o5, r7, l8, h8, u9, c7, _6, g6, f5, m5, v2) {
    this._layer = t5, this._streamDataController = n10, this._clientNodeLoader = s12, this._viewportQueries = o5, this._logger = r7, this.holeFilling = l8, this._isLoaded = h8, this._isReloading = u9, this._isSelected = c7, this._enable = _6, this._needsUpdate = g6, this._canRequest = f5, this._computeVisibilityObb = m5, this._computeNodeFiltering = v2, this._dirty = true, this._nodePages = new Array(), this._clientNodePage = null, this._nodeCount = 0, this._nodesPerPage = 0, this._rootIndex = 0, this._lodMetric = a5.None, this._lodConversion = (e7) => e7, this._isEditable = false, this._urlPrefix = "", this._loading = /* @__PURE__ */ new Set(), this._failedNodes = /* @__PURE__ */ new Set(), this._failedPages = /* @__PURE__ */ new Set(), this._indexMissing = 1, this._maxUnloadedPrio = Number.NEGATIVE_INFINITY, this._maxProcessingPrio = Number.POSITIVE_INFINITY, this._nodeTraversalState = /* @__PURE__ */ new Map(), this._version = w4(0), this._visibilityCacheVersion = w4(0), this._maxLevel = 1, this._featureEstimate = { estimate: 0, leavesReached: false }, this._unloadedMemoryEstimate = 0, this._missing = new l2({ deallocator: null }), this._prefetch = new l2({ deallocator: null }), this._updates = new x3(this._missing), this._imModificationUncategorized = new l2({ deallocator: null }), this.ignoreServiceObb = false, this.progressiveLoadPenalty = 0, this._pageQueue = [], this.needNodeElevationRange = false, this.layerHasModifications = false, this._layerHasFilter = false, this._isEditable = r2() && null != t5.associatedLayer && null != t5.associatedLayer.infoFor3D, t5.serviceUpdateTimeStamp && t5.serviceUpdateTimeStamp.lastUpdate && (this._lastUpdate = `${t5.serviceUpdateTimeStamp.lastUpdate}`), this._maxLodLevel = this._viewportQueries ? this._viewportQueries.maxLodLevel : 1, this._init(i9);
  }
  _init(e7) {
    if ("page" === e7.type) {
      const t5 = e7.rootPage;
      switch (this._urlPrefix = e7.urlPrefix, this._nodesPerPage = e7.pageSize, e7.lodMetric) {
        case "maxScreenThreshold":
          this._lodMetric = a5.MaxScreenThreshold;
          break;
        case "maxScreenThresholdSQ":
          this._lodMetric = a5.MaxScreenThreshold, this._lodConversion = T2;
      }
      if (this._isEditable) {
        this._rootIndex = -1;
        const i9 = V2(e7.rootIndex, e7.pageSize), n10 = t5.nodes[i9], s12 = { nodes: [{ index: this._rootIndex, children: [e7.rootIndex], mesh: void 0, obb: n10.obb, lodThreshold: n10.lodThreshold }] };
        this._addPage(E2(this._rootIndex, this._nodesPerPage), s12), this.getNode(-1).serviceObb = void 0;
      } else
        this._rootIndex = e7.rootIndex;
      this._addPage(E2(e7.rootIndex, this._nodesPerPage), t5), this._updateParentsAndLevel();
    } else if ("node" === e7.type) {
      if (this._urlPrefix = e7.urlPrefix, this._nodePages.push(O2()), this._isEditable) {
        this._clientNodePage = O2();
        const t6 = { id: "-1", version: null, mbs: e7.rootNode.mbs, obb: e7.rootNode.obb, sharedResource: null, geometryData: null, attributeData: null, featureData: null, children: [{ id: "root", href: "../root", mbs: e7.rootNode.mbs, obb: e7.rootNode.obb }] };
        this._rootIndex = this._makeClientRefNode(new t2(t6.id, null), -1);
        const i9 = this._validateNode(t6.id, t6);
        i9 && this._addNode(i9, this._rootIndex);
      } else
        this._rootIndex = this._makeRefNode(new t2(e7.rootNode.id, null), -1);
      const t5 = this._validateNode(e7.rootNode.id, e7.rootNode);
      t5 && this._addNode(t5, 0);
    }
  }
  addClientNodeToIndex(e7, t5) {
    const i9 = -1, n10 = new t2(e7, t5), s12 = this._makeClientRefNode(n10, i9);
    return this._linkChildToParentNode(i9, s12), this.requestUpdate(), s12;
  }
  removeClientNodeFromIndex(e7, t5, i9) {
    this._destroyClientRefNode(e7, t5, i9), this.requestUpdate();
  }
  _loadPage(e7) {
    this._loading.add(e7);
    const i9 = this._urlPrefix + e7;
    this._streamDataController.request(i9, "json").then((t5) => {
      this._pageQueue.push({ pageIndex: e7, page: t5 });
    }).catch((i10) => {
      this._loading.delete(e7), d(i10) || (this._failedPages.add(e7), this._logger.error("#loadPage()", this._layer, `Error when loading page ${e7}`, i10));
    });
  }
  _addQueuedPages(e7) {
    for (; this._pageQueue.length > 0 && !e7.done; ) {
      const { pageIndex: t5, page: i9 } = this._pageQueue.shift();
      this._addPage(t5, i9), this._loading.delete(t5), e7.madeProgress();
    }
    this._updateParentsAndLevel();
  }
  _addPage(e7, t5) {
    const n10 = [], o5 = [], r7 = t5.nodes.map((t6, r8) => {
      const l8 = n10.length, a10 = t6.children ? t6.children.length : 0;
      o5.push(this._rootIndex);
      for (let e8 = 0; e8 < a10; e8++)
        n10.push(t6.children[e8]);
      const d6 = `${t6.index}`, h8 = P3(t6.obb), c7 = E(h8.center[0], h8.center[1], h8.center[2], s4(h8.halfSize)), _6 = t6.mesh && t6.mesh.attribute, g6 = t6.mesh && t6.mesh.geometry, f5 = t6.mesh && t6.mesh.material, m5 = { hasSharedResource: false, isEmpty: null == g6, attributes: _6 && null != _6.resource ? `${_6.resource}` : void 0, geometry: g6 && null != g6.resource ? `${g6.resource}` : void 0, texture: f5 && null != f5.resource ? `${f5.resource}` : void 0, geometryDefinition: g6 ? g6.definition : -1, materialDefinition: f5 ? f5.definition : -1 }, v2 = new h4(d6, L2(r8, e7, this._nodesPerPage), c7, a10, 0, m5, this._lastUpdate, this._lodMetric, this._lodConversion(t6.lodThreshold), g6 ? g6.featureCount : null);
      return v2.serviceObb = h8, v2.visibilityObb = this._computeVisibilityObb(v2), v2.vertexCount = g6 ? g6.vertexCount : 0, new y5(l8, a10, C4(this._visibilityCacheVersion), null, v2);
    });
    if (-1 === e7)
      this._clientNodePage = O2(r7, n10, o5);
    else {
      for (let t6 = this._nodePages.length; t6 < e7; t6++)
        this._nodePages[t6] = null;
      this._nodePages[e7] = O2(r7, n10, o5);
    }
    this._nodeCount += r7.length;
  }
  _updateParentsAndLevel() {
    const e7 = new Array(), t5 = (t6, i9, n10) => {
      const s12 = this._getPage(t6);
      if (null != s12) {
        const o5 = V2(t6, this._nodesPerPage);
        s12.parents[o5] = null != i9 ? i9 : -1;
        const r7 = s12.nodes[o5].node;
        null != r7 && (r7.level = n10, e7.push(t6));
      }
    };
    for (t5(this._rootIndex, null, 0); e7.length; ) {
      const i9 = e7.pop(), n10 = this.getNode(i9);
      if (null != n10)
        for (let e8 = 0; e8 < n10.childCount; e8++) {
          t5(this.getChildIndex(n10.index, e8), i9, n10.level + 1), this._maxLevel = Math.max(this._maxLevel, n10.level + 1);
        }
    }
  }
  _getPage(e7) {
    const t5 = E2(e7, this._nodesPerPage);
    return t5 < 0 ? this._clientNodePage : this._nodePages[t5];
  }
  _getNodeInternal(e7) {
    const t5 = this._getPage(e7);
    return null == t5 ? null : t5.nodes[V2(e7, this._nodesPerPage)];
  }
  _addNode(e7, t5) {
    null != e7.children && this.populateChildren(t5, e7.children);
    const i9 = this.getParent(t5), n10 = null != i9 ? i9.level + 1 : 0;
    this._maxLevel = Math.max(this._maxLevel, e7.children ? n10 + 1 : n10);
    const { lodMetric: s12, maxError: o5 } = A3(e7.lodSelection), r7 = this._getNodeInternal(t5);
    return r7.node = new h4(e7.id, t5, e7.mbs, r7.childCount, n10, e7.resources, e7.version, s12, o5, e7.numFeatures), e7.obb && (r7.node.serviceObb = P3(e7.obb)), r7.node.visibilityObb = this._computeVisibilityObb(r7.node), null != r7.ref && (null == r7.ref.mbs && (r7.ref.mbs = e7.mbs), r7.node.renderMbs = r7.ref.renderMbs, r7.node.serviceObbInRenderSR = r7.ref.serviceObbInRenderSR, r7.ref.visibilityObb = r7.node.visibilityObb), r7.node;
  }
  _makeRefNode(e7, t5) {
    const i9 = this._nodePages[0];
    if (t5 < -1)
      return this._makeClientRefNode(e7, t5);
    if (null == i9)
      return -1;
    const n10 = i9.nodes.length;
    return i9.nodes.push(new y5(0, 0, C4(this._visibilityCacheVersion), e7, null)), this._nodeCount++, i9.parents.push(t5), Qe(e7.renderMbs), $e(e7.serviceObbInRenderSR), n10;
  }
  _makeClientRefNode(e7, t5) {
    const i9 = this._clientNodePage;
    if (null == i9)
      return -1;
    if (t5 >= 0)
      throw new Error("I3SIndex::client side nodes can not be made children of service side nodes.");
    const n10 = -(i9.nodes.length + 1);
    return i9.nodes.push(new y5(0, 0, C4(this._visibilityCacheVersion), e7, null)), this._nodeCount++, i9.parents.push(t5), Qe(e7.renderMbs), $e(e7.serviceObbInRenderSR), n10;
  }
  _linkChildToParentNode(e7, t5) {
    const i9 = this._clientNodePage;
    if (null == i9 || e7 >= 0)
      return;
    const n10 = V2(e7, this._nodesPerPage), s12 = V2(t5, this._nodesPerPage), o5 = i9.nodes[n10], r7 = o5.childOffset;
    i9.children.splice(o5.childOffset + o5.childCount, 0, t5);
    const l8 = 1;
    o5.childCount += l8, null != o5.node && (o5.node.childCount += l8);
    for (const a10 of i9.nodes)
      a10.childOffset > r7 && (a10.childOffset += l8);
    i9.parents[s12] = e7, this._updateParentBoundingInformation(e7);
  }
  _destroyClientRefNode(e7, t5, i9) {
    var _a;
    const n10 = this._clientNodePage;
    if (null == n10)
      return;
    const s12 = this.getParentIndex(e7);
    if (null == s12)
      return;
    const o5 = /* @__PURE__ */ new Set(), r7 = /* @__PURE__ */ new Map(), l8 = (e8) => {
      var _a2;
      const i10 = V2(e8, this._nodesPerPage), s13 = n10.nodes[i10];
      if (s13.childCount > 0)
        for (let t6 = s13.childOffset; t6 < s13.childOffset + s13.childCount; ++t6)
          l8(n10.children[t6]);
      t5((_a2 = s13.node) == null ? void 0 : _a2.id, e8), o5.add(s13), this._nodeTraversalState.delete(e8);
    };
    l8(e7);
    const a10 = n10.nodes, d6 = n10.children, h8 = n10.nodes.map(() => -1), u9 = [], c7 = [];
    for (let g6 = 0; g6 < a10.length; ++g6) {
      const e8 = a10[g6];
      if (o5.has(e8))
        continue;
      const t6 = u9.length, n11 = L2(g6, -1, this._nodesPerPage), s13 = L2(t6, -1, this._nodesPerPage);
      e8.node && (e8.node.index = s13), h8[g6] = s13, u9.push(e8), n11 !== s13 && (i9((_a = e8.node) == null ? void 0 : _a.id, n11, s13), r7.set(n11, s13));
    }
    this._nodeCount -= a10.length - u9.length;
    const _6 = u9.map(() => -1);
    for (let g6 = 0; g6 < u9.length; ++g6) {
      const e8 = L2(g6, -1, this._nodesPerPage), t6 = u9[g6], i10 = c7.length;
      for (let n11 = t6.childOffset; n11 < t6.childOffset + t6.childCount; ++n11) {
        const t7 = d6[n11];
        if (t7 >= 0)
          c7.push(t7);
        else {
          const i11 = V2(t7, this._nodesPerPage), n12 = a10[i11];
          if (o5.has(n12))
            continue;
          const s13 = h8[i11];
          c7.push(s13);
          _6[V2(s13, this._nodesPerPage)] = e8;
        }
      }
      t6.childOffset = i10, t6.childCount = c7.length - i10, t6.node && (t6.node.childCount = t6.childCount);
    }
    n10.nodes = u9, n10.children = c7, n10.parents = _6, this._updateParentBoundingInformation(h8[V2(s12, this._nodesPerPage)]);
  }
  _updateParentBoundingInformation(e7) {
    let t5 = e7;
    do {
      let e8 = null;
      const i9 = this._clientNodeLoader.indexSR, s12 = this._clientNodeLoader.renderSR, a10 = this._getNodeInternal(t5);
      if (null == a10)
        return;
      for (let l8 = 0; l8 < a10.childCount; l8++) {
        const a11 = this.getChildIndex(t5, l8), d7 = this._getNodeInternal(a11), h8 = null != d7 ? d7.ref || d7.node : null;
        if (null != h8 && h8.mbs[3] > 0)
          if (null == e8)
            e8 = q(h8.mbs, D2);
          else {
            const t6 = U2, o5 = Q, l9 = $;
            xn(h8.mbs, i9, t6, s12), xn(e8, i9, o5, s12), W(t6, o5, l9), xn(l9, s12, e8, i9);
          }
      }
      const d6 = a10.ref || a10.node;
      null != d6 && (null != e8 ? d6.mbs = q(e8, null != d6.mbs ? d6.mbs : _3()) : Qe(d6.mbs), Qe(d6.renderMbs), $e(d6.serviceObbInRenderSR), d6.geometryObb = null), this.invalidateNodeVisibilityCacheInternal(a10), t5 = this.getParentIndex(t5);
    } while (null != t5);
  }
  populateChildren(e7, t5) {
    const i9 = this._getNodeInternal(e7), n10 = this._getPage(e7);
    i9.childOffset = n10.children.length, i9.childCount = t5.length;
    for (let s12 = 0; s12 < t5.length; s12++) {
      const i10 = this._makeRefNode(t5[s12], e7);
      n10.children.push(i10);
    }
  }
  getNode(e7) {
    const t5 = this._getNodeInternal(e7);
    return null != t5 ? t5.node : null;
  }
  getIndexById(e7) {
    let t5;
    return this._forAllNodes((i9, n10) => {
      (null != i9.node && i9.node.id === e7 || null != i9.ref && i9.ref.id === e7) && (t5 = n10);
    }), t5;
  }
  getNodeById(e7) {
    const t5 = this.getIndexById(e7);
    return null != t5 && t5 >= 0 ? this.getNode(t5) : null;
  }
  getChildIndex(e7, t5) {
    const i9 = this._getPage(e7);
    if (null == i9)
      return -1;
    const n10 = i9.nodes[V2(e7, this._nodesPerPage)];
    return i9.children[n10.childOffset + t5];
  }
  getParentIndex(e7) {
    const t5 = this._getPage(e7);
    return null != t5 && e7 !== this._rootIndex ? t5.parents[V2(e7, this._nodesPerPage)] : null;
  }
  getParent(e7) {
    const t5 = this.getParentIndex(e7);
    return null != t5 ? this.getNode(t5) : null;
  }
  isLeaf(e7) {
    const t5 = this._getNodeInternal(e7);
    return null != t5 && 0 === t5.childCount;
  }
  get rootNode() {
    return this.getNode(this._rootIndex);
  }
  get size() {
    return this._nodeCount;
  }
  get isEditable() {
    return this._isEditable;
  }
  removeAllGeometryObbs() {
    this._forAllNodes((e7) => {
      null != e7.node && (e7.node.geometryObb = null);
    });
  }
  invalidateVisibilityCache() {
    this._visibilityCacheVersion = w4(this._visibilityCacheVersion);
  }
  invalidateNodeVisibilityCache(e7) {
    const t5 = this._getNodeInternal(e7);
    null != t5 && this.invalidateNodeVisibilityCacheInternal(t5);
  }
  invalidateNodeVisibilityCacheInternal(e7) {
    e7.visibilityCache = C4(this._visibilityCacheVersion);
  }
  invalidateBoundingVolumeCache(e7) {
    const t5 = this._getNodeInternal(e7);
    null != t5 && (I5(t5), this.invalidateNodeVisibilityCacheInternal(t5));
  }
  updateElevationChanged(e7) {
    const t5 = this._getNodeInternal(e7);
    if (null == t5)
      return;
    if (!this.needNodeElevationRange)
      return void this.invalidateBoundingVolumeCache(e7);
    const i9 = null != t5.node ? t5.node : t5.ref;
    if (null == i9)
      return;
    const n10 = i9.elevationRange;
    null != n10 && (n10.valid = false);
  }
  invalidateGeometryVisibility(e7) {
    const t5 = this._getNodeInternal(e7);
    null != t5 && null != t5.node && (t5.node.geometryObb = null, Qe(t5.node.renderMbs), $e(t5.node.serviceObbInRenderSR));
  }
  invalidateVisibilityObbs() {
    null != this.rootNode && this.traverse(this.rootNode, (e7) => (e7.visibilityObb = this._computeVisibilityObb(e7), e7.geometryObb = null, true));
  }
  _updateElevationRange(e7) {
    const t5 = this._getNodeInternal(e7);
    if (null == t5)
      return null;
    const i9 = null != t5.node ? t5.node : t5.ref;
    if (null == i9)
      return null;
    const n10 = i9.elevationRange;
    if (null != n10 && n10.valid)
      return n10;
    const s12 = new i5();
    let o5 = false;
    for (let r7 = 0; r7 < t5.childCount; r7++) {
      const t6 = this._updateElevationRange(this.getChildIndex(e7, r7));
      null != t6 ? (s12.min = Math.min(s12.min, t6.min), s12.max = Math.max(s12.max, t6.max)) : o5 = true;
    }
    if (0 === t5.childCount || o5 && null != t5.node && t5.node.resources.geometry) {
      const e8 = this._viewportQueries.getElevationRange(i9);
      null != e8 && (s12.min = Math.min(s12.min, e8.min), s12.max = Math.max(s12.max, e8.max));
    }
    return null != n10 && n10.min === s12.min && n10.max === s12.max ? (n10.valid = true, n10) : (s12.valid = true, null != t5.node && (t5.node.elevationRange = s12), null != t5.ref && (t5.ref.elevationRange = s12), this.invalidateBoundingVolumeCache(e7), s12);
  }
  isNodeVisible(e7) {
    const t5 = this._getNodeInternal(e7);
    if (null == t5 || null != t5.ref && !t5.ref.mbs)
      return true;
    if (this.needNodeElevationRange && this._updateElevationRange(e7), !S2(t5.visibilityCache, this._visibilityCacheVersion)) {
      const e8 = t5.node, i9 = !e8 || t5.ref && !e8.visibilityObb ? t5.ref ?? null : e8;
      if (this._layerHasFilter && this._computeNodeFiltering && (null != e8 || null != t5.ref) && t5.filterImpact === n6.NotChecked) {
        const i10 = null != e8 ? e8.mbs : null != t5.ref ? t5.ref.mbs : null;
        t5.filterImpact = null != i10 ? this._computeNodeFiltering(i10) : n6.Unmodified;
      }
      const n10 = null != e8 && t5.filterImpact === n6.Culled, s12 = !(null != e8 && e8.imModificationImpact === o.Culled) && (!i9 || this._viewportQueries.isNodeVisible(i9)) && !n10;
      return t5.visibilityCache = M3(s12, this._visibilityCacheVersion), s12;
    }
    return R(t5.visibilityCache);
  }
  isGeometryVisible(e7) {
    if (!this.isNodeVisible(e7))
      return false;
    const t5 = this._getNodeInternal(e7);
    return !!(null == t5 || null == t5.node || null == t5.node.geometryObb || this.layerHasModifications && t5.node.imModificationImpact === o.NotChecked) || this._viewportQueries.isGeometryVisible(t5.node);
  }
  _traverseCoverage(e7, t5, i9, n10, s12) {
    const o5 = this._getPage(e7);
    if (null == o5 || 0 === t5.childCount)
      return;
    const r7 = t5.childOffset + t5.childCount, l8 = new Array();
    for (let a10 = t5.childOffset; a10 < r7; ++a10) {
      const e8 = o5.children[a10], t6 = this._getNodeInternal(e8);
      null != t6 && null != t6.node && this.isGeometryVisible(e8) && l8.push(t6);
    }
    n10 /= l8.length;
    for (const a10 of l8) {
      const e8 = a10.node.index;
      this._isLoaded(e8) || this._isReloading(e8) ? (s12.delta = Math.max(s12.delta, i9), s12.coverage += n10) : this._traverseCoverage(e8, a10, i9 + 1, n10, s12);
    }
  }
  useNodeAsHole(e7) {
    if ("off" === this.holeFilling)
      return false;
    const t5 = this._getNodeInternal(e7);
    if (null == t5)
      return false;
    if ("always" === this.holeFilling)
      return true;
    if (S2(t5.useAsHole, this._version))
      return R(t5.useAsHole);
    const i9 = { delta: 0, coverage: 0 };
    this._traverseCoverage(e7, t5, 0, 1, i9);
    const n10 = i9.delta * i9.coverage <= 0.5;
    return t5.useAsHole = M3(n10, this._version), n10;
  }
  get maxLevel() {
    return this._maxLevel;
  }
  get dirty() {
    return this._dirty;
  }
  destroy() {
    this._updates.add.prune(), this._updates.update.prune();
  }
  requestUpdate() {
    this._dirty = true, this._indexMissing = 1, this._version = w4(this._version);
  }
  imModificationsChanged(e7) {
    this.layerHasModifications = e7, this._forAllNodes(({ node: e8 }) => {
      null != e8 && (e8.imModificationImpact = o.NotChecked, e8.visibilityObb = this._computeVisibilityObb(e8), e8.hasModifications && this.invalidateGeometryVisibility(e8.index));
    }), this.invalidateVisibilityCache();
  }
  layerFilterChanged(e7) {
    this._layerHasFilter = e7, this._forAllNodes((e8) => {
      if (null != e8) {
        e8.filterImpact = n6.NotChecked;
        const t5 = e8.node;
        null != t5 && this.invalidateNodeVisibilityCache(t5.index);
      }
    }), this.invalidateVisibilityCache();
  }
  update(e7, t5, i9) {
    if (!this._dirty)
      return;
    this._pageQueue.length > 0 && this._addQueuedPages(t5), this._maxUnloadedPrio = Number.NEGATIVE_INFINITY, this._maxProcessingPrio = Number.NEGATIVE_INFINITY, this._missing.clear(), this._prefetch.clear(), this._updates.reset(e7), P4.clear();
    let n10 = true;
    const s12 = new F2(), o5 = new F2(), r7 = this._imModificationUncategorized;
    r7.clear();
    const l8 = /* @__PURE__ */ new Set(), a10 = (a11, d7, h8) => {
      if (null == d7) {
        let e8 = this._entryPriority(a11);
        e8 === 1 / 0 && (e8 = this._entryPriority(h8));
        const t6 = E2(a11, this._nodesPerPage);
        return P4.set(t6, Math.max(e8, P4.get(t6) || 0)), this._loading.has(t6) || this._failedPages.has(t6) || this._missing.push(t6), void (this._maxProcessingPrio = Math.max(this._maxProcessingPrio, e8));
      }
      const u9 = d7.node;
      if (this._updateNodeFeatureEstimate(u9, o5), null == u9) {
        const e8 = this._entryPriority(a11);
        return this._loading.has(a11) || this._failedNodes.has(a11) || (this._missing.push(a11), P4.set(a11, e8)), void (this._maxProcessingPrio = Math.max(this._maxProcessingPrio, e8));
      }
      const c7 = this._getPage(a11);
      if (0 === this._missing.length && 0 === this._nodesPerPage)
        for (let e8 = 0; e8 < d7.childCount; e8++) {
          const t6 = c7.children[d7.childOffset + e8], i10 = this._getNodeInternal(t6);
          null == i10 || i10.node || this._loading.has(t6) || this._failedNodes.has(t6) || (P4.set(t6, this._entryPriority(t6)), this._prefetch.push(t6));
        }
      if (u9.failed || u9.resources.isEmpty)
        return void (n10 && d7.childCount > 0 && this._isSelected(u9) && (n10 = false));
      if (l8.add(u9.id), this._isLoaded(a11)) {
        if (s12.known += u9.memory, ++s12.knownNodes, this._isSelected(u9) ? d7.childCount > 0 && (n10 = false) : (s12.unremoved += u9.memory, n10 = false), this._needsUpdate(u9)) {
          const e8 = this._entryPriority(a11);
          P4.set(a11, e8), this._maxProcessingPrio = Math.max(this._maxProcessingPrio, e8), this._updates.update.push(a11);
        }
        return;
      }
      if (u9.memory && (s12.known += u9.memory, ++s12.knownNodes), !this._isSelected(u9))
        return void (this._isReloading(a11) && this._updates.remove.push(a11));
      if (d7.childCount > 0 && (n10 = false), u9.memory ? (s12.missing += u9.memory, s12.known += u9.memory, ++s12.knownNodes) : ++s12.missingNodes, e7.includes(u9.index))
        return this._maxProcessingPrio = Math.max(this._maxProcessingPrio, this._entryPriority(a11)), void (this._updates.cancel = this._updates.cancel.filter((e8) => e8 !== u9.index));
      if (!t5.done && this._enable(u9))
        return void t5.madeProgress();
      const _6 = this._entryPriority(a11);
      P4.set(a11, _6), this._maxProcessingPrio = Math.max(this._maxProcessingPrio, _6), this._updates.add.push(a11), this.layerHasModifications && i9 && null != u9 && u9.imModificationImpact === o.NotChecked && r7.push(a11);
    };
    this.traverseVisible(a10);
    const d6 = this._updates.add;
    d6.length > 0 && this.layerHasModifications && (r7.length > 0 && (i9 == null ? void 0 : i9(r7)), d6.filterInPlace((e8) => {
      const t6 = this._getNodeInternal(e8), i10 = null == t6 || null == t6.node || t6.node.imModificationImpact !== o.Culled;
      return i10 || this.invalidateNodeVisibilityCache(e8), i10;
    })), this._unloadedMemoryEstimate = s12.missing - s12.unremoved, s12.knownNodes > 3 && s12.missingNodes > 0 && (this._unloadedMemoryEstimate += s12.known / s12.knownNodes * s12.missingNodes), this._unloadedMemoryEstimate = 0.8 * Math.max(0, this._unloadedMemoryEstimate), this._featureEstimate.estimate = this._computeFeatureEstimate(o5), this._featureEstimate.leavesReached = n10, this._missing.sort((e8, t6) => e8 - t6), this._missing.filterInPlace((e8, t6) => t6 < 1 || this._missing.data[t6 - 1] !== e8), this._missing.sort((e8, t6) => P4.get(e8) - P4.get(t6)), this._missing.length > 0 && (this._maxUnloadedPrio = P4.get(this._missing.back()), this._prefetch.clear()), this._updates.add.filterInPlace((e8) => P4.get(e8) >= this._maxUnloadedPrio).sort((e8, t6) => P4.get(e8) - P4.get(t6)), this._updates.update.sort((e8, t6) => P4.get(e8) - P4.get(t6)), this._indexMissing = this._loading.size + this._missing.length, this._dirty = this._indexMissing > 0, P4.clear();
  }
  checkFeatureTarget(e7, t5) {
    const i9 = this._viewportQueries.updateScreenSpaceErrorBias(t5);
    let n10 = t5, s12 = t5, o5 = i9, r7 = 10;
    for (; r7--; ) {
      const i10 = new F2();
      this._updateFeatureEstimate(n10, i10);
      if (this._computeFeatureEstimate(i10) <= e7) {
        if (n10 >= t5 || i10.missingNodes > 0 || 0 === r7)
          break;
        o5 = n10, n10 = 0.5 * (n10 + s12);
      } else
        s12 = n10, n10 = 0.5 * (n10 + o5);
    }
    return this._version = w4(this._version), this._viewportQueries.updateScreenSpaceErrorBias(i9), Math.min(t5, n10);
  }
  _updateFeatureEstimate(e7, t5) {
    this._version = w4(this._version), this._viewportQueries.updateScreenSpaceErrorBias(e7), this.traverseVisible((e8, i9) => this._updateNodeFeatureEstimate(null != i9 ? i9.node : void 0, t5));
  }
  _updateNodeFeatureEstimate(e7, t5) {
    if (null != e7 && !e7.failed && null != e7.numFeatures)
      return this._isLoaded(e7.index) ? (t5.known += e7.numFeatures, ++t5.knownNodes, void (this._isSelected(e7) || (t5.unremoved += e7.numFeatures))) : void (this._isSelected(e7) && (null != e7.numFeatures ? (t5.missing += e7.numFeatures, t5.known += e7.numFeatures, ++t5.knownNodes) : ++t5.missingNodes));
  }
  _computeFeatureEstimate(e7) {
    let t5 = e7.known - e7.unremoved;
    return e7.knownNodes > 3 && e7.missingNodes > 0 && (t5 += e7.known / e7.knownNodes * e7.missingNodes), Math.max(0, t5);
  }
  load() {
    return this._load(this._missing);
  }
  prefetch() {
    return this._prefetch.sort((e7, t5) => P4.get(e7) - P4.get(t5)), this._load(this._prefetch);
  }
  _load(e7) {
    if (0 === e7.length || !this._canRequest())
      return false;
    for (; e7.length > 0 && this._canRequest(); )
      if (0 === this._nodesPerPage)
        this._loadNode(e7.pop());
      else {
        const t5 = e7.pop();
        t5 >= 0 ? this._loadPage(t5) : this._loadNode(t5);
      }
    return true;
  }
  get isLoading() {
    return this._indexMissing > 0;
  }
  get isPrefetching() {
    return this._prefetch.length > 0;
  }
  get indexLoading() {
    return this._loading.size;
  }
  get indexMissing() {
    return this._indexMissing;
  }
  get unloadedMemoryEstimate() {
    return this._unloadedMemoryEstimate;
  }
  get updates() {
    return this._updates;
  }
  get featureEstimate() {
    return this._featureEstimate;
  }
  get maxPriority() {
    return Math.max(this._maxProcessingPrio, this._maxUnloadedPrio);
  }
  nodeTraversalState(e7) {
    if (null == e7)
      return null;
    let t5 = this._nodeTraversalState.get(e7.index);
    if (t5 && S2(t5.version, this._version))
      return t5;
    const i9 = this._viewportQueries.getLodLevel(e7), n10 = this._viewportQueries.hasLOD(e7);
    let s12 = true;
    if (n10) {
      const t6 = this.getParentIndex(e7.index);
      if (null != t6) {
        const e8 = this._nodeTraversalState.get(t6);
        s12 = !!e8 && i9 > e8.lodLevel;
      } else
        s12 = i9 > 0;
    } else
      s12 = 0 === e7.childCount;
    return t5 ? (t5.lodLevel = i9, t5.isChosen = s12, t5.version = M3(true, this._version), t5) : (t5 = new d2(n10, s12, i9, M3(true, this._version)), this._nodeTraversalState.set(e7.index, t5), t5);
  }
  async _loadNode(e7) {
    this._loading.add(e7);
    const i9 = this._getNodeInternal(e7).ref;
    if (null == i9)
      return void this._failedNodes.add(e7);
    const n10 = i9.id, s12 = this._urlPrefix + n10, o5 = () => {
      this._loading.delete(e7), 0 === this._missing.length && 0 === this._loading.size && this.requestUpdate();
    };
    let r7 = null;
    try {
      r7 = e7 >= 0 ? await this._streamDataController.request(s12, "json") : await this._clientNodeLoader.loadNodeJSON(n10);
    } catch (d6) {
      return o5(), void (d(d6) || (this._logger.error("#loadNode()", this._layer, "Error loading node: " + s12), this._failedNodes.add(e7)));
    }
    o5();
    const l8 = this._validateNode(n10, r7);
    if (null == l8)
      return;
    l8.obb && this.invalidateNodeVisibilityCache(e7);
    const a10 = this._addNode(l8, e7);
    this.nodeTraversalState(a10);
  }
  _validateNode(e7, t5) {
    if (null == t5 || "object" != typeof t5 || t5.id !== e7)
      return this._logger.error("#validateNode()", this._layer, `Invalid node. Wrong type or wrong id "${e7}"`), null;
    if (!Array.isArray(t5.mbs))
      return this._logger.error("#validateNode()", this._layer, `Invalid bounding volume on node ${e7}.`), null;
    t5.sharedResource && "./shared" !== t5.sharedResource.href && "./shared/" !== t5.sharedResource.href && this._logger.warn("#validateNode()", this._layer, `Invalid shared resource href on node "${e7}"`);
    const i9 = t5.geometryData;
    null == i9 || Array.isArray(i9) && 0 === i9.length || Array.isArray(i9) && 1 === i9.length && "./geometries/0" === i9[0].href || this._logger.warn("#validateNode()", this._layer, `Invalid geometry data on node "${e7}"`);
    const n10 = t5.attributeData, s12 = this._layer.attributeStorageInfo;
    null == n10 || Array.isArray(n10) && !n10.some((e8, t6) => {
      var _a;
      return e8.href !== `./attributes/${((_a = s12 == null ? void 0 : s12[t6]) == null ? void 0 : _a.key) ?? `f_${t6}`}/0`;
    }) || this._logger.warn("#validateNode()", this._layer, `Invalid attribute data on node "${e7}"`), t5.featureData && t5.featureData.length > 1 && this._logger.warn("#validateNode()", this._layer, `Node ${e7} has ${t5.featureData.length} bundles. Only the first bundle will be loaded.`);
    const o5 = t5.hasOwnProperty("obb") && !this.ignoreServiceObb ? t5.obb : null, r7 = t5.featureData && 1 === t5.featureData.length && t5.featureData[0].featureRange ? t5.featureData[0].featureRange[1] - t5.featureData[0].featureRange[0] + 1 : void 0, l8 = (t6) => {
      if (null == t6)
        return null;
      const i10 = (t7) => this._logger.error("#validateNode()", this._layer, `Invalid node reference on node ${e7}: ${t7}`);
      if ("number" == typeof t6.id)
        i10(`id ${t6.id} is a number instead of a string.`);
      else if ("string" != typeof t6.id || !Array.isArray(t6.mbs))
        return i10("Missing or invalid id."), null;
      if (!Array.isArray(t6.mbs))
        return i10(`Invalid bounding volume on reference ${t6.id}.`), null;
      t6.href && t6.href !== "../" + t6.id && this._logger.error("#validateNode()", this._layer, `Invalid node href on node "${e7}"`);
      const n11 = t6.hasOwnProperty("obb") && !this.ignoreServiceObb ? t6.obb : null, s13 = new t2(`${t6.id}`, t6.mbs);
      return s13.serviceObb = n11, s13.visibilityObb = this._computeVisibilityObb(s13), s13;
    }, a10 = Array.isArray(t5.children) ? t5.children.map(l8).filter((e8) => null != e8) : null, d6 = t5.featureData && t5.featureData.length > 1, u9 = t5.isEmpty && true === t5.isEmpty;
    return { id: e7, mbs: t5.mbs, obb: o5, children: a10, resources: { isEmpty: !d6 && u9, hasSharedResource: null != t5.sharedResource, attributes: t5.attributeData ? e7 : void 0, texture: t5.textureData && t5.textureData.length > 0 ? e7 : void 0, geometry: null != t5.geometryData ? e7 : void 0 }, version: "string" == typeof t5.version ? t5.version : null, lodSelection: Array.isArray(t5.lodSelection) ? t5.lodSelection : null, numFeatures: r7 };
  }
  resetFailedNodes() {
    this._failedNodes.clear(), this._failedPages.clear(), this._forAllNodes((e7) => {
      null != e7.node && (e7.node.failed = false);
    });
  }
  _entryPriority(e7) {
    const t5 = this._getNodeInternal(e7), i9 = this.getParentIndex(e7);
    if (null == t5 || null == i9 && null == t5.node)
      return null == i9 ? 1 / 0 : this._entryPriority(i9);
    let n10 = 0;
    if (t5.node && null != i9) {
      const e8 = this._nodeTraversalState.get(i9);
      null != e8 && (n10 = e8.lodLevel);
    }
    let s12 = this.progressiveLoadPenalty;
    for (let r7 = e7; null != r7; r7 = this.getParentIndex(r7))
      if (this._isLoaded(r7)) {
        s12 = 0;
        break;
      }
    const o5 = null != t5.ref ? this._viewportQueries.distToPOI(t5.ref) : null != t5.node ? this._viewportQueries.distToPOI(t5.node) : 0;
    return -o5 - n10 * (o5 + this.progressiveLoadPenalty) + s12;
  }
  traverseVisible(e7) {
    const t5 = this._getNodeInternal(this._rootIndex);
    null != t5 ? this._traverseVisible(this._rootIndex, null, t5, e7) : e7(this._rootIndex, null, null);
  }
  _traverseVisible(e7, t5, i9, n10) {
    if (i9.node && 0 === i9.childCount)
      return void (this.isGeometryVisible(e7) && n10(e7, i9, t5));
    if (!this.isNodeVisible(e7))
      return;
    if (n10(e7, i9, t5), null == i9.node)
      return;
    const s12 = this.nodeTraversalState(i9.node);
    if ((s12 == null ? void 0 : s12.nodeHasLOD) && s12.lodLevel === this._maxLodLevel)
      return;
    const o5 = this._getPage(e7);
    for (let r7 = 0; r7 < i9.childCount; r7++) {
      const t6 = o5.children[i9.childOffset + r7], s13 = this._getNodeInternal(t6);
      null != s13 ? this._traverseVisible(t6, e7, s13, n10) : n10(t6, null, e7);
    }
  }
  traverse(e7, t5) {
    t5(e7) && this.traverseChildren(e7, t5);
  }
  traverseChildren(e7, t5) {
    const i9 = e7.index, n10 = this._getNodeInternal(i9);
    null != n10 && this._traverseChildren(i9, n10, t5);
  }
  _traverseChildren(e7, t5, i9) {
    const n10 = this._getPage(e7);
    if (null == n10)
      return;
    const s12 = t5.childOffset + t5.childCount;
    for (let o5 = t5.childOffset; o5 < s12; ++o5) {
      const e8 = n10.children[o5], t6 = this._getNodeInternal(e8);
      null != t6 && null != t6.node && i9(t6.node) && this._traverseChildren(e8, t6, i9);
    }
  }
  updateChildrenLoaded(e7, t5) {
    let i9 = this.getNode(e7);
    for (; null != i9; )
      i9.childrenLoaded += t5, i9 = this.getParent(i9.index);
  }
  checkChildrenLoadedInvariant() {
    if (null == this.rootNode)
      return true;
    const e7 = [], t5 = (i9) => {
      let n10 = this._isLoaded(i9.index) || this._isReloading(i9.index) ? 1 : 0;
      return this.traverseChildren(i9, (e8) => (n10 += t5(e8), false)), i9.childrenLoaded !== n10 && e7.push(i9.index), n10;
    };
    return t5(this.rootNode), e7.length && this._logger.error("childrenLoaded invariant broken at following nodes: " + e7.join(",")), e7.length > 0;
  }
  updateStats(e7) {
    if (this._updates.add.length > 0 && (e7.nodes += " + " + this._updates.add.length), (this._indexMissing || this._prefetch.length > 0) && (e7.index += " + " + this._indexMissing || this._prefetch.length), e7.prio = this._maxProcessingPrio, this._featureEstimate.estimate) {
      const t5 = this._featureEstimate.estimate - e7.features;
      t5 > 0 ? e7.features += " + " + t5 : t5 < 0 && (e7.features += " - " + -t5);
    }
  }
  updateElevationInfo(e7, t5) {
    this.needNodeElevationRange = t5 && !!e7 && ("relative-to-ground" === e7.mode || "on-the-ground" === e7.mode), this._viewportQueries.updateElevationInfo(e7), this.invalidateAllElevationRanges();
  }
  invalidateAllElevationRanges() {
    this._forAllNodes((e7) => {
      I5(e7), null != e7.node && (e7.node.elevationRange = null), null != e7.ref && (e7.ref.elevationRange = null);
    });
  }
  _forAllNodes(e7) {
    if (null != this._clientNodePage) {
      const t5 = this._clientNodePage;
      for (let i9 = 0; i9 < t5.nodes.length; i9++)
        e7(t5.nodes[i9], -(i9 + 1));
    }
    for (let t5 = 0; t5 < this._nodePages.length; t5++) {
      const i9 = this._nodePages[t5];
      if (i9) {
        const n10 = t5 * this._nodesPerPage;
        for (let t6 = 0; t6 < i9.nodes.length; t6++)
          e7(i9.nodes[t6], n10 + t6);
      }
    }
  }
  get test() {
    return { addNode: (e7, t5) => this._addNode(e7, t5) };
  }
};
var P4 = /* @__PURE__ */ new Map();
var x3 = class {
  constructor(t5) {
    this.missing = t5, this.update = new l2({ deallocator: null }), this.add = new l2({ deallocator: null }), this.remove = new l2({ deallocator: null }), this.cancel = [];
  }
  reset(e7) {
    this.add.clear(), this.update.clear(), this.cancel = e7;
  }
};
function I5(e7) {
  null != e7.node && (Qe(e7.node.renderMbs), $e(e7.node.serviceObbInRenderSR)), null != e7.ref && (Qe(e7.ref.renderMbs), $e(e7.ref.serviceObbInRenderSR));
}
function C4(e7) {
  return ke(e7, -2);
}
function w4(e7) {
  return ke(e7, 2);
}
function M3(e7, t5) {
  return t5 + (e7 ? 1 : 0);
}
function S2(e7, t5) {
  return (-2 & e7) === t5;
}
function R(e7) {
  return 1 == (1 & e7);
}
function E2(e7, t5) {
  return e7 < 0 ? -1 : 0 === t5 ? 0 : e7 / t5 | 0;
}
function O2(e7 = [], t5 = [], i9 = []) {
  return { nodes: e7, children: t5, parents: i9 };
}
function V2(e7, t5) {
  return e7 < 0 ? -e7 - 1 : 0 === t5 ? e7 : e7 % t5;
}
function L2(e7, t5, i9) {
  return -1 === t5 ? -(e7 + 1) : 0 === i9 ? e7 : t5 * i9 + e7;
}
var k = [["maxScreenThreshold", a5.MaxScreenThreshold], ["screenSpaceRelative", a5.ScreenSpaceRelative], ["removedFeatureDiameter", a5.RemovedFeatureDiameter], ["distanceRangeFromDefaultCamera", a5.DistanceRangeFromDefaultCamera]];
function A3(e7) {
  if (e7) {
    for (let t5 = 0; t5 < e7.length; t5++)
      for (const i9 of k)
        if (i9[0] === e7[t5].metricType)
          return { lodMetric: i9[1], maxError: e7[t5].maxError };
  }
  return { lodMetric: a5.None, maxError: 0 };
}
var F2 = class {
  constructor() {
    this.known = 0, this.knownNodes = 0, this.missing = 0, this.missingNodes = 0, this.unremoved = 0;
  }
};
function T2(e7) {
  return Math.sqrt(e7 * (4 / Math.PI));
}
var D2 = _3();
var U2 = _3();
var Q = _3();
var $ = _3();

// node_modules/@arcgis/core/views/3d/layers/support/I3SLayerView.js
var a8;
!function(a10) {
  a10[a10.FadeIn = 0] = "FadeIn", a10[a10.FadeOut = 1] = "FadeOut";
}(a8 || (a8 = {}));

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SLodHandling.js
var s9 = class {
  constructor(e7) {
    this._layerView = e7, this._lodGlobalDirty = false;
  }
  startNodeLoading(e7, i9, o5, s12) {
    this._maxLodLevel = s12.maxLodLevel, this._index = o5, this._isNodeInScaleBounds = e7, this._removeNodes = i9;
  }
  shouldLoadNode(e7) {
    if (null == e7)
      return false;
    const i9 = this._index.nodeTraversalState(e7);
    return !!this._isChosenMaxLOD(i9) || !!i9.isChosen && this._childrenRequireLoading(e7);
  }
  setLodGlobalDirty() {
    this._lodGlobalDirty = true;
  }
  get requiresLODGlobalHandling() {
    return null != this._index && true === this._lodGlobalDirty;
  }
  lodGlobalHandling(e7) {
    if (!this.requiresLODGlobalHandling)
      return false;
    this._lodGlobalDirty = false;
    const i9 = this._layerView.view.resourceController.memoryController.usedMemory, o5 = Math.max(0, Math.floor(10 * (i9 - 1)));
    d5.clear(), this._lodGlobalHandling(this._index.rootNode, o5, false, !!this._layerView.nodeCrossfadingEnabled);
    const s12 = d5.length;
    this._removeNodes(d5, e7);
    const t5 = d5.length < s12;
    return 0 !== d5.length && (this._lodGlobalDirty = true), d5.clear(), t5;
  }
  _lodGlobalHandling(e7, s12, t5, l8) {
    if (null == e7)
      return false;
    const r7 = e7.index, n10 = this._index, a10 = this._layerView, h8 = n10.nodeTraversalState(e7), u9 = this._isChosenMaxLOD(h8), _6 = e7.resources.isEmpty;
    if (u9 && _6)
      return e7.childrenLoaded > 0 && this._removeChildrenRecursive(e7), true;
    const c7 = a10.isNodeLoaded(r7);
    if (l8 && c7 && u9) {
      const i9 = !t5 && this.hasNoVisibleChildren(e7);
      a10.fadeNode(r7, a8.FadeIn, !i9);
    }
    const x5 = c7 && (!a10.isNodeFullyFadedIn || a10.isNodeFullyFadedIn(r7));
    if (c7 && (a10.updateNodeState(r7, u9 ? c3.Leaf : c3.Hole), u9))
      return x5 && this._removeChildrenRecursive(e7), x5;
    const L3 = e7.childCount > 0;
    let y7 = L3;
    if (L3)
      for (let i9 = 0; i9 < e7.childCount; i9++) {
        const e8 = n10.getChildIndex(r7, i9), o5 = n10.getNode(e8);
        if (null != o5) {
          !(!n10.isGeometryVisible(e8) || this._lodGlobalHandling(o5, s12, t5 || x5, l8)) && this._isNodeInScaleBounds(o5) && (y7 = false);
        } else
          n10.isNodeVisible(e8) && (y7 = false);
      }
    const N2 = c7 && !u9 && (y7 || d5.length < s12);
    N2 && d5.push(r7), !l8 || N2 || !c7 || t5 || y7 || a10.fadeNode(r7, a8.FadeIn, false);
    const m5 = e7.resources.isEmpty;
    return y7 || x5 && !N2 || m5;
  }
  _removeChildrenRecursive(e7) {
    this._index.traverseChildren(e7, (e8) => ((this._layerView.isNodeLoaded(e8.index) || this._layerView.isNodeReloading(e8.index)) && d5.push(e8.index), e8.childrenLoaded > 0));
  }
  hasNoVisibleChildren(e7) {
    let i9 = true;
    return this._index.traverseChildren(e7, (e8) => !(!i9 || !this._index.isNodeVisible(e8.index)) && (this._layerView.isNodeLoaded(e8.index) ? (i9 = false, false) : e8.childrenLoaded > 0)), i9;
  }
  _childrenRequireLoading(e7) {
    let i9 = false, o5 = true;
    return this._index.traverseChildren(e7, (e8) => {
      if (!o5 || !this._index.isNodeVisible(e8.index))
        return false;
      const s12 = this._index.nodeTraversalState(e8);
      return this._isChosenMaxLOD(s12) && this._index.isGeometryVisible(e8.index) && (i9 = true), this._layerView.isNodeLoaded(e8.index) ? (o5 = false, false) : e8.childrenLoaded > 0;
    }), o5 && i9;
  }
  _isChosenMaxLOD(e7) {
    return e7.isChosen && (!e7.nodeHasLOD || e7.lodLevel === this._maxLodLevel);
  }
};
var d5 = new l2({ deallocator: null });

// node_modules/@arcgis/core/views/3d/webgl-engine/core/material/RenderTexture.js
var s10 = class {
  constructor(s12, r7) {
    this._textureRep = s12, this.loadPromise = null, this._disposed = false;
    const i9 = this._textureRep.acquire(r7);
    T(i9) ? (i9.then((t5) => {
      this._disposed ? f(t5) : this._textureRef = t5;
    }), this.loadPromise = i9) : this._textureRef = i9;
  }
  dispose() {
    this._textureRef = f(this._textureRef), this._disposed = true;
  }
  get glTexture() {
    return null != this._textureRef ? this._textureRef.glTexture : null;
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SMaterialUtil.js
function g4(e7, o5) {
  const r7 = /* @__PURE__ */ new Map(), s12 = (e8, o6) => {
    if (null == e8)
      return -1;
    const a10 = r7.get(e8.id);
    if (a10)
      return a10.usage |= o6, a10.id;
    const s13 = r7.size;
    return r7.set(e8.id, { id: s13, usage: o6 }), s13;
  }, t5 = o5.pbrMetallicRoughness, l8 = t5 == null ? void 0 : t5.baseColorFactor, i9 = o5.emissiveFactor, u9 = u3({ normalTexture: o5.normalTexture, emissiveTexture: o5.emissiveTexture, emissiveFactor: o5.emissiveFactor, occlusionTexture: o5.occlusionTexture, metallicRoughnessTexture: t5 == null ? void 0 : t5.metallicRoughnessTexture, metallicFactor: t5 == null ? void 0 : t5.metallicFactor, roughnessFactor: t5 == null ? void 0 : t5.roughnessFactor }), p6 = u9 ? r4[0] : (t5 == null ? void 0 : t5.metallicFactor) ?? n9[0], g6 = u9 ? r4[1] : (t5 == null ? void 0 : t5.roughnessFactor) ?? n9[1], T6 = "mask" === o5.alphaMode ? s8.Color | s8.AlphaMask : s8.Color, x5 = { baseColorFactor: l8 ? [l8[0], l8[1], l8[2], l8[3]] : [1, 1, 1, 1], baseColorTextureId: s12(t5 && t5.baseColorTexture, T6), metallicRoughnessTextureId: s12(t5 && t5.metallicRoughnessTexture, s8.MetallicRoughness), metallicFactor: p6, roughnessFactor: g6 }, b7 = { alphaMode: o5.alphaMode, alphaCutoff: o5.alphaCutoff, doubleSided: o5.doubleSided, cullFace: "none" === o5.cullFace ? n7.None : "back" === o5.cullFace ? n7.Back : "front" === o5.cullFace ? n7.Front : n7.None, normalTextureId: s12(o5.normalTexture, s8.Normal), emissiveTextureId: s12(o5.emissiveTexture, s8.Emissive), occlusionTextureId: s12(o5.occlusionTexture, s8.Occlusion), emissiveFactor: i9 ? [i9[0], i9[1], i9[2]] : [0, 0, 0], metallicRoughness: x5, wrapTextures: false, hasParametersFromSource: u9 }, F4 = [];
  return r7.forEach(({ usage: o6 }, a10) => {
    const r8 = null != e7 && e7[a10] && e7[a10].formats, s13 = r8 ? h6(r8.map(({ name: e8, format: o7 }) => ({ name: e8, encoding: f4[o7] }))) : [];
    F4.push({ id: a10, usage: o6, encodings: s13 });
  }), { material: b7, textures: F4 };
}
function h6(e7) {
  return e7.sort((e8, o5) => e8.encoding - o5.encoding);
}
var f4 = { ktx2: e6.KTX2, basis: e6.Basis, dds: e6.DDS_S3TC, png: e6.PNG, jpg: e6.JPG, "ktx-etc2": e6.KTX_ETC2 };
var T3 = { [u2.KTX2_ENCODING]: e6.Basis, [u2.BASIS_ENCODING]: e6.Basis, [u2.DDS_ENCODING]: e6.DDS_S3TC, "image/png": e6.PNG, "image/jpg": e6.JPG, "image/jpeg": e6.JPG, "image/ktx": e6.KTX_ETC2 };
function x4(o5) {
  var _a, _b;
  const r7 = o5 && o5.materialDefinitions ? Object.keys(o5.materialDefinitions)[0] : null, s12 = o5 && o5.textureDefinitions ? Object.keys(o5.textureDefinitions)[0] : null, t5 = r7 ? (_a = o5.materialDefinitions) == null ? void 0 : _a[r7] : null, l8 = s12 ? (_b = o5.textureDefinitions) == null ? void 0 : _b[s12] : null, i9 = b5();
  if (null != t5) {
    const o6 = t5.params;
    o6.diffuse && (i9.metallicRoughness.baseColorFactor = [o6.diffuse[0], o6.diffuse[1], o6.diffuse[2], 1]), null != o6.doubleSided && (i9.doubleSided = o6.doubleSided, i9.cullFace = o6.doubleSided ? n7.None : n7.Back), "none" !== o6.cullFace && "front" !== o6.cullFace && "back" !== o6.cullFace || (i9.cullFace = "none" === o6.cullFace ? n7.None : "back" === o6.cullFace ? n7.Back : n7.Front), o6.transparency && (i9.metallicRoughness.baseColorFactor[3] = i2(1 - o6.transparency, 0, 1)), (o6.useVertexColorAlpha || i9.metallicRoughness.baseColorFactor[3] < 1) && (i9.alphaMode = "blend");
  }
  const u9 = [];
  if (null != l8) {
    const e7 = 0;
    !l8.wrap || "repeat" !== l8.wrap[0] && "repeat" !== l8.wrap[1] || (i9.wrapTextures = true);
    let o6 = s8.Color;
    "rgba" === l8.channels && (i9.alphaMode = "blend", o6 |= s8.AlphaMask);
    const r8 = l8.images.length - 1, s13 = l8.images[r8], t6 = (e8) => e8 && e8.split("/").pop(), n10 = Array.isArray(l8.encoding) ? h6(l8.encoding.map((e8, o7) => ({ name: t6(s13.href[o7]), encoding: T3[e8] || 0 }))) : [{ name: t6(s13.href), encoding: T3[l8.encoding] || 0 }];
    u9.push({ id: e7, usage: o6, encodings: n10 }), i9.metallicRoughness.baseColorTextureId = e7;
  }
  return { material: i9, textures: u9 };
}
var b5 = () => ({ alphaMode: "opaque", alphaCutoff: o3, doubleSided: true, cullFace: n7.None, normalTextureId: -1, emissiveTextureId: -1, occlusionTextureId: -1, emissiveFactor: [0, 0, 0], metallicRoughness: { baseColorFactor: [0.8, 0.8, 0.8, 1], baseColorTextureId: -1, metallicRoughnessTextureId: -1, metallicFactor: 0, roughnessFactor: 0.6 }, wrapTextures: false, hasParametersFromSource: true });
function F3(e7, o5, r7, s12) {
  if (null == e7 || null == e7.data)
    return null;
  const t5 = e7.data, l8 = s12.renderingContext.parameters.maxMaxAnisotropy, n10 = !e7.downsampled && l8 > 1, i9 = r7 || !o5.wrapTextures ? C5 : P5, c7 = w5(e7.encoding), m5 = e7.usage & s8.Color ? "opaque" === o5.alphaMode ? 3 : 4 : 3;
  return new w2(t5, { mipmap: n10, maxAnisotropy: l8, encoding: c7, wrap: i9, components: m5, noUnpackFlip: true });
}
var C5 = { s: D.CLAMP_TO_EDGE, t: D.CLAMP_TO_EDGE };
var P5 = { s: D.REPEAT, t: D.REPEAT };
function S3(o5, l8, n10, u9, c7, p6) {
  const g6 = p6.rendererTextureUsage, h8 = (e7) => R2(u9, n10, e7 & g6), f5 = l8.metallicRoughness.baseColorFactor, T6 = i2(l8.metallicRoughness.baseColorFactor[3], 0, 1);
  o5.baseColor = [f5[0], f5[1], f5[2], T6], o5.hasParametersFromSource = !!l8.hasParametersFromSource, o5.usePBR = p6.usePBR, o5.mrrFactors = [l8.metallicRoughness.metallicFactor, l8.metallicRoughness.roughnessFactor, l8.hasParametersFromSource ? r4[2] : n9[2]], o5.emissiveFactor = l8.emissiveFactor, o5.isIntegratedMesh = p6.isIntegratedMesh, o5.textureAlphaCutoff = "mask" === l8.alphaMode ? l8.alphaCutoff : o3, o5.alphaDiscardMode = "opaque" === l8.alphaMode ? i6.Opaque : "mask" === l8.alphaMode ? i6.Mask : i6.MaskBlend;
  const x5 = [], b7 = h8(s8.Color | s8.AlphaMask);
  null != b7 && (o5.baseColorTexture = new s10(c7, b7), x5.push(o5.baseColorTexture.loadPromise));
  const F4 = h8(s8.MetallicRoughness);
  null != F4 && (o5.metallicRoughnessTexture = new s10(c7, F4), x5.push(o5.metallicRoughnessTexture.loadPromise));
  const C6 = h8(s8.Emissive);
  null != C6 && (o5.emissionTexture = new s10(c7, C6), x5.push(o5.emissionTexture.loadPromise));
  const P6 = h8(s8.Occlusion);
  null != P6 && (o5.occlusionTexture = new s10(c7, P6), x5.push(o5.occlusionTexture.loadPromise));
  const S5 = h8(s8.Normal);
  return null != S5 && (o5.normalTexture = new s10(c7, S5), x5.push(o5.normalTexture.loadPromise)), o5.commonMaterialParameters.hasSlicePlane = p6.slicePlaneEnabled, o5.commonMaterialParameters.doubleSided = l8.doubleSided, o5.commonMaterialParameters.cullFace = l8.cullFace, o5.ellipsoidMode = a6(p6.viewSpatialReference), Promise.all(x5);
}
function M4(e7) {
  const a10 = !!e7.compressedTextureS3TC, r7 = !!e7.compressedTextureETC, s12 = has("disable-feature:i3s-basis") ? 0 : e6.Basis | e6.KTX2, t5 = e6.JPG | e6.PNG, l8 = s12 | e6.DDS_S3TC;
  return t5 | (a10 ? l8 : 0) | (r7 ? s12 : 0);
}
function D3(e7, o5) {
  if (null != o5)
    return e7.find((e8) => 0 != (e8.encoding & o5));
}
function R2(e7, o5, r7) {
  if (null == e7 || r7 === s8.None)
    return null;
  for (let a10 = 0; a10 < e7.length; a10++) {
    const s12 = e7[a10];
    if (null != s12 && 0 != (s12.usage & r7)) {
      const e8 = o5[a10];
      return null != e8 ? e8.id : null;
    }
  }
  return null;
}
function w5(e7) {
  switch (e7) {
    case e6.KTX2:
      return u2.KTX2_ENCODING;
    case e6.Basis:
      return u2.BASIS_ENCODING;
    case e6.DDS_S3TC:
      return u2.DDS_ENCODING;
    case e6.PNG:
      return "image/png";
    case e6.JPG:
      return "image/jpeg";
    case e6.KTX_ETC2:
      return "image/ktx";
    default:
      return "";
  }
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SNodeLoader.js
var c6 = class _c {
  constructor(e7, t5, r7, i9, o5, n10) {
    if (this._streamDataController = t5, this._logger = r7, this._defaultGeometrySchema = i9, this._requiredAttributes = o5, this._options = n10, this._logLayer = e7, this._layerUrl = e7.parsedUrl.path, this._geometryDefinitions = e7.geometryDefinitions, e7.materialDefinitions) {
      const t6 = e7.textureSetDefinitions;
      this._materialAndTextures = e7.materialDefinitions.map((e8) => g4(t6, e8));
    }
  }
  _load(e7, t5, r7) {
    return this._streamDataController.request(e7, t5, r7);
  }
  _loadAttribute(e7, t5, r7) {
    const i9 = `${this._layerUrl}/nodes/${e7.resources.attributes}/attributes/${t5.key}/0`;
    return this._load(i9, "binary", r7).then((e8) => I2(t5, e8));
  }
  loadAttributes(e7, t5, r7) {
    return j(t5.map((t6) => this._loadAttribute(e7, t6.attributeStorageInfo, r7))).then((r8) => {
      const i9 = {};
      for (let n10 = 0; n10 < t5.length; ++n10) {
        const s12 = r8[n10].value;
        if (s12)
          i9[t5[n10].name] = s12;
        else {
          if (d(r8[n10].error))
            throw r8[n10].error;
          this._logger.error("#loadAttributes", this._logLayer, `Failed to load attributeData for '${t5[n10].name}' on node '${e7.id}'`, r8[n10].error);
        }
      }
      return i9;
    });
  }
  async loadNodeData(r7, i9) {
    const o5 = null != this._requiredAttributes && r7.resources.attributes ? _2(this.loadAttributes(r7, this._requiredAttributes, i9)) : null, { bufferDefinition: n10, bufferIndex: s12 } = b6(this._geometryDefinitions, r7), a10 = !!r7.resources.geometry, l8 = a10 ? _2(this._loadGeometry(r7.resources.geometry, s12, i9)) : null, d6 = r7.resources.hasSharedResource ? await this._loadShared(r7, i9) : null, c7 = r7.resources.materialDefinition, y7 = this._materialAndTextures && null != c7 && c7 >= 0 ? this._materialAndTextures[c7] : null != d6 ? x4(d6) : null, D5 = y7 == null ? void 0 : y7.material, p6 = (y7 == null ? void 0 : y7.textures) ?? [], x5 = `${r7.id}`, A4 = !a10 && this._options.loadFeatureData, w6 = A4 ? await this._loadFeatureData(x5, i9) : null, T6 = A4 ? m4(w6) : h7(D5), $3 = null == T6 ? g5(w6) : null, j4 = p6.length > 0 ? _2(this.loadTextures(r7, p6, i9)) : null;
    let I6 = null, U3 = null;
    if (l8) {
      I6 = y3(await l8);
      const e7 = _5(this._defaultGeometrySchema, d6);
      U3 = p4(n10, e7);
    }
    const S5 = j4 ? y3(await j4) : null, q3 = o5 ? y3(await o5) : {}, B3 = q3 ? { attributeData: q3, loadedAttributes: this._requiredAttributes } : null;
    if (null != T6)
      return { geometryData: T6, attributeDataInfo: B3, geometryBuffer: I6, geometryDescriptor: U3, requiredTextures: p6, textureData: S5 };
    if (null != $3)
      return { pointData: $3, attributeDataInfo: B3, geometryBuffer: I6, geometryDescriptor: U3, requiredTextures: p6, textureData: S5 };
    throw new Error();
  }
  static _addAbsoluteHrefTexture(e7, t5) {
    const r7 = e7.textureDefinitions;
    if (null != r7)
      for (const i9 of Object.keys(r7))
        for (const e8 of r7[i9].images)
          Array.isArray(e8.href) ? e8.hrefConcat = e8.href.map((e9) => _(e9, t5)) : e8.hrefConcat = _(e8.href, t5);
  }
  static _fixTextureEncodings(e7) {
    const t5 = e7.textureDefinitions;
    if (null != t5)
      for (const r7 in t5) {
        const e8 = t5[r7];
        if (Array.isArray(e8.encoding))
          for (let t6 = 0; t6 < e8.encoding.length; t6++) {
            const r8 = e8.encoding[t6];
            "data:" === r8.substring(0, 5) && (e8.encoding[t6] = r8.substring(5));
          }
        else {
          const t6 = e8.encoding;
          "data:" === t6.substring(0, 5) && (e8.encoding = t6.substring(5));
        }
      }
  }
  _loadShared(e7, t5) {
    const r7 = `${this._layerUrl}/nodes/${e7.resources.geometry}/shared`;
    return this._load(r7, "json", t5).then((e8) => (_c._fixTextureEncodings(e8), _c._addAbsoluteHrefTexture(e8, r7), e8));
  }
  _loadTexture(e7, t5, r7, i9, o5, n10) {
    let a10 = false;
    return o5 === e6.DDS_S3TC || o5 === e6.KTX2 || o5 === e6.Basis ? this._load(e7, "binary", n10).then((e8) => ({ id: t5, usage: r7, data: e8, encoding: o5, downsampled: a10 })) : this._load(e7, "image", n10).then((e8) => {
      let n11 = e8;
      const s12 = 4096, u9 = 2;
      if (i9 && e8.width * e8.height >= s12) {
        const t6 = Math.ceil(e8.width / u9), r8 = Math.ceil(e8.height / u9), i10 = document.createElement("canvas");
        i10.width = t6, i10.height = r8;
        i10.getContext("2d").drawImage(e8, 0, 0, t6, r8), n11 = i10, a10 = true;
      }
      return { id: t5, usage: r7, data: n11, encoding: o5, downsampled: a10 };
    });
  }
  loadTextures(e7, t5, r7) {
    const i9 = !!this._options.uncompressedTextureDownsamplingEnabled, o5 = this._options.textureUsageMask;
    return Promise.all(t5.map((t6) => {
      if (0 == (t6.usage & o5))
        return null;
      const n10 = D3(t6.encodings, this._options.textureEncodings);
      if (null == n10)
        return this._logger.error("#loadTextures", this._logLayer, `No known encoding for texture found on node ${e7.id}`), Promise.reject();
      const s12 = e7.resources.texture || e7.id, a10 = `${this._layerUrl}/nodes/${s12}/textures/${n10.name}`;
      return this._loadTexture(a10, t6.id, t6.usage, i9, n10.encoding, r7);
    }));
  }
  _loadFeatureData(e7, t5) {
    const r7 = `${this._layerUrl}/nodes/${e7}/features/0`;
    return this._load(r7, "json", t5);
  }
  _loadGeometry(e7, t5, r7) {
    const i9 = `${this._layerUrl}/nodes/${e7}/geometries/${t5}`;
    return this._load(i9, "binary", r7);
  }
};
function h7(e7) {
  return { featureIds: [], geometries: [{ type: "ArrayBufferView", params: { material: e7 } }], featureDataPosition: [0, 0, 0] };
}
function m4(e7) {
  if (!e7)
    return null;
  for (const t5 of e7.featureData) {
    const e8 = t5.geometries;
    if (null != e8)
      for (const r7 of e8)
        return { featureIds: [t5.id], featureDataPosition: t5.position, geometries: [r7] };
  }
  return null;
}
function g5(e7) {
  if (!e7)
    return null;
  const t5 = new Array();
  for (const r7 of e7.featureData)
    null != r7.position && t5.push({ featureIds: [r7.id], featureDataPosition: r7.position, geometries: [] });
  return t5;
}
function _5(e7, t5) {
  if (!e7 || !t5 || !t5.materialDefinitions)
    return e7;
  const i9 = Object.keys(t5.materialDefinitions)[0];
  return !t5.materialDefinitions[i9].params.vertexRegions && e7.vertexAttributes.region && delete (e7 = a(e7)).vertexAttributes.region, e7;
}
function b6(e7, t5) {
  const r7 = { bufferDefinition: null, bufferIndex: 0 }, i9 = t5.resources.geometryDefinition;
  if (null == e7 || null == i9 || i9 < 0)
    return r7;
  const o5 = i9 >= 0 ? e7[i9].geometryBuffers : null;
  if (null == o5)
    return r7;
  for (let n10 = 0; n10 < o5.length; n10++) {
    const e8 = o5[n10];
    if (null == e8.compressedAttributes)
      r7.bufferIndex = n10, r7.bufferDefinition = o5[n10];
    else if ("draco" === e8.compressedAttributes.encoding && !has("disable-feature:i3s-draco"))
      return r7.bufferIndex = n10, r7.bufferDefinition = e8, r7;
  }
  return r7;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SStreamDataController.js
var r5 = class {
  constructor(e7, t5) {
    this._requester = e7, this._apiKey = t5, this._activeRequests = /* @__PURE__ */ new Set();
  }
  get busy() {
    return this._requester.busy;
  }
  request(r7, s12, o5) {
    const l8 = new AbortController(), a10 = h(o5, () => l8.abort()), n10 = { signal: l8.signal, query: { token: this._apiKey } }, i9 = this._requester.request(r7, s12, n10), u9 = { response: i9, abortController: l8, abortHandle: a10 };
    return this._activeRequests.add(u9), L(i9, () => {
      var _a;
      u9.abortController = null, (_a = u9.abortHandle) == null ? void 0 : _a.remove(), u9.abortHandle = null, this._activeRequests.delete(u9);
    }), i9;
  }
  cancelAll() {
    this._activeRequests.forEach((e7) => {
      var _a, _b;
      (_a = e7.abortController) == null ? void 0 : _a.abort(), e7.abortController = null, (_b = e7.abortHandle) == null ? void 0 : _b.remove();
    }), this._activeRequests.clear();
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SViewportQueries.js
var y6 = 1e5;
var B = class {
  constructor(e7, t5, i9, s12, n10, r7, o5, a10, c7 = {}) {
    this._indexSR = e7, this._renderCoordsHelper = t5, this._clippingArea = n10, this._elevationProvider = r7, this._viewingMode = o5, this._options = c7, this._frustum = I3(), this._useFrustumCulling = false, this._poi = n(), this._elevationContext = null, this.minDistance = 1 / 0, this.maxDistance = 0, this.maxLodLevel = 2, this._tmpObb = O(), this._tmp1 = n(), this._tmp2 = n(), this._tmp3 = n(), this._tmp0 = n(), this._screenspaceErrorBias = c7.screenspaceErrorBias || 1, this._progressiveLoadFactor = c7.progressiveLoadFactor || 1, this.updateCamera(i9, s12), this.engineSR = this._renderCoordsHelper.spatialReference, this.updateElevationInfo(a10), this._tmpPoint = Z(0, 0, 0, e7), this._isECEFOBBInLocalMode = this._indexSR.isWGS84 && (this.engineSR.isWebMercator || G(this.engineSR)), this._indexSREllipsoidRadius = A(this._indexSR).radius;
  }
  updateElevationInfo(e7) {
    null != e7 ? (this._elevationContext = o4.fromElevationInfo(e7), this._elevationContext.updateFeatureExpressionInfoContext(u5(d3(e7, false)))) : this._elevationContext = null;
  }
  updateCamera(e7, t5) {
    this._useFrustumCulling = t5, t5 && s6(e7.viewMatrix, e7.projectionMatrix, this._frustum), this._screenSizeFactor = 1 / (e7.perScreenPixelRatio / 2), this._camPos = e7.eye, this.minDistance = 1 / 0, this.maxDistance = 0;
  }
  setPointOfInterest(e7) {
    this._poi = e7;
  }
  updateScreenSpaceErrorBias(e7) {
    const t5 = this._screenspaceErrorBias;
    return this._screenspaceErrorBias = e7, t5;
  }
  updateClippingArea(e7) {
    this._clippingArea = e7;
  }
  getElevationRange(e7) {
    if (null == this._elevationContext)
      return null;
    const t5 = e7.mbs;
    if (!t5)
      return null;
    const i9 = "relative-to-scene" === this._elevationContext.mode ? "scene" : "ground";
    if (this._elevationProvider.getSphereElevationBounds)
      return this._elevationProvider.getSphereElevationBounds(t5, this._indexSR);
    const s12 = t5[0], n10 = t5[1], r7 = t5[2], o5 = this._elevationProvider.getElevation(s12, n10, r7, this._indexSR, i9);
    return null != o5 ? { min: o5, max: o5 } : null;
  }
  getRenderMbs(e7) {
    const t5 = e7.renderMbs;
    if (Pe(t5))
      return t5;
    if (e7.mbs && a3(t5, e7.mbs), this._elevationContext && e7.elevationRange && Number.isFinite(e7.elevationRange.min)) {
      let i9 = 0, s12 = 0;
      switch (this._elevationContext.mode) {
        case "relative-to-ground":
          i9 = this._elevationContext.geometryZWithOffset(t5[2], this._renderCoordsHelper) + e7.elevationRange.min - t5[2], s12 = e7.elevationRange.max - e7.elevationRange.min;
          break;
        case "on-the-ground":
          i9 = e7.elevationRange.min - t5[2], s12 = e7.elevationRange.max - e7.elevationRange.min;
      }
      t5[2] += i9 + 0.5 * s12, t5[3] += 0.5 * s12;
    } else
      this._elevationContext && t5[3] < y6 && (this._tmpPoint.x = t5[0], this._tmpPoint.y = t5[1], this._tmpPoint.z = t5[2], t5[2] = f2(this._tmpPoint, this._elevationProvider, this._elevationContext, this._renderCoordsHelper));
    return xn(t5, this._indexSR, t5, this.engineSR), t5;
  }
  getVisibilityObb(e7) {
    if (null != e7.visibilityObb)
      return e7.visibilityObb;
    const t5 = e7.serviceObb, i9 = 0.01 * this._indexSREllipsoidRadius;
    return null == t5 || !e7.mbs || !Be(t5) || this._isECEFOBBInLocalMode && t5.halfSize.some((e8) => e8 > i9) ? null : (e7.serviceObbInRenderSR = this._computeRenderObb(t5, e7.serviceObbInRenderSR, e7.mbs[3], e7.elevationRange), e7.serviceObbInRenderSR);
  }
  _computeRenderObb(e7, t5, i9, s12) {
    if (null == t5)
      t5 = O();
    else if (Be(t5))
      return t5;
    let n10 = 0, r7 = 0;
    if (this._elevationContext && null != s12 && Number.isFinite(s12.min))
      switch (this._elevationContext.mode) {
        case "relative-to-ground":
          n10 = this._elevationContext.geometryZWithOffset(e7.center[2], this._renderCoordsHelper) + s12.min - e7.center[2], r7 = s12.max - s12.min;
          break;
        case "on-the-ground":
          n10 = s12.min - e7.center[2], r7 = s12.max - s12.min;
      }
    else
      this._elevationContext && i9 < y6 && (this._tmpPoint.x = e7.center[0], this._tmpPoint.y = e7.center[1], this._tmpPoint.z = e7.center[2], n10 = f2(this._tmpPoint, this._elevationProvider, this._elevationContext, this._renderCoordsHelper) - e7.center[2]);
    return r7 > 0 ? (Ce(e7, this._indexSR, this._tmpObb, this.engineSR, n10), se(this._tmpObb, 0, r7, this._viewingMode, t5)) : Ce(e7, this._indexSR, t5, this.engineSR, n10), t5;
  }
  isNodeVisible(e7) {
    const t5 = this.getRenderMbs(e7);
    if (!this._isMBSinClippingArea(t5))
      return false;
    if (!this._useFrustumCulling)
      return true;
    const i9 = this.getVisibilityObb(e7);
    return null != i9 ? Z2(i9, this._frustum) : P2(this._frustum, C3(t5));
  }
  isGeometryVisible(e7) {
    if (!this._useFrustumCulling)
      return true;
    const t5 = e7.geometryObb;
    return null != t5 ? Z2(t5, this._frustum) : this.isNodeVisible(e7);
  }
  _isMBSinClippingArea(e7) {
    return null == this._clippingArea || te(this._clippingArea, e7) !== ee.OUTSIDE;
  }
  _screenSpaceDiameterMbs(t5, i9) {
    const s12 = this.getRenderMbs(t5), n10 = Math.sqrt(p3(s12, this._camPos)), r7 = n10 - s12[3];
    return this._updateMinMaxDistance(n10), r7 < 0 ? 0.5 * Number.MAX_VALUE : i9 / r7 * this._screenSizeFactor;
  }
  calcCameraDistance(e7) {
    return this.calcCameraDistanceToCenter(e7) - this.getRenderMbs(e7)[3];
  }
  calcCameraDistanceToCenter(e7) {
    const i9 = this.getRenderMbs(e7), s12 = x(i9, this._camPos);
    return this._updateMinMaxDistance(s12), s12;
  }
  calcAngleDependentLoD(e7) {
    const s12 = this.getRenderMbs(e7), n10 = s12[3], r7 = (Math.abs(s12[0] * (s12[0] - this._camPos[0]) + s12[1] * (s12[1] - this._camPos[1]) + s12[2] * (s12[2] - this._camPos[2])) / s4(s12) + n10) / x(s12, this._camPos);
    return Math.min(1, r7);
  }
  hasLOD(e7) {
    return e7.lodMetric !== a5.None;
  }
  _getDistancePlanarMode(e7, t5) {
    const i9 = e7[0] - t5[0], s12 = e7[1] - t5[1], n10 = e7[2] - t5[2], r7 = i9 * i9 + s12 * s12, o5 = t5[3];
    if (r7 <= o5 * o5)
      return Math.abs(n10);
    const a10 = Math.sqrt(r7) - o5;
    return Math.sqrt(n10 * n10 + a10 * a10);
  }
  _getDistanceGlobeMode(h8, c7) {
    const l8 = s4(c7), m5 = s4(h8) - l8;
    g(this._tmp0, h8, P(h8, c7) / v(h8));
    const u9 = p3(c7, this._tmp0), p6 = c7[3];
    if (u9 <= p6 * p6)
      return Math.abs(m5);
    {
      const e7 = g(this._tmp0, c7, 1 / l8), r7 = l8, u10 = p6 * p6 / 2 / r7, _6 = g(this._tmp1, e7, r7 - u10), d6 = h8, g6 = e3(this._tmp2, d6, _6), v2 = e3(this._tmp2, g6, g(this._tmp3, e7, P(e7, g6))), b7 = u(this._tmp2, _6, g(this._tmp2, v2, p6 / s4(v2)));
      let x5 = x(d6, b7);
      if (m5 >= 2e5) {
        const t5 = e3(this._tmp1, d6, b7);
        let s12 = P(t5, e7) / s4(t5);
        s12 < 0.08 && (s12 = 1e-4), x5 /= s12;
      }
      return x5;
    }
  }
  _getDistance(e7, t5) {
    return this.engineSR === c2(this.engineSR) ? this._getDistanceGlobeMode(e7, t5) : this._getDistancePlanarMode(e7, t5);
  }
  _updateMinMaxDistance(e7) {
    e7 > 0 ? (this.minDistance = Math.min(this.minDistance, e7), this.maxDistance = Math.max(this.maxDistance, e7)) : (this.minDistance = 0, this.maxDistance = Math.max(this.maxDistance, -e7));
  }
  getLodLevel(e7) {
    if (e7.lodMetric === a5.None)
      return 0;
    if (0 === e7.childCount)
      return this.maxLodLevel;
    if (this._useFrustumCulling && this._progressiveLoadFactor < 1) {
      const t5 = this._progressiveLoadFactor * this._screenspaceErrorBias, i9 = this._screenspaceErrorBias;
      return this.evaluateLODmetric(e7, t5) ? this.evaluateLODmetric(e7, i9) ? 2 : 1 : 0;
    }
    return this.evaluateLODmetric(e7, this._screenspaceErrorBias) ? this.maxLodLevel : 0;
  }
  evaluateLODmetric(e7, t5) {
    switch (e7.lodMetric) {
      case a5.ScreenSpaceRelative: {
        const i9 = this.getRenderMbs(e7), s12 = this._getDistance(this._camPos, i9), n10 = 2 * s12 / this._screenSizeFactor, r7 = s12 + i9[3];
        return this._updateMinMaxDistance(r7), e7.maxError * t5 <= n10;
      }
      case a5.MaxScreenThreshold: {
        let i9 = this._screenSpaceDiameterMbs(e7, e7.mbs[3] * t5);
        return this._options.angleDependentLoD && (i9 *= this.calcAngleDependentLoD(e7)), i9 < e7.maxError;
      }
      case a5.RemovedFeatureDiameter:
        return this._screenSpaceDiameterMbs(e7, e7.maxError) * t5 < 10;
      case a5.DistanceRangeFromDefaultCamera:
        return this.calcCameraDistance(e7) > e7.maxError * t5;
    }
    return false;
  }
  distToPOI(e7) {
    const i9 = this.getRenderMbs(e7);
    return x(i9, this._poi) - i9[3];
  }
  distCameraToPOI() {
    return x(this._camPos, this._poi);
  }
};

// node_modules/@arcgis/core/layers/graphics/controllers/I3SOnDemandController.js
var q2 = "esri.layers.graphics.controllers.I3SOnDemandController";
var j3 = s.getLogger(q2);
var Q2 = 100;
var T4 = 2;
var E3 = 1e4;
var H2 = 1e-4;
var k2 = 1.2;
var R3 = 500;
var B2 = 1.5;
var z2 = class extends m3(m) {
  get isMeshPyramid() {
    var _a;
    return "mesh-pyramids" === this.layer.profile || "MeshPyramid" === ((_a = this.layer.store) == null ? void 0 : _a.lodType);
  }
  get isGraphics3D() {
    return "points" === this.layer.profile;
  }
  get useMaximumNumberOfFeatures() {
    return !this.isMeshPyramid && (null == this.layer.priority || "High" === this.layer.priority);
  }
  get indexStreamController() {
    const e7 = this.layerView.view.resourceController.createStreamDataRequester(A2.I3S_INDEX);
    return new r5(e7, this.layer.apiKey);
  }
  get dataStreamController() {
    const e7 = this.layerView.view.resourceController.createStreamDataRequester(A2.I3S_DATA);
    return new r5(e7, this.layer.apiKey);
  }
  get crsVertex() {
    return me(this.layer);
  }
  get crsIndex() {
    return pe(this.layer);
  }
  get layer() {
    return this.layerView.i3slayer;
  }
  get running() {
    return this.updating;
  }
  get rootNodeVisible() {
    if (null != this._index) {
      const e7 = this._index.rootNode;
      if (null != e7)
        return this._updateViewData(), this._index.isNodeVisible(e7.index);
    }
    return true;
  }
  get index() {
    return this._index;
  }
  constructor(e7) {
    super(e7), this.screenSizeFactor = 0, this.featureTarget = 5e4, this.fixedFeatureTarget = false, this.updating = true, this.updatingProgress = 1, this.leavesReached = false, this.scaleVisibilityEnabled = true, this.worker = null, this._featureLOD = 1, this._stableFeatureLOD = false, this._isIdle = false, this._cameraDirty = true, this._invisibleDirty = false, this._idleStateCallbacks = null, this._newLoadingNodes = new l2({ deallocator: null }), this._loadedNodeScales = /* @__PURE__ */ new Map(), this._modificationsNodeFilteringArray = new l2(), this._downloadingCount = 0, this._loadingNodes = /* @__PURE__ */ new Map(), this._updatingNodes = /* @__PURE__ */ new Map(), this._progressMaxNumNodes = 1, this._requiredAttributes = new Array(), this._requiredAttributesDirty = true, this._updatesDisabled = false, this.disableIDBCache = false, this._disableMemCache = false, this._restartNodeLoading = false, this._fields = null, this._attributeStorageInfo = null, this._handles = new t(), this._idleQueue = new n4(), this._elevationUpdateNodes = new l2({ deallocator: null }), this._errorCount = 0;
  }
  initialize() {
    const { layerView: e7, layer: t5 } = this;
    this._disableMemCache = !e7.loadCachedGPUData || !e7.addCachedGPUData, this._lodHandling = new s9(e7), this._defaultGeometrySchema = t5.store.defaultGeometrySchema, this.disableIDBCache = has("disable-feature:idb-cache"), "fields" in t5 && (this._fields = t5.fields, this._attributeStorageInfo = t5.attributeStorageInfo), this.addResolvingPromise(Promise.all([t5.indexInfo, t5.when(), e7.when()]).then(([i9]) => {
      if (this.destroyed || !e7 || e7.destroyed || !i9)
        return;
      const { view: s12, clientGeometry: r7 } = e7, { resourceController: a10 } = s12;
      if (this._setClippingArea(s12.clippingArea), this.addHandles([l4(() => {
        var _a, _b;
        return (_b = (_a = s12 == null ? void 0 : s12.pointsOfInterest) == null ? void 0 : _a.focus) == null ? void 0 : _b.renderLocation;
      }, (e8) => this._pointOfInterestChanged(e8), h2), l4(() => a10.memoryController.memoryFactor, () => this._setCameraDirty(), U), l4(() => e7.contentVisible, (e8) => {
        const t6 = e8 ? () => this._updateIdleState(true) : () => this._updateViewData(), i10 = e8 ? () => this._updateIdleState(false) : () => {
        };
        e8 && null != this._index && this._index.invalidateAllElevationRanges(), this._idleStateCallbacks ? (e8 || this.cancelNodeLoading(), this.restartNodeLoading(), this._idleStateCallbacks.idleBegin = t6, this._idleStateCallbacks.idleEnd = i10) : this._idleStateCallbacks = a10.scheduler.registerIdleStateCallbacks(t6, i10);
      }, h2), l7(e7.view.resourceController.scheduler, this), l4(() => e7.uncompressedTextureDownsamplingEnabled, () => this.restartNodeLoading()), l4(() => [this.featureTarget, this.fixedFeatureTarget], () => {
        this._setCameraDirty(), this._stableFeatureLOD = false;
      }), l4(() => {
        var _a;
        return (_a = s12.state) == null ? void 0 : _a.contentCamera;
      }, () => this._setCameraDirty()), l4(() => t5.elevationInfo, (e8) => this._elevationInfoChanged(e8)), l4(() => t5.effectiveScaleRange, () => this._scaleBoundsChanged()), l4(() => e7.lodFactor, () => this._setCameraDirty()), l4(() => e7.availableFields, () => this._requiredFieldsChange()), l4(() => e7.holeFilling, (e8) => null != this._index && (this._index.holeFilling = e8))]), this._updateScaleHandles(), this._viewportQueries = new B(this.crsIndex, s12.renderCoordsHelper, s12.state.contentCamera, !s12.state.fixedContentCamera || this.isGraphics3D, this._clippingArea, this.isMeshPyramid ? s12.basemapTerrain : s12.elevationProvider, o2(s12.viewingMode), this.layer.elevationInfo, { progressiveLoadFactor: this._getProgressiveLoadFactor(), screenspaceErrorBias: this._lod, angleDependentLoD: this._lod < 0.5 }), this._clientNodeLoader = new h5(this.layer.uid, this.crsIndex, s12.renderCoordsHelper.spatialReference, s12.state.viewingMode, s12.resourceController.memoryController, this.worker), this._index = new N(t5, i9, this.indexStreamController, this._clientNodeLoader, this._viewportQueries, j3, e7.holeFilling, (t6) => e7.isNodeLoaded(t6), (t6) => e7.isNodeReloading(t6), (e8) => this._shouldLoadNode(e8), (e8) => this._enableFromGPUCache(e8, c3.Leaf), (e8) => this._needsUpdate(e8), () => !this.indexStreamController.busy, (t6) => e7.computeVisibilityObb ? e7.computeVisibilityObb(t6) : null, (e7 == null ? void 0 : e7.computeNodeFiltering) ? (t6) => e7.computeNodeFiltering(t6) : void 0), this._index.updateElevationInfo(this.layer.elevationInfo, this.isMeshPyramid || this.isGraphics3D), this._index.imModificationsChanged(!!e7.hasModifications), this._index.layerFilterChanged(!!e7.hasGeometryFilter), null != r7) {
        for (const e8 of r7)
          this._addMesh(e8.mesh, e8.oid);
        this.addHandles(r7.on("change", (e8) => {
          for (const t6 of e8.removed)
            this._removeMesh(t6.oid);
          for (const t6 of e8.added)
            this._addMesh(t6.mesh, t6.oid);
        }));
      }
      this._startNodeLoading();
    })), this._tmpPoint = Z(0, 0, 0, this.crsIndex);
  }
  updateNodeModificationStatus(e7) {
    const t5 = this._index, i9 = this.layerView;
    null != t5 && (i9 == null ? void 0 : i9.updateNodeModificationStatus) && (this._modificationsNodeFilteringArray.clear(), e7.forAll((e8) => {
      const i10 = t5.getNode(e8);
      null != i10 && this._modificationsNodeFilteringArray.push(i10);
    }), i9.updateNodeModificationStatus(this._modificationsNodeFilteringArray), this._invisibleDirty = true);
  }
  destroy() {
    this.cancelNodeLoading(), this._idleStateCallbacks && (this._isIdle = false, this._idleStateCallbacks.remove(), this._idleStateCallbacks = null), this._handles.destroy(), this._nodeLoader = null, K.prune(), null != W2 && (W2.hide(), W2 = null);
  }
  _getRequiredAttributes() {
    if (null == this._attributeStorageInfo || !this._fields || !this.layerView.availableFields)
      return [];
    const e7 = this._attributeStorageInfo, t5 = this._fields, i9 = this.layer.objectIdField;
    return this.layerView.availableFields.map((i10) => {
      const s12 = $2(e7, i10), r7 = $2(t5, i10);
      return s12 >= 0 && r7 >= 0 ? { index: s12, name: t5[r7].name, field: t5[r7], attributeStorageInfo: e7[s12] } : null;
    }).filter((e8) => null != e8 && e8.name !== i9);
  }
  _requiredFieldsChange() {
    const e7 = this._getRequiredAttributes();
    X(this._requiredAttributes, e7) || (this._requiredAttributes = e7, this._requiredAttributesDirty = false, this.restartNodeLoading());
  }
  requestUpdate() {
    this._requiredAttributesDirty = true, this.restartNodeLoading();
  }
  _setClippingArea(e7) {
    const t5 = i3();
    u6(e7, t5, this.layerView.view.renderSpatialReference) ? this._clippingArea = t5 : this._clippingArea = null;
  }
  _pointOfInterestChanged(e7) {
    null != this._viewportQueries && (this._viewportQueries.setPointOfInterest(e7), null != this._index && (this._index.progressiveLoadPenalty = J.distancePenalty * this._viewportQueries.distCameraToPOI(), this._index.requestUpdate()));
  }
  updateClippingArea(e7) {
    this._setClippingArea(e7), null != this._viewportQueries && null != this._index && (this._viewportQueries.updateClippingArea(this._clippingArea), this._index.invalidateVisibilityCache()), this._setCameraDirty();
  }
  _setCameraDirty() {
    this._cameraDirty = true, this._lodHandling.setLodGlobalDirty(), this._evaluateUpdating();
  }
  _addMesh(e7, t5) {
    if (null == this._index)
      return;
    const i9 = this._clientNodeLoader.createMeshNodeInfo(e7, t5), s12 = this._index.addClientNodeToIndex(i9.id, i9.mbs);
    this._clientNodeLoader.addMeshNode(s12, i9), this._evaluateUpdating(), this.notifyChange("rootNodeVisible");
  }
  _removeMesh(e7) {
    const t5 = this._clientNodeLoader.getMeshNodeIndex(e7);
    if (null != t5) {
      if (null == this._index)
        throw new Error("delayed removal of client side i3s node geometry not supported yet.");
      {
        const e8 = (e9, t6) => {
          var _a, _b, _c, _d;
          this.layerView.removeNode(t6), this._loadedNodeScales.delete(t6), this._clientNodeLoader.removeNode(e9), this.layerView.deleteCachedNodeData && null != e9 && this.layerView.deleteCachedNodeData(e9), (_d = (_c = this.layerView).deleteCachedGPUData) == null ? void 0 : _d.call(_c, (_b = (_a = this.layerView).loadCachedGPUData) == null ? void 0 : _b.call(_a, t6));
        }, i9 = (e9, t6, i10) => {
          this._clientNodeLoader.updateNodeIndex(e9, t6, i10), this.layerView.updateNodeIndex && this.layerView.updateNodeIndex(t6, i10);
        };
        this._index.removeClientNodeFromIndex(t5, e8, i9), this.notifyChange("rootNodeVisible");
      }
    }
  }
  updateElevationChanged(e7, t5) {
    const i9 = this._index;
    if (null == i9 || null == i9.rootNode || null == t5)
      return null;
    this.crsIndex.equals(t5) || (kn(e7, t5, Y, this.crsIndex), e7 = Y);
    const s12 = this._elevationUpdateNodes;
    return s12.clear(), H(e7, i9.rootNode, i9, (e8) => s12.push(e8.index)), s12.length && (s12.forAll((e8) => i9.updateElevationChanged(e8)), this._setCameraDirty()), s12;
  }
  removeAllGeometryObbs() {
    null != this._index && this._index.removeAllGeometryObbs();
  }
  getRenderMbs(e7) {
    return null != this._viewportQueries ? this._viewportQueries.getRenderMbs(e7) : null;
  }
  _elevationInfoChanged(e7) {
    null != this._index && (this._index.updateElevationInfo(e7, this.isMeshPyramid || this.isGraphics3D), this._setCameraDirty());
  }
  _updateScaleHandles() {
    const e7 = "scale-bounds";
    this._handles.remove(e7), this._areScaleBoundsActive && this._handles.add(this.layerView.view.basemapTerrain.on("scale-change", (e8) => this._scaleUpdateHandler(e8)), e7);
  }
  _scaleBoundsChanged() {
    this._areScaleBoundsActive || this._loadedNodeScales.clear(), this._updateScaleHandles(), this._setCameraDirty();
  }
  _scaleUpdateHandler(e7) {
    this._updateScaleInBoundingRect(e7.extent, e7.spatialReference), this._setCameraDirty();
  }
  _updateScaleInBoundingRect(e7, t5) {
    const i9 = this._index;
    if (null == i9)
      return;
    null != i9.rootNode && kn(e7, t5, Y, this.crsIndex) && this._loadedNodeScales.forEach((e8, t6) => {
      const s12 = i9.getNode(t6);
      null != s12 && b(Y, s12.mbs) && this._loadedNodeScales.set(t6, this._computeScale(s12));
    });
  }
  restartNodeLoading() {
    this._restartNodeLoading = true, this.cancelNodeLoading(), this._evaluateUpdating();
  }
  schedule(e7, t5) {
    return this._idleQueue.push(e7, t5);
  }
  reschedule(e7, t5) {
    return this._idleQueue.unshift(e7, t5);
  }
  get _isIntegratedMesh() {
    return "integrated-mesh" === this.layer.type;
  }
  get _areScaleBoundsActive() {
    const { minScale: e7, maxScale: t5 } = u4(this.layer);
    return this.scaleVisibilityEnabled && (e7 > 0 || t5 > 0);
  }
  get unloadedMemoryEstimate() {
    return null != this._index && this.layerView.contentVisible ? this._index.unloadedMemoryEstimate * this._lodDropFactor : 0;
  }
  async _loadNodeData(e7, t5) {
    return (e7.index < 0 ? this._clientNodeLoader : this._nodeLoader).loadNodeData(e7, t5);
  }
  async _loadAttributes(e7, t5, i9) {
    return (e7.index < 0 ? this._clientNodeLoader : this._nodeLoader).loadAttributes(e7, t5, i9);
  }
  get indexDepth() {
    return null != this._index ? this._index.maxLevel : 0;
  }
  set disableMemCache(e7) {
    this.layerView.loadCachedGPUData && this.layerView.addCachedGPUData || (this._disableMemCache = true), this._disableMemCache = e7;
  }
  runTask(e7, t5) {
    return this.layerView.contentVisible ? this.layerView.visible && null != this._index ? (this._processWithErrorLogging(e7, t5), this._index.maxPriority) : -1 / 0 : (this._updateViewData(), this._evaluateUpdating(), -1 / 0);
  }
  _processWithErrorLogging(e7, t5) {
    try {
      this._process(e7, t5);
    } catch (i9) {
      this._errorCount < 50 ? j3.error("Error during processing: " + i9) : 50 === this._errorCount && j3.error("Too many errors for this layer. Further errors will not be displayed."), this._errorCount++;
    }
  }
  _process(e7, t5) {
    this._restartNodeLoading && this._startNodeLoading(), null != this._nodeLoader && null != this._index && (this._updateViewData(), this._invisibleDirty && this._removeInvisibleNodes(e7) && (this._invisibleDirty = false), this._isIntegratedMesh && (e7.enabled = false), e7.run(() => this._processIndex(e7)), this._updateFeatureLOD(), e7.run(() => this._processCache(e7)), this._isIntegratedMesh && (e7.enabled = true), e7.run(() => this._processNodes(e7, t5)), this._idleQueue.runTask(e7), e7.run(() => this._prefetchIndex()), t5.numIndexLoading += this._index.indexLoading, t5.numNodesLoading += this._downloadingCount, e7.run(() => this._lodHandling.lodGlobalHandling(e7)), this._evaluateUpdating());
  }
  _processIndex(e7) {
    if (null == this._index)
      return false;
    if (this._index.dirty) {
      this._newLoadingNodes.clear(), this._index.update(Array.from(this._loadingNodes.keys()), e7, (e8) => this.updateNodeModificationStatus(e8)), this._disableMemCache || (this._newLoadingNodes.pushArray(this._index.updates.add.data, this._index.updates.add.length), this._newLoadingNodes.pushArray(this._index.updates.missing.data, this._index.updates.missing.length));
      const t5 = this._index.featureEstimate.leavesReached;
      this._index.isLoading || t5 === this._get("leavesReached") || this._set("leavesReached", t5);
    }
    return this._index.load();
  }
  _prefetchIndex() {
    return !(null == this._index || this._loadingNodes.size > 0 || this._index.updates.add.length > 0) && this._index.prefetch();
  }
  _updateFeatureLOD() {
    if (!this.useMaximumNumberOfFeatures || null == this._index || null == this._viewportQueries)
      return;
    const e7 = !this._index.isLoading, t5 = this.featureTarget * this._baseLOD, i9 = this._index.featureEstimate;
    if (i9.estimate = i9.estimate || t5 / 2, this._index.indexMissing > R3) {
      if (this._featureLOD <= H2)
        return;
      this._featureLOD /= B2, this._stableFeatureLOD = false;
    } else if (e7 && i9.estimate < t5) {
      if (i9.leavesReached || this._featureLOD >= E3 || this._stableFeatureLOD)
        return;
      const e8 = Math.min(10, Math.max(t5 / i9.estimate, 1.001));
      this._featureLOD *= e8;
      const s12 = this._lod, r7 = this._index.checkFeatureTarget(t5, s12);
      r7 !== s12 && (this._featureLOD = r7 / this._baseLOD, this._stableFeatureLOD = true);
    } else {
      if (!(i9.estimate > t5 * k2 || e7 && i9.estimate > t5))
        return;
      if (this._featureLOD <= H2)
        return;
      this._featureLOD /= 1 + 0.25 * (i9.estimate / t5 - 1), this._stableFeatureLOD = false;
    }
    this._featureLOD = Math.min(E3, Math.max(H2, this._featureLOD)), this._viewportQueries.updateScreenSpaceErrorBias(this._lod), this._index.requestUpdate();
  }
  _processCache(e7) {
    const t5 = this._index;
    if (null == t5)
      return false;
    for (; this._newLoadingNodes.length > 0 && !e7.done; ) {
      const i9 = this._newLoadingNodes.pop();
      for (let s12 = t5.getParent(i9); null != s12 && (!this.layerView.isNodeLoaded(s12.index) && this._isNodeInScaleBounds(s12)); s12 = t5.getParent(s12.index))
        if (this._enableFromGPUCache(s12, c3.Hole)) {
          e7.madeProgress();
          break;
        }
    }
    return e7.hasProgressed;
  }
  _processNodes(e7, t5) {
    if (null == this._index)
      return false;
    let i9 = (this._isIdle ? Q2 : T4) - this._loadingNodes.size;
    const s12 = this._index.updates;
    for (s12.cancel.forEach(this._cancelNode, this), s12.cancel = []; s12.remove.length > 0 && !e7.done; )
      this.layerView.removeNode(s12.remove.pop()), e7.madeProgress();
    for (; s12.update.length > 0 && !e7.done; ) {
      const t6 = this._index.getNode(s12.update.pop());
      null != t6 && (this._updateLoadedNode(t6), e7.madeProgress());
    }
    for (; s12.add.length > 0 && !e7.done && i9 > 0; ) {
      --i9;
      const r7 = this._index.getNode(s12.add.back());
      if (null == r7 || r7.cacheState !== s7.Cached && !this._hasNodeLoadToken(t5))
        break;
      s12.add.pop(), this._loadNode(r7), e7.madeProgress();
    }
    return e7.hasProgressed;
  }
  _cancelAllNodes() {
    this._loadingNodes.forEach((e7) => e7.abort()), this._loadingNodes.clear(), this._updatingNodes.forEach((e7) => e7.abort()), this._updatingNodes.clear();
  }
  _cancelNode(e7) {
    const t5 = this._loadingNodes.get(e7);
    t5 && (t5.abort(), this._loadingNodes.delete(e7));
  }
  _hasNodeLoadToken(e7) {
    return !(!this._isIdle && e7.numNodesLoading + this._loadingNodes.size >= T4) && (this._downloadingCount < I4 && !this.dataStreamController.busy);
  }
  _evaluateUpdating() {
    let e7 = false, t5 = 0;
    if (this.layerView) {
      if (this.layerView.contentVisible) {
        const i9 = (null != this._index ? this._index.indexMissing : 0) + 3 * (null != this._index ? this._index.updates.add.length : 0) + 2 * this._loadingNodes.size;
        e7 = !!(i9 > 0 || this._updatingNodes.size > 0 || this._restartNodeLoading || this._cameraDirty || this._idleQueue.running || this._lodHandling && this._lodHandling.requiresLODGlobalHandling || null != this._index && this._index.isPrefetching), 0 === i9 && (this._progressMaxNumNodes = 1), this._progressMaxNumNodes = Math.max(i9, this._progressMaxNumNodes), t5 = 1 - i9 / this._progressMaxNumNodes;
      } else
        e7 = this._cameraDirty, t5 = e7 ? 0 : 1;
      this.updating = e7, this.updatingProgress = t5;
    }
  }
  _updateViewData() {
    if (!this._cameraDirty || null == this._index || null == this._viewportQueries)
      return;
    const e7 = this.layerView.view, { contentCamera: t5, fixedContentCamera: i9 } = e7.state;
    this.screenSizeFactor = 1 / (t5.perScreenPixelRatio / 2), this._viewportQueries.updateCamera(t5, !i9 || this.isGraphics3D), this._viewportQueries.setPointOfInterest(e7.pointsOfInterest.focus.renderLocation), this._viewportQueries.updateScreenSpaceErrorBias(this._lod), this._index.invalidateVisibilityCache(), this._index.progressiveLoadPenalty = J.distancePenalty * this._viewportQueries.distCameraToPOI(), this._index.requestUpdate(), this._stableFeatureLOD = false, this._invisibleDirty = true, this._cameraDirty = false, this.notifyChange("rootNodeVisible");
  }
  _getProgressiveLoadFactor() {
    return this.layerView.view.resourceController.memoryController.memoryFactor < 1 ? 1 : this.layerView.progressiveLoadFactor;
  }
  get _lod() {
    return this._featureLOD * this._baseLOD;
  }
  get _baseLOD() {
    const e7 = this.layerView.lodFactor, t5 = this.layerView.view.resourceController.memoryController.memoryFactor;
    return this.fixedFeatureTarget ? 1 : (e7 > 0 ? e7 : 1) * t5;
  }
  get _lodDropFactor() {
    if (this.fixedFeatureTarget)
      return 1;
    const e7 = this.layerView.view.resourceController.memoryController;
    return (Math.min(e7.memoryFactor, 0.5) - e7.minQuality) / (0.5 - e7.minQuality);
  }
  isGeometryVisible(e7) {
    return null != this._index && this._index.isGeometryVisible(e7.index);
  }
  updateVisibility(e7) {
    null != this._index && this._index.invalidateNodeVisibilityCache(e7);
  }
  invalidateGeometryVisibility(e7) {
    null != this._index && this._index.invalidateGeometryVisibility(e7);
  }
  invalidateVisibilityObbs() {
    null != this._index && this._index.invalidateVisibilityObbs();
  }
  modificationsChanged() {
    null != this._index && this._index.imModificationsChanged(!!this.layerView.hasModifications), this._invisibleDirty = true;
  }
  _shouldLoadNode(e7) {
    return !(!this._lodHandling.shouldLoadNode(e7) || this._shouldDropNode(e7)) && (!(null == this._index || !this._index.isGeometryVisible(e7.index)) && this._isNodeInScaleBounds(e7));
  }
  _shouldDropNode(e7) {
    if (null == this._viewportQueries)
      return false;
    const t5 = this._lodDropFactor;
    if (t5 >= 1 || !this._lodHandling.hasNoVisibleChildren(e7))
      return false;
    return Math.abs(this._viewportQueries.calcCameraDistanceToCenter(e7)) - this._viewportQueries.minDistance > (this._viewportQueries.maxDistance - this._viewportQueries.minDistance) * t5;
  }
  _startNodeLoading() {
    this._restartNodeLoading = false;
    const e7 = this._index;
    if (this._updatesDisabled || null == e7 || null == this._viewportQueries)
      return;
    this._updateViewData(), this._requiredAttributesDirty && (this._requiredAttributes = this._getRequiredAttributes(), this._requiredAttributesDirty = false);
    const t5 = { textureEncodings: this.layerView.supportedTextureEncodings, uncompressedTextureDownsamplingEnabled: this.layerView.uncompressedTextureDownsamplingEnabled, textureUsageMask: this.layerView.rendererTextureUsage, loadFeatureData: this.useMaximumNumberOfFeatures };
    this._nodeLoader = new c6(this.layer, this.dataStreamController, j3, this._defaultGeometrySchema, this._requiredAttributes, t5), e7.requestUpdate(), this._lodHandling.startNodeLoading((e8) => this._isNodeInScaleBounds(e8), (e8, t6) => this._removeNodes(e8, t6, Z3.fadeout), e7, { maxLodLevel: this._viewportQueries.maxLodLevel }), this._evaluateUpdating();
  }
  isNodeLoading() {
    return null != this._nodeLoader && null != this._index;
  }
  cancelNodeLoading() {
    this.isNodeLoading() && (this.indexStreamController.cancelAll(), this.dataStreamController.cancelAll(), this._idleQueue.cancelAll(), this._cancelAllNodes(), this._nodeLoader = null, this._evaluateUpdating());
  }
  _removeInvisibleNodes(e7) {
    const t5 = this._index;
    if (null == t5 || null == this._viewportQueries)
      return false;
    K.clear(), this.layerView.getLoadedNodeIndices(K);
    const i9 = 0 === this._viewportQueries.maxDistance, s12 = i9 ? () => false : (e8) => this._shouldDropNode(e8);
    return K.filterInPlace((e8) => {
      const i10 = t5.getNode(e8);
      return null == i10 || !t5.isGeometryVisible(e8) || s12(i10) || !this._isNodeInScaleBounds(i10);
    }), K.length > 0 && this._lodHandling.setLodGlobalDirty(), this._removeNodes(K, e7, Z3.pop), !(i9 && this._lodDropFactor < 1) && (0 === K.length || (K.clear(), false));
  }
  markNodeToRemove(e7) {
    K.push(e7);
  }
  removeMarkedNodes() {
    this._removeNodes(K, C2, Z3.pop);
  }
  _removeNodes(e7, t5, i9) {
    const s12 = e7.length;
    if (0 !== s12 && !t5.done) {
      for (null != this._index && this._index.requestUpdate(); e7.length > 0 && !t5.done; ) {
        const s13 = e7.pop(), r7 = this._index;
        i9 === Z3.fadeout && this.layerView.nodeFadeoutEnabled && null != r7 && r7.isGeometryVisible(s13) ? this.layerView.fadeNode(s13, a8.FadeOut, true) : this.layerView.removeNode(s13), t5.madeProgress();
      }
      if (this._loadedNodeScales.size > 0)
        for (let t6 = e7.length; t6 < s12; t6++) {
          const i10 = e7.data[t6];
          this._loadedNodeScales.delete(i10);
        }
    }
  }
  _needsUpdate(e7) {
    if (e7.resources.isEmpty || this._updatingNodes.has(e7.index))
      return false;
    const t5 = this.layerView.getLoadedAttributes(e7.index);
    return null != t5 && t5 !== this._requiredAttributes;
  }
  async _updateLoadedNode(e7) {
    const t5 = new AbortController();
    this._updatingNodes.set(e7.index, t5), this._evaluateUpdating();
    try {
      const i9 = X(this.layerView.getLoadedAttributes(e7.index), this._requiredAttributes);
      let s12 = null;
      s12 = i9 ? await Promise.resolve(this.layerView.getAttributeData(e7.index)) : await this._loadAttributes(e7, this._requiredAttributes, t5.signal), await this.schedule(() => this.layerView.updateAttributes(e7.index, { loadedAttributes: this._requiredAttributes, attributeData: s12 }, t5.signal), t5.signal);
    } catch (i9) {
      if (!d(i9))
        return this.layerView.updateAttributes(e7.index, { loadedAttributes: this._requiredAttributes, attributeData: {} }, t5.signal);
    }
    this._updatingNodes.delete(e7.index), this._evaluateUpdating();
  }
  _loadNode(e7) {
    if (this._loadingNodes.has(e7.index))
      return void j3.error("already loading node " + e7.index);
    const t5 = new AbortController();
    this._loadingNodes.set(e7.index, t5), this._evaluateUpdating(), this._loadAndAddNode(e7, t5.signal).then((i9) => {
      i9 && null != this._index && this._loadingNodes.get(e7.index) === t5 && (this._loadingNodes.delete(e7.index), this._index.requestUpdate());
    }).catch((e8) => {
      if (!d(e8))
        throw e8;
    }).finally(() => {
      this._loadingNodes.get(e7.index) === t5 && this._loadingNodes.delete(e7.index), this._evaluateUpdating();
    });
  }
  _loadAndAddNode(e7, t5) {
    return e7.cacheState === s7.Uncached ? this._loadUncached(e7, t5).then(() => false) : this._loadCached(e7, t5).then((t6) => !t6 && (e7.cacheState = s7.Uncached, true)).catch((t6) => !d(t6) && (e7.cacheState = s7.Uncached, true));
  }
  _enableFromGPUCache(e7, t5) {
    if (this._disableMemCache || null == this._index)
      return false;
    if (t5 === c3.Hole && !this._index.useNodeAsHole(e7.index))
      return true;
    const i9 = this._loadCachedGPUData(e7);
    return !!i9 && (this.layerView.addCachedGPUData(e7, i9, t5), this._nodeAdded(), true);
  }
  _loadCachedGPUData(e7) {
    const t5 = this.layerView.loadCachedGPUData(e7.index);
    return null != t5 && null != t5.attributeInfo && X(t5.attributeInfo.loadedAttributes, this._requiredAttributes) ? t5 : (this.layerView.deleteCachedGPUData(t5), null);
  }
  _nodeAdded() {
    null != this._index && this._index.requestUpdate(), this._lodHandling.setLodGlobalDirty(), this._evaluateUpdating();
  }
  updateLoadStatus(e7, t5) {
    const i9 = this._index;
    null != i9 && i9.updateChildrenLoaded(e7, t5 ? 1 : -1);
  }
  async _loadCached(e7, t5) {
    if (this._enableFromGPUCache(e7, c3.Leaf))
      return true;
    const i9 = this.layerView;
    if (this.disableIDBCache || !i9.loadCachedNodeData || !i9.addCachedNodeData)
      return false;
    const s12 = (t6, i10) => this._nodeLoader.loadTextures(e7, t6, i10), r7 = (t6, i10) => this._clientNodeLoader.loadTextures(e7, t6, i10), a10 = e7.index >= 0 ? s12 : r7, d6 = await this.schedule(() => i9.loadCachedNodeData(e7, t5, a10), t5);
    if (null == d6)
      return false;
    const o5 = this._requiredAttributes, n10 = await this.reschedule(() => this._loadAttributes(e7, o5, t5), t5);
    return await this.reschedule(() => i9.addCachedNodeData(e7, d6, { loadedAttributes: o5, attributeData: n10 }, t5), t5), this._nodeAdded(), true;
  }
  _loadUncached(e7, t5) {
    return this._downloadingCount++, this._loadNodeData(e7, t5).catch((e8) => {
      throw this._downloadingCount--, e8;
    }).then((i9) => (this._downloadingCount--, this.schedule(() => this.layerView.addNode(e7, i9, t5), t5))).then(() => {
      this._nodeAdded(), e7.cacheState = s7.Cached;
    }).catch((t6) => {
      if (!d(t6))
        throw j3.error("#loadNodeData()", this.layer, `Failed to load node '${e7.id}'`, t6), e7.failed = true, null != this._index && this._index.requestUpdate(), t6;
    });
  }
  _updateIdleState(e7) {
    e7 !== this._isIdle && (this._isIdle = e7, this._evaluateUpdating(), e7 && this._index && null != this._index && this._index.resetFailedNodes());
  }
  _getScale(e7) {
    if (this._loadedNodeScales.has(e7.index))
      return this._loadedNodeScales.get(e7.index);
    const t5 = this._computeScale(e7);
    return this.layerView.isNodeLoaded(e7.index) && this._loadedNodeScales.set(e7.index, t5), t5;
  }
  _computeScale(e7) {
    this._tmpPoint.x = e7.mbs[0], this._tmpPoint.y = e7.mbs[1], this._tmpPoint.z = e7.mbs[2];
    const t5 = e7.mbs[3];
    return this.layerView.view.basemapTerrain.getSphereScale(this._tmpPoint, t5);
  }
  _isNodeInScaleBounds(e7) {
    if (!this._areScaleBoundsActive)
      return true;
    const t5 = this._getScale(e7), { minScale: i9, maxScale: s12 } = u4(this.layer);
    return t3(t5, i9, s12);
  }
  updateStats(e7) {
    e7.index = null != this._index ? this._index.size : 0, this.isGraphics3D && (e7.detail = this._featureLOD, e7.target = this.featureTarget * this._baseLOD), null != this._index && this._index.updateStats(e7);
  }
  get test() {
    const e7 = this;
    return { index: this._index, set disableUpdates(t5) {
      e7._updatesDisabled = t5, t5 ? e7.cancelNodeLoading() : e7.requestUpdate();
    }, set disableIDBCache(t5) {
      e7.disableIDBCache = t5;
    }, set ignoreServiceObb(t5) {
      null != e7._index && (e7._index.ignoreServiceObb = t5);
    }, shouldLoadNode: (t5) => e7._shouldLoadNode(t5) };
  }
  notifyLODUpdate() {
    this._lodHandling.setLodGlobalDirty(), this._evaluateUpdating(), null != this._index && this._index.requestUpdate();
  }
  geometryFilterChanged(e7) {
    const t5 = this._index;
    null != t5 && t5.layerFilterChanged(e7), this._setCameraDirty();
  }
};
e([y2({ readOnly: true })], z2.prototype, "isMeshPyramid", null), e([y2({ readOnly: true })], z2.prototype, "isGraphics3D", null), e([y2({ readOnly: true })], z2.prototype, "useMaximumNumberOfFeatures", null), e([y2({ readOnly: true })], z2.prototype, "indexStreamController", null), e([y2({ readOnly: true })], z2.prototype, "dataStreamController", null), e([y2({ readOnly: true })], z2.prototype, "crsVertex", null), e([y2({ readOnly: true })], z2.prototype, "crsIndex", null), e([y2()], z2.prototype, "screenSizeFactor", void 0), e([y2()], z2.prototype, "featureTarget", void 0), e([y2()], z2.prototype, "fixedFeatureTarget", void 0), e([y2()], z2.prototype, "layerView", void 0), e([y2()], z2.prototype, "layer", null), e([y2()], z2.prototype, "updating", void 0), e([y2({ readOnly: true })], z2.prototype, "running", null), e([y2()], z2.prototype, "updatingProgress", void 0), e([y2({ readOnly: true })], z2.prototype, "leavesReached", void 0), e([y2({ constructOnly: true })], z2.prototype, "scaleVisibilityEnabled", void 0), e([y2({ constructOnly: true })], z2.prototype, "worker", void 0), e([y2({ readOnly: true, dependsOn: [] })], z2.prototype, "rootNodeVisible", null), z2 = e([a2(q2)], z2);
var K = new l2({ deallocator: null });
var W2;
function X(e7, t5) {
  return null != e7 && e7.length === t5.length && e7.every((e8) => $2(t5, e8.name) >= 0);
}
function $2(e7, t5) {
  const i9 = t5.toLowerCase();
  for (let s12 = 0; s12 < e7.length; s12++)
    if (e7[s12].name.toLowerCase() === i9)
      return s12;
  return -1;
}
var J = { factorIM: 0.2, factor3dObject: 0.05, distancePenalty: 10 };
var Y = i3();
var Z3;
!function(e7) {
  e7[e7.pop = 0] = "pop", e7[e7.fadeout = 1] = "fadeout";
}(Z3 || (Z3 = {}));
var ee2 = z2;

// node_modules/@arcgis/core/core/ReactiveSet.js
var s11 = class {
  constructor() {
    this._set = /* @__PURE__ */ new Set(), this._observable = new s5();
  }
  get size() {
    return i(this._observable), this._set.size;
  }
  add(t5) {
    const e7 = this._set.size;
    return this._set.add(t5), this._set.size !== e7 && this._observable.notify(), this;
  }
  clear() {
    this._set.size > 0 && (this._set.clear(), this._observable.notify());
  }
  delete(t5) {
    const e7 = this._set.delete(t5);
    return e7 && this._observable.notify(), e7;
  }
  entries() {
    return i(this._observable), this._set.entries();
  }
  forEach(e7, s12) {
    i(this._observable), this._set.forEach((t5, r7) => e7.call(s12, t5, r7, this), s12);
  }
  has(e7) {
    return i(this._observable), this._set.has(e7);
  }
  keys() {
    return i(this._observable), this._set.keys();
  }
  values() {
    return i(this._observable), this._set.values();
  }
  [Symbol.iterator]() {
    return i(this._observable), this._set[Symbol.iterator]();
  }
  get [Symbol.toStringTag]() {
    return this._set[Symbol.toStringTag];
  }
};

// node_modules/@arcgis/core/layers/support/featureQueryAll.js
async function r6(e7, r7, a10) {
  r7 = r7.clone(), e7.capabilities.query.supportsMaxRecordCountFactor && (r7.maxRecordCountFactor = u8(e7));
  const n10 = t4(e7), o5 = e7.capabilities.query.supportsPagination;
  r7.start = 0, r7.num = n10;
  let i9 = null;
  for (; ; ) {
    const t5 = await e7.source.queryFeaturesJSON(r7, a10);
    if (null == i9 ? i9 = t5 : i9.features = i9.features.concat(t5.features), i9.exceededTransferLimit = t5.exceededTransferLimit, !o5 || !t5.exceededTransferLimit)
      break;
    r7.start += n10;
  }
  return i9;
}
function t4(e7) {
  return u8(e7) * a9(e7);
}
function a9(e7) {
  return e7.capabilities.query.maxRecordCount || 2e3;
}
function u8(r7) {
  return r7.capabilities.query.supportsMaxRecordCountFactor ? b3.MAX_MAX_RECORD_COUNT_FACTOR : 1;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SOverrides.js
var G2 = "esri.views.3d.layers.i3s.I3SOverrides";
var D4 = class extends m {
  constructor(e7) {
    super(e7), this._warnMaximumChangedObjectsExceeded = false, this._maximumNumberOfEditOVerrides = T5, this._original3DOFLDefinitionExpression = null, this._interactiveEditingSessions = new V(), this.geometryOverrides = new V(), this._clientGeometryCache = /* @__PURE__ */ new Map(), this._associatedLayerView = null, this._attributeChangedObjectIds = new s11(), this._geometryChangedObjectIds = new s11(), this._pendingFetchChangedObjectIds = null, this._pendingFetchAbortController = new AbortController(), this._pendingAttributeQueriesCache = /* @__PURE__ */ new Map();
  }
  initialize() {
    var _a;
    this._memCache = this.memoryController.newCache(`i3s-attribute-overrides-${this.layer.uid}`), this._pendingFetchChangedObjectIds = this._fetchChangedObjectIds((_a = this._pendingFetchAbortController) == null ? void 0 : _a.signal), this._pendingFetchChangedObjectIds.finally(() => {
      this._pendingFetchAbortController = null, this._pendingFetchChangedObjectIds = null;
    }), this.is3DOFL && null != this._associatedLayer && (a4() ? this._associatedLayer.load().then((e7) => {
      this.destroyed || (this._original3DOFLDefinitionExpression = e7.definitionExpression, this.addHandles(l4(() => this._definitionExpression, (t5) => e7.definitionExpression = t5, h2)), this._associatedLayerView = new l6({ layer: this._associatedLayer, view: this.view }));
    }) : r2());
  }
  destroy() {
    this.is3DOFL && null != this._associatedLayer && (a4() ? null != this._associatedLayerView && (this._associatedLayer.definitionExpression = this._original3DOFLDefinitionExpression) : r2()), this._set("layer", null), this._memCache = l(this._memCache), this._pendingFetchAbortController = e2(this._pendingFetchAbortController), this._pendingFetchChangedObjectIds = null, this._pendingAttributeQueriesCache.clear();
  }
  get is3DOFL() {
    return n3() && null != this._associatedLayer && null != this._associatedLayer.infoFor3D;
  }
  get sortedGeometryChangedObjectIds() {
    return this.is3DOFL ? [...this._geometryChangedObjectIds].sort((e7, t5) => e7 - t5) : [];
  }
  get _associatedLayer() {
    return null == this.layer ? null : this.layer.associatedLayer;
  }
  get hasGeometryChanges() {
    return this._geometryChangedObjectIds.size > 0;
  }
  get _definitionExpression() {
    const e7 = this.sortedGeometryChangedObjectIds;
    return 0 === e7.length ? "1 = 0" : `OBJECTID IN (${e7.join(",")})`;
  }
  get updating() {
    if (!this.is3DOFL)
      return false;
    if (a4()) {
      return !(null != this._associatedLayerView) || null != this._associatedLayerView && this._associatedLayerView.updating;
    }
    return r2(), false;
  }
  get isEmpty() {
    return null == this._pendingFetchChangedObjectIds && 0 === this._attributeChangedObjectIds.size && 0 === this._geometryChangedObjectIds.size;
  }
  featureHasGeometryChanges(e7) {
    return this._geometryChangedObjectIds.has(e7);
  }
  featureHasAttributeChanges(e7) {
    return this._attributeChangedObjectIds.has(e7);
  }
  createInteractiveEditSession(e7) {
    this._attributeChangedObjectIds.add(e7);
    const t5 = n3() && r2() && null != this.is3DOFL, s12 = this._interactiveEditingSessions, r7 = new S4(e7, { rollback: () => {
      s12.remove(r7);
    }, commit: (s13, r8) => {
      for (const [t6, i9] of s13)
        this.updateAttributeValue(e7, t6, i9);
      t5 && null != r8 && this.updateGeometry(e7, r8);
    } });
    return s12.unshift(r7), r7;
  }
  async applyAttributeOverrides(e7, t5, s12) {
    if (null == t5)
      return;
    const { loadedAttributes: r7, attributeData: i9 } = t5;
    if (null == r7 || 0 === r7.length || null == i9)
      return;
    if (this._pendingFetchChangedObjectIds && await p2(this._pendingFetchChangedObjectIds, s12), 0 === this._attributeChangedObjectIds.size)
      return;
    const o5 = { loadedAttributes: r7, attributeData: i9 }, n10 = this._getOverridesFromCache(e7, o5, this._attributeChangedObjectIds), { objectIds: a10, fieldNames: d6 } = n10;
    if (0 === a10.length || 0 === d6.length)
      return;
    const c7 = await this._queryAttributeOverridesFromAssociatedLayer(a10, d6, s12);
    null != c7 && this._processOverridesFromAssociatedLayer(e7, c7, d6, o5);
  }
  updateGeometry(e7, t5) {
    this._geometryChangedObjectIds.add(e7);
    const s12 = this._clientGeometryCache.get(e7);
    if (null != s12 && (this.geometryOverrides.remove(s12), this._clientGeometryCache.delete(e7)), null != t5) {
      const s13 = { oid: e7, mesh: t5 };
      this.geometryOverrides.add(s13), this._clientGeometryCache.set(e7, s13);
    }
  }
  updateAttributeValue(e7, t5, s12) {
    this._attributeChangedObjectIds.add(e7), this._cacheAttributeValue(e7, t5, s12);
  }
  featureAdded(e7) {
    this.is3DOFL && r2() && this._geometryChangedObjectIds.add(e7), this._attributeChangedObjectIds.add(e7);
  }
  _cacheAttributeValue(e7, t5, s12) {
    this._memCache.put(this._getAttributeCacheKey(e7, t5), s12, this._memCacheAttributeValueSize(s12));
  }
  _getOverridesFromCache(e7, { loadedAttributes: t5, attributeData: s12 }, r7) {
    const i9 = /* @__PURE__ */ new Set(), o5 = new Array();
    for (const a10 of t5)
      o5[a10.index] = s12[a10.name];
    const n10 = /* @__PURE__ */ new Set();
    for (let a10 = 0; a10 < e7.length; a10++) {
      const s13 = e7[a10];
      if (r7.has(s13))
        for (const e8 of t5) {
          const t6 = this._attributeFromCache(s13, e8.index);
          void 0 === t6 ? (i9.add(s13), n10.add(e8.name)) : o5[e8.index][a10] = t6;
        }
    }
    return { objectIds: Array.from(i9), fieldNames: Array.from(n10) };
  }
  _attributeFromCache(e7, t5) {
    const s12 = this._fromInteractiveEditingSession(e7, t5);
    if (void 0 !== s12)
      return s12;
    const r7 = this._getAttributeCacheKey(e7, t5);
    return this._memCache.get(r7);
  }
  _fromInteractiveEditingSession(e7, t5) {
    if (null != this._interactiveEditingSessions)
      for (const s12 of this._interactiveEditingSessions) {
        if (s12.objectId !== e7)
          continue;
        const r7 = s12.getAttribute(t5);
        if (void 0 !== r7)
          return r7;
      }
  }
  _getAttributeCacheKey(e7, t5) {
    return `${e7}-${t5}`;
  }
  async _queryAttributeOverridesFromAssociatedLayer(e7, t5, s12) {
    var _a;
    if (0 === e7.length)
      return null;
    this._logWarningIfMaximumObjectsExceeded();
    const { associatedLayer: r7 } = this.layer;
    if (null == r7)
      return null;
    const i9 = this._pendingAttributeQueriesCache, o5 = new Array(), n10 = /* @__PURE__ */ new Map();
    for (const g6 of e7) {
      const e8 = i9.get(g6);
      if (e8)
        o5.push(e8);
      else {
        const e9 = C();
        y(e9.promise), n10.set(g6, e9), i9.set(g6, e9.promise);
      }
    }
    const a10 = Array.from(n10.keys()), d6 = r7.createQuery(), { objectIdField: c7 } = r7, h8 = [c7, ...t5];
    d6.where = "1=1", d6.returnGeometry = false, d6.outFields = h8, d6.cacheHint = true, d6.objectIds = a10;
    const [l8, u9] = await Promise.all([this._executeBatchQuery(r7, a10, d6, s12), Promise.all(o5)]).then((e8) => (s3(s12), e8)).catch((e8) => {
      for (const [t6, s13] of n10)
        i9.delete(t6), s13.reject(e8);
      throw e8;
    }), y7 = [];
    for (const m5 of l8)
      if (m5.ok)
        for (const e8 of m5.value.features) {
          const t6 = e8, s13 = t6.attributes[c7];
          (_a = n10.get(s13)) == null ? void 0 : _a.resolve(t6), i9.delete(s13), n10.delete(s13), y7.push(t6);
        }
    for (const m5 of u9)
      m5 && y7.push(m5);
    for (const [m5, p6] of n10)
      i9.delete(m5), p6.resolve(null);
    return y7;
  }
  async _queryGeometryOverridesFromAssociatedLayer(e7, t5) {
    if (0 === e7.length || !this.is3DOFL || !r2())
      return null;
    this._logWarningIfMaximumObjectsExceeded();
    const s12 = this.layer.associatedLayer, { objectIdField: r7, globalIdField: i9 } = s12, o5 = [r7, ...null != i9 ? [i9] : []], n10 = s12.createQuery();
    n10.where = "1=1", n10.returnGeometry = true, n10.outFields = o5, n10.cacheHint = true, n10.objectIds = e7, n10.returnZ = s12.hasZ, n10.returnM = s12.hasM;
    const a10 = await this._executeBatchQuery(s12, e7, n10, t5), d6 = s12.infoFor3D, { spatialReference: c7 } = s12, h8 = [];
    for (const l8 of a10) {
      if (!l8.ok)
        continue;
      const e8 = l8.value, { assetMaps: t6, features: s13, globalIdFieldName: r8 } = e8;
      if (null == t6)
        continue;
      const i10 = M(d6, t6);
      for (const o6 of s13) {
        const e9 = S(o6, r8, c7, d6, i10), t7 = o6;
        null != e9 ? (t7.geometry = e9, h8.push(t7)) : t7.geometry = null;
      }
    }
    return h8;
  }
  _logWarningIfMaximumObjectsExceeded() {
    if (!this._warnMaximumChangedObjectsExceeded)
      return;
    this._warnMaximumChangedObjectsExceeded = false;
    let e7 = `The number of edited objects that are not yet cached in the scene service exceeds the maximum limit. Attribute changes will only be available for the first ${c(this._maximumNumberOfEditOVerrides)} objects. Please consider re-caching the scene service`;
    const t5 = this.layer.portalItem;
    t5 && t5.loaded ? e7 += ` (${t5.portal.url}/home/item.html?id=${t5.id}#settings)` : e7 += ` (${this.layer.parsedUrl.path})`, s.getLogger(G2).warn("#queryOverrides()", this.layer.title, `${e7}.`);
  }
  async _executeBatchQuery(e7, t5, s12, o5) {
    if (0 === t5.length)
      return [];
    const n10 = t4(e7);
    t5 = [...t5].sort((e8, t6) => e8 - t6);
    const a10 = p(t5, n10).map((t6) => {
      const r7 = s12.clone();
      return r7.objectIds = t6, b2(r6(e7, r7, { signal: o5 }));
    });
    return Promise.all(a10);
  }
  _processOverridesFromAssociatedLayer(e7, t5, s12, { loadedAttributes: r7, attributeData: i9 }) {
    const o5 = this._associatedLayer;
    if (null == o5)
      return;
    const n10 = o5.objectIdField, a10 = s12.map((t6) => (t6 in i9 || (i9[t6] = new Array(e7.length)), i9[t6])), d6 = new Map(r7.map((e8) => [e8.name, e8.index])), c7 = s12.map((e8) => d6.get(e8)), h8 = new Map(Array.from(e7, (e8, t6) => [e8, t6]));
    for (const l8 of t5) {
      const e8 = l8.attributes[n10];
      for (let t6 = 0; t6 < s12.length; t6++) {
        const r8 = c7[t6], i10 = h8.get(e8), o6 = l8.attributes[s12[t6]];
        a10[t6][i10] = o6, this._cacheAttributeValue(e8, r8, o6);
      }
    }
  }
  _memCacheAttributeValueSize(e7) {
    return "string" == typeof e7 ? r3(e7) : n5();
  }
  async _fetchChangedObjectIds(e7) {
    var _a, _b, _c, _d;
    const s12 = this.layer;
    await s12.load({ signal: e7 }), this._geometryChangedObjectIds.clear(), this._attributeChangedObjectIds.clear();
    const { associatedLayer: r7 } = s12;
    if (null == r7 || !((_b = (_a = r7.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsChangeTracking))
      return;
    const i9 = this._getFetchChangedObjectIdsServerGen();
    if (null == i9)
      return;
    const n10 = r7.layerId, a10 = this.is3DOFL, d6 = { f: "json", returnIdsOnly: true, layers: `[${n10}]`, returnUpdates: true, returnDeletes: a10, returnInserts: a10, layerServerGens: JSON.stringify([{ id: n10, serverGen: i9 }]) };
    if (a10) {
      const e8 = r7.infoFor3D;
      d6.fieldsToCompare = JSON.stringify({ fields: [...Object.values(e8.transformFieldRoles), e8.sourceHashField] });
    }
    const h8 = await _2(j2(`${r7.url}/extractChanges`, { method: "post", query: d6, timeout: M5, signal: e7 }));
    if (!h8.ok && m2(h8.error)) {
      const e8 = this.layer.title;
      s.getLogger(G2).warn("extractChanges:timeout", e8, `${e8} could not obtain edited features that are not cached in the scene service. Display of features may not be up to date with the latest edits. Consider re-caching the scene service.`);
    }
    if (h8.ok && 1 === ((_d = (_c = h8.value.data) == null ? void 0 : _c.edits) == null ? void 0 : _d.length)) {
      const t5 = h8.value.data.edits[0], s13 = t5 == null ? void 0 : t5.objectIds, i10 = t5 == null ? void 0 : t5.fieldUpdates, o5 = (s13 == null ? void 0 : s13.adds) ?? [], n11 = (s13 == null ? void 0 : s13.updates) ?? [], d7 = (s13 == null ? void 0 : s13.deletes) ?? [], c7 = [...o5, ...n11, ...d7], l8 = a10 ? [...o5, ...i10 ?? n11, ...d7] : [], u9 = Math.min(this._maximumNumberOfEditOVerrides, c7.length);
      u9 < c7.length && (this._warnMaximumChangedObjectsExceeded = true);
      const m5 = c7.sort((e8, t6) => e8 - t6);
      for (let e8 = 0; e8 < u9; ++e8) {
        const t6 = m5[e8];
        this._attributeChangedObjectIds.add(t6);
      }
      for (const e8 of l8)
        this._geometryChangedObjectIds.add(e8);
      if (this.is3DOFL && r2() && this._geometryChangedObjectIds.size > 0) {
        const t6 = await this._queryGeometryOverridesFromAssociatedLayer(Array.from(this._geometryChangedObjectIds), e7);
        if (null != t6)
          for (const e8 of t6)
            null != e8.geometry && this.updateGeometry(e8.attributes[r7.objectIdField], e8.geometry);
      }
    }
  }
  _getFetchChangedObjectIdsServerGen() {
    const e7 = this.layer;
    if (null != e7.serviceUpdateTimeStamp && null != e7.serviceUpdateTimeStamp.lastUpdate)
      return e7.serviceUpdateTimeStamp.lastUpdate;
    const t5 = e7.associatedLayer;
    return null != t5 && null != t5.serverGens && null != t5.serverGens.minServerGen ? t5.serverGens.minServerGen : null;
  }
  get test() {
    const e7 = Array.from(this._attributeChangedObjectIds), t5 = this._pendingFetchChangedObjectIds, s12 = this;
    return { changedObjectIds: e7, pendingFetchChangedObjectIds: t5, get maximumNumberOfEditOVerrides() {
      return s12._maximumNumberOfEditOVerrides;
    }, set maximumNumberOfEditOVerrides(e8) {
      s12._maximumNumberOfEditOVerrides = e8;
    } };
  }
};
e([y2({ constructOnly: true })], D4.prototype, "view", void 0), e([y2({ constructOnly: true })], D4.prototype, "layer", void 0), e([y2({ readOnly: true })], D4.prototype, "is3DOFL", null), e([y2()], D4.prototype, "_interactiveEditingSessions", void 0), e([y2({ readOnly: true })], D4.prototype, "sortedGeometryChangedObjectIds", null), e([y2({ readOnly: true })], D4.prototype, "geometryOverrides", void 0), e([y2()], D4.prototype, "_clientGeometryCache", void 0), e([y2()], D4.prototype, "_associatedLayer", null), e([y2()], D4.prototype, "_associatedLayerView", void 0), e([y2({ constructOnly: true })], D4.prototype, "memoryController", void 0), e([y2()], D4.prototype, "_attributeChangedObjectIds", void 0), e([y2()], D4.prototype, "_geometryChangedObjectIds", void 0), e([y2()], D4.prototype, "hasGeometryChanges", null), e([y2()], D4.prototype, "_pendingFetchChangedObjectIds", void 0), e([y2()], D4.prototype, "_pendingFetchAbortController", void 0), e([y2()], D4.prototype, "_definitionExpression", null), e([y2()], D4.prototype, "updating", null), e([y2()], D4.prototype, "isEmpty", null), D4 = e([a2(G2)], D4);
var S4 = class {
  constructor(e7, t5) {
    this.objectId = e7, this._options = t5, this._updates = /* @__PURE__ */ new Map(), this._updatedGeometry = void 0, this._state = V3.ACTIVE;
  }
  getAttribute(e7) {
    return this._updates.get(e7);
  }
  setAttribute(e7, t5) {
    this.isActive && this._updates.set(e7, t5);
  }
  getGeometry() {
    return this._updatedGeometry;
  }
  setGeometry(e7) {
    this.isActive && (this._updatedGeometry = e7);
  }
  rollback() {
    this.isActive && (this._state = V3.ROLLED_BACK, this._options.rollback(), this._updatedGeometry = void 0);
  }
  commit() {
    this.isActive && (this._state = V3.COMMITTED, this._options.commit(this._updates, this._updatedGeometry), this._updates.clear(), this._updatedGeometry = void 0);
  }
  get isActive() {
    return this._state === V3.ACTIVE;
  }
};
var V3;
!function(e7) {
  e7[e7.ACTIVE = 0] = "ACTIVE", e7[e7.COMMITTED = 1] = "COMMITTED", e7[e7.ROLLED_BACK = 2] = "ROLLED_BACK";
}(V3 || (V3 = {}));
var M5 = 1e4;
var T5 = 5e4;

export {
  e6 as e,
  s8 as s,
  a8 as a,
  b5 as b,
  F3 as F,
  S3 as S,
  M4 as M,
  D3 as D,
  ee2 as ee,
  s11 as s2,
  D4 as D2
};
//# sourceMappingURL=chunk-2HZ6BJUS.js.map
