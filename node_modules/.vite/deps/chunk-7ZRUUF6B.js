import {
  e as e6
} from "./chunk-XACNEHDM.js";
import {
  d,
  o as o2
} from "./chunk-VC3BY3DV.js";
import {
  e as e4
} from "./chunk-PV5KBAYL.js";
import {
  e as e3
} from "./chunk-YVVROPAO.js";
import {
  a
} from "./chunk-IVMJPIWO.js";
import {
  e as e5
} from "./chunk-WRFNQB7U.js";
import {
  o as o3
} from "./chunk-UUW6REOV.js";
import {
  s
} from "./chunk-Z3NHJA5D.js";
import {
  i2 as i
} from "./chunk-BO2REVMA.js";
import {
  n as n2,
  o
} from "./chunk-V66LHQVK.js";
import {
  e as e2
} from "./chunk-CW7LIPBH.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  e
} from "./chunk-7EG7BYWF.js";
import {
  n
} from "./chunk-CQX57DED.js";

// node_modules/@arcgis/core/chunks/Fog.glsl.js
var u = class extends n2 {
  constructor() {
    super(...arguments), this.fogColor = n(), this.fogStrength = 4e-6, this.atmosphereC = 1, this.fogAmount = 0;
  }
};
function h() {
  const r = new i();
  r.attributes.add(O.POSITION, "vec2"), r.include(o2, { textureCoordinateType: d.Default }), r.varyings.add("worldRay", "vec3"), r.varyings.add("eyeDir", "vec3");
  const { vertex: a2, fragment: c } = r;
  return a2.uniforms.add(new e4("inverseProjectionMatrix", (e7, r2) => r2.camera.inverseProjectionMatrix), new e4("inverseViewMatrix", (r2, a3) => e(w, a3.camera.viewMatrix))), a2.code.add(o`void main(void) {
vec3 posViewNear = (inverseProjectionMatrix * vec4(position, -1, 1)).xyz;
eyeDir = posViewNear;
worldRay = (inverseViewMatrix * vec4(posViewNear, 0)).xyz;
forwardTextureCoordinates();
gl_Position = vec4(position, 1, 1);
}`), c.uniforms.add(new o3("atmosphereC", (e7) => e7.atmosphereC), new e3("cameraPosition", (e7, r2) => r2.camera.eye), new e5("nearFar", (e7, r2) => r2.camera.nearFar), new s("depthTexture", (e7) => e7.depthTexture), new o3("fogStrength", (e7) => e7.fogStrength), new o3("fogAmount", (e7) => e7.fogAmount), new e3("fogColor", (e7) => e7.fogColor)), r.include(e6), c.include(a), c.code.add(o`vec2 sphereIntersect(vec3 start, vec3 dir) {
float a = dot(dir, dir);
float b = 2.0 * dot(dir, start);
float d = (b * b) - 4.0 * a * atmosphereC;
if (d < 0.0) {
return vec2(1e5, -1e5);
}
return vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));
}`), c.code.add(o`vec4 applyFog(float dist, vec3 rayDir){
if(dist == -1.0){
vec2 rayAtmosphereIntersect = sphereIntersect(cameraPosition, rayDir);
dist = 0.055 * rayAtmosphereIntersect.y;
}
float fogAmount = fogAmount * (1.0 - exp(-dist * fogStrength));
return vec4(fogAmount * fogColor, fogAmount);
}`), c.code.add(o`vec3 tonemapACES(vec3 x) {
return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);
}
void main() {
vec3 rayDir = normalize(worldRay);
float terrainDepth = -1.0;
float depthSample = texture(depthTexture, vuv0).r;
float zNorm = 2.0 * depthSample - 1.0;
float linDepth = 2.0 * nearFar[0] * nearFar[1] / (nearFar[1] + nearFar[0] - zNorm * (nearFar[1] - nearFar[0]));
if(depthSample < 1.0 && depthSample > 0.0){
vec3 cameraSpaceRay = normalize(eyeDir);
cameraSpaceRay /= cameraSpaceRay.z;
cameraSpaceRay *= linDepth;
terrainDepth = max(0.0, length(cameraSpaceRay));
}
vec4 fog = applyFog(terrainDepth, rayDir);
fragColor = delinearizeGamma(vec4(tonemapACES(fog.rgb), fog.a));
}`), r;
}
var w = e2();
var y = Object.freeze(Object.defineProperty({ __proto__: null, FogPassParameters: u, build: h }, Symbol.toStringTag, { value: "Module" }));

export {
  u,
  h,
  y
};
//# sourceMappingURL=chunk-7ZRUUF6B.js.map
