{
  "version": 3,
  "sources": ["../../@arcgis/core/chunks/BlendWeights.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.27/esri/copyright.txt for details.\n*/\nimport{glsl as e}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as o}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as r}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{VertexAttribute as t}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{addResolutionUniform as s}from\"../views/3d/webgl-engine/shaders/SMAAPassParameters.js\";const c={maxSearchSteps:8,maxDistanceAreaTex:16};function x(){const x=new o,{attributes:d,varyings:a,vertex:i,fragment:n}=x;return d.add(t.POSITION,\"vec2\"),a.add(\"uv\",\"vec2\"),a.add(\"offsets[2]\",\"vec4\"),a.add(\"maxOffset\",\"vec4\"),a.add(\"pixelCoord\",\"vec2\"),s(i),i.code.add(e`\n      void main() {\n        uv = position * 0.5 + vec2(0.5);\n        gl_Position = vec4(position, 0, 1);\n\n        pixelCoord = uv * resolution.zw;\n        offsets[0] = uv.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );\n        offsets[1] = uv.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );\n        maxOffset = vec4( offsets[0].xz, offsets[1].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( ${e.int(c.maxSearchSteps)} );\n      }\n    `),n.uniforms.add(new r(\"edgesTexture\",(e=>e.edges.colorTexture))),n.uniforms.add(new r(\"areaTexture\",(e=>e.areaTexture))),n.uniforms.add(new r(\"searchTexture\",(e=>e.searchTexture))),s(n),n.code.add(e`\n      #define SMAA_AREATEX_PIXEL_SIZE ( 1.0 / vec2( 160.0, 560.0 ) )\n      #define SMAA_AREATEX_SUBTEX_SIZE ( 1.0 / 7.0 )\n\n      vec4 sampleLevelZeroOffset(sampler2D tex, vec2 coord, vec2 offset) {\n        return texture(tex, coord + offset.x * resolution.xy, 0.0);\n      }\n\n      float searchLength(sampler2D searchTex, vec2 e, float bias, float scale) {\n        e.r = bias + e.r * scale;\n        return 255.0 * texture( searchTex, e, 0.0 ).r;\n      }\n\n      float searchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 0.0, 1.0 );\n        for ( int i = 0; i < ${e.int(c.maxSearchSteps)}; i ++ ) {\n          e = texture( edgesTex, texcoord, 0.0 ).rg;\n          texcoord -= vec2( 2.0, 0.0 ) * resolution.xy;\n          if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n        }\n        texcoord.x += 0.25 * resolution.x;\n        texcoord.x += resolution.x;\n        texcoord.x += 2.0 * resolution.x;\n        texcoord.x -= resolution.x * searchLength(searchTex, e, 0.0, 0.5);\n        return texcoord.x;\n      }\n\n      float searchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 0.0, 1.0 );\n        for ( int i = 0; i < ${e.int(c.maxSearchSteps)}; i ++ ) {\n          e = texture( edgesTex, texcoord, 0.0 ).rg;\n          texcoord += vec2( 2.0, 0.0 ) * resolution.xy;\n          if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n        }\n        texcoord.x -= 0.25 * resolution.x;\n        texcoord.x -= resolution.x;\n        texcoord.x -= 2.0 * resolution.x;\n        texcoord.x += resolution.x * searchLength( searchTex, e, 0.5, 0.5 );\n        return texcoord.x;\n      }\n\n      float searchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 1.0, 0.0 );\n        for ( int i = 0; i < ${e.int(c.maxSearchSteps)}; i ++ ) {\n          e = texture( edgesTex, texcoord, 0.0 ).rg;\n          texcoord += vec2( 0.0, 2.0 ) * resolution.xy;\n          if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n        }\n        texcoord.y -= 0.25 * resolution.y;\n        texcoord.y -= resolution.y;\n        texcoord.y -= 2.0 * resolution.y;\n        texcoord.y += resolution.y * searchLength( searchTex, e.gr, 0.0, 0.5 );\n        return texcoord.y;\n      }\n\n      float searchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n        vec2 e = vec2( 1.0, 0.0 );\n        for ( int i = 0; i < ${e.int(c.maxSearchSteps)}; i ++ ) {\n          e = texture( edgesTex, texcoord, 0.0 ).rg;\n          texcoord -= vec2( 0.0, 2.0 ) * resolution.xy;\n          if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n        }\n        texcoord.y += 0.25 * resolution.y;\n        texcoord.y += resolution.y;\n        texcoord.y += 2.0 * resolution.y;\n        texcoord.y -= resolution.y * searchLength( searchTex, e.gr, 0.5, 0.5 );\n        return texcoord.y;\n      }\n\n      vec2 getArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n        vec2 texcoord = float( ${e.int(c.maxDistanceAreaTex)} ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n        texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n        texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n        return texture( areaTex, texcoord, 0.0 ).rg;\n      }\n\n      void main() {\n        ivec4 subsampleIndices = ivec4(0.0);\n        vec4 weights = vec4(0.0);\n        vec2 e = texture( edgesTexture, uv ).rg;\n        if ( e.g > 0.0 ) {\n          vec2 d;\n          vec2 coords;\n          coords.x = searchXLeft( edgesTexture, searchTexture, offsets[0].xy, maxOffset.x );\n          coords.y = offsets[1].y;\n          d.x = coords.x;\n          float e1 = texture( edgesTexture, coords, 0.0 ).r;\n          coords.x = searchXRight( edgesTexture, searchTexture, offsets[0].zw, maxOffset.y );\n          d.y = coords.x;\n          d = d * resolution.z - pixelCoord.x;\n          vec2 sqrt_d = sqrt( abs(d) );\n          coords.y -= 1.0 * resolution.y;\n          float e2 = sampleLevelZeroOffset( edgesTexture, coords, vec2( 1.0, 0.0 ) ).r;\n          weights.rg = getArea( areaTexture, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n        }\n\n        if ( e.r > 0.0 ) {\n          vec2 d;\n          vec2 coords;\n          coords.y = searchYUp( edgesTexture, searchTexture, offsets[1].xy, maxOffset.z );\n          coords.x = offsets[0].x;\n          d.x = coords.y;\n          float e1 = texture( edgesTexture, coords, 0.0 ).g;\n          coords.y = searchYDown( edgesTexture, searchTexture, offsets[1].zw, maxOffset.w );\n          d.y = coords.y;\n          d = d * resolution.w - pixelCoord.y;\n          vec2 sqrt_d = sqrt(abs(d));\n          coords.y -= 1.0 * resolution.y;\n          float e2 = sampleLevelZeroOffset( edgesTexture, coords, vec2(0.0, 1.0)).g;\n          weights.ba = getArea( areaTexture, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\n          // for some reason the following lines are necessary to prevent\n          // texture lookup precision issues on some Intel integrated graphics chips\n          vec4 dbg = (offsets[0] + offsets[1] + maxOffset + coords.xyyx);\n          weights.r += 0.00000001 * dot(vec4(0, 1, 0, 1), dbg);\n        }\n        fragColor = weights;\n      }\n    `),x}const d=Object.freeze(Object.defineProperty({__proto__:null,build:x},Symbol.toStringTag,{value:\"Module\"}));export{d as B,x as b};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAIyc,IAAM,IAAE,EAAC,gBAAe,GAAE,oBAAmB,GAAE;AAAE,SAAS,IAAG;AAAC,QAAMA,KAAE,IAAI,KAAE,EAAC,YAAWC,IAAE,UAAS,GAAE,QAAOC,IAAE,UAASC,GAAC,IAAEH;AAAE,SAAOC,GAAE,IAAI,EAAE,UAAS,MAAM,GAAE,EAAE,IAAI,MAAK,MAAM,GAAE,EAAE,IAAI,cAAa,MAAM,GAAE,EAAE,IAAI,aAAY,MAAM,GAAE,EAAE,IAAI,cAAa,MAAM,GAAE,EAAEC,EAAC,GAAEA,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qHAQnmB,EAAE,IAAI,EAAE,cAAc,CAAC;AAAA;AAAA,KAEvI,GAAEC,GAAE,SAAS,IAAI,IAAI,EAAE,gBAAgB,OAAG,EAAE,MAAM,YAAa,CAAC,GAAEA,GAAE,SAAS,IAAI,IAAI,EAAE,eAAe,OAAG,EAAE,WAAY,CAAC,GAAEA,GAAE,SAAS,IAAI,IAAI,EAAE,iBAAiB,OAAG,EAAE,aAAc,CAAC,GAAE,EAAEA,EAAC,GAAEA,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAe5K,EAAE,IAAI,EAAE,cAAc,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAcvB,EAAE,IAAI,EAAE,cAAc,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAcvB,EAAE,IAAI,EAAE,cAAc,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAcvB,EAAE,IAAI,EAAE,cAAc,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iCAarB,EAAE,IAAI,EAAE,kBAAkB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAgDvD,GAAEH;AAAC;AAAC,IAAM,IAAE,OAAO,OAAO,OAAO,eAAe,EAAC,WAAU,MAAK,OAAM,EAAC,GAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,CAAC;",
  "names": ["x", "d", "i", "n"]
}
