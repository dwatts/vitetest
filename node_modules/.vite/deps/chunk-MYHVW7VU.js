import {
  n as n2,
  t as t4,
  u as u3
} from "./chunk-6SPYK5IY.js";
import {
  I
} from "./chunk-VSNGV5F4.js";
import {
  ee
} from "./chunk-CPHFVZ42.js";
import {
  t as t3
} from "./chunk-RRRAGAMB.js";
import {
  f as f2
} from "./chunk-LFQ3TKCC.js";
import {
  o as o2
} from "./chunk-PC4A4CQR.js";
import {
  e as e2
} from "./chunk-UM64E5NS.js";
import {
  t as t2
} from "./chunk-M5UHI5WR.js";
import {
  J,
  V,
  fe
} from "./chunk-SLMR4CTS.js";
import {
  E
} from "./chunk-LEDSC236.js";
import {
  d as d2
} from "./chunk-MRYR5ID7.js";
import {
  d
} from "./chunk-CEFGWR5H.js";
import {
  b as b2
} from "./chunk-O443WBFA.js";
import {
  $,
  Hn,
  nn,
  xn
} from "./chunk-BNBT4QTW.js";
import {
  S as S2,
  i as i3
} from "./chunk-AQ7R6V4L.js";
import {
  a as a2,
  h,
  i as i2,
  m as m2,
  q
} from "./chunk-EKJ2DJIR.js";
import {
  i
} from "./chunk-TEHNQYQD.js";
import {
  S,
  o,
  u
} from "./chunk-TPJLFGOT.js";
import {
  M
} from "./chunk-3VUFACNT.js";
import {
  f,
  g
} from "./chunk-ZEEBL7ZN.js";
import {
  A,
  A2,
  Q,
  u as u2
} from "./chunk-RTDN6KAT.js";
import {
  s as s3
} from "./chunk-GJ7PJ7XG.js";
import {
  j
} from "./chunk-H7RDAEPY.js";
import {
  n
} from "./chunk-7KH4CLS5.js";
import {
  m,
  t2 as t,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  l
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import {
  b,
  v
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SMeshViewFilter.js
var O = "esri.views.3d.layers.i3s.I3SMeshViewFilter";
var B = s.getLogger(O);
var L = class extends m {
  constructor(e3) {
    super(e3), this._projectionEngineLoaded = false;
  }
  initialize() {
    j(() => {
      var _a;
      return ((_a = this.viewFilter) == null ? void 0 : _a.geometry) || null != this.layerFilter;
    }).then(() => this.loadAsyncModule(import("./geometryEngine-NWIGJMDQ.js").then((e3) => {
      this.destroyed || (this._geometryEngine = e3);
    })));
  }
  get sortedObjectIds() {
    if (null == this.viewFilter || null == this.viewFilter.objectIds)
      return null;
    const e3 = e2(this.viewFilter.objectIds);
    return e3.sort(), e3;
  }
  get parsedWhereClause() {
    const e3 = null != this.viewFilter ? this.viewFilter.where : null;
    if (null == e3 || !e3)
      return null;
    try {
      return f2.create(e3, this.layerFieldsIndex);
    } catch (t5) {
      B.error(`Failed to parse filter where clause: ${t5}`);
    }
    return null;
  }
  addFilters(e3, t5, r, i4) {
    const s4 = this.sortedObjectIds;
    null != s4 && e3.push((e4) => V(s4, true, e4)), this.addSqlFilter(e3, this.parsedWhereClause);
    const n4 = t4(this._layerMaskGeometries), a3 = this._geometryEngine;
    if (null != n4 && null != this.layerFilter && null != a3) {
      const s5 = this.layerFilter.spatialRelationship;
      e3.push((e4, o4) => q2(a3, e4, o4, i4, t5, r, n4, s5));
    }
    const l3 = t4(this._viewMaskGeometries);
    if (null != l3 && null != this.viewFilter && null != a3) {
      const s5 = this.viewFilter.spatialRelationship;
      e3.push((e4, n5) => q2(a3, e4, n5, i4, t5, r, l3, s5));
    }
  }
  isMBSGeometryVisible(e3, t5, r) {
    const i4 = t4(this._layerMaskGeometries), s4 = this._geometryEngine;
    if (null != i4 && null != this.layerFilter && null != s4) {
      const n5 = this.layerFilter.spatialRelationship, o4 = i4[0].spatialReference || t5;
      if (!xn(e3, r, N, o4))
        return B.warnOnce("SceneLayer.mask geometry is using unsupported SpatialReference, skipping geometry filter for MBS"), true;
      return V2(s4, N, i4, o4, n5);
    }
    const n4 = t4(this._viewMaskGeometries);
    if (null != n4 && null != this.viewFilter && null != s4) {
      const i5 = this.viewFilter.spatialRelationship, o4 = n4[0].spatialReference || t5;
      if (!xn(e3, r, N, o4))
        return B.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter for MBS"), true;
      return V2(s4, N, n4, o4, i5);
    }
    return true;
  }
  get parsedGeometry() {
    const e3 = t4(this._viewMaskGeometries), t5 = t4(this._layerMaskGeometries);
    return null == e3 || null == t5 ? e3 || t5 : t5.concat(e3);
  }
  get _layerMaskGeometries() {
    const e3 = this.layerFilter;
    return null == e3 ? null : null == this._geometryEngine ? n2 : "disjoint" === e3.spatialRelationship ? e3.geometries.map((e4) => ({ type: "polygon", rings: e4.rings, spatialReference: e4.spatialReference, cache: {} })) : [e3.geometries.reduce((e4, t5) => (e4.rings = [...e4.rings, ...t5.rings], e4), { type: "polygon", rings: [], spatialReference: e3.geometries[0].spatialReference, cache: {} })];
  }
  get _viewMaskGeometries() {
    if (null == this.viewFilter)
      return null;
    const { geometry: e3 } = this.viewFilter;
    if (null == e3)
      return null;
    if (null == this.viewFilter || null == this._geometryEngine)
      return n2;
    const { distance: t5, units: r } = this.viewFilter, i4 = this.viewFilter.spatialRelationship, s4 = "mesh" === e3.type ? e3.extent : e3;
    if (null == t5 || 0 === t5)
      return W(this._geometryEngine, s4, i4);
    const n4 = r || Q(s4.spatialReference);
    if (s4.spatialReference.isWGS84) {
      const e4 = this._geometryEngine.geodesicBuffer(s4, t5, n4);
      return W(this._geometryEngine, e4, i4);
    }
    const o4 = g(s4, f.WGS84);
    if (null != o4) {
      const e4 = g(this._geometryEngine.geodesicBuffer(o4, t5, n4), s4.spatialReference);
      return W(this._geometryEngine, e4, i4);
    }
    if (!this._projectionEngineLoaded && (this.loadAsyncModule($().then(() => this._projectionEngineLoaded = true)), !this._projectionEngineLoaded))
      return null;
    let l3 = null;
    try {
      l3 = nn(s4, f.WGS84);
    } catch (c) {
    }
    if (l3)
      try {
        l3 = nn(this._geometryEngine.geodesicBuffer(l3, t5, n4), s4.spatialReference);
      } catch (c) {
        l3 = null;
      }
    return l3 || B.error(`Filter by geodesic buffer (distance) unsupported, failed to project input geometry (${s4.spatialReference.wkid}) to WGS84.`), W(this._geometryEngine, l3, i4);
  }
  get updating() {
    return u3(this._layerMaskGeometries) || u3(this._viewMaskGeometries);
  }
  static checkSupport(e3) {
    return null != e3 && (e3.timeExtent ? (B.warn("Filters with a timeExtent are not supported for mesh scene layers"), false) : !!U(e3.spatialRelationship) || (B.warn(`Filters with spatialRelationship other than ${P.join(", ")} are not supported for mesh scene layers`), false));
  }
};
e([y()], L.prototype, "layerFilter", void 0), e([y({ type: d2 })], L.prototype, "viewFilter", void 0), e([y()], L.prototype, "layerFieldsIndex", void 0), e([y()], L.prototype, "loadAsyncModule", void 0), e([y()], L.prototype, "addSqlFilter", void 0), e([y({ readOnly: true })], L.prototype, "sortedObjectIds", null), e([y({ readOnly: true })], L.prototype, "parsedWhereClause", null), e([y({ readOnly: true })], L.prototype, "parsedGeometry", null), e([y({ readOnly: true })], L.prototype, "_layerMaskGeometries", null), e([y({ readOnly: true })], L.prototype, "_viewMaskGeometries", null), e([y()], L.prototype, "updating", null), e([y()], L.prototype, "_projectionEngineLoaded", void 0), e([y()], L.prototype, "_geometryEngine", void 0), L = e([a(O)], L);
var P = ((e3) => e3)(["contains", "intersects", "disjoint"]);
function U(e3) {
  return null != e3 && P.includes(e3);
}
var K;
function W(e3, t5, s4) {
  if (null == t5)
    return null;
  if ("disjoint" === s4 && "polygon" === t5.type) {
    const s5 = t5.rings.length, n4 = t5.spatialReference, o4 = new Array(s5);
    for (let e4 = 0; e4 < s5; ++e4) {
      const r = a2(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      h(r, t5.rings[e4]), o4[e4] = { type: "polygon", rings: [t5.rings[e4]], spatialReference: n4, cache: {}, aabr: r };
    }
    o4.sort((e4, t6) => e4.aabr[0] - t6.aabr[0]);
    const a3 = /* @__PURE__ */ new Set(), l3 = new v();
    for (let t6 = 0; t6 < o4.length; ++t6) {
      const r = o4[t6], s6 = r.aabr[0];
      a3.forEach((t7) => {
        if (s6 >= t7.aabr[2])
          return void a3.delete(t7);
        if (r.aabr[1] > t7.aabr[3] || r.aabr[3] < t7.aabr[1] || !e3.intersects(r, t7))
          return;
        r.rings = r.rings.concat(t7.rings), m2(r.aabr, t7.aabr, r.aabr), r.cache = {}, a3.delete(t7);
        const n5 = b(o4, t7, o4.length, l3);
        o4.splice(n5, 1);
      }), a3.add(r);
    }
    for (const e4 of o4)
      e4.aabr = void 0;
    return o4;
  }
  return [t5];
}
function V2(e3, t5, r, i4, s4) {
  if (t5[3] >= 0.5 * (t5[2] + A2(i4).radius))
    return true;
  const n4 = z(e3, t5, i4);
  return r.every((t6) => H(e3, t6, n4, s4) !== K.DISCARD);
}
function q2(e3, t5, r, i4, s4, n4, o4, a3) {
  const l3 = o4[0].spatialReference || s4.spatialReference;
  if (!xn(r.node.mbs, n4, N, l3))
    return void B.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter");
  const c = z(e3, N, l3), p2 = $2(a3, s4, l3, i4, r.objectHandle);
  for (const u4 of o4) {
    if (0 === t5.length)
      return;
    switch (H(e3, u4, c, a3)) {
      case K.DISCARD:
        return void (t5.length = 0);
      case K.KEEP:
        continue;
    }
    J(t5, r.featureIds, (t6) => Q2(e3, u4, t6, p2));
  }
}
!function(e3) {
  e3[e3.KEEP = 0] = "KEEP", e3[e3.DISCARD = 1] = "DISCARD", e3[e3.TEST = 2] = "TEST";
}(K || (K = {}));
var N = E(0, 0, 0, 0);
function $2(e3, t5, r, i4, s4) {
  const n4 = t5.renderSpatialReference, o4 = /* @__PURE__ */ new Map(), a3 = { type: "polygon", rings: [[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]], spatialReference: r };
  a3.rings[0][3] = a3.rings[0][0];
  const l3 = { indices: null, data: null, stride: 0, startIndex: 0, endIndex: 0 };
  let c, p2;
  switch (e3) {
    case "intersects":
      c = (e4, t6, r2) => e4.intersects(t6, r2) ? K.KEEP : K.TEST, p2 = Z;
      break;
    case "contains":
      c = (e4, t6, r2) => e4.contains(t6, r2) ? K.TEST : K.DISCARD, p2 = Z;
      break;
    default:
      c = (e4, t6, r2) => e4.disjoint(t6, r2) ? K.TEST : K.DISCARD, p2 = J2;
  }
  return { collection: i4, object: s4, type: e3, maskSR: r, renderSR: n4, aabbCache: o4, triangle: a3, positions: l3, triangleTest: c, geometryTest: p2 };
}
function z(e3, t5, r) {
  const i4 = { type: "point", x: t5[0], y: t5[1], hasZ: false, hasM: false, spatialReference: r }, s4 = !u2(r) && !A(r), o4 = Number.isNaN(t5[3]) ? 0 : i(t5[3], 0, 2 * s3.radius), a3 = s4 ? e3.buffer(i4, o4, 1) : e3.geodesicBuffer(i4, o4, 1);
  return a3.type = "polygon", a3;
}
function H(e3, t5, r, i4) {
  switch (i4) {
    case "intersects":
    case "contains":
      return Z(e3, t5, r);
    case "disjoint":
      return J2(e3, t5, r);
  }
}
function Z(e3, t5, r) {
  return e3.intersects(t5, r) ? e3.contains(t5, r) ? K.KEEP : K.TEST : K.DISCARD;
}
function J2(e3, t5, r) {
  return e3.intersects(t5, r) ? e3.contains(t5, r) ? K.DISCARD : K.TEST : K.KEEP;
}
function Q2(e3, t5, r, i4) {
  const { collection: s4, object: n4, renderSR: o4, maskSR: a3, geometryTest: l3, aabbCache: c } = i4;
  let p2 = c.get(r);
  if (!p2) {
    const e4 = s4.getObjectTransform(n4);
    s4.getComponentAabb(n4, r, X);
    const t6 = [[X[0], X[1], 0], [X[0], X[4], 0], [X[3], X[4], 0], [X[3], X[1], 0]];
    for (let r2 = 0; r2 < 4; ++r2)
      S(t6[r2], t6[r2], e4.rotationScale), u(t6[r2], t6[r2], e4.position), Hn(t6[r2], o4, t6[r2], a3);
    p2 = { type: "polygon", rings: [t6], spatialReference: a3, cache: {} }, p2.rings[0][4] = p2.rings[0][0], c.set(r, p2);
  }
  switch (l3(e3, t5, p2)) {
    case K.DISCARD:
      return false;
    case K.KEEP:
      return true;
  }
  const { triangle: u4, triangleTest: g2, positions: y3 } = i4, h3 = u4.rings[0][0], j2 = u4.rings[0][1], S3 = u4.rings[0][2], R = s4.getObjectTransform(n4);
  s4.getComponentPositions(n4, r, y3);
  const { indices: E2, data: b3, stride: v2, startIndex: F, endIndex: _ } = y3;
  for (let k = F; k < _; k += 3) {
    const r2 = v2 * E2[k], i5 = v2 * E2[k + 1], s5 = v2 * E2[k + 2];
    switch (o(h3, b3[r2], b3[r2 + 1], b3[r2 + 2]), o(j2, b3[i5], b3[i5 + 1], b3[i5 + 2]), o(S3, b3[s5], b3[s5 + 1], b3[s5 + 2]), S(h3, h3, R.rotationScale), S(j2, j2, R.rotationScale), S(S3, S3, R.rotationScale), u(h3, h3, R.position), u(j2, j2, R.position), u(S3, S3, R.position), Hn(h3, o4, h3, a3), Hn(j2, o4, j2, a3), Hn(S3, o4, S3, a3), g2(e3, t5, u4)) {
      case K.DISCARD:
        return false;
      case K.KEEP:
        return true;
    }
  }
  return "intersects" !== i4.type;
}
var X = i3();

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SQueryEngine.js
var p = ee;
var d3 = class extends m {
  get spatialReference() {
    return this.layerView.view.spatialReference;
  }
  get layer() {
    return this.layerView.i3slayer;
  }
  get defaultQueryJSON() {
    return new b2({ outSpatialReference: this.spatialReference }).toJSON();
  }
  get _dataQueryEngine() {
    return this._ensureDataQueryEngine();
  }
  constructor(e3) {
    super(e3), this._handles = new t();
  }
  initialize() {
    this._handles.add(this.layerView.on("visible-geometry-changed", () => this.spatialIndex.events.emit("changed")));
  }
  destroy() {
    this._dataQueryEngineInstance = l(this._dataQueryEngineInstance), this._handles = l(this._handles), this._set("layerView", null);
  }
  async executeQueryForCount(e3, r) {
    return this._dataQueryEngine.executeQueryForCount(this._ensureQueryJSON(e3), r);
  }
  async executeQueryForExtent(e3, r) {
    const { count: t5, extent: s4 } = await this._dataQueryEngine.executeQueryForExtent(this._ensureQueryJSON(e3), r);
    return { count: t5, extent: M.fromJSON(s4) };
  }
  async executeQueryForIds(e3, r) {
    return this._dataQueryEngine.executeQueryForIds(this._ensureQueryJSON(e3), r);
  }
  async executeQuery(e3, r) {
    const s4 = this._ensureQueryJSON(e3);
    if (s4.returnGeometry)
      throw new s2("feature-store:unsupported-query", "returnGeometry is not yet supported for mesh scene layer queries");
    if (s4.returnCentroid)
      throw new s2("feature-store:unsupported-query", "returnCentroid is not yet supported for mesh scene layer queries");
    const n4 = await this._dataQueryEngine.executeQuery(s4, r), o4 = d.fromJSON(n4);
    return o4.features.forEach((e4) => {
      e4.geometry = null;
    }), o4;
  }
  _ensureQueryJSON(e3) {
    return null == e3 ? this.defaultQueryJSON : e3.toJSON();
  }
  _ensureDataQueryEngine() {
    var _a;
    if (this._dataQueryEngineInstance)
      return this._dataQueryEngineInstance;
    const e3 = this.layer.objectIdField || o2, r = "esriGeometryPolygon", t5 = ((_a = this.layer.fields) == null ? void 0 : _a.map((e4) => e4.toJSON())) ?? [], s4 = this.layerView.view.resourceController.scheduler, n4 = this.spatialReference.toJSON(), o4 = this.priority, i4 = this.spatialIndex;
    return this._dataQueryEngineInstance = new p({ hasZ: true, hasM: false, geometryType: r, fields: t5, timeInfo: null, spatialReference: n4, objectIdField: e3, featureStore: i4, scheduler: s4, priority: o4 }), this._dataQueryEngineInstance;
  }
};
e([y({ constructOnly: true })], d3.prototype, "layerView", void 0), e([y({ constructOnly: true })], d3.prototype, "priority", void 0), e([y({ constructOnly: true })], d3.prototype, "spatialIndex", void 0), e([y()], d3.prototype, "spatialReference", null), e([y()], d3.prototype, "layer", null), e([y()], d3.prototype, "defaultQueryJSON", null), d3 = e([a("esri.views.3d.layers.i3s.I3SQueryEngine")], d3);

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SQueryFeatureAdapter.js
var o3 = class {
  constructor(t5) {
    this._objectIdField = t5.objectIdField, this._getFeatureExtent = t5.getFeatureExtent;
  }
  getObjectId(t5) {
    return t5.id;
  }
  getAttributes(t5) {
    var _a;
    const { meta: e3, index: r } = t5, o4 = {};
    this._objectIdField && (o4[this._objectIdField] = t5.id);
    const n4 = (_a = e3.attributeInfo) == null ? void 0 : _a.attributeData;
    if (null != n4)
      for (const s4 of Object.keys(n4))
        o4[s4] = fe(n4[s4], r);
    return o4;
  }
  getAttribute(t5, e3) {
    var _a;
    if (e3 === this._objectIdField)
      return t5.id;
    const { meta: r, index: o4 } = t5, n4 = (_a = r.attributeInfo) == null ? void 0 : _a.attributeData;
    return null != n4 ? fe(n4[e3], o4) : null;
  }
  getGeometry(t5) {
    if (t5.geometry)
      return t5.geometry;
    const [e3, i4, o4, s4, a3] = this._getFeatureExtent(t5, n3);
    return new t2([5], [e3, i4, o4, s4, i4, o4, s4, a3, o4, e3, a3, o4, e3, i4, o4]);
  }
  getCentroid(t5, i4) {
    if (t5.geometry)
      return t3(new t2(), t5.geometry, i4.hasZ, i4.hasM);
    const [o4, s4, a3, u4, d5, c] = this._getFeatureExtent(t5, n3);
    return new t2([0], [(o4 + u4) / 2, (s4 + d5) / 2, (a3 + c) / 2]);
  }
  cloneWithGeometry(t5, e3) {
    const { id: r, index: i4, meta: o4 } = t5;
    return { id: r, index: i4, meta: o4, geometry: e3 };
  }
};
var n3 = i3();

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SQueryFeatureStore.js
var f3 = i3();
var l2 = class extends m {
  constructor(r) {
    super(r), this.events = new n();
  }
  forEach(r) {
    this.forAllFeatures((e3) => (r(e3), I.CONTINUE));
  }
  forEachBounds(r, e3) {
    const t5 = this.getFeatureExtent;
    for (const o4 of r)
      e3(t5(o4, f3));
  }
  forEachInBounds(r, e3) {
    this.forAllFeatures((t5) => {
      const o4 = this.getFeatureExtent(t5, y2);
      return q(r, S2(o4, d4)) && e3(t5), I.CONTINUE;
    }, (e4) => {
      if (xn(e4.node.mbs, this.sourceSpatialReference, h2, this.viewSpatialReference), h2[0] >= r[0] && h2[2] <= r[2] && h2[1] >= r[1] && h2[3] <= r[3])
        return I.CONTINUE;
      const t5 = Math.max(r[0], Math.min(h2[0], r[2])), o4 = Math.max(r[1], Math.min(h2[1], r[3])), s4 = h2[0] - t5, a3 = h2[1] - o4;
      return s4 * s4 + a3 * a3 <= h2[3] * h2[3] ? I.CONTINUE : I.SKIP;
    });
  }
};
e([y({ constructOnly: true })], l2.prototype, "featureAdapter", void 0), e([y({ constructOnly: true })], l2.prototype, "forAllFeatures", void 0), e([y({ constructOnly: true })], l2.prototype, "getFeatureExtent", void 0), e([y({ constructOnly: true })], l2.prototype, "sourceSpatialReference", void 0), e([y({ constructOnly: true })], l2.prototype, "viewSpatialReference", void 0), l2 = e([a("esri.views.3d.layers.i3s.I3SQueryFeatureStore")], l2);
var h2 = E(0, 0, 0, 0);
var y2 = i3();
var d4 = i2();

export {
  L,
  d3 as d,
  o3 as o,
  l2 as l
};
//# sourceMappingURL=chunk-MYHVW7VU.js.map
