import {
  x
} from "./chunk-GM6POGRC.js";
import {
  e2 as e6
} from "./chunk-ACTOBSLJ.js";
import {
  n as n3
} from "./chunk-IBJTEQQG.js";
import {
  c
} from "./chunk-7DFZCT3D.js";
import {
  o as o3
} from "./chunk-ASBUA7EG.js";
import {
  e as e2
} from "./chunk-FY4ZONHH.js";
import {
  P
} from "./chunk-N3RXOITN.js";
import {
  o as o2
} from "./chunk-Z6IKMUOC.js";
import {
  e as e3
} from "./chunk-PV5KBAYL.js";
import {
  e
} from "./chunk-YVVROPAO.js";
import {
  s
} from "./chunk-BFVOSCOB.js";
import {
  e as e5
} from "./chunk-QS45OHBM.js";
import {
  a
} from "./chunk-3I3GE5YW.js";
import {
  e as e4
} from "./chunk-WRFNQB7U.js";
import {
  o as o4
} from "./chunk-UUW6REOV.js";
import {
  i,
  i2
} from "./chunk-BO2REVMA.js";
import {
  o
} from "./chunk-V66LHQVK.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  r
} from "./chunk-NLWV7Q6F.js";
import {
  n as n2,
  r as r2
} from "./chunk-SS3YG6J3.js";
import {
  n
} from "./chunk-4CZO65BK.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/IsNaN.glsl.js
function o5(o7) {
  const e7 = o`bool isNaN( float val )
{
return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;
}`;
  o7.code.add(e7);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/AdjustProjectedPosition.glsl.js
var l = r2(0.5, -4e-4);
function i3(o7, i5) {
  const c2 = o7.vertex;
  c2.include(o5), c2.constants.add("depthBias", "vec2", l), c2.uniforms.add(new e4("inverseViewport", (o8, r3) => r3.inverseViewport)), i5.legacy ? (c2.uniforms.add(new e3("proj", (o8, r3) => r3.camera.projectionMatrix)), c2.code.add(o`vec2 calculateProjectedBiasXY(vec4 projPos, vec3 globalNormal) {
float offsetXY = depthBias.x;
vec4 projNormal = proj * localView * vec4(globalNormal, 0.0);
return offsetXY * projPos.w * 2.0 * inverseViewport * normalize(projNormal.xyz).xy;
}`)) : (c2.uniforms.add(new e2("transformNormalViewFromGlobal", (o8) => o8.transformNormalViewFromGlobal), new e3("transformProjFromView", (o8) => o8.transformProjFromView)), c2.code.add(o`vec2 calculateProjectedBiasXY(vec4 projPos, vec3 globalNormal) {
float offsetXY = depthBias.x;
vec4 projNormal = transformProjFromView * vec4(transformNormalViewFromGlobal * globalNormal, 0.0);
return offsetXY * projPos.w * 2.0 * inverseViewport * normalize(projNormal.xyz).xy;
}`)), c2.code.add(o`float _calculateProjectedBiasZ(vec4 projPos) {
float offsetZ = depthBias.y;
return sqrt(max(projPos.z,0.0)) * offsetZ;
}
vec4 adjustProjectedPosition(vec4 projPos, vec3 worldNormal, float lineWidth) {
vec2 offsetXY = calculateProjectedBiasXY(projPos, worldNormal);
if (!isNaN(offsetXY.x) && !isNaN(offsetXY.y)) {
projPos.xy += offsetXY;
}
projPos.z += _calculateProjectedBiasZ(projPos);
return projPos;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardByCoverage.glsl.js
function a2(a3, r3) {
  const d2 = a3.fragment;
  d2.constants.add("coverageTestThreshold", "float", 0.01), r3.antialiasing ? d2.code.add(o`#define discardByCoverage(radius, coverage) { if (coverage < coverageTestThreshold) discard; }`) : d2.code.add(o`#define discardByCoverage(radius, coverage) { float coverageLimit = radius <= 0.5 ? coverageTestThreshold : 0.75; if (coverage < coverageLimit) discard; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/DiscardNonSilhouetteEdges.glsl.js
function o6(o7, r3) {
  const l2 = o7.vertex;
  r3.silhouette ? (l2.code.add(o`bool isSilhouetteEdge(vec3 viewDir, vec3 normalA, vec3 normalB) {
float faceAVisible = dot(viewDir, normalA);
float faceBVisible = dot(viewDir, normalB);
return faceAVisible * faceBVisible < 0.0;
}`), r3.legacy ? l2.code.add(o`bool discardNonSilhouetteEdges(vec3 viewPos, vec3 worldPos) {
vec3 viewNormalA = _modelToViewNormal(normalA);
vec3 viewNormalB = _modelToViewNormal(normalB);
vec3 viewDir = -viewPos;
if (isSilhouetteEdge(viewDir, viewNormalA, viewNormalB)) {
return false;
}
gl_Position = vec4(10.0, 10.0, 10.0, 1.0);
return true;
}`) : l2.code.add(o`bool discardNonSilhouetteEdges(vec3 viewPos, vec3 worldPos) {
vec3 worldNormalA = _modelToWorldNormal(normalA);
vec3 worldNormalB = _modelToWorldNormal(normalB);
vec3 viewDir = -worldPos;
if (isSilhouetteEdge(viewDir, worldNormalA, worldNormalB)) {
return false;
}
gl_Position = vec4(10.0, 10.0, 10.0, 1.0);
return true;
}`)) : l2.code.add(o`bool discardNonSilhouetteEdges(vec3 viewPos, vec3 worldPos) {
return false;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/EdgeUtil.glsl.js
function f(f2, v2) {
  const u = f2.vertex;
  u.include(a), u.uniforms.add(new o4("distanceFalloffFactor", (o7) => o7.distanceFalloffFactor)), u.code.add(o`float distanceBasedPerspectiveFactor(float distance) {
return clamp(sqrt(distanceFalloffFactor / distance), 0.0, 1.0);
}`), u.uniforms.add(new s("componentDataTex", (o7) => o7.componentDataTexture)), f2.attributes.add(O.COMPONENTINDEX, "float"), u.constants.add("componentColorFieldOffset", "float", 0), u.constants.add("componentOtherFieldOffset", "float", 1), u.constants.add("componentVerticalOffsetFieldOffset", "float", 2), u.constants.add("componentFieldCount", "float", 3), u.constants.add("lineWidthFractionFactor", "float", 8), u.constants.add("extensionLengthOffset", "float", 128), u.constants.add("verticalOffsetScale", "float", 2 * x), u.code.add(o`vec2 _componentTextureCoords(float componentIndex, float fieldOffset) {
float fieldIndex = componentFieldCount * componentIndex + fieldOffset;
float texSize = float(textureSize(componentDataTex, 0).x);
float colIndex = mod(fieldIndex, texSize);
float rowIndex = floor(fieldIndex / texSize);
return vec2(colIndex, rowIndex) + 0.5;
}
struct ComponentData {
vec4 color;
float lineWidth;
float extensionLength;
float type;
float verticalOffset;
};
ComponentData readComponentData() {
vec2 colorIndex = _componentTextureCoords(componentIndex, componentColorFieldOffset);
vec2 otherIndex = _componentTextureCoords(componentIndex, componentOtherFieldOffset);
vec2 verticalOffsetIndex = _componentTextureCoords(componentIndex, componentVerticalOffsetFieldOffset);
vec4 colorValue = texelFetch(componentDataTex, ivec2(colorIndex), 0);
vec4 otherValue = texelFetch(componentDataTex, ivec2(otherIndex), 0);
float verticalOffset = (rgba2float(texelFetch(componentDataTex, ivec2(verticalOffsetIndex), 0)) - 0.5) * verticalOffsetScale;
return ComponentData(
vec4(colorValue.rgb, colorValue.a * otherValue.w),
otherValue.x * (255.0 / lineWidthFractionFactor),
otherValue.y * 255.0 - extensionLengthOffset,
-(otherValue.z * 255.0) + 0.5,
verticalOffset
);
}`), v2.legacy ? u.code.add(o`vec3 _modelToWorldNormal(vec3 normal) {
return (model * vec4(normal, 0.0)).xyz;
}
vec3 _modelToViewNormal(vec3 normal) {
return (localView * model * vec4(normal, 0.0)).xyz;
}`) : (u.uniforms.add(new o3("transformNormalGlobalFromModel", (o7) => o7.transformNormalGlobalFromModel)), u.code.add(o`vec3 _modelToWorldNormal(vec3 normal) {
return transformNormalGlobalFromModel * normal;
}`)), v2.silhouette ? (f2.attributes.add(O.NORMALA, "vec3"), f2.attributes.add(O.NORMALB, "vec3"), u.code.add(o`vec3 worldNormal() {
return _modelToWorldNormal(normalize(normalA + normalB));
}`)) : (f2.attributes.add(O.NORMAL, "vec3"), u.code.add(o`vec3 worldNormal() {
return _modelToWorldNormal(normal);
}`)), v2.legacy ? u.code.add(o`void worldAndViewFromModelPosition(vec3 modelPos, float verticalOffset, out vec3 worldPos, out vec3 viewPos) {
worldPos = (model * vec4(modelPos, 1.0)).xyz;
viewPos = (localView * vec4(worldPos, 1.0)).xyz;
}`) : (u.include(c, v2), u.include(c, v2), u.uniforms.add(new e2("transformViewFromCameraRelativeRS", (o7) => o7.transformViewFromCameraRelativeRS), new o3("transformWorldFromModelRS", (o7) => o7.transformWorldFromModelRS), new o2("transformWorldFromModelTL", (o7) => o7.transformWorldFromModelTL), new o2("transformWorldFromModelTH", (o7) => o7.transformWorldFromModelTH), new e("transformWorldFromViewTL", (o7) => o7.transformWorldFromViewTL), new e("transformWorldFromViewTH", (o7) => o7.transformWorldFromViewTH)), u.code.add(o`
      void worldAndViewFromModelPosition(vec3 modelPos, float verticalOffset, out vec3 worldPos, out vec3 viewPos) {
        vec3 rotatedModelPosition = transformWorldFromModelRS * modelPos;

        vec3 transformCameraRelativeFromModel = dpAdd(
          transformWorldFromModelTL,
          transformWorldFromModelTH,
          -transformWorldFromViewTL,
          -transformWorldFromViewTH
        );

        worldPos = transformCameraRelativeFromModel + rotatedModelPosition;

        if (verticalOffset != 0.0) {
          vec3 vUp = ${v2.spherical ? o`normalize(transformWorldFromModelTL + rotatedModelPosition);` : o`vec3(0.0, 0.0, 1.0);`}
          worldPos += verticalOffset * vUp;
        }

        viewPos = transformViewFromCameraRelativeRS * worldPos;
      }
    `)), u.uniforms.add(new e3("transformProjFromView", (o7, e7) => e7.camera.projectionMatrix)), u.code.add(o`vec4 projFromViewPosition(vec3 position) {
return transformProjFromView * vec4(position, 1.0);
}`), u.code.add(o`float calculateExtensionLength(float extensionLength, float lineLength) {
return extensionLength / (log2(max(1.0, 256.0 / lineLength)) * 0.2 + 1.0);
}`);
}
function v(o7) {
  return o7.mode === x2.SKETCH || o7.mode === x2.MIXED;
}
var x2;
var F;
!function(o7) {
  o7[o7.SOLID = 0] = "SOLID", o7[o7.SKETCH = 1] = "SKETCH", o7[o7.MIXED = 2] = "MIXED", o7[o7.COUNT = 3] = "COUNT";
}(x2 || (x2 = {})), function(o7) {
  o7[o7.REGULAR = 0] = "REGULAR", o7[o7.SILHOUETTE = 1] = "SILHOUETTE";
}(F || (F = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/UnpackAttributes.glsl.js
function i4(i5, o7) {
  const d2 = i5.vertex;
  switch (i5.attributes.add(O.SIDENESS, "vec2"), o7.mode === x2.MIXED ? d2.code.add(o`struct UnpackedAttributes {
vec2 sideness;
vec2 sidenessNorm;
float lineWidthPixels;
float extensionLengthPixels;
float type;
};`) : d2.code.add(o`struct UnpackedAttributes {
vec2 sideness;
vec2 sidenessNorm;
float lineWidthPixels;
float extensionLengthPixels;
};`), o7.mode) {
    case x2.MIXED:
      d2.code.add(o`UnpackedAttributes unpackAttributes(ComponentData component) {
vec2 sidenessNorm = sideness;
vec2 sideness = sidenessNorm * 2.0 - 1.0;
float fType = component.type;
float extensionLengthPixels = component.extensionLength;
float lineWidth = component.lineWidth;
if (fType <= 0.0) {
extensionLengthPixels *= variantExtension * 2.0 - 1.0;
}
return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels, fType);
}`);
      break;
    case x2.SKETCH:
      d2.code.add(o`UnpackedAttributes unpackAttributes(ComponentData component) {
vec2 sidenessNorm = sideness;
vec2 sideness = sidenessNorm * 2.0 - 1.0;
float extensionLengthPixels = component.extensionLength;
extensionLengthPixels *= variantExtension * 2.0 - 1.0;
float lineWidth = component.lineWidth;
return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels);
}`);
      break;
    case x2.SOLID:
      d2.code.add(o`UnpackedAttributes unpackAttributes(ComponentData component) {
vec2 sidenessNorm = sideness;
vec2 sideness = sidenessNorm * 2.0 - 1.0;
float extensionLengthPixels = component.extensionLength;
float lineWidth = component.lineWidth;
return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels);
}`);
      break;
    case x2.COUNT:
      break;
    default:
      n(o7.mode);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/LineAmplitude.glsl.js
function d(d2, u) {
  const a3 = d2.vertex;
  switch (d2.include(i4, u), u.mode) {
    case x2.SOLID:
      a3.code.add(o`float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {
return 0.0;
}`);
      break;
    case x2.SKETCH:
      a3.uniforms.add(new e6("strokesAmplitude", (e7) => e7.strokesTexture.amplitude)), a3.code.add(o`float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {
return strokesAmplitude;
}`);
      break;
    case x2.MIXED:
      a3.uniforms.add(new e6("strokesAmplitude", (e7) => e7.strokesTexture.amplitude)), a3.code.add(o`float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {
float type = unpackedAttributes.type;
if (type <= 0.0) {
return strokesAmplitude;
}
else {
return 0.0;
}
}`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/LineOffset.glsl.js
function n5(r3, c2) {
  r3.include(i4, c2);
  const { vertex: n6, fragment: i5 } = r3;
  switch (v(c2) && (n6.uniforms.add(new s("strokesTexture", (e7) => e7.strokesTexture.texture)), n6.uniforms.add(new e6("strokesLog2Resolution", (e7) => Math.log2(e7.strokesTexture.resolution)), new e6("strokeVariants", (e7) => e7.strokesTexture.variants)), r3.varyings.add("vStrokeUV", "vec2"), i5.uniforms.add(new s("strokesTexture", (e7) => e7.strokesTexture.texture), new e6("strokesNormalizationScale", (e7) => e7.strokesTexture.normalizationScale)), n6.code.add(o`void calculateStyleOutputsSketch(float lineLength, UnpackedAttributes unpackedAttributes) {
vec2 sidenessNorm = unpackedAttributes.sidenessNorm;
float lineIndex = clamp(ceil(log2(lineLength)), 0.0, strokesLog2Resolution);
vStrokeUV = vec2(exp2(lineIndex) * sidenessNorm.y, lineIndex * strokeVariants + variantStroke + 0.5) / vec2(textureSize(strokesTexture, 0));
vStrokeUV.x += variantOffset;
}`), r3.fragment.include(a), i5.code.add(o`float calculateLineOffsetSketch() {
float offsetNorm = rgba2float(texture(strokesTexture, vStrokeUV));
return (offsetNorm - 0.5) * strokesNormalizationScale;
}
float calculateLinePressureSketch() {
return rgba2float(texture(strokesTexture, vStrokeUV + vec2(0.0, 0.5)));
}`)), c2.mode) {
    case x2.SOLID:
      n6.code.add(o`void calculateStyleOutputs(UnpackedAttributes unpackedAttributes) {}`), i5.code.add(o`float calculateLineOffset() {
return 0.0;
}
float calculateLinePressure() {
return 1.0;
}`);
      break;
    case x2.SKETCH:
      n6.code.add(o`void calculateStyleOutputs(UnpackedAttributes unpackedAttributes)
{
calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);
}`), i5.code.add(o`float calculateLineOffset() {
return calculateLineOffsetSketch();
}
float calculateLinePressure() {
return calculateLinePressureSketch();
}`);
      break;
    case x2.MIXED:
      r3.varyings.add("vType", "float"), n6.code.add(o`void calculateStyleOutputs(UnpackedAttributes unpackedAttributes)
{
vType = unpackedAttributes.type;
if (unpackedAttributes.type <= 0.0) {
calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);
}
}`), i5.code.add(o`float calculateLineOffset() {
if (vType <= 0.0) {
return calculateLineOffsetSketch();
}
else {
return 0.0;
}
}
float calculateLinePressure() {
if (vType <= 0.0) {
return calculateLinePressureSketch();
}
else {
return 1.0;
}
}`);
  }
}

// node_modules/@arcgis/core/chunks/EdgeShader.glsl.js
function w(i5) {
  const r3 = new i2(), { vertex: w2, fragment: L2 } = r3;
  return i5.legacy && w2.uniforms.add(new A("model"), new A("localView")), r3.include(i3, i5), r3.include(f, i5), r3.include(d, i5), r3.include(i4, i5), r3.include(n5, i5), r3.include(P, i5), r3.include(o6, i5), r3.include(a2, i5), r3.include(n3, i5), r3.varyings.add("vColor", "vec4"), r3.varyings.add("vRadius", "float"), r3.varyings.add("vPosition", "vec3"), r3.varyings.add("vWorldPosition", "vec3"), r3.varyings.add("vViewPos", "vec3"), r3.varyings.add("vLineLengthPixels", "float"), r3.varyings.add("vSizeFalloffFactor", "float"), w2.uniforms.add(new e4("pixelToNDC", (i6, o7) => r(h, 2 / o7.camera.fullViewport[2], 2 / o7.camera.fullViewport[3])), new e5("viewport", (e7, i6) => i6.camera.fullViewport), new o4("pixelRatio", (e7, i6) => i6.camera.pixelRatio)), r3.attributes.add(O.POSITION0, "vec3"), r3.attributes.add(O.POSITION1, "vec3"), r3.attributes.add(O.VARIANTOFFSET, "float"), r3.attributes.add(O.VARIANTSTROKE, "float"), r3.attributes.add(O.VARIANTEXTENSION, "float"), w2.code.add(o`
    const float opaqueCutoff = 1.0 / 255.0;

    void calculateGeometricOutputs(vec3 viewPosV0, vec3 viewPosV1, vec3 worldPosV0, vec3 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {
      vec2 sideness = unpackedAttributes.sideness;
      vec2 sidenessNorm = unpackedAttributes.sidenessNorm;

      vWorldPosition = mix(worldPosV0, worldPosV1, sidenessNorm.y).xyz;

      vec3 viewPos = mix(viewPosV0, viewPosV1, sidenessNorm.y);
      vViewPos = viewPos;

      vec4 projPosV0 = projFromViewPosition(viewPosV0);
      vec4 projPosV1 = projFromViewPosition(viewPosV1);
      vec4 projPos = projFromViewPosition(viewPos);

      vec3 screenSpaceLineNDC = (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);
      vec2 ndcToPixel = viewport.zw * 0.5;
      vec2 screenSpaceLinePixels = screenSpaceLineNDC.xy * ndcToPixel;
      float lineLengthPixels = length(screenSpaceLinePixels);

      float dzPerPixel = screenSpaceLineNDC.z / lineLengthPixels;
      vec2 screenSpaceDirection = screenSpaceLinePixels / lineLengthPixels;
      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;

      float falloffFactor = distanceBasedPerspectiveFactor(-viewPos.z) * pixelRatio;
      float lineWidthPixels = unpackedAttributes.lineWidthPixels * falloffFactor;

      float extensionLengthPixels = calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;
      float lineAmplitudePixels = calculateLineAmplitude(unpackedAttributes) * pixelRatio;

      vSizeFalloffFactor = falloffFactor;

      float lineWidthAndAmplitudePixels = lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;
      float extendedLineLengthPixels = lineLengthPixels + extensionLengthPixels + extensionLengthPixels;

      ${i5.antialiasing ? o`
        const float aaPaddingPixels = 1.0;

        // Line size with padding
        float halfAAPaddedLineWidthAndAmplitudePixels = lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;
        float aaPaddedRoundedCapSizePixels = lineWidthPixels * 0.5 + aaPaddingPixels;` : o`
        float halfAAPaddedLineWidthAndAmplitudePixels = max(lineWidthAndAmplitudePixels, 1.0) * 0.5;
        float aaPaddedRoundedCapSizePixels = max(lineWidthPixels, 1.0) * 0.5;`}

      // Half line width in NDC including padding for anti aliasing
      vec2 halfAAPaddedLineWidthAndAmplitudeNDC = halfAAPaddedLineWidthAndAmplitudePixels * pixelToNDC;
      vec2 aaPaddedRoundedCapSizeNDC = aaPaddedRoundedCapSizePixels * pixelToNDC;
      vec2 extensionLengthNDC = extensionLengthPixels * pixelToNDC;

      // Compute screen space position of vertex, offsetting for line size and end caps
      vec2 ndcOffset = (
          screenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)
        + perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC
      );

      projPos.xy += ndcOffset * projPos.w;
      projPos.z += (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;

      projPos = adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));

      // Line length with end caps
      float aaPaddedLineWithCapsLengthPixels = extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;

      float pixelPositionAlongLine = aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;

      // Position in pixels with origin at first vertex of line segment
      vPosition = vec3(
        halfAAPaddedLineWidthAndAmplitudePixels * sideness.x,
        pixelPositionAlongLine,
        pixelPositionAlongLine / extendedLineLengthPixels
      );

      // The line width radius in pixels
      vRadius = lineWidthPixels * 0.5;
      vLineLengthPixels = extendedLineLengthPixels;

      // discard short edges below a certain length threshold
      ${i5.mode === x2.SKETCH ? o`
        if (lineLengthPixels <= 3.0) {
          gl_Position = vec4(10.0, 10.0, 10.0, 1.0);
          return;
        }` : i5.mode === x2.MIXED ? o`
        if (lineLengthPixels <= 3.0 && unpackedAttributes.type <= 0.0) {
           gl_Position = vec4(10.0, 10.0, 10.0, 1.0);
           return;
        }` : ""}
      gl_Position = projPos;
    }

    void main() {
      ComponentData component = readComponentData();
      UnpackedAttributes unpackedAttributes = unpackAttributes(component);

      vec3 worldPosV0, worldPosV1, viewPosV0, viewPosV1;
      worldAndViewFromModelPosition(position0, component.verticalOffset, worldPosV0, viewPosV0);
      worldAndViewFromModelPosition(position1, component.verticalOffset, worldPosV1, viewPosV1);

      // Component color
      vColor = component.color;

      // Discard fully transparent edges
      if (vColor.a < opaqueCutoff) {
        gl_Position = vec4(10.0, 10.0, 10.0, 1.0);
        return;
      }

      if (discardNonSilhouetteEdges(viewPosV0, worldPosV0)) {
        return;
      }

      // General geometric computation for all types of edges
      calculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal(), unpackedAttributes);

      // Specific computation for different edge styles
      calculateStyleOutputs(unpackedAttributes);
    }
  `), L2.code.add(o`
    vec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {
      float positionX = position.x - calculateLineOffset();

      if (radius < 1.0) {
        float coverageX = clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);
        float coverageY = clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);
        return vec2(0.5 - min(coverageX, coverageY), 0.0);
      }
      else {
        // Between -radius -> 0 for start cap, 0 for line, 0 -> radius
        float positionOnCap = position.y - clamp(position.y, 0.0, lineLength);

        vec2 lineToPosition = vec2(positionX, positionOnCap);
        return vec2(length(lineToPosition) - radius, positionOnCap / radius);
      }
    }

    void main() {
      ${i5.hasMultipassTerrain ? "terrainDepthTest(gl_FragCoord, vViewPos.z);" : ""}
      float radius = vRadius * calculateLinePressure();

      vec2 distance = lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);
      float coverage = clamp(0.5 - distance.x, 0.0, 1.0);

      discardByCoverage(radius, coverage);
      discardBySlice(vWorldPosition);

      fragColor = vec4(vColor.rgb, vColor.a * coverage);
    }
  `), r3;
}
var h = n2();
var A = class extends i {
  constructor(e7) {
    super(e7, "mat4");
  }
};
var L = Object.freeze(Object.defineProperty({ __proto__: null, build: w }, Symbol.toStringTag, { value: "Module" }));

export {
  x2 as x,
  F,
  w,
  L
};
//# sourceMappingURL=chunk-GIWW523T.js.map
