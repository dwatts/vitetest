import {
  T,
  e2
} from "./chunk-TRGMWULG.js";
import {
  f,
  l as l2
} from "./chunk-DOR4M5EA.js";
import {
  e as e3
} from "./chunk-QS45OHBM.js";
import {
  a
} from "./chunk-3I3GE5YW.js";
import {
  o as o3
} from "./chunk-UUW6REOV.js";
import {
  s
} from "./chunk-Z3NHJA5D.js";
import {
  o as o2
} from "./chunk-V66LHQVK.js";
import {
  o
} from "./chunk-WDZ5AAFL.js";
import {
  D,
  G
} from "./chunk-BCDDCNQ2.js";
import {
  l,
  n
} from "./chunk-YGUWDSEH.js";
import {
  r2 as r
} from "./chunk-3CQBBMMD.js";
import {
  e2 as e
} from "./chunk-V76KGJFU.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/ProceduralTextureRepository.js
var t = class {
  constructor(t2, r4, s3) {
    this._createTexture = t2, this._parametersKey = r4, this._repository = /* @__PURE__ */ new Map(), this._orphanCache = s3.newCache(`procedural-texture-repository:${e()}`, (e4) => e4.dispose());
  }
  destroy() {
    for (const [e4, { texture: t2 }] of this._repository)
      t2.dispose();
    this._repository.clear(), this._orphanCache.destroy();
  }
  swap(e4, t2 = null) {
    const r4 = this._acquire(e4);
    return this.release(t2), r4;
  }
  release(e4) {
    if (null == e4)
      return;
    const t2 = this._parametersKey(e4), r4 = this._repository.get(t2);
    if (r4 && (r4.refCount--, 0 === r4.refCount)) {
      this._repository.delete(t2);
      const { texture: e5 } = r4, s3 = e5.gpuMemoryUsage;
      this._orphanCache.put(t2, e5, s3);
    }
  }
  _acquire(e4) {
    if (null == e4)
      return null;
    const t2 = this._parametersKey(e4), s3 = this._repository.get(t2);
    if (s3)
      return s3.refCount++, s3.texture;
    const o5 = this._orphanCache.pop(t2) ?? this._createTexture(e4), i = new r2(o5);
    return this._repository.set(t2, i), o5;
  }
};
var r2 = class {
  constructor(e4) {
    this.texture = e4, this.refCount = 1;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/stippleTextureRepository.js
function a2(t2, a3) {
  return new t((e4) => {
    const { encodedData: a4, paddedPixels: u3 } = c(e4), s3 = new e2();
    return s3.internalFormat = G.RGBA, s3.width = u3, s3.height = 1, s3.wrapMode = D.CLAMP_TO_EDGE, new T(t2, s3, a4);
  }, (t3) => `${t3.pattern.join(",")}-r${t3.pixelRatio}`, a3);
}
function c(e4) {
  const r4 = u(e4), o5 = 1 / e4.pixelRatio, n2 = s2(e4), i = l3(e4), a3 = (Math.floor(0.5 * (i - 1)) + 0.5) * o5, c3 = [];
  let f3 = 1;
  for (const t2 of r4) {
    for (let e5 = 0; e5 < t2; e5++) {
      const r5 = f3 * (Math.min(e5, t2 - 1 - e5) + 0.5) * o5 / a3 * 0.5 + 0.5;
      c3.push(r5);
    }
    f3 = -f3;
  }
  const d = Math.round(r4[0] / 2), m2 = [...c3.slice(d), ...c3.slice(0, d)], h2 = n2 + p, x = new Uint8Array(4 * h2);
  let w = 4;
  for (const u3 of m2)
    o(u3, x, w), w += 4;
  return x.copyWithin(0, w - 4, w), x.copyWithin(w, 4, 8), { encodedData: x, paddedPixels: h2 };
}
function u(t2) {
  return t2.pattern.map((e4) => Math.round(e4 * t2.pixelRatio));
}
function s2(t2) {
  if (null == t2)
    return 1;
  const e4 = u(t2);
  return Math.floor(e4.reduce((t3, e5) => t3 + e5));
}
function l3(t2) {
  return u(t2).reduce((t3, e4) => Math.max(t3, e4));
}
var p = 2;

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/ensureColor4.js
function o4(c3) {
  return null == c3 ? l : 4 === c3.length ? c3 : r(r3, c3[0], c3[1], c3[2], 1);
}
var r3 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js
function c2(e4, t2) {
  e4.constants.add("stippleAlphaColorDiscard", "float", 1e-3), e4.constants.add("stippleAlphaHighlightDiscard", "float", 0.5), t2.stippleEnabled ? f2(e4, t2) : u2(e4);
}
function f2(s3, n2) {
  const c3 = !(n2.draped && n2.stipplePreferContinuous), { vertex: f3, fragment: u3 } = s3;
  u3.include(a), n2.draped || (f(f3, n2), f3.uniforms.add(new o3("worldToScreenPerDistanceRatio", (e4, t2) => 1 / t2.camera.perScreenPixelRatio)), f3.code.add(o2`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - cameraPosition);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)), s3.varyings.add("vStippleDistance", "float"), n2.stippleRequiresClamp && s3.varyings.add("vStippleDistanceLimits", "vec2"), n2.stippleRequiresStretchMeasure && s3.varyings.add("vStipplePatternStretch", "float"), f3.code.add(o2`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${h};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `), f3.code.add(o2`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`), f3.code.add(o2`
    if (segmentLengthPseudoScreen >= ${c3 ? "patternLength" : "1e4"}) {
  `), l2(f3, n2), f3.code.add(o2`
        // Round the screen length to get an integer number of pattern repetitions (minimum 1).
        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
        float segmentLengthScreenRounded = flooredRepetitions * patternLength;

        ${n2.stippleRequiresStretchMeasure ? o2`
              float stretch = repetitions / flooredRepetitions;

              // We need to impose a lower bound on the stretch factor to prevent the dots from merging together when there is only 1 repetition.
              // 0.75 is the lowest possible stretch value for flooredRepetitions > 1, so it makes sense as lower bound.
              vStipplePatternStretch = max(0.75, stretch);` : ""}

        return vec2(0.0, segmentLengthScreenRounded);
      }
      return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
    }
  `), u3.constants.add("stippleTexturePadding", "float", p), u3.uniforms.add(new s("stipplePatternTexture", (e4) => e4.stippleTexture), new o3("stipplePatternSDFNormalizer", (e4) => S(e4.stipplePattern)), new o3("stipplePatternPixelSizeInv", (e4) => 1 / m(e4))), u3.code.add(o2`float padStippleTexture(float u) {
float paddedTextureSize = float(textureSize(stipplePatternTexture, 0).x);
float unpaddedTextureSize = paddedTextureSize - stippleTexturePadding;
return (u * unpaddedTextureSize + stippleTexturePadding * 0.5) / paddedTextureSize;
}`), u3.code.add(o2`
    float getStippleSDF(out bool isClamped) {
      ${n2.stippleRequiresClamp ? o2`
          float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);
          vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
          isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;` : o2`
          float stippleDistanceClamped = vStippleDistance;
          isClamped = false;`}

      float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv;
      ${n2.stippleScaleWithLineWidth ? o2`u *= vLineSizeInv;` : ""}
      u = padStippleTexture(fract(u));

      float encodedSDF = rgba2float(texture(stipplePatternTexture, vec2(u, 0.5)));
      float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;

      ${n2.stippleRequiresStretchMeasure ? o2`return (sdf - 0.5) * vStipplePatternStretch + 0.5;` : o2`return sdf;`}
    }

    float getStippleSDF() {
      bool ignored;
      return getStippleSDF(ignored);
    }

    float getStippleAlpha() {
      bool isClamped;
      float stippleSDF = getStippleSDF(isClamped);

      float antiAliasedResult = ${n2.stippleScaleWithLineWidth ? o2`clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);` : o2`clamp(stippleSDF + 0.5, 0.0, 1.0);`}

      return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
    }
  `), n2.stippleOffColorEnabled ? (u3.uniforms.add(new e3("stippleOffColor", (e4) => o4(e4.stippleOffColor))), u3.code.add(o2`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)) : u3.code.add(o2`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`);
}
function u2(e4) {
  e4.fragment.code.add(o2`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`);
}
function S(e4) {
  return e4 ? (Math.floor(0.5 * (l3(e4) - 1)) + 0.5) / e4.pixelRatio : 1;
}
function m(e4) {
  const t2 = e4.stipplePattern;
  return t2 ? s2(e4.stipplePattern) / t2.pixelRatio : 1;
}
var h = o2.float(0.4);

export {
  t,
  a2 as a,
  c2 as c,
  m
};
//# sourceMappingURL=chunk-SCAYUERS.js.map
