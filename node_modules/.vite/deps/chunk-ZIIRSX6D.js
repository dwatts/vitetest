import {
  D
} from "./chunk-3NWIYHNX.js";
import {
  r as r2
} from "./chunk-CERU5LKM.js";
import {
  a as a2,
  p,
  s as s2
} from "./chunk-JZVYLVFO.js";
import {
  A,
  E,
  c,
  l
} from "./chunk-LIXBKTBN.js";
import {
  P,
  e as e2,
  f,
  i as i2,
  l as l2,
  m,
  o as o4,
  s
} from "./chunk-VDSNHCMM.js";
import {
  E as E2
} from "./chunk-6LC2JTLC.js";
import {
  e,
  i,
  t
} from "./chunk-V6CD66ZZ.js";
import {
  W,
  _,
  a
} from "./chunk-6FHMQNMS.js";
import {
  t as t2
} from "./chunk-YQDOKTNT.js";
import {
  d2 as d,
  o2
} from "./chunk-SMDDCTGQ.js";
import {
  r
} from "./chunk-YLTVH2K4.js";
import {
  o as o3
} from "./chunk-SADO52IH.js";
import {
  h
} from "./chunk-73PNWDTS.js";
import {
  H
} from "./chunk-Z7LZRT7C.js";
import {
  O as O2
} from "./chunk-BN6X2OXK.js";
import {
  G,
  O,
  o
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/LineMarkerTechnique.js
var R = /* @__PURE__ */ new Map([[O2.POSITION, 0], [O2.UV0, 2], [O2.AUXPOS1, 3], [O2.NORMAL, 4], [O2.COLOR, 5], [O2.COLORFEATUREATTRIBUTE, 5], [O2.SIZE, 6], [O2.SIZEFEATUREATTRIBUTE, 6], [O2.OPACITYFEATUREATTRIBUTE, 7]]);
var b = class _b extends e {
  initializeProgram(e3) {
    return new i(e3.rctx, _b.shader.get().build(this.configuration), R);
  }
  _makePipelineState(t3, i3) {
    const o5 = this.configuration, a3 = t3 === o3.NONE;
    return W({ blending: o5.output === h.Color || o5.output === h.Alpha ? a3 ? c : A(t3) : null, depthTest: { func: l(t3) }, depthWrite: a3 ? o5.writeDepth ? a : null : E(t3), colorWrite: _, stencilWrite: o5.hasOccludees ? e2 : null, stencilTest: o5.hasOccludees ? i3 ? o4 : f : null, polygonOffset: { factor: 0, units: -10 } });
  }
  initializePipeline() {
    return this.configuration.occluder && (this._occluderPipelineTransparent = W({ blending: c, depthTest: s, depthWrite: null, colorWrite: _, stencilWrite: null, stencilTest: m }), this._occluderPipelineOpaque = W({ blending: c, depthTest: s, depthWrite: null, colorWrite: _, stencilWrite: l2, stencilTest: P }), this._occluderPipelineMaskWrite = W({ blending: null, depthTest: i2, depthWrite: null, colorWrite: null, stencilWrite: e2, stencilTest: o4 })), this._occludeePipelineState = this._makePipelineState(this.configuration.transparencyPassType, true), this._makePipelineState(this.configuration.transparencyPassType, false);
  }
  getPipelineState(e3, t3) {
    return t3 ? this._occludeePipelineState : this.configuration.occluder ? e3 === E2.TRANSPARENT_OCCLUDER_MATERIAL ? this._occluderPipelineTransparent : e3 === E2.OCCLUDER_MATERIAL ? this._occluderPipelineOpaque : this._occluderPipelineMaskWrite : super.getPipelineState(e3, t3);
  }
};
b.shader = new t(D, () => import("./LineMarker.glsl-L2C7GDIL.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/LineMarkerMaterial.js
var v = class extends d {
  constructor(e3) {
    super(e3, new E3()), this._vertexAttributeLocations = R, this._configuration = new a2(), this._layout = this.createLayout();
  }
  dispose() {
  }
  getConfiguration(e3, t3) {
    return this._configuration.output = e3, this._configuration.space = t3.slot === E2.DRAPED_MATERIAL ? p.Draped : this.parameters.worldSpace ? p.World : p.Screen, this._configuration.hideOnShortSegments = this.parameters.hideOnShortSegments, this._configuration.hasCap = this.parameters.cap !== r2.BUTT, this._configuration.anchor = this.parameters.anchor, this._configuration.hasTip = this.parameters.hasTip, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.hasOccludees = this.parameters.hasOccludees, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.vvSize = !!this.parameters.vvSize, this._configuration.vvColor = !!this.parameters.vvColor, this._configuration.vvOpacity = !!this.parameters.vvOpacity, this._configuration.occluder = this.parameters.renderOccluded === o2.OccludeAndTransparentStencil, this._configuration.transparencyPassType = t3.transparencyPassType, this._configuration.hasMultipassTerrain = t3.multipassTerrain.enabled, this._configuration.cullAboveGround = t3.multipassTerrain.cullAboveGround, this._configuration;
  }
  intersect() {
  }
  createLayout() {
    const e3 = H().vec3f(O2.POSITION).vec2f(O2.UV0).vec3f(O2.AUXPOS1);
    return this.parameters.worldSpace && e3.vec3f(O2.NORMAL), this.parameters.vvSize ? e3.f32(O2.SIZEFEATUREATTRIBUTE) : e3.f32(O2.SIZE), this.parameters.vvColor ? e3.f32(O2.COLORFEATUREATTRIBUTE) : e3.vec4f(O2.COLOR), this.parameters.vvOpacity && e3.f32(O2.OPACITYFEATUREATTRIBUTE), e3;
  }
  createBufferWriter() {
    return new S(this._layout, this.parameters);
  }
  requiresSlot(e3, t3) {
    if (t3 === h.Color || t3 === h.Alpha || t3 === h.Highlight || t3 === h.Depth) {
      if (e3 === E2.DRAPED_MATERIAL)
        return true;
      if (this.parameters.renderOccluded === o2.OccludeAndTransparentStencil)
        return e3 === E2.OPAQUE_MATERIAL || e3 === E2.OCCLUDER_MATERIAL || e3 === E2.TRANSPARENT_OCCLUDER_MATERIAL;
      if (t3 === h.Color || t3 === h.Alpha) {
        return e3 === (this.parameters.writeDepth ? E2.TRANSPARENT_MATERIAL : E2.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL);
      }
      return e3 === E2.OPAQUE_MATERIAL;
    }
    return false;
  }
  createGLMaterial(e3) {
    return new f2(e3);
  }
};
var f2 = class extends r {
  constructor() {
    super(...arguments), this._markerPrimitive = null;
  }
  dispose() {
    super.dispose(), this._markerTextureRepository.release(this._markerPrimitive), this._markerPrimitive = null;
  }
  _updateParameters(e3) {
    const t3 = this._material.parameters.markerPrimitive;
    return t3 !== this._markerPrimitive && (this._material.setParameters({ markerTexture: this._markerTextureRepository.swap(t3, this._markerPrimitive) }), this._markerPrimitive = t3), this._material.setParameters(this.textureBindParameters), this.ensureTechnique(b, e3);
  }
  _updateOccludeeState(e3) {
    e3.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e3.hasOccludees });
  }
  beginSlot(e3) {
    return this._output !== h.Color && this._output !== h.Alpha || this._updateOccludeeState(e3), this._updateParameters(e3);
  }
};
var E3 = class extends t2 {
  constructor() {
    super(...arguments), this.width = 0, this.color = [1, 1, 1, 1], this.markerPrimitive = "arrow", this.placement = "end", this.cap = r2.BUTT, this.anchor = s2.Center, this.hasTip = false, this.worldSpace = false, this.hideOnShortSegments = false, this.writeDepth = true, this.hasSlicePlane = false, this.vvFastUpdate = false, this.hasOccludees = false, this.markerTexture = null;
  }
};
var S = class {
  constructor(e3, t3) {
    this.vertexBufferLayout = e3, this._parameters = t3;
  }
  elementCount() {
    return "begin-end" === this._parameters.placement ? 12 : 6;
  }
  write(i3, s3, a3, o5, n2) {
    const h2 = a3.vertexAttributes.get(O2.POSITION).data, c2 = h2.length / 3;
    let p2 = [1, 0, 0];
    const l3 = a3.vertexAttributes.get(O2.NORMAL);
    this._parameters.worldSpace && null != l3 && (p2 = l3.data);
    let m2 = 1, d2 = 0;
    this._parameters.vvSize ? d2 = a3.vertexAttributes.get(O2.SIZEFEATUREATTRIBUTE).data[0] : a3.vertexAttributes.has(O2.SIZE) && (m2 = a3.vertexAttributes.get(O2.SIZE).data[0]);
    let T = [1, 1, 1, 1], A2 = 0;
    this._parameters.vvColor ? A2 = a3.vertexAttributes.get(O2.COLORFEATUREATTRIBUTE).data[0] : a3.vertexAttributes.has(O2.COLOR) && (T = a3.vertexAttributes.get(O2.COLOR).data);
    let _2 = 0;
    this._parameters.vvOpacity && (_2 = a3.vertexAttributes.get(O2.OPACITYFEATUREATTRIBUTE).data[0]);
    const v2 = new Float32Array(o5.buffer);
    let f3 = n2 * (this.vertexBufferLayout.stride / 4);
    const E4 = (e3, t3, r3, i4) => {
      if (v2[f3++] = e3[0], v2[f3++] = e3[1], v2[f3++] = e3[2], v2[f3++] = r3[0], v2[f3++] = r3[1], v2[f3++] = t3[0], v2[f3++] = t3[1], v2[f3++] = t3[2], this._parameters.worldSpace && (v2[f3++] = p2[0], v2[f3++] = p2[1], v2[f3++] = p2[2]), this._parameters.vvSize ? v2[f3++] = d2 : v2[f3++] = m2, this._parameters.vvColor)
        v2[f3++] = A2;
      else {
        const e4 = Math.min(4 * i4, T.length - 4);
        v2[f3++] = T[e4], v2[f3++] = T[e4 + 1], v2[f3++] = T[e4 + 2], v2[f3++] = T[e4 + 3];
      }
      this._parameters.vvOpacity && (v2[f3++] = _2);
    };
    let S2;
    !function(e3) {
      e3[e3.ASCENDING = 1] = "ASCENDING", e3[e3.DESCENDING = -1] = "DESCENDING";
    }(S2 || (S2 = {}));
    const g = (s4, a4) => {
      const o6 = o(O3, h2[3 * s4], h2[3 * s4 + 1], h2[3 * s4 + 2]), n3 = R2;
      let u = s4 + a4;
      do {
        o(n3, h2[3 * u], h2[3 * u + 1], h2[3 * u + 2]), u += a4;
      } while (G(o6, n3) && u >= 0 && u < c2);
      i3 && (O(o6, o6, i3), O(n3, n3, i3)), E4(o6, n3, [-1, -1], s4), E4(o6, n3, [1, -1], s4), E4(o6, n3, [1, 1], s4), E4(o6, n3, [-1, -1], s4), E4(o6, n3, [1, 1], s4), E4(o6, n3, [-1, 1], s4);
    }, I = this._parameters.placement;
    "begin" !== I && "begin-end" !== I || g(0, S2.ASCENDING), "end" !== I && "begin-end" !== I || g(c2 - 1, S2.DESCENDING);
  }
};
var O3 = n();
var R2 = n();

export {
  v
};
//# sourceMappingURL=chunk-ZIIRSX6D.js.map
