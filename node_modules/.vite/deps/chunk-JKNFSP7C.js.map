{
  "version": 3,
  "sources": ["../../@arcgis/core/chunks/ShadowCastAccumulate.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.27/esri/copyright.txt for details.\n*/\nimport{a as e,w as a}from\"./mat4.js\";import{c as r}from\"./mat4f64.js\";import{ScreenSpacePass as o}from\"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js\";import{ReadLinearDepth as s}from\"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js\";import{ReadShadowMapPassParameters as i,ReadShadowMapPass as t}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";import{CameraSpace as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js\";import{RgbaFloatEncoding as l}from\"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";import{Float2PassUniform as n}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{glsl as c}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{Matrix4PassUniform as p}from\"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";import{ShaderBuilder as h}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as m}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";class w extends i{}const u=255,g=1/u;function f(r){const i=new h,w=i.fragment;return w.include(l),w.include(s),i.include(d),i.include(o),i.include(t,r),w.uniforms.add(new m(\"depthMap\",(e=>e.linearDepthTexture)),new p(\"inverseViewMatrix\",((r,o)=>e(v,a(v,o.camera.viewMatrix,o.camera.center)))),new n(\"nearFar\",((e,a)=>a.camera.nearFar))),w.constants.add(\"sampleValue\",\"float\",g),w.code.add(c`void main(void) {\nfloat depth = rgba2float(texture(depthMap, uv));\nif (depth == 0.0) {\ndiscard;\n}\nfloat currentPixelDepth = linearDepthFromFloat(depth, nearFar);\nif (-currentPixelDepth > nearFar.y || -currentPixelDepth < nearFar.x) {\ndiscard;\n}\nvec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);\nvec4 worldSpacePos = inverseViewMatrix * currentPixelPos;\nmat4 shadowMatrix;\nfloat linearDepth = -currentPixelDepth;\nint i = chooseCascade(linearDepth, shadowMatrix);\nif (i >= numCascades) {\ndiscard;\n}\nvec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);\nif (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {\ndiscard;\n}\nvec2 uvShadow = cascadeCoordinates(i, lvpos);\nfloat depthShadow = readShadowMapDepth(uvShadow, shadowMapTex);\nbool shadow = depthShadow < lvpos.z;\nif (!shadow) {\ndiscard;\n}\nfragColor = vec4(sampleValue);\n}`),i}const v=r(),x=Object.freeze(Object.defineProperty({__proto__:null,ShadowCastAccumulatePassParameters:w,ShadowCastMaxSamples:u,build:f},Symbol.toStringTag,{value:\"Module\"}));export{w as S,u as a,x as b,f as c};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAI+lC,IAAM,IAAN,cAAgB,EAAC;AAAC;AAAC,IAAM,IAAE;AAAR,IAAY,IAAE,IAAE;AAAE,SAASA,GAAE,GAAE;AAAC,QAAMC,KAAE,IAAIA,MAAEC,KAAED,GAAE;AAAS,SAAOC,GAAE,QAAQ,CAAC,GAAEA,GAAE,QAAQC,EAAC,GAAEF,GAAE,QAAQ,CAAC,GAAEA,GAAE,QAAQG,EAAC,GAAEH,GAAE,QAAQ,GAAE,CAAC,GAAEC,GAAE,SAAS,IAAI,IAAI,EAAE,YAAY,CAAAG,OAAGA,GAAE,kBAAmB,GAAE,IAAIA,GAAE,qBAAqB,CAACC,IAAEF,OAAI,EAAEG,IAAE,EAAEA,IAAEH,GAAE,OAAO,YAAWA,GAAE,OAAO,MAAM,CAAC,CAAE,GAAE,IAAIC,GAAE,WAAW,CAACA,IAAEF,OAAIA,GAAE,OAAO,OAAQ,CAAC,GAAED,GAAE,UAAU,IAAI,eAAc,SAAQ,CAAC,GAAEA,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4Bl+C,GAAED;AAAC;AAAC,IAAMM,KAAE,EAAE;AAAV,IAAY,IAAE,OAAO,OAAO,OAAO,eAAe,EAAC,WAAU,MAAK,oCAAmC,GAAE,sBAAqB,GAAE,OAAMP,GAAC,GAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,CAAC;",
  "names": ["f", "i", "w", "a", "o", "e", "r", "v"]
}
