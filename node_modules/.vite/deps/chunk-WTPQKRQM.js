import {
  A,
  B,
  G,
  P,
  f
} from "./chunk-BCDDCNQ2.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-HMVAPW5X.js";
import {
  has
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/webgl/checkWebGLError.js
var o = s.getLogger("esri.views.webgl.checkWebGLError");
function t(e, r) {
  switch (r) {
    case e.INVALID_ENUM:
      return "Invalid Enum. An unacceptable value has been specified for an enumerated argument.";
    case e.INVALID_VALUE:
      return "Invalid Value. A numeric argument is out of range.";
    case e.INVALID_OPERATION:
      return "Invalid Operation. The specified command is not allowed for the current state.";
    case e.INVALID_FRAMEBUFFER_OPERATION:
      return "Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";
    case e.OUT_OF_MEMORY:
      return "Out of memory. Not enough memory is left to execute the command.";
    case e.CONTEXT_LOST_WEBGL:
      return "WebGL context has been lost";
    default:
      return "Unknown error";
  }
}
var n = !!has("enable-feature:webgl-debug");
function a() {
  return n;
}
function c() {
  return n;
}
function u(r) {
  if (a()) {
    const n3 = r.getError();
    if (n3) {
      const a3 = t(r, n3), c2 = new Error().stack;
      o.error(new s2("webgl-error", "WebGL error occured", { message: a3, stack: c2 }));
    }
  }
}

// node_modules/@arcgis/core/views/webgl/Util.js
function a2(e) {
  const r = e.gl;
  switch (r.getError()) {
    case r.NO_ERROR:
      return null;
    case r.INVALID_ENUM:
      return "An unacceptable value has been specified for an enumerated argument";
    case r.INVALID_VALUE:
      return "An unacceptable value has been specified for an argument";
    case r.INVALID_OPERATION:
      return "The specified command is not allowed for the current state";
    case r.INVALID_FRAMEBUFFER_OPERATION:
      return "The currently bound framebuffer is not framebuffer complete";
    case r.OUT_OF_MEMORY:
      return "Not enough memory is left to execute the command";
    case r.CONTEXT_LOST_WEBGL:
      return "WebGL context is lost";
  }
  return "Unknown error";
}
function n2(e, r) {
  return e.vertexBuffers[r].byteLength / i(e.layout[r]);
}
function i(e) {
  return e[0].stride;
}
function R(e, r, t2, s3, c2 = 0) {
  const a3 = e.gl, n3 = e.capabilities.instancing;
  e.bindBuffer(t2);
  for (const i2 of s3) {
    const e2 = r.get(i2.name);
    void 0 === e2 && console.error(`There is no location for vertex attribute '${i2.name}' defined.`);
    const t3 = c2 * i2.stride;
    if (i2.count <= 4)
      a3.vertexAttribPointer(e2, i2.count, i2.type, i2.normalized, i2.stride, i2.offset + t3), a3.enableVertexAttribArray(e2), i2.divisor > 0 && n3 && n3.vertexAttribDivisor(e2, i2.divisor);
    else if (9 === i2.count)
      for (let r2 = 0; r2 < 3; r2++)
        a3.vertexAttribPointer(e2 + r2, 3, i2.type, i2.normalized, i2.stride, i2.offset + 12 * r2 + t3), a3.enableVertexAttribArray(e2 + r2), i2.divisor > 0 && n3 && n3.vertexAttribDivisor(e2 + r2, i2.divisor);
    else if (16 === i2.count)
      for (let r2 = 0; r2 < 4; r2++)
        a3.vertexAttribPointer(e2 + r2, 4, i2.type, i2.normalized, i2.stride, i2.offset + 16 * r2 + t3), a3.enableVertexAttribArray(e2 + r2), i2.divisor > 0 && n3 && n3.vertexAttribDivisor(e2 + r2, i2.divisor);
    else
      console.error("Unsupported vertex attribute element count: " + i2.count);
  }
}
function o2(r, t2, s3, c2) {
  const a3 = r.gl, n3 = r.capabilities.instancing;
  r.bindBuffer(s3);
  for (const e of c2) {
    const r2 = t2.get(e.name);
    if (e.count <= 4)
      a3.disableVertexAttribArray(r2), e.divisor && e.divisor > 0 && n3 && n3.vertexAttribDivisor(r2, 0);
    else if (9 === e.count)
      for (let t3 = 0; t3 < 3; t3++)
        a3.disableVertexAttribArray(r2 + t3), e.divisor && e.divisor > 0 && n3 && n3.vertexAttribDivisor(r2 + t3, 0);
    else if (16 === e.count)
      for (let t3 = 0; t3 < 4; t3++)
        a3.disableVertexAttribArray(r2 + t3), e.divisor && e.divisor > 0 && n3 && n3.vertexAttribDivisor(r2 + t3, 0);
    else
      console.error("Unsupported vertex attribute element count: " + e.count);
  }
  r.unbindBuffer(A.ARRAY_BUFFER);
}
function E(e) {
  switch (e) {
    case G.ALPHA:
    case G.LUMINANCE:
    case G.RED:
    case G.RED_INTEGER:
    case P.R8:
    case P.R8I:
    case P.R8UI:
    case P.R8_SNORM:
    case B.STENCIL_INDEX8:
      return 1;
    case G.LUMINANCE_ALPHA:
    case G.RG:
    case G.RG_INTEGER:
    case P.RGBA4:
    case P.R16F:
    case P.R16I:
    case P.R16UI:
    case P.RG8:
    case P.RG8I:
    case P.RG8UI:
    case P.RG8_SNORM:
    case P.RGB565:
    case P.RGB5_A1:
    case B.DEPTH_COMPONENT16:
      return 2;
    case G.DEPTH_COMPONENT:
    case G.RGB:
    case G.RGB_INTEGER:
    case P.RGB8:
    case P.RGB8I:
    case P.RGB8UI:
    case P.RGB8_SNORM:
    case P.SRGB8:
    case B.DEPTH_COMPONENT24:
      return 3;
    case G.DEPTH_STENCIL:
    case G.DEPTH24_STENCIL8:
    case G.RGBA:
    case G.RGBA_INTEGER:
    case P.RGBA8:
    case P.R32F:
    case P.R11F_G11F_B10F:
    case P.RG16F:
    case P.R32I:
    case P.R32UI:
    case P.RG16I:
    case P.RG16UI:
    case P.RGBA8I:
    case P.RGBA8UI:
    case P.RGBA8_SNORM:
    case P.SRGB8_ALPHA8:
    case P.RGB9_E5:
    case P.RGB10_A2UI:
    case P.RGB10_A2:
    case B.DEPTH_STENCIL:
    case B.DEPTH_COMPONENT32F:
    case B.DEPTH24_STENCIL8:
      return 4;
    case B.DEPTH32F_STENCIL8:
      return 5;
    case P.RGB16F:
    case P.RGB16I:
    case P.RGB16UI:
      return 6;
    case P.RG32F:
    case P.RG32I:
    case P.RG32UI:
    case P.RGBA16F:
    case P.RGBA16I:
    case P.RGBA16UI:
      return 8;
    case P.RGB32F:
    case P.RGB32I:
    case P.RGB32UI:
      return 12;
    case P.RGBA32F:
    case P.RGBA32I:
    case P.RGBA32UI:
      return 16;
    case f.COMPRESSED_RGB_S3TC_DXT1_EXT:
    case f.COMPRESSED_RGBA_S3TC_DXT1_EXT:
      return 0.5;
    case f.COMPRESSED_RGBA_S3TC_DXT3_EXT:
    case f.COMPRESSED_RGBA_S3TC_DXT5_EXT:
      return 1;
    case f.COMPRESSED_R11_EAC:
    case f.COMPRESSED_SIGNED_R11_EAC:
    case f.COMPRESSED_RGB8_ETC2:
    case f.COMPRESSED_SRGB8_ETC2:
    case f.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
    case f.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return 0.5;
    case f.COMPRESSED_RG11_EAC:
    case f.COMPRESSED_SIGNED_RG11_EAC:
    case f.COMPRESSED_RGBA8_ETC2_EAC:
    case f.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
      return 1;
  }
  return 0;
}

export {
  a,
  c,
  u,
  a2,
  n2 as n,
  R,
  o2 as o,
  E
};
//# sourceMappingURL=chunk-WTPQKRQM.js.map
