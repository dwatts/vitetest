import {
  i as i5
} from "./chunk-N5A7N3L3.js";
import {
  C as C2,
  F as F3,
  O as O3,
  y as y3
} from "./chunk-RL5CVLRQ.js";
import {
  n as n4
} from "./chunk-XGIDQJNQ.js";
import {
  d as d2
} from "./chunk-TYEEWKIN.js";
import {
  a as a3,
  c,
  u as u3
} from "./chunk-WLMHEQN2.js";
import "./chunk-Y4ZO2DJL.js";
import {
  A
} from "./chunk-BUKSB3RJ.js";
import {
  s as s5
} from "./chunk-Y3PBROKK.js";
import {
  m as m2
} from "./chunk-PFDC65N2.js";
import {
  M,
  i as i4,
  t as t8
} from "./chunk-V33FVMPT.js";
import "./chunk-U67EYFX3.js";
import {
  t as t7
} from "./chunk-644IM3NW.js";
import {
  c as c3,
  t as t6,
  u as u4
} from "./chunk-VYGC2LVC.js";
import "./chunk-YEDW7SLL.js";
import {
  e as e6,
  f,
  r as r4
} from "./chunk-VDSNHCMM.js";
import {
  E as E3
} from "./chunk-6LC2JTLC.js";
import {
  s as s4
} from "./chunk-XM3YSFN6.js";
import {
  r as r6
} from "./chunk-KM375BNF.js";
import "./chunk-H3DKDGMJ.js";
import {
  c as c2
} from "./chunk-FB6EWBGE.js";
import {
  e as e5,
  i as i3,
  t as t5
} from "./chunk-V6CD66ZZ.js";
import {
  W as W2,
  _ as _2,
  a as a4
} from "./chunk-6FHMQNMS.js";
import {
  r as r5
} from "./chunk-KFDARCTS.js";
import "./chunk-WTPQKRQM.js";
import {
  E as E2
} from "./chunk-NU4UASX6.js";
import "./chunk-JHDKOKT6.js";
import "./chunk-LIO6VZRI.js";
import "./chunk-7DFZCT3D.js";
import "./chunk-ASBUA7EG.js";
import "./chunk-FY4ZONHH.js";
import {
  h as h5
} from "./chunk-73PNWDTS.js";
import "./chunk-N3RXOITN.js";
import "./chunk-CR5XNTAP.js";
import "./chunk-Z6IKMUOC.js";
import "./chunk-PV5KBAYL.js";
import "./chunk-YVVROPAO.js";
import {
  h as h4
} from "./chunk-IWA3Q52A.js";
import "./chunk-WA4HIOYR.js";
import "./chunk-3I3GE5YW.js";
import "./chunk-WRFNQB7U.js";
import "./chunk-Z3NHJA5D.js";
import "./chunk-BO2REVMA.js";
import "./chunk-V66LHQVK.js";
import {
  t as t4
} from "./chunk-JP7O2ZWE.js";
import "./chunk-4SIKLJSS.js";
import {
  Z
} from "./chunk-2XKILFME.js";
import "./chunk-G4LSNP77.js";
import "./chunk-BA6PBZHC.js";
import "./chunk-SGBMUZSF.js";
import {
  t as t2
} from "./chunk-FF5LS3YE.js";
import {
  C,
  E,
  F,
  I as I2
} from "./chunk-BCDDCNQ2.js";
import {
  Ce,
  Me,
  ve
} from "./chunk-SLMR4CTS.js";
import "./chunk-BFVDDR4R.js";
import "./chunk-XKENZ7D5.js";
import {
  $,
  N,
  Q,
  T as T2,
  W,
  X,
  Y as Y2
} from "./chunk-GZTS5346.js";
import "./chunk-EK3Y2IYO.js";
import "./chunk-6S2FCH6S.js";
import "./chunk-BZL5MAFP.js";
import "./chunk-XY26YCFX.js";
import {
  t as t3
} from "./chunk-3TTW7E7W.js";
import {
  F as F2,
  h as h3
} from "./chunk-FOEAKQNX.js";
import {
  h as h2
} from "./chunk-LEDSC236.js";
import "./chunk-NETCTS4Y.js";
import "./chunk-OKABUMQT.js";
import "./chunk-CW7LIPBH.js";
import "./chunk-TYOIANOD.js";
import "./chunk-VN2IXVGV.js";
import "./chunk-WWUAHPIM.js";
import {
  O as O2
} from "./chunk-BN6X2OXK.js";
import "./chunk-NX5NNI52.js";
import "./chunk-G2DTL6AE.js";
import "./chunk-O443WBFA.js";
import "./chunk-RGS3ANC3.js";
import "./chunk-YGUWDSEH.js";
import {
  r as r3
} from "./chunk-ZWFMUHG3.js";
import "./chunk-EFRTD25L.js";
import {
  p as p2,
  u
} from "./chunk-GSS6WNQU.js";
import "./chunk-C2EHS6UI.js";
import "./chunk-F4ILXEXC.js";
import "./chunk-63ERNIOV.js";
import {
  I,
  n as n3
} from "./chunk-KRCNIFX2.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-M6OG7C2T.js";
import "./chunk-GOK5MP3B.js";
import "./chunk-NLWV7Q6F.js";
import "./chunk-RVS5HU2K.js";
import "./chunk-JB7FDW5N.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-H37COY3W.js";
import "./chunk-NVGPNIR6.js";
import "./chunk-B4D7M7HT.js";
import "./chunk-3T2ETA25.js";
import "./chunk-5IYCCZ54.js";
import "./chunk-VMTVUE47.js";
import "./chunk-GDZM4A6K.js";
import {
  h as h6
} from "./chunk-XWGNMTES.js";
import "./chunk-6NNEHJYI.js";
import {
  kn
} from "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import "./chunk-W4KI5YEI.js";
import "./chunk-CAFGOFIE.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-JNDFAMXY.js";
import "./chunk-NTEKJWGF.js";
import "./chunk-TFIKV5RU.js";
import "./chunk-KW6QQDGN.js";
import {
  B,
  O,
  Y,
  b,
  i as i2,
  v as v2,
  y as y2,
  z
} from "./chunk-AQ7R6V4L.js";
import {
  u as u2
} from "./chunk-DOQ3SAAR.js";
import {
  b as b2
} from "./chunk-4BXK4H4L.js";
import "./chunk-SLVNG7FV.js";
import {
  _,
  a as a2
} from "./chunk-SVCGLUNW.js";
import "./chunk-DEZCXTA3.js";
import "./chunk-RRJGZKNX.js";
import "./chunk-PL5Q4C6Y.js";
import "./chunk-KFSY6ZZH.js";
import {
  V
} from "./chunk-7EQSYZHW.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-GGOVZ2GK.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import "./chunk-4OR73Y2R.js";
import {
  i,
  p
} from "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import {
  P as P2,
  e as e4,
  g,
  j as j2,
  r,
  s as s3,
  v
} from "./chunk-TPJLFGOT.js";
import {
  n as n2
} from "./chunk-CQX57DED.js";
import {
  r2
} from "./chunk-3CQBBMMD.js";
import "./chunk-Z2ZUNW5S.js";
import "./chunk-7L7Z2HXM.js";
import "./chunk-75NKPXTR.js";
import "./chunk-EUVARFSM.js";
import "./chunk-3VUFACNT.js";
import "./chunk-ZEEBL7ZN.js";
import {
  T2 as T
} from "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-57CHUY45.js";
import "./chunk-SJ2GJCS2.js";
import {
  U,
  h,
  l as l3
} from "./chunk-H7RDAEPY.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-S5OISW44.js";
import "./chunk-7KH4CLS5.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-JL3TJGVW.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import {
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a,
  e as e3,
  l as l2
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import {
  P,
  d,
  j,
  s as s2
} from "./chunk-7I33FAWS.js";
import {
  e as e2,
  l,
  t
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  R,
  m,
  n2 as n
} from "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/3d/layers/PointCloudWorkerHandle.js
var r7 = class extends h4 {
  constructor(t11) {
    super("PointCloudWorker", "transform", { transform: (t12) => this._getTransferList(t12) }, t11);
  }
  _getTransferList(t11) {
    const r11 = [t11.geometryBuffer];
    if (null != t11.primaryAttributeData && t11.primaryAttributeData.buffer && r11.push(t11.primaryAttributeData.buffer), null != t11.modulationAttributeData && t11.modulationAttributeData.buffer && r11.push(t11.modulationAttributeData.buffer), null != t11.filterAttributesData)
      for (const e9 of t11.filterAttributesData)
        null != e9 && e9.buffer && r11.push(e9.buffer);
    for (const e9 of t11.userAttributesData)
      e9.buffer && r11.push(e9.buffer);
    return r11;
  }
};

// node_modules/@arcgis/core/views/3d/layers/i3s/LoDUtil.js
function t9(e9, t11, g4) {
  for (let n7 = 0; n7 < t11.length; n7++)
    r8[n7] = false, o[n7] = null;
  for (let r11 = 0; r11 < e9.length; r11++)
    n5[r11] = false, l4[r11] = null;
  for (let n7 = 0; n7 < t11.length; n7++) {
    const o3 = h7(t11[n7], e9, g4);
    o3 >= 0 && (r8[n7] = true, null != l4[o3] ? l4[o3].push(t11[n7]) : l4[o3] = [t11[n7]]);
  }
  for (let l7 = 0; l7 < e9.length; l7++) {
    const r11 = h7(e9[l7], t11, g4);
    r11 >= 0 && (n5[l7] = true, null != o[r11] ? o[r11].push(e9[l7]) : o[r11] = [e9[l7]]);
  }
  const u8 = [];
  for (let r11 = 0; r11 < e9.length; r11++)
    null != l4[r11] || n5[r11] || u8.push({ load: [], remove: [e9[r11]] });
  for (let n7 = 0; n7 < t11.length; n7++)
    null != o[n7] || r8[n7] || u8.push({ load: [t11[n7]], remove: [] });
  for (let n7 = 0; n7 < t11.length; n7++)
    null != o[n7] && (o[n7].length > 1 || o[n7][0] !== t11[n7]) && u8.push({ load: [t11[n7]], remove: o[n7] });
  for (let n7 = 0; n7 < e9.length; n7++)
    null != l4[n7] && (l4[n7].length > 1 || l4[n7][0] !== e9[n7]) && u8.push({ load: l4[n7], remove: [e9[n7]] });
  return u8;
}
var n5 = [false];
var l4 = [null];
var r8 = [false];
var o = [null];
function h7(e9, t11, n7) {
  let l7 = e9;
  for (; l7 > 0; ) {
    const e10 = t11.indexOf(l7);
    if (e10 >= 0)
      return e10;
    l7 = n7.getParentId(l7);
  }
  return t11.indexOf(l7);
}
function g2(t11, n7, l7) {
  return t11.sort((t12, r11) => {
    if (0 === t12.load.length && 0 === r11.load.length)
      return 0;
    if (0 === t12.load.length)
      return -1;
    if (0 === r11.load.length)
      return 1;
    if (0 === t12.remove.length && 0 === r11.remove.length) {
      const o3 = l7.getRenderCenter(t12.load[0]), h10 = l7.getRenderCenter(r11.load[0]);
      return P2(o3, n7) - P2(h10, n7);
    }
    if (0 === t12.remove.length)
      return -1;
    if (0 === r11.remove.length)
      return 1;
    if (1 === t12.load.length && 1 === r11.load.length) {
      const o3 = l7.getRenderCenter(t12.load[0]), h10 = l7.getRenderCenter(r11.load[0]);
      return P2(o3, n7) - P2(h10, n7);
    }
    if (1 === t12.load.length)
      return -1;
    if (1 === r11.load.length)
      return 1;
    {
      const o3 = l7.getRenderCenter(t12.remove[0]), h10 = l7.getRenderCenter(r11.remove[0]);
      return P2(o3, n7) - P2(h10, n7);
    }
  });
}
function u5(e9, t11, n7) {
  for (let l7 = 0; l7 < e9.length; ++l7) {
    const r11 = e9[l7];
    r11.load.length > t11 && 1 === r11.remove.length && d3(e9, r11, n7);
  }
}
function d3(e9, t11, n7) {
  const l7 = [t11.remove[0]], r11 = [];
  for (; 1 === l7.length; ) {
    const e10 = l7.pop();
    r11.length = 0;
    for (let o3 = 0; o3 < t11.load.length; o3++) {
      let h10 = t11.load[o3], g4 = n7.getParentId(h10);
      for (; g4 !== e10; )
        h10 = g4, g4 = n7.getParentId(h10);
      let u8 = l7.indexOf(h10);
      u8 < 0 && (u8 = l7.length, l7.push(h10), r11.push([])), r11[u8].push(t11.load[o3]);
    }
  }
  t11.load = l7;
  for (let o3 = 0; o3 < l7.length; o3++)
    r11[o3].length > 1 ? e9.push({ remove: [l7[o3]], load: r11[o3] }) : l7[o3] = r11[o3][0];
}

// node_modules/@arcgis/core/views/3d/layers/i3s/PagedNodeIndex.js
var h8 = class {
  constructor(e9, t11, s7) {
    this._pages = [], this.pageSize = 0, this._nodeSR = null, this._renderSR = null, this._nodeSR = e9, this._renderSR = t11, this.pageSize = s7;
  }
  addPage(e9, t11, s7 = 0) {
    for (; this._pages.length < e9; )
      this._pages.push(null);
    const n7 = g3(t11, this._nodeSR, this._renderSR, s7);
    this._pages[e9] = { nodes: t11, renderObbs: n7, parents: new Uint32Array(this.pageSize) }, u6(this._pages, this.pageSize);
  }
  hasPage(e9) {
    return !!this._pages[e9];
  }
  getNode(e9) {
    const t11 = this.pageSize;
    return this._pages[l5(e9, t11)].nodes[c4(e9, t11)];
  }
  getRenderObb(e9) {
    const t11 = this.pageSize;
    return this._pages[l5(e9, t11)].renderObbs[c4(e9, t11)];
  }
  getRenderCenter(e9) {
    return this.getRenderObb(e9).center;
  }
  setRenderObb(e9, t11) {
    const s7 = this.pageSize;
    Q(t11, this._pages[l5(e9, s7)].renderObbs[c4(e9, s7)]);
  }
  getParentId(e9) {
    const t11 = this.pageSize;
    return this._pages[l5(e9, t11)].parents[c4(e9, t11)];
  }
  hasNodes(e9, t11) {
    const s7 = l5(e9, this.pageSize), n7 = l5(e9 + t11 - 1, this.pageSize);
    for (let i6 = s7; i6 <= n7; i6++)
      if (null == this._pages[i6])
        return false;
    return true;
  }
  forEachNodeId(e9) {
    for (let t11 = 0; t11 < this._pages.length; t11++) {
      const s7 = this._pages[t11];
      if (s7)
        for (let n7 = 0; n7 < s7.nodes.length; n7++)
          e9(t11 * this.pageSize + n7);
    }
  }
  createVisibilityTraverse() {
    const t11 = { index: this, queue: [], masks: [], tempAabb: i2() };
    return (e9, s7) => a5(t11, e9, s7);
  }
};
function a5(e9, n7, i6) {
  const p3 = e9.index;
  if (!p3.hasNodes(0, 1))
    return;
  const h10 = e9.queue;
  h10.length = 0, h10.push(0);
  const a6 = e9.masks;
  for (a6.length = 0, a6.push(0); h10.length > 0; ) {
    const g4 = h10.pop();
    let u8 = a6.pop();
    const c5 = p3.getNode(g4), d4 = p3.getRenderObb(g4);
    let f2 = true;
    if (null != n7.clippingBox) {
      const i7 = 1 << n7.frustum.length;
      if (0 == (u8 & i7)) {
        const o3 = W(d4, e9.tempAabb);
        b(n7.clippingBox, o3) ? u8 |= i7 : z(n7.clippingBox, o3) || (f2 = false);
      }
    }
    for (let e10 = 0; e10 < n7.frustum.length && f2; e10++) {
      const t11 = 1 << e10;
      if (0 == (u8 & t11)) {
        const s7 = T2(d4, n7.frustum[e10]);
        s7 > 0 ? f2 = false : s7 < 0 && (u8 |= t11);
      }
    }
    if (i6.predicate(g4, c5, f2)) {
      const e10 = c5.firstChild, t11 = c5.childCount;
      let s7 = false;
      const n8 = l5(e10, p3.pageSize), r11 = l5(e10 + t11 - 1, p3.pageSize);
      for (let o3 = n8; o3 <= r11; o3++)
        if (!p3.hasPage(o3)) {
          i6.pageMiss(g4, o3), s7 = true;
          break;
        }
      if (!s7)
        for (let i7 = 0; i7 < t11; i7++)
          h10.push(e10 + i7), a6.push(u8);
    }
  }
}
function g3(e9, t11, s7, i6) {
  const r11 = new N(e9.length);
  for (let o3 = 0; o3 < e9.length; o3++)
    Ce(e9[o3].obb, t11, r11.obbs[o3], s7, i6);
  return r11.obbs;
}
function u6(e9, t11) {
  const s7 = [0];
  for (; s7.length; ) {
    const n7 = s7.pop(), i6 = e9[l5(n7, t11)].nodes[c4(n7, t11)];
    for (let r11 = 0; r11 < i6.childCount; r11++) {
      const o3 = i6.firstChild + r11;
      null != e9[l5(o3, t11)] && (e9[l5(o3, t11)].parents[c4(o3, t11)] = n7, s7.push(o3));
    }
  }
}
function l5(e9, t11) {
  return e9 / t11 | 0;
}
function c4(e9, t11) {
  return e9 % t11;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/PointCloudRendererUtil.js
function t10(t11) {
  const e9 = t11.renderer, n7 = e9 == null ? void 0 : e9.type, o3 = (e9 == null ? void 0 : e9.toJSON()) ?? null;
  let l7 = null, i6 = false;
  const a6 = t11.attributeStorageInfo;
  "point-cloud-unique-value" === n7 || "point-cloud-stretch" === n7 || "point-cloud-class-breaks" === n7 ? l7 = u7(a6, e9.field) : "point-cloud-rgb" === n7 ? (l7 = r9(a6, e9.field), i6 = null != l7) : (l7 = r9(a6, "RGB"), i6 = null != l7);
  let s7 = null;
  return (e9 == null ? void 0 : e9.colorModulation) && (s7 = u7(a6, e9.colorModulation.field)), { rendererJSON: o3, isRGBRenderer: i6, primaryAttribute: l7, modulationAttribute: s7 };
}
function e7(t11) {
  const e9 = t11.filters;
  return e9 ? e9.map((e10) => ({ filterJSON: e10.toJSON(), attributeInfo: u7(t11.attributeStorageInfo, e10.field) })) : [];
}
function n6(t11) {
  const e9 = t11 == null ? void 0 : t11.pointSizeAlgorithm;
  return e9 && "splat" === e9.type ? e9 : null;
}
function o2(t11) {
  const e9 = t11 == null ? void 0 : t11.pointSizeAlgorithm;
  return e9 && "fixed-size" === e9.type ? e9 : null;
}
function l6(t11) {
  const e9 = t11 == null ? void 0 : t11.pointSizeAlgorithm;
  return !(!e9 || !e9.type) && "fixed-size" === e9.type;
}
function r9(t11, e9) {
  for (const n7 of t11 ?? [])
    if (n7.name === e9 && null != n7.attributeValues && "UInt8" === n7.attributeValues.valueType && 3 === n7.attributeValues.valuesPerElement)
      return { name: e9, storageInfo: n7, useElevation: false };
  return null;
}
function u7(t11, e9) {
  for (const n7 of t11 ?? [])
    if (n7.name === e9) {
      const t12 = "embedded-elevation" === n7.encoding;
      return t12 ? { name: e9, storageInfo: null, useElevation: t12 } : { name: e9, storageInfo: n7, useElevation: t12 };
    }
  return "elevation" === (e9 == null ? void 0 : e9.toLowerCase()) ? { name: e9, storageInfo: null, useElevation: true } : null;
}

// node_modules/@arcgis/core/views/3d/layers/i3s/PointGraphic.js
var e8 = class extends h6 {
  constructor(r11) {
    super(r11), this.pointCloudMetadata = null;
  }
};
e([y({ constructOnly: true, clonable: "reference" })], e8.prototype, "pointCloudMetadata", void 0), e8 = e([a("esri.views.3d.layers.i3s.PointGraphic")], e8);

// node_modules/@arcgis/core/views/3d/layers/i3s/PointHighlights.js
var h9 = class {
  constructor(e9) {
    this._context = e9, this._highlights = /* @__PURE__ */ new Set();
  }
  get hasHighlights() {
    return this._highlights.size > 0;
  }
  destroy() {
    this._highlights = null;
  }
  add(t11) {
    const i6 = new s6(t11);
    return this._highlights.add(i6), this._enableSet(i6), e3(() => this._removeSet(i6));
  }
  _removeSet(e9) {
    this._disableSet(e9), this._highlights.delete(e9);
  }
  _enableSet(e9) {
    e9.enabled || (e9.enabled = true, this._context.forEachNode((t11) => this._enableSetForNode(e9, t11)));
  }
  _enableSetForNode(e9, t11) {
    if (!e9.enabled)
      return;
    const i6 = e9.ids.get(t11.id);
    i6 && i6.forEach((i7) => this._context.addHighlight(t11, i7, e9.id));
  }
  _disableSet(e9) {
    e9.enabled && (e9.enabled = false, this._context.forEachNode((t11) => this._disableSetForNode(e9, t11)));
  }
  _disableSetForNode(e9, t11) {
    e9.enabled || this._context.removeHighlight(t11, e9.id);
  }
  nodeAdded(e9) {
    this._highlights.forEach((t11) => this._enableSetForNode(t11, e9));
  }
  nodeRemoved(e9) {
    this._highlights.forEach((t11) => this._disableSetForNode(t11, e9));
  }
  removeAll() {
    this._highlights.forEach((e9) => this._disableSet(e9));
  }
};
var s6 = class {
  constructor(e9) {
    this.id = new r4(t4.Highlight), this.ids = /* @__PURE__ */ new Map(), this.enabled = false;
    for (const t11 of e9)
      null != t11 && this._add(t11.nodeId, t11.pointId);
  }
  _add(e9, t11) {
    const i6 = this.ids.get(e9);
    i6 ? i6.add(t11) : this.ids.set(e9, /* @__PURE__ */ new Set([t11]));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/PointRendererTechnique.js
var m3 = class _m extends e5 {
  constructor(e9, r11, i6) {
    super(e9, r11, i6);
  }
  initializeProgram(e9) {
    return new i3(e9.rctx, _m.shader.get().build(this.configuration), E2);
  }
  initializePipeline() {
    return W2({ depthTest: { func: I2.LESS }, depthWrite: a4, colorWrite: _2, stencilWrite: this.configuration.hasOccludees ? e6 : null, stencilTest: this.configuration.hasOccludees ? f : null });
  }
};
m3.shader = new t5(C2, () => import("./PointRenderer.glsl-CHOYBUBA.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/PointRendererTechniqueConfiguration.js
var r10 = class extends s4 {
  constructor() {
    super(...arguments), this.output = h5.Color, this.hasSlicePlane = false, this.drawScreenSize = false, this.useFixedSizes = false, this.hasOccludees = false, this.clippingEnabled = false;
  }
};
e([r5({ count: h5.COUNT })], r10.prototype, "output", void 0), e([r5()], r10.prototype, "hasSlicePlane", void 0), e([r5()], r10.prototype, "drawScreenSize", void 0), e([r5()], r10.prototype, "useFixedSizes", void 0), e([r5()], r10.prototype, "hasOccludees", void 0), e([r5()], r10.prototype, "clippingEnabled", void 0), e([r5({ constValue: true })], r10.prototype, "hasSliceInVertexProgram", void 0);

// node_modules/@arcgis/core/views/3d/layers/i3s/PointRenderer.js
var V2 = { positions: [new t2(O2.POSITION, 3, C.FLOAT, 0, 12)], colors: [new t2(O2.COLOR, 3, C.UNSIGNED_BYTE, 0, 3, true)] };
var W3 = class {
  get needsHighlight() {
    return this._highlights.hasHighlights;
  }
  constructor(e9) {
    this._params = e9, this.type = i4.PCL, this.isGround = false, this._passParameters = new y3(), this._highlights = new h9({ forEachNode: (e10) => this.forEachNode(e10), addHighlight: (e10, t11, s7) => this._addHighlight(e10, t11, s7), removeHighlight: (e10, t11) => this._removeHighlight(e10, t11) }), this.canRender = true, this.layerUid = "", this._slicePlaneEnabled = false, this._techniqueConfig = new r10(), this._nodes = new l2();
  }
  initializeRenderContext(e9) {
    this._context = e9, this._techniqueRepository = this._context.techniqueRepository, e9.requestRender();
  }
  uninitializeRenderContext() {
  }
  intersect(e9, t11, m4, g4) {
    const _3 = n2(), S = n2(), w = n2(), y4 = n2(), j3 = h3(), F4 = e9.camera.perScreenPixelRatio / 2, v3 = e9.camera.near;
    e4(S, g4, m4);
    const C3 = 1 / s3(S);
    g(S, S, C3), j2(w, S), r2(j3, S[0], S[1], S[2], -P2(S, m4));
    const E4 = new Z2(), H = new Z2(), N2 = new Array(), O4 = i2(), L = i2(this._passParameters.clipBox);
    Y(L, -m4[0], -m4[1], -m4[2], L), this._nodes.forAll((i6) => {
      const r11 = i6.splatSize * this._passParameters.scaleFactor;
      let n7 = X(i6.obb, j3), h10 = Y2(i6.obb, j3);
      n7 -= Y3(r11, n7 + v3, this._passParameters, F4, i6.isLeaf), h10 -= Y3(r11, h10 + v3, this._passParameters, F4, i6.isLeaf);
      const l7 = h10 < 0, c5 = null != E4.dist && null != H.dist && E4.dist < n7 * C3 && H.dist > h10 * C3;
      if (l7 || c5)
        return;
      const f2 = G(r11, h10 + v3, this._passParameters, F4, i6.isLeaf);
      if (!$(i6.obb, m4, S, f2))
        return;
      const P3 = f2 * f2;
      W(i6.obb, O4), Y(O4, -m4[0], -m4[1], -m4[2], O4);
      const b3 = !b(L, O4);
      e4(y4, i6.origin, m4);
      const A2 = i6.coordinates.length / 3;
      for (let s7 = 0; s7 < A2; s7++) {
        if (_3[0] = y4[0] + i6.coordinates[3 * s7], _3[1] = y4[1] + i6.coordinates[3 * s7 + 1], _3[2] = y4[2] + i6.coordinates[3 * s7 + 2], b3 && !y2(L, _3))
          continue;
        const n8 = P2(_3, S), h11 = v(_3) - n8 * n8;
        if (h11 > P3)
          continue;
        let l8 = n8 + v3;
        const c6 = Y3(r11, l8, this._passParameters, F4, i6.isLeaf);
        if (n8 - c6 < 0)
          continue;
        l8 -= c6;
        const u8 = G(r11, l8, this._passParameters, F4, i6.isLeaf);
        if (h11 > u8 * u8)
          continue;
        const d4 = (n8 - c6) * C3, f3 = (e10) => (e10.point = J(i6, s7, e10.point), e10.dist = d4, e10.normal = w, e10.node = i6, e10.pointId = s7, e10.layerUid = this.layerUid, e10);
        if ((null == E4.dist || d4 < E4.dist) && (null == t11 || t11(m4, g4, d4)) && f3(E4), e9.options.store !== t8.MIN && (null == H.dist || d4 > H.dist) && (null == t11 || t11(m4, g4, d4)) && f3(H), e9.options.store === t8.ALL && (null == t11 || t11(m4, g4, d4))) {
          const e10 = new Z2();
          N2.push(f3(e10));
        }
      }
    });
    const T3 = (e10) => {
      const { layerUid: t12, node: s7, pointId: i6 } = e10;
      return new s5(e10.point, t12, i6, () => this._params.createGraphic(s7, i6, e10.point));
    }, B2 = (e10, t12) => {
      const s7 = T3(t12);
      e10.set(this.type, s7, t12.dist, t12.normal);
    };
    if ($2(E4)) {
      const t12 = e9.results.min;
      (null == t12.dist || E4.dist < t12.dist) && B2(t12, E4);
    }
    if ($2(H) && e9.options.store !== t8.MIN) {
      const t12 = e9.results.max;
      (null == t12.dist || H.dist > t12.dist) && B2(t12, H);
    }
    if (e9.options.store === t8.ALL) {
      const t12 = h2(m4, g4);
      for (const s7 of N2) {
        const i6 = M(t12);
        B2(i6, s7), e9.results.all.push(i6);
      }
    }
  }
  prepareTechnique(e9) {
    return 0 === this._nodes.length || e9.output !== h5.Color && e9.output !== h5.Depth && e9.output !== h5.Highlight ? null : (this._nodes.forAll((t11) => {
      null == t11.vao && this._initNode(e9, t11);
    }), this._techniqueConfig.drawScreenSize = this._passParameters.drawScreenSpace, this._techniqueConfig.useFixedSizes = this._passParameters.useFixedSizes, this._techniqueConfig.hasSlicePlane = this._slicePlaneEnabled, this._techniqueConfig.hasOccludees = e9.bindParameters.hasOccludees, this._techniqueConfig.clippingEnabled = this._clippingEnabled, this._techniqueConfig.output = e9.output === h5.Depth ? h5.Depth : e9.output === h5.Highlight ? h5.Highlight : h5.Color, this._techniqueRepository.releaseAndAcquire(m3, this._techniqueConfig, this._technique));
  }
  render(e9, t11) {
    const s7 = e9.rctx, i6 = s7.bindTechnique(t11, this._passParameters, e9.bindParameters), r11 = e9.output === h5.Highlight;
    this._nodes.forAll((t12) => {
      0 === t12.coordinates.length || r11 && !t12.highlights || (i6.bindDraw(t12, e9.bindParameters, this._passParameters), s7.bindVAO(t12.vao), r11 ? this._renderHighlightFragments(s7, t12) : s7.drawArrays(E.POINTS, 0, t12.coordinates.length / 3));
    });
  }
  _renderHighlightFragments(e9, t11) {
    const s7 = t11.highlights;
    if (null == s7)
      return;
    let i6 = s7[0].component, r11 = i6 + 1;
    for (let o3 = 1; o3 < s7.length; o3++) {
      const t12 = s7[o3].component;
      if (t12 !== r11) {
        const s8 = r11 - i6;
        s8 > 0 && e9.drawArrays(E.POINTS, i6, s8), i6 = t12;
      }
      r11 = t12 + 1;
    }
    const n7 = r11 - i6;
    n7 > 0 && e9.drawArrays(E.POINTS, i6, n7);
  }
  set useFixedSizes(e9) {
    this._passParameters.useFixedSizes !== e9 && (this._passParameters.useFixedSizes = e9, this._requestRender());
  }
  get useFixedSizes() {
    return this._passParameters.useFixedSizes;
  }
  set scaleFactor(e9) {
    this._passParameters.scaleFactor !== e9 && (this._passParameters.scaleFactor = e9, this._requestRender());
  }
  get scaleFactor() {
    return this._passParameters.scaleFactor;
  }
  set minSizePx(e9) {
    this._passParameters.minSizePx !== e9 && (this._passParameters.minSizePx = e9, this._requestRender());
  }
  get minSizePx() {
    return this._passParameters.minSizePx;
  }
  set useRealWorldSymbolSizes(e9) {
    this._passParameters.useRealWorldSymbolSizes !== e9 && (this._passParameters.useRealWorldSymbolSizes = e9, this._requestRender());
  }
  get useRealWorldSymbolSizes() {
    return this._passParameters.useRealWorldSymbolSizes;
  }
  set size(e9) {
    this._passParameters.size !== e9 && (this._passParameters.size = e9, this._requestRender());
  }
  get size() {
    return this._passParameters.size;
  }
  set sizePx(e9) {
    this._passParameters.sizePx !== e9 && (this._passParameters.sizePx = e9, this._requestRender());
  }
  get sizePx() {
    return this._passParameters.sizePx;
  }
  set clippingBox(e9) {
    O(this._passParameters.clipBox, e9 || v2);
  }
  get _clippingEnabled() {
    return !B(this._passParameters.clipBox, v2, (e9, t11) => e9 === t11);
  }
  get slicePlaneEnabled() {
    return this._slicePlaneEnabled;
  }
  set slicePlaneEnabled(e9) {
    this._slicePlaneEnabled !== e9 && (this._slicePlaneEnabled = e9, this._requestRender());
  }
  addNode(e9) {
    this._nodes.push(e9), this._highlights.nodeAdded(e9), this._requestRender();
  }
  removeNode(t11) {
    let s7 = null;
    return this._nodes.filterInPlace((i6) => i6.id !== t11 || (s7 = i6, i6.vao = t(i6.vao), this._highlights.nodeRemoved(i6), false)), this._requestRender(), s7;
  }
  forEachNode(e9) {
    this._nodes.forAll(e9);
  }
  removeAll() {
    this._nodes.forAll((t11) => t11.vao = t(t11.vao)), this._highlights.removeAll(), this._nodes.clear(), this._requestRender();
  }
  highlight(e9) {
    return this._highlights.add(e9);
  }
  _addHighlight(e9, t11, s7) {
    e9.highlights = Q2(e9.highlights, t11, s7), this._requestRender();
  }
  _removeHighlight(e9, t11) {
    e9.highlights = X2(e9.highlights, t11), this._requestRender();
  }
  _initNode(e9, t11) {
    const s7 = e9.rctx;
    t11.vao = new r6(s7, E2, V2, { positions: c2.createVertex(s7, F.STATIC_DRAW, t11.coordinates), colors: c2.createVertex(s7, F.STATIC_DRAW, t11.rgb) });
  }
  _requestRender() {
    this._context && this._context.requestRender();
  }
};
var U2 = class extends O3 {
  constructor(e9, t11, s7, i6, r11, n7, o3, a6, h10 = null, l7 = null) {
    super(s7, r11, t11), this.id = e9, this.obb = i6, this.coordinates = n7, this.rgb = o3, this.attributes = a6, this.pointIdFilterMap = h10, this.highlights = l7;
  }
};
function k(e9) {
  return e9.hasOwnProperty("splatSize");
}
function G(e9, t11, s7, i6, r11) {
  if (s7.drawScreenSpace)
    return s7.fixedSize * t11 * i6;
  const n7 = F3(r11) * t11 * i6;
  return s7.useFixedSizes ? Math.min(s7.fixedSize / 2, n7) : s7.screenMinSize > 0 ? Math.min(Math.max(s7.screenMinSize * t11 * i6, e9 / 2), n7) : Math.min(e9 / 2, n7);
}
function Y3(e9, t11, s7, i6, r11) {
  return s7.drawScreenSpace ? 0 : G(e9, t11, s7, i6, r11);
}
function J(e9, t11, s7) {
  return null == s7 && (s7 = n2()), s7[0] = e9.origin[0] + e9.coordinates[3 * t11], s7[1] = e9.origin[1] + e9.coordinates[3 * t11 + 1], s7[2] = e9.origin[2] + e9.coordinates[3 * t11 + 2], s7;
}
function K(e9) {
  return null != e9.component ? e9.component : -1;
}
function Q2(e9, t11, s7) {
  null == e9 && (e9 = []);
  const i6 = { component: t11, id: s7 };
  e9.push(i6);
  const r11 = K(i6);
  let n7 = e9.length - 1;
  for (; n7 > 0 && r11 < K(e9[n7 - 1]); )
    [e9[n7 - 1], e9[n7]] = [e9[n7], e9[n7 - 1]], --n7;
  return e9;
}
function X2(e9, t11) {
  if (null == e9)
    return e9;
  const s7 = e9.filter((e10) => e10.id !== t11);
  return 0 === s7.length ? null : s7;
}
var Z2 = class {
  constructor() {
    this.node = null, this.pointId = null, this.point = null, this.dist = null, this.normal = null, this.layerUid = "";
  }
};
function $2(e9) {
  return null != e9.dist && null != e9.point && null != e9.pointId && null != e9.node;
}

// node_modules/@arcgis/core/views/3d/layers/PointCloudLayerView3D.js
var _e = 8;
var me = h3();
var ge = class extends i5(n4(d2)) {
  constructor() {
    super(...arguments), this.type = "point-cloud-3d", this.maximumPointCount = 4e6, this.slicePlaneEnabled = false, this._renderer = null, this._rendererAdded = false, this._renderedNodes = /* @__PURE__ */ new Set(), this._nodeScales = /* @__PURE__ */ new Map(), this._updateViewNeeded = true, this._lodFactor = 1, this._maxLoggedBoxWarnings = 5, this._pageMultiplier = 1, this._nodeLoadEpoch = 0, this._indexQueue = [], this._workQueue = new Array(), this._idleQueue = new n3(), this._indexPagesLoading = /* @__PURE__ */ new Map(), this._loadingNodes = /* @__PURE__ */ new Map(), this._recalcWork = true, this._layerIsVisible = false, this._codedDomainPopulationPromise = null, this._codedDomainPopulationAbortController = null, this._totalWork = 0, this._index = null, this._loadingInitNodePage = false, this._nodeIdArray = [], this.ignoresMemoryFactor = false;
  }
  get baseUrl() {
    return this.layer.parsedUrl.path;
  }
  get pointScale() {
    const e9 = n6(this.layer && this.layer.renderer), t11 = 1;
    return e9 && null != e9.scaleFactor ? e9.scaleFactor : t11;
  }
  get useRealWorldSymbolSizes() {
    const e9 = o2(this.layer && this.layer.renderer), t11 = false;
    return e9 && null != e9.useRealWorldSymbolSizes ? e9.useRealWorldSymbolSizes : t11;
  }
  get pointSize() {
    const e9 = o2(this.layer && this.layer.renderer), t11 = 0;
    return e9 && null != e9.size ? e9.size : t11;
  }
  get inverseDensity() {
    const e9 = 96;
    return this.layer && this.layer.renderer ? 1 * e9 / this.layer.renderer.pointsPerInch : 5;
  }
  get availableFields() {
    const e9 = t10(this.layer), t11 = /* @__PURE__ */ new Set();
    e9.primaryAttribute && t11.add(e9.primaryAttribute.name), e9.modulationAttribute && t11.add(e9.modulationAttribute.name);
    const i6 = e7(this.layer);
    if (i6)
      for (const r11 of i6)
        r11.attributeInfo && t11.add(r11.attributeInfo.name);
    if (this.layer.outFields)
      for (const r11 of b2(this.layer.fieldsIndex, this.layer.outFields))
        t11.add(r11);
    return Array.from(t11);
  }
  get _clippingBox() {
    if (!this.view || !this.view.clippingArea)
      return null;
    const e9 = i2(), t11 = this.view.renderSpatialReference;
    return m2(this.view.clippingArea, e9, t11) ? e9 : null;
  }
  get _elevationOffset() {
    const e9 = this.layer && this.layer.elevationInfo;
    if (e9 && "absolute-height" === e9.mode) {
      const t11 = T(this.layer.spatialReference), i6 = r3(e9.unit);
      return (e9.offset ?? 0) * i6 / t11;
    }
    return 0;
  }
  initialize() {
    const e9 = this.view.resourceController, t11 = Ne(e9);
    this._worker = new r7(t11), this.addResolvingPromise(this._worker.promise), this._tmpPoint = Z(0, 0, 0, this.layer.spatialReference), ve(this.layer), Me(this.layer, this.view), this._indexRequester = e9.createStreamDataRequester(A.I3S_INDEX), this._dataRequester = e9.createStreamDataRequester(A.I3S_DATA), this._initRenderer();
    const i6 = this._initNodePages(), r11 = this.view.resourceController.memoryController;
    this._memCache = r11.newCache(`pcl-${this.layer.uid}`), this.updatingHandles.add(() => this._clippingBox, () => this._setUpdateViewNeeded(), h), this.updatingHandles.add(() => this._elevationOffset, () => this._elevationOffsetChanged(), h), this.updatingHandles.add(() => this.layer.renderer, () => this._rendererChanged(), h), this.updatingHandles.add(() => this.layer.filters, () => this._reload(), h), this.updatingHandles.add(() => this.layer.outFields, () => this._reload(), h), this.updatingHandles.add(() => this.layer.effectiveScaleRange, () => this._setUpdateViewNeeded()), this.updatingHandles.add(() => this.view.state.contentCamera, () => this._setUpdateViewNeeded()), this.handles.add([this.view.basemapTerrain.on("scale-change", (e10) => this._scaleUpdateHandler(e10)), l3(() => r11.memoryFactor, () => this._setUpdateViewNeeded(), U)]), this.addResolvingPromise(i6), this.when(() => {
      this.handles.add([e9.scheduler.registerTask(I.POINT_CLOUD_LAYER, this), e9.scheduler.registerIdleStateCallbacks(() => this._idleBegin(), () => this._idleEnd()), this.updatingHandles.add(() => this.suspended, (e10) => {
        e10 ? this._clearNodeState() : this._setUpdateViewNeeded();
      }, h)]);
    }, () => {
      this.updatingHandles.removeAll(), this.handles.removeAll();
    });
  }
  _setUpdateViewNeeded() {
    this._updateViewNeeded = true, this._updateLoading();
  }
  destroy() {
    this.cancelLoading(), this._worker = l(this._worker), this._destroyRenderer(), this._memCache = l(this._memCache), this._codedDomainPopulationAbortController = e2(this._codedDomainPopulationAbortController), this._codedDomainPopulationPromise = null;
  }
  _initRenderer() {
    this._renderer = new W3({ createGraphic: (e9, t11, i6) => this._createGraphic(e9, t11, i6) }), this._renderer.layerUid = this.layer.uid, this.updatingHandles.add(() => this._clippingBox, (e9) => this._renderer.clippingBox = e9, h), this.updatingHandles.add(() => this.suspended, (e9) => this._setPointsVisible(!e9), h), this.updatingHandles.add(() => this.pointScale, (e9) => this._renderer.scaleFactor = e9, h), this._renderer.minSizePx = Math.sqrt(2), this.updatingHandles.add(() => this.useRealWorldSymbolSizes, (e9) => this._renderer.useRealWorldSymbolSizes = e9, h), this.updatingHandles.add(() => this.pointSize, (e9) => {
      const t11 = u2(e9);
      this._renderer.size = e9, this._renderer.sizePx = t11;
    }, h), this.updatingHandles.add(() => this.slicePlaneEnabled, (e9) => this._renderer.slicePlaneEnabled = e9, h), this.updatingHandles.add(() => this.inverseDensity, () => this._setUpdateViewNeeded(), h), this.updatingHandles.add(() => this.maximumPointCount, () => this._setUpdateViewNeeded(), h), this.updatingHandles.add(() => this.view.qualitySettings.sceneService.pointCloud.lodFactor, (e9) => {
      this._lodFactor = e9, this._setUpdateViewNeeded();
    }, h);
  }
  _destroyRenderer() {
    this._renderer.removeAll(), this._setPointsVisible(false);
  }
  _createGraphic(e9, t11, i6) {
    const r11 = null != e9.pointIdFilterMap ? e9.pointIdFilterMap[t11] : t11, s7 = this.view.computeMapPointFromVec3d(i6), o3 = this._createGraphicAttributes(e9, r11);
    return new e8({ pointCloudMetadata: { nodeId: e9.id, pointIndexInNode: t11, attributePointIndexInNode: r11, epoch: this._nodeLoadEpoch }, geometry: s7, attributes: o3, layer: this.layer, sourceLayer: this.layer });
  }
  _createGraphicAttributes(e9, t11) {
    const i6 = {};
    for (const r11 of e9.attributes)
      this._encodeGraphicAttribute(r11.attributeInfo, r11.values, t11, i6);
    return i6;
  }
  _encodeGraphicAttribute(e9, t11, i6, r11) {
    var _a;
    const s7 = (_a = e9.storageInfo) == null ? void 0 : _a.attributeValues, o3 = (s7 == null ? void 0 : s7.valuesPerElement) ?? 1;
    if (1 === o3)
      r11[e9.name] = t11[i6];
    else if ("UInt8" === (s7 == null ? void 0 : s7.valueType) && o3 <= 4) {
      let s8 = 0;
      const n7 = i6 * o3;
      for (let e10 = n7; e10 < n7 + o3; e10++)
        s8 = (s8 << 8) + t11[e10];
      r11[e9.name] = s8;
    } else
      r11[e9.name] = void 0;
  }
  _setPointsVisible(e9) {
    e9 && !this._rendererAdded ? (this.view._stage.addRenderPlugin([E3.OPAQUE_MATERIAL], this._renderer), this._rendererAdded = true) : !e9 && this._rendererAdded && (this.view._stage.removeRenderPlugin(this._renderer), this._rendererAdded = false);
  }
  _rendererChanged() {
    this._renderer.useFixedSizes = l6(this.layer.renderer), this._reload();
  }
  _reload() {
    this._clearNodeState(), this._memCache.clear(), this._setUpdateViewNeeded();
  }
  _elevationOffsetChanged() {
    this._clearNodeState(), this._memCache.clear(), this._initNodePages();
  }
  _scaleUpdateHandler(e9) {
    const t11 = this.layer.effectiveScaleRange;
    c3(t11.minScale, t11.maxScale) ? kn(e9.extent, e9.spatialReference, be, this.layer.spatialReference) && (this._nodeScales.forEach((t12, i6) => {
      if (!this._renderedNodes.has(i6))
        return void this._nodeScales.delete(i6);
      const r11 = this._index.getNode(i6);
      p(be, r11.obb.center) && this._nodeScales.set(i6, e9.scale);
    }), this._setUpdateViewNeeded()) : this._nodeScales.clear();
  }
  _displayNodes(e9) {
    this._workQueue = t9([...this._renderedNodes], e9, this._index), g2(this._workQueue, this.view.state.contentCamera.viewForward, this._index), u5(this._workQueue, _e, this._index), this._updateQueues(), this._totalWork = this._computeWork(), this._updateLoading(), this._layerIsVisible = e9.length > 0 || this._loadingInitNodePage, this.notifyChange("suspended");
  }
  cancelLoading() {
    this._cancelNodeLoading(), this._cancelIndexLoading();
  }
  _cancelNodeLoading() {
    const e9 = new Array();
    this._loadingNodes.forEach(({ abortController: t11 }) => e9.push(t11)), this._loadingNodes.clear();
    for (const t11 of e9)
      t11.abort();
    this._workQueue = [], this._idleQueue.cancelAll(), this._totalWork = this._computeWork(), this._updateLoading();
  }
  _updateQueues() {
    const e9 = /* @__PURE__ */ new Set();
    this._workQueue.forEach((t12) => t12.load.forEach((t13) => e9.add(t13)));
    const t11 = new Array(), i6 = /* @__PURE__ */ new Map();
    this._loadingNodes.forEach((r11, s7) => {
      e9.has(s7) ? i6.set(s7, r11) : t11.push(r11);
    }), this._loadingNodes = i6;
    for (const { abortController: r11 } of t11)
      r11.abort();
    this._workQueue = this._workQueue.filter((e10) => {
      for (const t12 of e10.load)
        if (this._loadingNodes.has(t12))
          return this._recalcWork = true, false;
      return true;
    }), this._totalWork = this._computeWork(), this._updateLoading();
  }
  _cancelIndexLoading() {
    this._indexQueue = [], this._indexPagesLoading.forEach(({ abortController: e9 }) => e9.abort()), this._indexPagesLoading.clear(), this._totalWork = this._computeWork(), this._updateLoading();
  }
  _clearNodeState() {
    this._nodeLoadEpoch++, this._renderedNodes.forEach((e9) => this._removeFromRenderer(e9)), this._cancelNodeLoading();
  }
  _idleBegin() {
    this._setUpdateViewNeeded();
  }
  _idleEnd() {
    this._setUpdateViewNeeded();
  }
  get running() {
    return this.suspended ? this._updateViewNeeded : this._updateViewNeeded || this._indexQueue.length > 0 || this._workQueue.length > 0 || this._idleQueue.running;
  }
  runTask(e9) {
    if (this.suspended) {
      if (this._updateViewNeeded) {
        this._updateViewNeeded = false;
        const e10 = this._isRootNodeVisible();
        e10 !== this._layerIsVisible && (this._layerIsVisible = e10, this.notifyChange("suspended")), this._updateLoading();
      }
    } else {
      for (e9.run(() => this._updateWorkQueues()); this._indexQueue.length > 0 && e9.run(() => this._processIndexQueue()); )
        ;
      this._processWorkQueue(e9), this._idleQueue.runTask(e9);
    }
  }
  _processIndexQueue() {
    const e9 = this._indexQueue.shift(), t11 = this._loadNodePage(e9);
    return this._indexPagesLoading.set(e9, t11), t11.promise.then((t12) => {
      this._index.addPage(e9, t12, this._elevationOffset), this._setUpdateViewNeeded();
    }).then(() => {
      this._indexPagesLoading.delete(e9);
    }, () => {
      this._indexPagesLoading.delete(e9);
    }), true;
  }
  _processWorkQueue(e9) {
    for (; !e9.done; ) {
      const t11 = this._scheduleWorkEntry();
      if (null == t11)
        return;
      this._processWorkEntry(t11), e9.madeProgress();
    }
  }
  _scheduleWorkEntry() {
    let e9 = this._workQueue.length;
    for (; e9--; ) {
      const e10 = this._workQueue.shift();
      if (!e10.remove.find((e11) => !this._renderedNodes.has(e11)))
        return e10;
      this._workQueue.push(e10);
    }
    return null;
  }
  _processWorkEntry(e9) {
    if (0 !== e9.load.length)
      Promise.all(e9.load.map((e10) => {
        const t11 = new AbortController(), i6 = this._memCache.pop(e10.toString());
        return null != i6 ? this._loadingNodes.set(e10, { abortController: t11, promise: Promise.resolve(i6) }) : this._loadingNodes.has(e10) || this._loadingNodes.set(e10, { abortController: t11, promise: this._loadNode(e10, t11.signal) }), this._loadingNodes.get(e10).promise;
      })).then((t11) => {
        for (let i6 = 0; i6 < e9.load.length; i6++)
          if (t11[i6]) {
            const r11 = this._setupRendererData(e9.load[i6], t11[i6]);
            this._addToRenderer(r11);
          }
        for (const i6 of e9.remove)
          this._removeFromRenderer(i6);
      }).catch(() => {
      }).then(() => {
        for (const t11 of e9.load)
          this._loadingNodes.delete(t11);
        this._updateLoading(), this._recalcWork && !this._idleQueue.running && 0 === this._indexQueue.length && 0 === this._loadingNodes.size && (this._recalcWork = false, this._setUpdateViewNeeded());
      }), this._updateLoading();
    else
      for (const t11 of e9.remove)
        this._removeFromRenderer(t11);
  }
  async _populateClassCodeCodedDomain(e9, t11) {
    var _a, _b, _c;
    const r11 = "CLASS_CODE", s7 = this.layer.fieldsIndex.get(r11);
    if (!s7 || s7.domain)
      return;
    if (!e9.includes(s7.name))
      return;
    const o3 = await _(this.layer.queryCachedStatistics(r11, { signal: t11 }));
    if (false === o3.ok)
      return;
    const n7 = (_c = (_b = (_a = o3.value) == null ? void 0 : _a.stats) == null ? void 0 : _b.labels) == null ? void 0 : _c.labels;
    n7 && Array.isArray(n7) && (s7.domain = new u({ name: "CLASS_CODE", codedValues: n7.map((e10) => new p2({ code: e10.value, name: e10.label })) }));
  }
  async prepareFetchPopupFeatures(e9) {
    return this._codedDomainPopulationPromise || (this._codedDomainPopulationAbortController = new AbortController(), this._codedDomainPopulationPromise = this._populateClassCodeCodedDomain(e9, this._codedDomainPopulationAbortController.signal).then(() => {
      this._codedDomainPopulationAbortController = null;
    })), this._codedDomainPopulationPromise;
  }
  async whenGraphicAttributes(e9, i6) {
    const s7 = this._splitGraphicsPerNode(e9), o3 = this.layer.attributeStorageInfo, n7 = i6.map((e10) => u7(o3, e10)).filter(R), a6 = async (e10, t11) => {
      const i7 = this._index.getNode(t11);
      await a2(n7, async (t12) => {
        const r11 = t12.useElevation ? await this._loadElevationAttributeFromGeometry(i7.resourceId) : await this._loadAndParseAttribute(i7, t12);
        if (r11) {
          for (const i8 of e10)
            if (this._isValidPointGraphic(i8)) {
              const e11 = i8.pointCloudMetadata.attributePointIndexInNode;
              this._encodeGraphicAttribute(t12, r11, e11, i8.attributes);
            }
        }
      });
    }, l7 = [];
    return s7.forEach((e10, t11) => {
      l7.push(a6(e10, t11));
    }), await j(l7), e9;
  }
  _isValidPointGraphic(e9) {
    var _a;
    return e9 instanceof e8 && ((_a = e9.pointCloudMetadata) == null ? void 0 : _a.epoch) === this._nodeLoadEpoch;
  }
  _splitGraphicsPerNode(e9) {
    const t11 = /* @__PURE__ */ new Map();
    for (const i6 of e9) {
      if (!this._isValidPointGraphic(i6))
        continue;
      const e10 = i6.pointCloudMetadata, r11 = t11.get(e10.nodeId);
      r11 ? r11.push(i6) : t11.set(e10.nodeId, [i6]);
    }
    return t11;
  }
  async _loadAndParseAttribute(e9, t11) {
    const i6 = await this._loadAttribute(e9.resourceId, t11, null);
    return null != i6 ? c({ attributeInfo: t11, buffer: i6 }, null, e9.vertexCount) : null;
  }
  async _loadElevationAttributeFromGeometry(e9) {
    const t11 = this.layer.store.defaultGeometrySchema, i6 = u3(t11, await this._loadGeometry(e9, null));
    return a3(i6, i6.length / 3);
  }
  highlight(e9) {
    if (!e9)
      return { remove() {
      } };
    const t11 = V.isCollection(e9) ? e9.toArray() : Array.isArray(e9) ? e9 : [e9];
    return this._renderer.highlight(t11.map((e10) => this._graphicToPointDefinition(e10)));
  }
  _graphicToPointDefinition(e9) {
    if (!this._isValidPointGraphic(e9))
      return null;
    const { nodeId: t11, pointIndexInNode: i6 } = e9.pointCloudMetadata;
    return null != t11 && null != i6 ? { nodeId: t11, pointId: i6 } : null;
  }
  _computeWork() {
    let e9 = 0;
    for (const t11 of this._workQueue)
      e9 += t11.load.length + t11.remove.length;
    return e9 += this._loadingNodes.size, e9 += (this._indexQueue.length + this._indexPagesLoading.size) * this._index.pageSize, e9 += this._loadingInitNodePage ? 100 : 0, e9 += this._updateViewNeeded ? 100 : 0, e9;
  }
  get updatingProgressValue() {
    if (this.suspended)
      return this._updateViewNeeded ? 0 : 1;
    const e9 = this._computeWork();
    return 1 - Math.min(this._totalWork, e9) / this._totalWork;
  }
  _updateLoading() {
    this.notifyChange("updating"), this.notifyChange("updatingProgressValue");
  }
  canResume() {
    return super.canResume() && this._layerIsVisible;
  }
  isUpdating() {
    return this.suspended ? this._updateViewNeeded : this._computeWork() > 0;
  }
  _initNodePages() {
    const e9 = this.layer.store.index, t11 = e9.nodesPerPage || e9.nodePerIndexBlock;
    return this._index = new h8(this.layer.spatialReference, this.view.renderCoordsHelper.spatialReference, t11), this._cancelIndexLoading(), this._traverseVisible = this._index.createVisibilityTraverse(), this._loadingInitNodePage = true, this._layerIsVisible = true, this.notifyChange("suspended"), this._updateLoading(), this._pageMultiplier = null != e9.nodesPerPage ? 1 : e9.nodePerIndexBlock, this._loadNodePage(0).promise.then((e10) => {
      this._index.addPage(0, e10, this._elevationOffset), this._loadingInitNodePage = false, this._setUpdateViewNeeded();
    });
  }
  _loadNodePage(e9) {
    const t11 = new AbortController(), i6 = `${this.baseUrl}/nodepages/${e9 * this._pageMultiplier}`;
    return { promise: this._requestNodePage(i6, t11.signal).then((t12) => t12.nodes.map((t13, i7) => ({ resourceId: null != t13.resourceId ? t13.resourceId : e9 * this._index.pageSize + i7, obb: t13.obb, firstChild: t13.firstChild, childCount: t13.childCount, vertexCount: t13.vertexCount ?? t13.pointCount, lodThreshold: t13.lodThreshold ?? t13.effectiveArea }))), abortController: t11 };
  }
  _updateWorkQueues() {
    if (!this._updateViewNeeded)
      return false;
    let e9 = this.inverseDensity / this._lodFactor * this._getLodMemoryFactor();
    const t11 = this.maximumPointCount * this._lodFactor * this._getLodMemoryFactor();
    let i6 = this._computeNodesForMinimumDensity(e9), r11 = this._computePointCount(i6), s7 = Math.sqrt(r11 / (0.75 * t11));
    for (; r11 > t11; )
      e9 *= s7, i6 = this._computeNodesForMinimumDensity(e9), r11 = this._computePointCount(i6), s7 = Math.sqrt(2);
    return this._displayNodes(i6), this._updateViewNeeded = false, this._updateLoading(), true;
  }
  _computePointCount(e9) {
    let t11 = 0;
    for (let i6 = 0; i6 < e9.length; i6++) {
      const r11 = this._index.getNode(e9[i6]);
      r11 && (t11 += r11.vertexCount);
    }
    return t11;
  }
  _getLodMemoryFactor() {
    return this.view.resourceController.memoryController.memoryFactor;
  }
  _isRootNodeVisible() {
    let e9 = false;
    return this._traverseVisible({ frustum: this.view.state.contentCamera.frustum, clippingBox: this._clippingBox }, { predicate: (t11, i6, r11) => (e9 = r11, false), pageMiss: () => {
    } }), e9;
  }
  _computeNodesForMinimumDensity(e9) {
    const t11 = this.view.state.contentCamera, i6 = t11.frustum, r11 = this._clippingBox, s7 = t11.viewForward, o3 = P2(s7, t11.eye), n7 = F2(s7, -o3, me), a6 = t11.perScreenPixelRatio / 2, d4 = e9 * e9, l7 = this._nodeIdArray;
    l7.length = 0;
    const { minScale: h10, maxScale: u8 } = u4(this.layer), p3 = 0 === h10 && 0 === u8 ? (e10) => l7.push(e10) : (e10) => {
      const t12 = this._getScale(e10);
      t6(t12, h10, u8) && l7.push(e10);
    };
    return this._traverseVisible({ frustum: i6, clippingBox: r11 }, { predicate: (e10, t12, i7) => {
      if (!i7)
        return false;
      if (0 === t12.childCount)
        return p3(e10), false;
      const r12 = this._index.getRenderObb(e10);
      return !(this._computeAveragePixelArea(r12, t12.lodThreshold, t12.vertexCount, n7, a6) <= d4) || (p3(e10), false);
    }, pageMiss: (e10, t12) => {
      p3(e10), this._indexQueue.includes(t12) || this._indexQueue.push(t12);
    } }), l7;
  }
  _getScale(e9) {
    let t11 = this._nodeScales.get(e9);
    if (null == t11) {
      const i6 = this._index.getNode(e9).obb.center;
      this._tmpPoint.x = i6[0], this._tmpPoint.y = i6[1], this._tmpPoint.z = i6[2], t11 = this.view.basemapTerrain.getScale(this._tmpPoint), this._nodeScales.set(e9, t11);
    }
    return t11;
  }
  _computeAveragePixelArea(e9, t11, i6, r11, s7) {
    const o3 = 1e-7, n7 = Math.max(o3, X(e9, r11));
    return t11 / (n7 * n7) / (4 * s7 * s7) / i6;
  }
  _loadNode(e9, t11) {
    try {
      return this._loadNodeAsync(e9, t11);
    } catch (i6) {
      throw d(i6) || s.getLogger(this).error(i6), i6;
    }
  }
  async _loadAdditionalUserAttributes(e9, i6, r11) {
    const s7 = this.layer.outFields;
    if (!s7)
      return [];
    const o3 = b2(this.layer.fieldsIndex, s7), n7 = new Set(e9.map((e10) => null != e10 ? e10.name : null)), a6 = this.layer.attributeStorageInfo, d4 = [];
    for (const t11 of o3) {
      if (n7.has(t11))
        continue;
      const e10 = u7(a6, t11);
      e10 && d4.push(i6(e10));
    }
    const l7 = await P(d4);
    return s2(r11), l7.filter(R);
  }
  async _loadNodeAsync(e9, t11) {
    const i6 = this._index.getNode(e9), r11 = t10(this.layer), s7 = e7(this.layer), o3 = i6.resourceId, n7 = async (e10) => {
      if (!e10)
        return null;
      if (e10.useElevation)
        return { attributeInfo: e10, buffer: null };
      const i7 = await this._loadAttribute(o3, e10, t11);
      return null != i7 ? { attributeInfo: e10, buffer: i7 } : null;
    };
    return this._idleQueue.push(async () => {
      const i7 = this._loadGeometry(o3, t11), { primaryAttribute: a6, modulationAttribute: d4 } = r11, l7 = n7(a6), h10 = n7(d4), p3 = s7.map((e10) => e10.attributeInfo), c5 = p3.map((e10) => n7(e10)), _3 = this._loadAdditionalUserAttributes([a6, d4, ...p3], n7, t11), [m4, g4, f2, y4, b3] = await Promise.all([i7, l7, h10, Promise.all(c5), _3]);
      s2(t11);
      const w = { geometryBuffer: m4, primaryAttributeData: g4, modulationAttributeData: f2, filterAttributesData: y4, userAttributesData: b3, schema: this.layer.store.defaultGeometrySchema, rendererInfo: r11, filterInfo: s7, obb: this._index.getRenderObb(e9), elevationOffset: this._elevationOffset, inSR: this.layer.spatialReference.toJSON(), outSR: this.view.renderCoordsHelper.spatialReference.toJSON() };
      return this._worker.invoke(w, t11);
    }, t11);
  }
  async _loadGeometry(e9, t11) {
    return this._requestData(`${this.baseUrl}/nodes/${e9}/geometries/0`, t11);
  }
  async _loadAttribute(e9, t11, i6) {
    if (null == t11 || !t11.storageInfo)
      return null;
    const r11 = t11.storageInfo.key;
    return this._requestData(`${this.baseUrl}/nodes/${e9}/attributes/${r11}`, i6);
  }
  _requestNodePage(e9, t11) {
    const i6 = { f: "json", token: this.layer.apiKey };
    return this._indexRequester.request(e9, "json", { query: i6, signal: t11 });
  }
  _requestData(e9, t11) {
    return this._dataRequester.request(e9, "binary", { query: { token: this.layer.apiKey }, signal: t11 });
  }
  _removeFromRenderer(e9) {
    if (this._renderedNodes.has(e9)) {
      const t11 = this._renderer.removeNode(e9);
      this._renderedNodes.delete(e9), this._nodeScales.delete(e9), this._memCache.put(t11.id.toString(), t11, ye(t11));
    }
  }
  _addToRenderer(e9) {
    this._renderedNodes.has(e9.id) || (this._renderedNodes.add(e9.id), this._renderer.addNode(e9));
  }
  _setupRendererData(e9, t11) {
    const i6 = this._index.getNode(e9), r11 = Math.sqrt(i6.lodThreshold / i6.vertexCount), s7 = this._index.getRenderObb(e9);
    if (k(t11))
      return t11.splatSize = r11, t11.obb = s7, r(t11.origin, t11.obb.center), t11;
    const n7 = 0.01 * Math.max(s7.halfSize[0], s7.halfSize[1], s7.halfSize[2]);
    if (t11.obb.halfSize[0] > s7.halfSize[0] + n7 || t11.obb.halfSize[1] > s7.halfSize[1] + n7 || t11.obb.halfSize[2] > s7.halfSize[2] + n7) {
      if (this._maxLoggedBoxWarnings > 0) {
        const i7 = (e10) => `[${e10.halfSize[0]}, ${e10.halfSize[1]}, ${e10.halfSize[2]}]`;
        s.getLogger(this).warn(`Node ${e9} reported bounding box too small. got ${i7(s7)} but points cover ${i7(t11.obb)}`), 0 == --this._maxLoggedBoxWarnings && s.getLogger(this).warn("  Too many bounding box errors, stopping reporting for this layer.");
      }
      this._index.setRenderObb(e9, t11.obb);
    }
    return new U2(e9, r11, t3(s7.center), s7, 0 === i6.childCount, t11.points, t11.rgb, t11.attributes, t11.pointIdFilterMap);
  }
  get usedMemory() {
    let e9 = 0;
    return this._renderer.forEachNode((t11) => {
      e9 += we, e9 += m(t11.coordinates);
      for (const i6 of t11.attributes) {
        const t12 = i6.values;
        n(t12.buffer) && (e9 += m(t12));
      }
    }), e9;
  }
  get unloadedMemory() {
    const e9 = this._renderedNodes.size;
    if (e9 < 4)
      return 0;
    const t11 = [...this._renderedNodes].reduce((e10, t12) => e10 + this._index.getNode(t12).vertexCount);
    let i6 = this._loadingNodes.size;
    for (let r11 = 0; r11 < this._workQueue.length; r11++)
      i6 += this._workQueue[r11].load.length, i6 -= this._workQueue[r11].remove.length;
    if (i6 < 0)
      return 0;
    return i6 * t11 / e9 * ((this.usedMemory - e9 * we) / t11) + i6 * we;
  }
  get performanceInfo() {
    return { nodes: this._renderedNodes.size, displayedNumberOfFeatures: [...this._renderedNodes].reduce((e9, t11) => e9 + this._index.getNode(t11).vertexCount, 0), maximumNumberOfFeatures: this.maximumPointCount, totalNumberOfFeatures: -1, core: null, "Loading Nodes": this._loadingNodes.size, "Index Queue": this._indexQueue.length, "Work Queue": this._workQueue.length, "Idle Queue": this._idleQueue.length };
  }
  get test() {
    return { index: this._index, visibleNodes: this._renderedNodes };
  }
};
e([y()], ge.prototype, "layer", void 0), e([y()], ge.prototype, "baseUrl", null), e([y()], ge.prototype, "pointScale", null), e([y()], ge.prototype, "useRealWorldSymbolSizes", null), e([y()], ge.prototype, "pointSize", null), e([y()], ge.prototype, "inverseDensity", null), e([y()], ge.prototype, "maximumPointCount", void 0), e([y({ readOnly: true })], ge.prototype, "availableFields", null), e([y({ readOnly: true })], ge.prototype, "_clippingBox", null), e([y({ readOnly: true })], ge.prototype, "_elevationOffset", null), e([y({ type: Boolean })], ge.prototype, "slicePlaneEnabled", void 0), e([y()], ge.prototype, "updating", void 0), e([y(t7)], ge.prototype, "updatingProgress", void 0), e([y({ readOnly: true })], ge.prototype, "updatingProgressValue", null), ge = e([a("esri.views.3d.layers.PointCloudLayerView3D")], ge);
var fe = ge;
function ye(e9) {
  return 5 * e9.coordinates.length + 128;
}
var be = i();
var we = 160;
function Ne(e9) {
  return (t11) => e9.immediate.schedule(t11);
}
export {
  fe as default
};
//# sourceMappingURL=PointCloudLayerView3D-VIPX2HWV.js.map
