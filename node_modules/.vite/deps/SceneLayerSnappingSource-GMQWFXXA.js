import {
  r as r2
} from "./chunk-SX7Y47S2.js";
import {
  l,
  r
} from "./chunk-FEOJNOKF.js";
import "./chunk-VIDC736D.js";
import "./chunk-67UNUI4B.js";
import {
  a as a3
} from "./chunk-ZP577M7K.js";
import {
  h
} from "./chunk-IWA3Q52A.js";
import "./chunk-2XKILFME.js";
import "./chunk-G4LSNP77.js";
import "./chunk-BA6PBZHC.js";
import "./chunk-G65FMKS5.js";
import "./chunk-SNFNEEDE.js";
import "./chunk-M7PTINEZ.js";
import "./chunk-Z7LZRT7C.js";
import "./chunk-SGBMUZSF.js";
import "./chunk-3TMT4LDG.js";
import "./chunk-OX5TJXHM.js";
import "./chunk-BDWD2ZNU.js";
import "./chunk-FF5LS3YE.js";
import "./chunk-BCDDCNQ2.js";
import "./chunk-FIBWCATC.js";
import {
  E
} from "./chunk-LEDSC236.js";
import "./chunk-CW7LIPBH.js";
import "./chunk-TYOIANOD.js";
import "./chunk-VN2IXVGV.js";
import "./chunk-WWUAHPIM.js";
import "./chunk-BN6X2OXK.js";
import "./chunk-YGUWDSEH.js";
import "./chunk-ZWFMUHG3.js";
import "./chunk-EFRTD25L.js";
import "./chunk-GSS6WNQU.js";
import "./chunk-C2EHS6UI.js";
import "./chunk-7JB7RSO7.js";
import "./chunk-CEUJOC5P.js";
import "./chunk-GOK5MP3B.js";
import "./chunk-NLWV7Q6F.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-B4D7M7HT.js";
import "./chunk-3T2ETA25.js";
import "./chunk-5IYCCZ54.js";
import {
  d
} from "./chunk-VMTVUE47.js";
import "./chunk-GDZM4A6K.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-AQ7R6V4L.js";
import "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import "./chunk-4OR73Y2R.js";
import "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import {
  n as n2
} from "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-3VUFACNT.js";
import "./chunk-ZEEBL7ZN.js";
import "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import "./chunk-57CHUY45.js";
import "./chunk-SJ2GJCS2.js";
import "./chunk-H7RDAEPY.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-S5OISW44.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import {
  m,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2,
  o2
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import {
  a,
  s
} from "./chunk-7I33FAWS.js";
import {
  e as e2,
  n,
  o
} from "./chunk-DWOEYHKS.js";
import "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  R
} from "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorkerHandle.js
var p = class extends d {
  constructor(e3) {
    super(e3), this.availability = 0, this._ids = /* @__PURE__ */ new Set();
  }
  destroy() {
    this._workerHandle.destroy(), this._workerHandle = null;
  }
  initialize() {
    this._workerHandle = new l2(this.schedule, { fetchAllEdgeLocations: (e3, t) => this._fetchAllEdgeLocations(e3, t) });
  }
  async fetchCandidates(e3, t) {
    const r3 = e3.coordinateHelper, { point: o3 } = e3, s2 = h2;
    this.renderCoordsHelper.toRenderCoords(o3, r3.spatialReference, s2);
    const n3 = e3.distance, a4 = "number" == typeof n3 ? n3 : n3.distance, d2 = await this._workerHandle.invoke({ bounds: E(s2[0], s2[1], s2[2], a4), returnEdge: e3.returnEdge, returnVertex: e3.returnVertex }, t);
    return d2.candidates.sort((e4, t2) => e4.distance - t2.distance), d2.candidates.map((e4) => this._convertCandidate(r3, e4));
  }
  async add(e3, t) {
    this._ids.add(e3.id), await this._workerHandle.invokeMethod("add", e3, t);
  }
  async remove(e3, t) {
    this._ids.delete(e3.id), await this._workerHandle.invokeMethod("remove", e3, t);
  }
  _convertCandidate(e3, t) {
    switch (t.type) {
      case "edge":
        return new r({ objectId: t.objectId, targetPoint: this._convertRenderCoordinate(e3, t.target), edgeStart: this._convertRenderCoordinate(e3, t.start), edgeEnd: this._convertRenderCoordinate(e3, t.end), isDraped: false });
      case "vertex":
        return new r2({ objectId: t.objectId, targetPoint: this._convertRenderCoordinate(e3, t.target), isDraped: false });
    }
  }
  _convertRenderCoordinate({ spatialReference: e3 }, t) {
    const r3 = n2();
    return this.renderCoordsHelper.fromRenderCoords(t, r3, e3), l(r3);
  }
  async _fetchAllEdgeLocations(e3, t) {
    const r3 = [], o3 = [];
    for (const { id: s2, uid: n3 } of e3.components)
      this._ids.has(s2) && r3.push((async () => {
        const e4 = await this.fetchEdgeLocations(s2, t.signal), r4 = e4.locations.buffer;
        return o3.push(r4), { id: s2, uid: n3, objectIds: e4.objectIds, locations: r4, origin: e4.origin, type: e4.type };
      })());
    return { result: { components: (await Promise.all(r3)).filter(({ id: e4 }) => this._ids.has(e4)) }, transferList: o3 };
  }
};
e([y({ constructOnly: true })], p.prototype, "renderCoordsHelper", void 0), e([y({ constructOnly: true })], p.prototype, "fetchEdgeLocations", void 0), e([y({ constructOnly: true })], p.prototype, "schedule", void 0), e([y({ readOnly: true })], p.prototype, "availability", void 0), p = e([a2("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")], p);
var l2 = class extends h {
  constructor(e3, t) {
    super("SceneLayerSnappingSourceWorker", "fetchCandidates", {}, e3, { strategy: "dedicated", client: t });
  }
};
var h2 = n2();

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/I3SSnappingSource.js
var p2 = class extends d {
  get updating() {
    return this.updatingHandles.updating;
  }
  constructor(e3) {
    super(e3), this.availability = 1, this._abortController = new AbortController();
  }
  destroy() {
    this._tracker = o(this._tracker), this._abortController = e2(this._abortController);
  }
  initialize() {
    const { view: e3 } = this, r3 = e3.resourceController;
    this._edgeWorker = new a3(h3(r3)), this._workerHandle = new p({ renderCoordsHelper: this.view.renderCoordsHelper, schedule: h3(r3), fetchEdgeLocations: async (e4, r4) => {
      if (null == this._tracker)
        throw new Error("tracker-not-initialized");
      return this._tracker.fetchEdgeLocations(e4, this._edgeWorker, r4);
    } }), this.updatingHandles.addPromise(this._setupLayerView()), this.handles.add([o2(this._workerHandle), o2(this._edgeWorker)]);
  }
  async fetchCandidates(e3, r3) {
    return this._workerHandle.fetchCandidates(e3, r3);
  }
  refresh() {
  }
  async _setupLayerView() {
    if (this.destroyed)
      return;
    const e3 = n(this._abortController, (e4) => e4.signal), r3 = await this.getLayerView();
    null == r3 || a(e3) || (this._tracker = r3.trackSnappingSources({ add: (r4, t) => {
      this.updatingHandles.addPromise(this._workerHandle.add({ id: r4, bounds: t }, e3));
    }, remove: (r4) => {
      this.updatingHandles.addPromise(this._workerHandle.remove({ id: r4 }, e3));
    } }));
  }
};
function h3(e3) {
  return (r3) => e3.immediate.schedule(r3);
}
e([y({ constructOnly: true })], p2.prototype, "getLayerView", void 0), e([y({ constructOnly: true })], p2.prototype, "view", void 0), e([y({ readOnly: true })], p2.prototype, "updating", null), e([y({ readOnly: true })], p2.prototype, "availability", void 0), p2 = e([a2("esri.views.interactive.snapping.featureSources.I3SSnappingSource")], p2);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/SceneLayerSnappingSource.js
var c = class extends m {
  get updating() {
    return this._i3sSources.some((e3) => e3.updating);
  }
  constructor(e3) {
    super(e3), this.availability = 1, this._i3sSources = [];
  }
  destroy() {
    this._i3sSources.forEach((e3) => e3.destroy()), this._i3sSources.length = 0;
  }
  initialize() {
    const { view: e3 } = this, r3 = this.layerSource.layer;
    this._i3sSources = "building-scene" === r3.type ? this._getBuildingSceneI3SSources(e3, r3) : [this._getSceneLayerI3SSource(e3, r3)];
  }
  async fetchCandidates(e3, r3) {
    const s2 = await Promise.all(this._i3sSources.map((s3) => s3.fetchCandidates(e3, r3)));
    return s(r3), s2.flat();
  }
  refresh() {
    this._i3sSources.forEach((e3) => e3.refresh());
  }
  _getBuildingSceneI3SSources(e3, r3) {
    return r3.allSublayers.toArray().map((s2) => "building-component" === s2.type ? new p2({ getLayerView: async () => (await e3.whenLayerView(r3)).whenSublayerView(s2), view: e3 }) : null).filter(R);
  }
  _getSceneLayerI3SSource(e3, r3) {
    return new p2({ getLayerView: async () => {
      const s2 = await e3.whenLayerView(r3);
      return "scene-layer-graphics-3d" === s2.type ? void 0 : s2;
    }, view: e3 });
  }
};
e([y({ constructOnly: true })], c.prototype, "layerSource", void 0), e([y({ constructOnly: true })], c.prototype, "view", void 0), e([y({ readOnly: true })], c.prototype, "updating", null), e([y({ readOnly: true })], c.prototype, "availability", void 0), c = e([a2("esri.views.interactive.snapping.featureSources.SceneLayerSnappingSource")], c);
export {
  c as SceneLayerSnappingSource
};
//# sourceMappingURL=SceneLayerSnappingSource-GMQWFXXA.js.map
