import {
  m,
  o as o5
} from "./chunk-EPDLDPS4.js";
import {
  a as a4
} from "./chunk-NBYHM3OO.js";
import {
  e as e4
} from "./chunk-FAOMDC3K.js";
import {
  c,
  i,
  t as t2
} from "./chunk-5ZW42GDY.js";
import {
  l as l3
} from "./chunk-D7YAG5U3.js";
import {
  g
} from "./chunk-JHDKOKT6.js";
import {
  d
} from "./chunk-RDWKBYTH.js";
import {
  o as o2
} from "./chunk-SADO52IH.js";
import {
  e as e3
} from "./chunk-WVOBJDWI.js";
import {
  h
} from "./chunk-73PNWDTS.js";
import {
  o as o3,
  t
} from "./chunk-PKS3ZVLN.js";
import {
  P
} from "./chunk-N3RXOITN.js";
import {
  l as l2
} from "./chunk-DOR4M5EA.js";
import {
  e as e2
} from "./chunk-QS45OHBM.js";
import {
  a as a3
} from "./chunk-IVMJPIWO.js";
import {
  a as a2
} from "./chunk-3I3GE5YW.js";
import {
  e
} from "./chunk-WRFNQB7U.js";
import {
  o as o4
} from "./chunk-UUW6REOV.js";
import {
  s
} from "./chunk-Z3NHJA5D.js";
import {
  i2
} from "./chunk-BO2REVMA.js";
import {
  o
} from "./chunk-V66LHQVK.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  l
} from "./chunk-YGUWDSEH.js";
import {
  a,
  r
} from "./chunk-NLWV7Q6F.js";
import {
  n
} from "./chunk-SS3YG6J3.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/hud/HUDOcclusionPass.glsl.js
function n2(n3, p) {
  const { vertex: l4, fragment: d2 } = n3;
  l4.include(o5), p.hasMultipassGeometry && l4.include(a4), p.hasMultipassTerrain && n3.varyings.add("depth", "float"), l4.code.add(o`
  void main(void) {
    vec4 posProjCenter;
    if (dot(position, position) > 0.0) {
      // Render single point to center of the pixel to avoid subpixel
      // filtering to affect the marker color
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      posProjCenter = alignToPixelCenter(posProj, viewport.zw);

      ${p.hasMultipassGeometry ? o`
        // Don't draw vertices behind geometry
        if(geometryDepthTest(.5 + .5 * posProjCenter.xy / posProjCenter.w, projectAux.posView.z)){
          posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
        }` : ""}

      ${p.hasMultipassTerrain ? "depth = projectAux.posView.z;" : ""}
      vec3 vpos = projectAux.posModel;
      if (rejectBySlice(vpos)) {
        // Project out of clip space
        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
      }

    } else {
      // Project out of clip space
      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
    }

    gl_Position = posProjCenter;
    gl_PointSize = 1.0;
  }
  `), p.hasMultipassTerrain && d2.include(a3), p.hasMultipassTerrain && d2.uniforms.add(new s("terrainDepthTexture", (e5, r2) => r2.multipassTerrain.linearDepthTexture), new e("nearFar", (e5, r2) => r2.camera.nearFar)), d2.include(a2), d2.code.add(o`
  void main() {
    fragColor = vec4(1);
    ${p.hasMultipassTerrain ? o`
          // Read the rgba data from the texture linear depth
          vec4 terrainDepthData = texelFetch(terrainDepthTexture, ivec2(gl_FragCoord.xy), 0);

          float terrainDepth = linearDepthFromFloat(rgba2float(terrainDepthData), nearFar);

          // If HUD vertex is behind terrain and the terrain depth is not the initialize value (e.g. we are not looking at the sky)
          // Mark the HUD vertex as occluded by transparent terrain
          if(depth < terrainDepth && terrainDepthData != vec4(0,0,0,1)){
            fragColor.g = 0.5;
          }` : ""}
  }
  `);
}

// node_modules/@arcgis/core/chunks/HUDMaterial.glsl.js
function $(o6) {
  const i3 = new i2(), $2 = o6.signedDistanceFieldEnabled;
  if (i3.include(m, o6), i3.include(P, o6), o6.occlusionPass)
    return i3.include(n2, o6), i3;
  const { vertex: B2, fragment: H2 } = i3;
  i3.include(c), H2.include(a2), H2.include(e3), i3.include(l3, o6), i3.include(d, o6), i3.varyings.add("vcolor", "vec4"), i3.varyings.add("vtc", "vec2"), i3.varyings.add("vsize", "vec2"), o6.binaryHighlightOcclusionEnabled && i3.varyings.add("voccluded", "float"), B2.uniforms.add(new e2("viewport", (e5, o7) => o7.camera.fullViewport), new e("screenOffset", (o7, i4) => r(F, 2 * o7.screenOffset[0] * i4.camera.pixelRatio, 2 * o7.screenOffset[1] * i4.camera.pixelRatio)), new e("anchorPosition", (e5) => D(e5)), new e2("materialColor", (e5) => e5.color)), l2(B2, o6), $2 && (B2.uniforms.add(new e2("outlineColor", (e5) => e5.outlineColor)), H2.uniforms.add(new e2("outlineColor", (e5) => L(e5) ? e5.outlineColor : l), new o4("outlineSize", (e5) => L(e5) ? e5.outlineSize : 0))), o6.hasScreenSizePerspective && (t2(B2), i(B2)), (o6.debugDrawLabelBorder || o6.binaryHighlightOcclusionEnabled) && i3.varyings.add("debugBorderCoords", "vec4"), i3.attributes.add(O.UV0, "vec2"), i3.attributes.add(O.COLOR, "vec4"), i3.attributes.add(O.SIZE, "vec2"), i3.attributes.add(O.AUXPOS2, "vec4"), B2.code.add(o`
    void main(void) {
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      forwardObjectAndLayerIdColor();

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }
      vec2 inputSize;
      ${o6.hasScreenSizePerspective ? o`
      inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
      vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);
         ` : o`
      inputSize = size;
      vec2 screenOffsetScaled = screenOffset;`}

      ${o6.vvSize ? "inputSize *= vvScale(auxpos2).xx;" : ""}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);

      ${o6.occlusionTestEnabled || o6.binaryHighlightOcclusionEnabled ? "bool visible = testVisibilityHUD(posProj);" : ""}

      ${o6.binaryHighlightOcclusionEnabled ? "voccluded = visible ? 0.0 : 1.0;" : ""}
    `);
  const T = o`vec2 uv01 = floor(uv0);
vec2 uv = uv0 - uv01;
quadOffset.xy = ((uv01 - anchorPosition) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;`;
  o6.pixelSnappingEnabled && B2.include(o5);
  const E = o6.pixelSnappingEnabled ? $2 ? o`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;` : o`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}` : o`posProj += quadOffset;`;
  B2.code.add(o`
    ${o6.occlusionTestEnabled ? "if (visible) {" : ""}
    ${T}
    ${o6.vvColor ? "vcolor = interpolateVVColor(auxpos2.y) * materialColor;" : "vcolor = color / 255.0 * materialColor;"}

    ${o6.output === h.ObjectAndLayerIdColor ? o`vcolor.a = 1.0;` : ""}

    bool alphaDiscard = vcolor.a < ${o.float(t)};
    ${$2 ? `alphaDiscard = alphaDiscard && outlineColor.a < ${o.float(t)};` : ""}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${E}
      gl_Position = posProj;
    }

    vtc = uv;

    ${o6.debugDrawLabelBorder ? "debugBorderCoords = vec4(uv01, 1.5 / combinedSize);" : ""}
    vsize = inputSize;
    ${o6.occlusionTestEnabled ? o`} else { vtc = vec2(0.0);
      ${o6.debugDrawLabelBorder ? "debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);}" : "}"}` : ""}
  }
  `), H2.uniforms.add(new s("tex", (e5) => e5.texture));
  const U = o6.debugDrawLabelBorder ? o`(isBorder > 0.0 ? 0.0 : ${o.float(o3)})` : o.float(o3), V = o`
    ${o6.debugDrawLabelBorder ? o`
      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));` : ""}

    ${$2 ? o`
      vec4 fillPixelColor = vcolor;

      // Attempt to sample texel centers to avoid that thin cross outlines
      // disappear with large symbol sizes.
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041
      const float txSize = ${o.float(e4)};
      const float texelSize = 1.0 / txSize;
      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgba2float(texture(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${U} ||
          fillPixelColor.a + outlinePixelColor.a < ${o.float(t)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        fragColor = vec4(compositeColor, compositeAlpha);
      } else {
        if (fillAlphaFactor < ${U}) {
          discard;
        }

        fragColor = premultiplyAlpha(fillPixelColor);
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      ` : o`
          vec4 texColor = texture(tex, vtc, -0.5);
          if (texColor.a < ${U}) {
            discard;
          }
          fragColor = texColor * premultiplyAlpha(vcolor);
          `}

    // Draw debug border with transparency, so that original texels along border are still partially visible
    ${o6.debugDrawLabelBorder ? o`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);` : ""}
  `;
  return o6.output === h.Alpha && H2.code.add(o`
      void main() {
        ${V}
        fragColor = vec4(fragColor.a);
      }
      `), o6.output === h.ObjectAndLayerIdColor && H2.code.add(o`
      void main() {
        ${V}
        outputObjectAndLayerIdColor();
      }
      `), o6.output === h.Color && H2.code.add(o`
    void main() {
      ${V}
      ${o6.transparencyPassType === o2.FrontFace ? "fragColor.rgb /= fragColor.a;" : ""}
    }
    `), o6.output === h.Highlight && (i3.include(g, o6), H2.code.add(o`
    void main() {
      ${V}
      ${o6.binaryHighlightOcclusionEnabled ? o`
          if (voccluded == 1.0) {
            fragColor = vec4(1.0, 1.0, 0.0, 1.0);
          } else {
            fragColor = vec4(1.0, 0.0, 1.0, 1.0);
          }` : "outputHighlight();"}
    }
    `)), i3;
}
function L(e5) {
  return e5.outlineColor[3] > 0 && e5.outlineSize > 0;
}
function D(e5, i3 = F) {
  return e5.textureIsSignedDistanceField ? B(e5.anchorPosition, e5.distanceFieldBoundingBox, i3) : a(i3, e5.anchorPosition), i3;
}
function B(o6, i3, r2) {
  null != i3 ? r(r2, o6[0] * (i3[2] - i3[0]) + i3[0], o6[1] * (i3[3] - i3[1]) + i3[1]) : r(r2, 0, 0);
}
var F = n();
var H = Object.freeze(Object.defineProperty({ __proto__: null, build: $, calculateAnchorPosForRendering: D }, Symbol.toStringTag, { value: "Module" }));

export {
  $,
  D,
  H
};
//# sourceMappingURL=chunk-5GYSL2SB.js.map
