import {
  i as i2,
  o as o2
} from "./chunk-IEYHFJSJ.js";
import "./chunk-SX7Y47S2.js";
import "./chunk-KMWAP7WW.js";
import {
  l2,
  u
} from "./chunk-FEOJNOKF.js";
import "./chunk-VIDC736D.js";
import {
  a as a4
} from "./chunk-LYNC7OVT.js";
import {
  m as m3
} from "./chunk-67UNUI4B.js";
import {
  i,
  n,
  r
} from "./chunk-SAAQQDRS.js";
import {
  m as m2
} from "./chunk-3BTM6YO4.js";
import "./chunk-6OVHX5ZO.js";
import "./chunk-N6RC4PHI.js";
import {
  ee
} from "./chunk-CPHFVZ42.js";
import "./chunk-LLQHB2ZB.js";
import "./chunk-CFEAJLOI.js";
import "./chunk-RBDJB3ZY.js";
import "./chunk-RRRAGAMB.js";
import "./chunk-ERFCZMKG.js";
import "./chunk-C2GW4T2D.js";
import "./chunk-FLA7Z76H.js";
import "./chunk-LFQ3TKCC.js";
import "./chunk-ZD5B6I7X.js";
import "./chunk-HAYOKZGJ.js";
import "./chunk-SO7CVIZK.js";
import "./chunk-FJYIB7HF.js";
import {
  N
} from "./chunk-2EWAI4LP.js";
import "./chunk-DNEN337Y.js";
import "./chunk-ZL3HOHNK.js";
import "./chunk-2XKILFME.js";
import "./chunk-G4LSNP77.js";
import "./chunk-S5RIUWET.js";
import "./chunk-MVWFPLOX.js";
import "./chunk-X3YW4YOG.js";
import {
  rt
} from "./chunk-IG234GCS.js";
import "./chunk-WTKN55TU.js";
import {
  t
} from "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-BA6PBZHC.js";
import "./chunk-YA7WDOJK.js";
import "./chunk-467UETSR.js";
import "./chunk-SHFLRM67.js";
import "./chunk-GOK4EI36.js";
import "./chunk-LO3LAMAS.js";
import "./chunk-ZWFMUHG3.js";
import "./chunk-EFRTD25L.js";
import "./chunk-GSS6WNQU.js";
import "./chunk-C2EHS6UI.js";
import "./chunk-GZTLZ6RD.js";
import "./chunk-7JB7RSO7.js";
import "./chunk-CEUJOC5P.js";
import "./chunk-KRCNIFX2.js";
import "./chunk-LVVQ2RQY.js";
import "./chunk-M6OG7C2T.js";
import "./chunk-GOK5MP3B.js";
import "./chunk-NLWV7Q6F.js";
import "./chunk-SS3YG6J3.js";
import "./chunk-5IYCCZ54.js";
import {
  a as a3
} from "./chunk-VMTVUE47.js";
import "./chunk-GDZM4A6K.js";
import {
  Cn,
  Rn,
  nn
} from "./chunk-BNBT4QTW.js";
import "./chunk-3FQOSG5O.js";
import "./chunk-7EG7BYWF.js";
import "./chunk-JNDFAMXY.js";
import "./chunk-NTEKJWGF.js";
import "./chunk-TFIKV5RU.js";
import "./chunk-KW6QQDGN.js";
import "./chunk-AQ7R6V4L.js";
import "./chunk-DOQ3SAAR.js";
import "./chunk-4BXK4H4L.js";
import "./chunk-SLVNG7FV.js";
import "./chunk-OZXJDVTE.js";
import {
  d
} from "./chunk-SVCGLUNW.js";
import "./chunk-RRJGZKNX.js";
import "./chunk-PL5Q4C6Y.js";
import "./chunk-KFSY6ZZH.js";
import "./chunk-7EQSYZHW.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-GGOVZ2GK.js";
import {
  o
} from "./chunk-HIPTG7BJ.js";
import "./chunk-WLWP35G2.js";
import "./chunk-JPW73GY2.js";
import "./chunk-HXPVVSLV.js";
import {
  j
} from "./chunk-4OR73Y2R.js";
import "./chunk-EKJ2DJIR.js";
import "./chunk-TEHNQYQD.js";
import "./chunk-TPJLFGOT.js";
import "./chunk-CQX57DED.js";
import "./chunk-3CQBBMMD.js";
import "./chunk-Z2ZUNW5S.js";
import "./chunk-7L7Z2HXM.js";
import "./chunk-75NKPXTR.js";
import "./chunk-EUVARFSM.js";
import "./chunk-3VUFACNT.js";
import "./chunk-ZEEBL7ZN.js";
import "./chunk-RTDN6KAT.js";
import "./chunk-GJ7PJ7XG.js";
import {
  a as a2,
  h,
  l
} from "./chunk-H7RDAEPY.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-7KH4CLS5.js";
import "./chunk-WCHO7VLT.js";
import "./chunk-JL3TJGVW.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-43LWRDQS.js";
import "./chunk-R6YKST3K.js";
import "./chunk-ZJEWQGHG.js";
import "./chunk-YGB42LDG.js";
import "./chunk-F3KGLZDZ.js";
import "./chunk-MP6GH2AC.js";
import {
  m,
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import "./chunk-U3J7253Q.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-ZWUBORGT.js";
import "./chunk-3R7FAT25.js";
import {
  P,
  p,
  s
} from "./chunk-7I33FAWS.js";
import "./chunk-DWOEYHKS.js";
import "./chunk-HMVAPW5X.js";
import "./chunk-IYZKKFJM.js";
import {
  z
} from "./chunk-JZJWZ6DN.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/GraphicsSnappingSource.js
var I = "graphics-collections";
var O = class extends a3(m) {
  get updating() {
    return this.updatingHandles.updating;
  }
  get _hasZ() {
    const e2 = this.view;
    return null != e2 && "3d" === e2.type && "map-notes" !== this.layerSource.layer.type;
  }
  get _snappingElevationAligner() {
    const { view: e2 } = this, { layer: t2 } = this.layerSource, s2 = null != e2 && "3d" === e2.type;
    if (!s2 || "map-notes" === t2.type)
      return i();
    const o3 = async (s3, o4) => (await p(e2.whenLayerView(t2), o4)).elevationAlignPointsInFeatures(s3, o4);
    return i(s2, { elevationInfo: t2.elevationInfo, alignPointsInFeatures: o3, spatialReference: e2.spatialReference });
  }
  get _snappingElevationFilter() {
    const { view: e2 } = this, t2 = null != e2 && "3d" === e2.type && "map-notes" !== this.layerSource.layer.type;
    return r(t2);
  }
  get _symbologySnappingFetcher() {
    const { view: e2 } = this, { layer: t2 } = this.layerSource, s2 = null != e2 && "3d" === e2.type, o3 = this._extrudedPolygonSymbolsCount > 0;
    return s2 && "map-notes" !== t2.type && o3 ? n(o3, async (s3, o4) => {
      const r2 = await e2.whenLayerView(t2);
      return s(o4), r2.queryForSymbologySnapping({ candidates: s3, spatialReference: e2.spatialReference }, o4);
    }) : n();
  }
  constructor(e2) {
    super(e2), this.availability = 1, this._sources = { multipoint: null, point: null, polygon: null, polyline: null }, this._loadedWkids = /* @__PURE__ */ new Set(), this._loadedWkts = /* @__PURE__ */ new Set(), this._pendingAdds = [], this._extrudedPolygonSymbolsCount = 0;
  }
  destroy() {
    for (const e2 of this._pendingAdds)
      e2.task.abort();
    this._pendingAdds.length = 0, this._mapSources((e2) => this._destroySource(e2));
  }
  initialize() {
    this.updatingHandles.add(() => this.getGraphicsLayers(), (e3) => {
      this.updatingHandles.removeHandles(I);
      for (const t3 of e3)
        this._addMany(t3.graphics.toArray()), this.handles.add([t3.on("graphic-update", (e4) => this._onGraphicUpdate(e4)), this.updatingHandles.addOnCollectionChange(() => t3.graphics, (e4) => this._onGraphicsChanged(e4))], I);
    }, h);
    const { view: e2 } = this, { layer: t2 } = this.layerSource;
    null != e2 && "3d" === e2.type && "map-notes" !== t2.type && this.addHandles([e2.elevationProvider.on("elevation-change", ({ context: e3 }) => {
      m3(e3, t2.elevationInfo) && this._snappingElevationAligner.notifyElevationSourceChange();
    }), l(() => t2.elevationInfo, () => this._snappingElevationAligner.notifyElevationSourceChange(), h), a2(() => t2, ["edits", "apply-edits", "graphic-update"], () => this._symbologySnappingFetcher.notifySymbologyChange())]);
  }
  async fetchCandidates(e2, t2) {
    const { point: s2 } = e2, o3 = await P(this._mapSources((s3) => this._fetchCandidatesForSource(s3, e2, t2)));
    s(t2);
    const r2 = this._getGroundElevation, a5 = o3.flat().map((e3) => i2(e3, r2));
    return u(s2, a5), a5;
  }
  get _getGroundElevation() {
    return o2(this.view);
  }
  async _fetchCandidatesForSource(e2, t2, s2) {
    var _a;
    const o3 = l2(t2, ((_a = this.view) == null ? void 0 : _a.type) ?? "2d"), r2 = await e2.queryEngine.executeQueryForSnapping(o3, s2);
    s(s2);
    const i3 = await this._snappingElevationAligner.alignCandidates(r2.candidates, s2);
    s(s2);
    const a5 = await this._symbologySnappingFetcher.fetch(i3, s2);
    s(s2);
    const l3 = 0 === a5.length ? i3 : [...i3, ...a5];
    return this._snappingElevationFilter.filter(o3, l3);
  }
  refresh() {
  }
  _onGraphicUpdate(e2) {
    if (this.getGraphicsLayers().some((t2) => t2.graphics.includes(e2.graphic)))
      switch (e2.property) {
        case "geometry":
        case "visible":
          this._remove(e2.graphic), this._addMany([e2.graphic]);
      }
  }
  _onGraphicsChanged(e2) {
    for (const t2 of e2.removed)
      this._remove(t2);
    this._addMany(e2.added);
  }
  _addMany(e2) {
    const t2 = [], s2 = /* @__PURE__ */ new Map();
    for (const o3 of e2)
      null != o3.geometry && (this._needsInitializeProjection(o3.geometry.spatialReference) ? (t2.push(o3.geometry.spatialReference), s2.set(o3.uid, o3)) : this._add(o3));
    this._createPendingAdd(t2, s2);
  }
  _createPendingAdd(e2, t2) {
    if (!e2.length)
      return;
    const r2 = d(async (s2) => {
      await Rn(e2.map((e3) => ({ source: e3, dest: this.spatialReference })), { signal: s2 }), this._markLoadedSpatialReferences(e2);
      for (const [, e3] of t2)
        this._add(e3);
    });
    this.updatingHandles.addPromise(r2.promise);
    const i3 = { task: r2, graphics: t2 }, n2 = () => z(this._pendingAdds, i3);
    r2.promise.then(n2, n2), this._pendingAdds.push(i3);
  }
  _markLoadedSpatialReferences(e2) {
    for (const t2 of e2)
      null != t2.wkid && this._loadedWkids.add(t2.wkid), null != t2.wkt && this._loadedWkts.add(t2.wkt);
  }
  _add(e2) {
    if (null == e2.geometry || !e2.visible)
      return;
    let t2 = e2.geometry;
    if ("mesh" === t2.type)
      return;
    "extent" === t2.type && (t2 = j.fromExtent(t2));
    const s2 = this._ensureSource(t2.type);
    if (null == s2)
      return;
    const o3 = this._createOptimizedFeature(e2.uid, t2);
    null != o3 && (s2.featureStore.add(o3), N(e2.symbol) && this._extrudedPolygonSymbolsCount++);
  }
  _needsInitializeProjection(e2) {
    return (null == e2.wkid || !this._loadedWkids.has(e2.wkid)) && ((null == e2.wkt || !this._loadedWkts.has(e2.wkt)) && !Cn(e2, this.spatialReference));
  }
  _createOptimizedFeature(e2, t2) {
    const s2 = nn(a4(t2), this.spatialReference);
    if (!s2)
      return null;
    const o3 = this._ensureGeometryHasZ(s2), r2 = rt(o3, this._hasZ, false);
    return new t(r2, { [U]: e2 }, null, e2);
  }
  _ensureGeometryHasZ(e2) {
    if (!this._hasZ)
      return e2;
    const t2 = (e3) => {
      for (; e3.length < 3; )
        e3.push(0);
    }, s2 = e2.clone();
    switch (s2.hasZ = true, s2.type) {
      case "point":
        s2.z = s2.z ?? 0;
        break;
      case "multipoint":
        s2.points.forEach(t2);
        break;
      case "polyline":
        s2.paths.forEach((e3) => e3.forEach(t2));
        break;
      case "polygon":
        s2.rings.forEach((e3) => e3.forEach(t2));
    }
    return s2;
  }
  _ensureSource(e2) {
    const t2 = this._sources[e2];
    if (null != t2)
      return t2;
    const s2 = this._createSource(e2);
    return this._sources[e2] = s2, s2;
  }
  _createSource(e2) {
    const t2 = o.toJSON(e2), s2 = this._hasZ, o3 = new m2({ geometryType: t2, hasZ: s2, hasM: false });
    return { featureStore: o3, queryEngine: new ee({ featureStore: o3, fields: [{ name: U, type: "esriFieldTypeOID", alias: U }], geometryType: t2, hasM: false, hasZ: s2, objectIdField: U, spatialReference: this.spatialReference, scheduler: null != this.view && "3d" === this.view.type ? this.view.resourceController.scheduler : null }), type: e2 };
  }
  _remove(e2) {
    this._mapSources((t2) => this._removeFromSource(t2, e2));
    for (const t2 of this._pendingAdds)
      t2.graphics.delete(e2.uid), 0 === t2.graphics.size && t2.task.abort();
  }
  _removeFromSource(e2, t2) {
    const s2 = t2.uid;
    e2.featureStore.has(s2) && (e2.featureStore.removeById(t2.uid), N(t2.symbol) && this._extrudedPolygonSymbolsCount--);
  }
  _destroySource(e2) {
    e2.queryEngine.destroy(), this._sources[e2.type] = null;
  }
  _mapSources(e2) {
    const { point: t2, polygon: s2, polyline: o3, multipoint: r2 } = this._sources, i3 = [];
    return null != t2 && i3.push(e2(t2)), null != s2 && i3.push(e2(s2)), null != o3 && i3.push(e2(o3)), null != r2 && i3.push(e2(r2)), i3;
  }
};
e([y()], O.prototype, "getGraphicsLayers", void 0), e([y({ constructOnly: true })], O.prototype, "layerSource", void 0), e([y({ constructOnly: true })], O.prototype, "spatialReference", void 0), e([y({ constructOnly: true })], O.prototype, "view", void 0), e([y({ readOnly: true })], O.prototype, "updating", null), e([y({ readOnly: true })], O.prototype, "availability", void 0), e([y()], O.prototype, "_hasZ", null), e([y()], O.prototype, "_snappingElevationAligner", null), e([y()], O.prototype, "_snappingElevationFilter", null), e([y()], O.prototype, "_symbologySnappingFetcher", null), e([y()], O.prototype, "_extrudedPolygonSymbolsCount", void 0), e([y()], O.prototype, "_getGroundElevation", null), O = e([a("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")], O);
var U = "OBJECTID";
export {
  O as GraphicsSnappingSource
};
//# sourceMappingURL=GraphicsSnappingSource-3L6C2Y2L.js.map
