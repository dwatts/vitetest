import {
  $
} from "./chunk-SFIT2AUF.js";
import {
  i as i3,
  x
} from "./chunk-K4WBDIIJ.js";
import {
  T,
  e2 as e4
} from "./chunk-TRGMWULG.js";
import {
  a as a3,
  c as c2,
  f,
  s as s3
} from "./chunk-SGBMUZSF.js";
import {
  B,
  D,
  L,
  M,
  _
} from "./chunk-BCDDCNQ2.js";
import {
  e as e3
} from "./chunk-CW7LIPBH.js";
import {
  e as e2
} from "./chunk-VN2IXVGV.js";
import {
  n as n2
} from "./chunk-YGUWDSEH.js";
import {
  A,
  a as a2,
  b,
  g,
  j as j2,
  l as l2,
  o as o2,
  r as r3,
  s as s2,
  v
} from "./chunk-NLWV7Q6F.js";
import {
  l as l3
} from "./chunk-RVS5HU2K.js";
import {
  n as n3
} from "./chunk-SS3YG6J3.js";
import {
  c,
  h,
  i as i2,
  k
} from "./chunk-7EG7BYWF.js";
import {
  i,
  l,
  s
} from "./chunk-TEHNQYQD.js";
import {
  F,
  O,
  j,
  o,
  r
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import {
  r2,
  w
} from "./chunk-3CQBBMMD.js";
import {
  y3 as y
} from "./chunk-V76KGJFU.js";
import {
  a2 as a
} from "./chunk-HB2SQRT2.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  t
} from "./chunk-DWOEYHKS.js";
import {
  has
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/CascadeCamera.js
var p = class extends $ {
  constructor() {
    super(...arguments), this._projectionMatrix = e3();
  }
  get projectionMatrix() {
    return this._projectionMatrix;
  }
};
e([y()], p.prototype, "_projectionMatrix", void 0), e([y({ readOnly: true })], p.prototype, "projectionMatrix", null), p = e([a("esri.views.3d.webgl-engine.lib.CascadeCamera")], p);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/textureUtils.js
var t2 = 16;
function n4(n5) {
  return Math.ceil(n5 / t2) * t2;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/ShadowMap.js
var X;
!function(t3) {
  t3[t3.Highlight = 0] = "Highlight", t3[t3.Default = 1] = "Default";
}(X || (X = {}));
var q = class {
  constructor() {
    this.camera = new p(), this.lightMat = e3();
  }
};
var W = class {
  constructor() {
    this.maxNumCascadesHighQuality = 4, this.maxNumCascadesLowQuality = 4, this.textureSizeModHighQuality = 1.3, this.textureSizeModLowQuality = 0.9, this.splitSchemeLambda = 0;
  }
};
var J = class {
  get depthTexture() {
    var _a;
    return (_a = this._fbo) == null ? void 0 : _a.colorTexture;
  }
  get textureSize() {
    return this._textureSize;
  }
  get numCascades() {
    return this._numCascades;
  }
  get cascadeDistances() {
    return r2(this._usedCascadeDistances, this._cascadeDistances[0], this._numCascades > 1 ? this._cascadeDistances[1] : 1 / 0, this._numCascades > 2 ? this._cascadeDistances[2] : 1 / 0, this._numCascades > 3 ? this._cascadeDistances[3] : 1 / 0);
  }
  constructor(t3, s4) {
    this._rctx = t3, this._viewingMode = s4, this._enabled = false, this._snapshots = new Array(), this._textureSize = 0, this._numCascades = 1, this.settings = new W(), this._projectionView = e3(), this._projectionViewInverse = e3(), this._modelViewLight = e3(), this._cascadeDistances = [0, 0, 0, 0, 0], this._usedCascadeDistances = n2(), this._cascades = [new q(), new q(), new q(), new q()], this._lastOrigin = null, this._maxTextureSize = Math.min(has("esri-mobile") ? 2048 : 8192, this._rctx.parameters.maxTextureSize);
  }
  dispose() {
    this.enabled = false, this.disposeOffscreenBuffers();
  }
  disposeOffscreenBuffers() {
    this._fbo = t(this._fbo), this._discardAllSnapshots();
  }
  set maxCascades(s4) {
    this.settings.maxNumCascadesHighQuality = i(Math.floor(s4), 1, 4);
  }
  get maxCascades() {
    return this.settings.maxNumCascadesHighQuality;
  }
  set enabled(t3) {
    this._enabled = t3, t3 || this.disposeOffscreenBuffers();
  }
  get enabled() {
    return this._enabled;
  }
  get ready() {
    return this._enabled && null != this.depthTexture;
  }
  getSnapshot(t3) {
    return this.enabled ? this._snapshots[t3] : null;
  }
  get cascades() {
    for (let t3 = 0; t3 < this._numCascades; ++t3)
      rt[t3] = this._cascades[t3];
    return rt.length = this._numCascades, rt;
  }
  start(t3, s4, e5, i4, a4) {
    s3(this.enabled), this._textureSize = this._computeTextureSize(t3, a4, i4), this._ensureDepthTexture();
    const { near: r4, far: n5 } = this._clampNearFar(e5);
    this._computeCascadeDistances(n5, r4, i4), this._setupMatrices(t3, s4);
    const { viewMatrix: o3, projectionMatrix: c3 } = t3;
    for (let h2 = 0; h2 < this._numCascades; ++h2)
      this._constructCascade(h2, c3, o3, s4);
    this._lastOrigin = null, this.clear();
  }
  finish(t3) {
    s3(this.enabled), this._rctx.bindFramebuffer(t3);
  }
  getShadowMapMatrices(t3) {
    if (!this._lastOrigin || !F(t3, this._lastOrigin)) {
      this._lastOrigin = this._lastOrigin || n(), r(this._lastOrigin, t3);
      for (let s4 = 0; s4 < this._numCascades; ++s4) {
        i2(nt, this._cascades[s4].lightMat, t3);
        for (let t4 = 0; t4 < 16; ++t4)
          ot[16 * s4 + t4] = nt[t4];
      }
    }
    return ot;
  }
  takeCascadeSnapshotTo(t3, s4) {
    s3(this.enabled);
    const e5 = this._ensureSnapshot(s4);
    this._bindFbo();
    const i4 = this._rctx, a4 = i4.bindTexture(e5, T.TEXTURE_UNIT_FOR_UPDATES);
    i4.gl.copyTexSubImage2D(M.TEXTURE_2D, 0, t3.camera.viewport[0], t3.camera.viewport[1], t3.camera.viewport[0], t3.camera.viewport[1], t3.camera.viewport[2], t3.camera.viewport[3]), i4.bindTexture(a4, T.TEXTURE_UNIT_FOR_UPDATES);
  }
  clear() {
    const t3 = this._rctx;
    this._bindFbo(), t3.setClearColor(1, 1, 1, 1), t3.clearSafe(_.COLOR_BUFFER_BIT | _.DEPTH_BUFFER_BIT);
  }
  _computeTextureSize(t3, s4, e5) {
    const i4 = Math.min(window.devicePixelRatio, s4) / t3.pixelRatio, a4 = Math.max(t3.fullWidth, t3.fullHeight) * i4, r4 = e5 ? this.settings.textureSizeModHighQuality : this.settings.textureSizeModLowQuality;
    return Math.floor(Math.min(this._maxTextureSize, n4((1 === this.numCascades ? 1 : 2) * a4 * r4)));
  }
  _ensureDepthTexture() {
    var _a, _b;
    if (((_a = this._fbo) == null ? void 0 : _a.width) === this._textureSize)
      return;
    const t3 = new e4(this._textureSize);
    t3.wrapMode = D.CLAMP_TO_EDGE, t3.samplingMode = L.NEAREST, (_b = this._fbo) == null ? void 0 : _b.dispose(), this._fbo = new x(this._rctx, t3, new i3(B.DEPTH_COMPONENT16, this._textureSize));
  }
  _ensureSnapshot(t3) {
    let s4 = this._snapshots[t3];
    if (null != s4 && s4.descriptor.width === this._textureSize)
      return s4;
    this._discardSnapshot(t3);
    const e5 = new e4();
    return e5.wrapMode = D.CLAMP_TO_EDGE, e5.samplingMode = L.NEAREST, e5.width = this._textureSize, e5.height = this._textureSize, s4 = new T(this._rctx, e5), this._snapshots[t3] = s4, s4;
  }
  _discardSnapshot(t3) {
    this._snapshots[t3] = t(this._snapshots[t3]);
  }
  _discardAllSnapshots() {
    for (let t3 = 0; t3 < this._snapshots.length; ++t3)
      this._discardSnapshot(t3);
    this._snapshots.length = 0;
  }
  _bindFbo() {
    const t3 = this._rctx;
    t3.unbindTexture(this.depthTexture), t3.bindFramebuffer(this._fbo);
  }
  _constructCascade(t3, s4, e5, i4) {
    const a4 = this._cascades[t3], o3 = -this._cascadeDistances[t3], c3 = -this._cascadeDistances[t3 + 1], h2 = (s4[10] * o3 + s4[14]) / Math.abs(s4[11] * o3 + s4[15]), u = (s4[10] * c3 + s4[14]) / Math.abs(s4[11] * c3 + s4[15]);
    s3(h2 < u);
    for (let r4 = 0; r4 < 8; ++r4) {
      r2(Y, r4 % 4 == 0 || r4 % 4 == 3 ? -1 : 1, r4 % 4 == 0 || r4 % 4 == 1 ? -1 : 1, r4 < 4 ? h2 : u, 1);
      const t4 = Z[r4];
      w(t4, Y, this._projectionViewInverse), t4[0] /= t4[3], t4[1] /= t4[3], t4[2] /= t4[3];
    }
    j(at, Z[0]), a4.camera.viewMatrix = i2(K, this._modelViewLight, at);
    for (let r4 = 0; r4 < 8; ++r4)
      O(Z[r4], Z[r4], a4.camera.viewMatrix);
    let m = Z[0][2], _2 = Z[0][2];
    for (let r4 = 1; r4 < 8; ++r4)
      m = Math.min(m, Z[r4][2]), _2 = Math.max(_2, Z[r4][2]);
    m -= 200, _2 += 200, a4.camera.near = -_2, a4.camera.far = -m, jt(e5, i4, m, _2, a4.camera), c(a4.lightMat, a4.camera.projectionMatrix, a4.camera.viewMatrix);
    const l4 = this._textureSize / (1 === this.numCascades ? 1 : 2);
    a4.camera.viewport = [t3 % 2 == 0 ? 0 : l4, 0 === Math.floor(t3 / 2) ? 0 : l4, l4, l4];
  }
  _setupMatrices(t3, s4) {
    c(this._projectionView, t3.projectionMatrix, t3.viewMatrix), h(this._projectionViewInverse, this._projectionView);
    const e5 = this._viewingMode === l3.Global ? t3.eye : o(at, 0, 0, 1);
    k(this._modelViewLight, [0, 0, 0], [-s4[0], -s4[1], -s4[2]], e5);
  }
  _clampNearFar(t3) {
    let { near: s4, far: e5 } = t3;
    return s4 < 2 && (s4 = 2), e5 < 2 && (e5 = 2), s4 >= e5 && (s4 = 2, e5 = 4), { near: s4, far: e5 };
  }
  _computeCascadeDistances(t3, e5, i4) {
    const a4 = i4 ? this.settings.maxNumCascadesHighQuality : this.settings.maxNumCascadesLowQuality;
    this._numCascades = Math.min(1 + Math.floor(a3(t3 / e5, 4)), a4);
    const r4 = (t3 - e5) / this._numCascades, n5 = (t3 / e5) ** (1 / this._numCascades);
    let o3 = e5, c3 = e5;
    for (let h2 = 0; h2 < this._numCascades + 1; ++h2)
      this._cascadeDistances[h2] = s(o3, c3, this.settings.splitSchemeLambda), o3 *= n5, c3 += r4;
  }
  get gpuMemoryUsage() {
    var _a;
    return this._snapshots.reduce((t3, s4) => t3 + ((s4 == null ? void 0 : s4.gpuMemoryUsage) ?? 0), ((_a = this._fbo) == null ? void 0 : _a.gpuMemoryUsage) ?? 0);
  }
  get test() {
    return { cascades: this._cascades, textureSize: this._textureSize };
  }
};
var K = e3();
var Y = n2();
var Z = [];
for (let yt = 0; yt < 8; ++yt)
  Z.push(n2());
var $2 = n3();
var tt = n3();
var st = n3();
var et = n3();
var it = n3();
var at = n();
var rt = [];
var nt = e3();
var ot = new Array(64);
var ct = n3();
var ht = n3();
var ut = [n3(), n3(), n3(), n3()];
var mt = n3();
var _t = n3();
var lt = n3();
var dt = n3();
var pt = n3();
var ft = n3();
var xt = n3();
function gt(t3, s4, e5, i4, a4, r4, n5, o3) {
  r3(ct, 0, 0);
  for (let u = 0; u < 4; ++u)
    s2(ct, ct, t3[u]);
  l2(ct, ct, 0.25), r3(ht, 0, 0);
  for (let u = 4; u < 8; ++u)
    s2(ht, ht, t3[u]);
  l2(ht, ht, 0.25), A(ut[0], t3[4], t3[5], 0.5), A(ut[1], t3[5], t3[6], 0.5), A(ut[2], t3[6], t3[7], 0.5), A(ut[3], t3[7], t3[4], 0.5);
  let c3 = 0, h2 = b(ut[0], ct);
  for (let u = 1; u < 4; ++u) {
    const t4 = b(ut[u], ct);
    t4 < h2 && (h2 = t4, c3 = u);
  }
  o2(mt, ut[c3], t3[c3 + 4]);
  const M2 = mt[0];
  let b2, S;
  mt[0] = -mt[1], mt[1] = M2, o2(_t, ht, ct), j2(_t, mt) < 0 && g(mt, mt), A(mt, mt, _t, e5), v(mt, mt), b2 = S = j2(o2(lt, t3[0], ct), mt);
  for (let u = 1; u < 8; ++u) {
    const s5 = j2(o2(lt, t3[u], ct), mt);
    s5 < b2 ? b2 = s5 : s5 > S && (S = s5);
  }
  a2(i4, ct), l2(lt, mt, b2 - s4), s2(i4, i4, lt);
  let C = -1, T2 = 1, j3 = 0, y2 = 0;
  for (let u = 0; u < 8; ++u) {
    o2(dt, t3[u], i4), v(dt, dt);
    const s5 = mt[0] * dt[1] - mt[1] * dt[0];
    s5 > 0 ? s5 > C && (C = s5, j3 = u) : s5 < T2 && (T2 = s5, y2 = u);
  }
  c2(C > 0, "leftArea"), c2(T2 < 0, "rightArea"), l2(pt, mt, b2), s2(pt, pt, ct), l2(ft, mt, S), s2(ft, ft, ct), xt[0] = -mt[1], xt[1] = mt[0];
  const D2 = f(i4, t3[y2], ft, s2(lt, ft, xt), 1, a4), v2 = f(i4, t3[j3], ft, lt, 1, r4), z = f(i4, t3[j3], pt, s2(lt, pt, xt), 1, n5), E = f(i4, t3[y2], pt, lt, 1, o3);
  c2(D2, "rayRay"), c2(v2, "rayRay"), c2(z, "rayRay"), c2(E, "rayRay");
}
function wt(t3, s4) {
  return 3 * s4 + t3;
}
var Mt = n3();
function bt(t3, s4) {
  return r3(Mt, t3[s4], t3[s4 + 3]), Mt;
}
var St = n3();
var Ct = e2();
function Tt(t3, s4, e5, i4, a4) {
  o2(St, e5, i4), l2(St, St, 0.5), Ct[0] = St[0], Ct[1] = St[1], Ct[2] = 0, Ct[3] = St[1], Ct[4] = -St[0], Ct[5] = 0, Ct[6] = St[0] * St[0] + St[1] * St[1], Ct[7] = St[0] * St[1] - St[1] * St[0], Ct[8] = 1, Ct[wt(0, 2)] = -j2(bt(Ct, 0), t3), Ct[wt(1, 2)] = -j2(bt(Ct, 1), t3);
  let r4 = j2(bt(Ct, 0), e5) + Ct[wt(0, 2)], n5 = j2(bt(Ct, 1), e5) + Ct[wt(1, 2)], o3 = j2(bt(Ct, 0), i4) + Ct[wt(0, 2)], c3 = j2(bt(Ct, 1), i4) + Ct[wt(1, 2)];
  r4 = -(r4 + o3) / (n5 + c3), Ct[wt(0, 0)] += Ct[wt(1, 0)] * r4, Ct[wt(0, 1)] += Ct[wt(1, 1)] * r4, Ct[wt(0, 2)] += Ct[wt(1, 2)] * r4, r4 = 1 / (j2(bt(Ct, 0), e5) + Ct[wt(0, 2)]), n5 = 1 / (j2(bt(Ct, 1), e5) + Ct[wt(1, 2)]), Ct[wt(0, 0)] *= r4, Ct[wt(0, 1)] *= r4, Ct[wt(0, 2)] *= r4, Ct[wt(1, 0)] *= n5, Ct[wt(1, 1)] *= n5, Ct[wt(1, 2)] *= n5, Ct[wt(2, 0)] = Ct[wt(1, 0)], Ct[wt(2, 1)] = Ct[wt(1, 1)], Ct[wt(2, 2)] = Ct[wt(1, 2)], Ct[wt(1, 2)] += 1, r4 = j2(bt(Ct, 1), s4) + Ct[wt(1, 2)], n5 = j2(bt(Ct, 2), s4) + Ct[wt(2, 2)], o3 = j2(bt(Ct, 1), e5) + Ct[wt(1, 2)], c3 = j2(bt(Ct, 2), e5) + Ct[wt(2, 2)], r4 = -0.5 * (r4 / n5 + o3 / c3), Ct[wt(1, 0)] += Ct[wt(2, 0)] * r4, Ct[wt(1, 1)] += Ct[wt(2, 1)] * r4, Ct[wt(1, 2)] += Ct[wt(2, 2)] * r4, r4 = j2(bt(Ct, 1), s4) + Ct[wt(1, 2)], n5 = j2(bt(Ct, 2), s4) + Ct[wt(2, 2)], o3 = -n5 / r4, Ct[wt(1, 0)] *= o3, Ct[wt(1, 1)] *= o3, Ct[wt(1, 2)] *= o3, a4[0] = Ct[0], a4[1] = Ct[1], a4[2] = 0, a4[3] = Ct[2], a4[4] = Ct[3], a4[5] = Ct[4], a4[6] = 0, a4[7] = Ct[5], a4[8] = 0, a4[9] = 0, a4[10] = 1, a4[11] = 0, a4[12] = Ct[6], a4[13] = Ct[7], a4[14] = 0, a4[15] = Ct[8];
}
function jt(t3, s4, i4, a4, r4) {
  const n5 = 1 / Z[0][3], o3 = 1 / Z[4][3];
  s3(n5 < o3);
  let c3 = n5 + Math.sqrt(n5 * o3);
  const h2 = Math.sin(l(t3[2] * s4[0] + t3[6] * s4[1] + t3[10] * s4[2]));
  c3 /= h2, gt(Z, c3, h2, $2, tt, st, et, it), Tt($2, tt, et, it, r4.projectionMatrix), r4.projectionMatrix[10] = 2 / (i4 - a4), r4.projectionMatrix[14] = -(i4 + a4) / (i4 - a4);
}

export {
  n4 as n,
  X,
  J
};
//# sourceMappingURL=chunk-FIJZ6LYC.js.map
