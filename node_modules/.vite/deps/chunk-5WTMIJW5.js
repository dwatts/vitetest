import {
  Be
} from "./chunk-3C6NSN3C.js";
import {
  x
} from "./chunk-2CTB7MKH.js";
import {
  j as j2
} from "./chunk-Z2ZUNW5S.js";
import {
  j
} from "./chunk-43LWRDQS.js";
import {
  n
} from "./chunk-R6YKST3K.js";
import {
  f
} from "./chunk-7I33FAWS.js";

// node_modules/@arcgis/core/layers/support/FetchAssociatedFeatureLayer.js
var i = class {
  constructor(t, r, e, a) {
    var _a;
    this._parsedUrl = t, this._portalItem = r, this._apiKey = e, this.signal = a, this._rootDocument = null;
    const n2 = (_a = this._parsedUrl) == null ? void 0 : _a.path.match(/^(.*)\/SceneServer\/layers\/([\d]*)\/?$/i);
    n2 && (this._urlParts = { root: n2[1], layerId: parseInt(n2[2], 10) });
  }
  async fetch() {
    if (!this._urlParts)
      return null;
    const t = this._portalItem ?? await this._portalItemFromServiceItemId();
    if (null == t)
      return this._loadFromUrl();
    const r = await this._findAndLoadRelatedPortalItem(t);
    return null == r ? null : this._loadFeatureLayerFromPortalItem(r);
  }
  async fetchPortalItem() {
    if (!this._urlParts)
      return null;
    const t = this._portalItem ?? await this._portalItemFromServiceItemId();
    return null == t ? null : this._findAndLoadRelatedPortalItem(t);
  }
  async _fetchRootDocument() {
    if (null != this._rootDocument)
      return this._rootDocument;
    if (null == this._urlParts)
      return this._rootDocument = {}, {};
    const t = { query: { f: "json", token: this._apiKey }, responseType: "json", signal: this.signal }, e = `${this._urlParts.root}/SceneServer`;
    try {
      const a = await j(e, t);
      this._rootDocument = a.data;
    } catch {
      this._rootDocument = {};
    }
    return this._rootDocument;
  }
  async _fetchServiceOwningPortalUrl() {
    var _a, _b;
    const a = (_a = this._parsedUrl) == null ? void 0 : _a.path, n2 = a ? (_b = n) == null ? void 0 : _b.findServerInfo(a) : null;
    if (n2 == null ? void 0 : n2.owningSystemUrl)
      return n2.owningSystemUrl;
    const s = a ? a.replace(/(.*\/rest)\/.*/i, "$1") + "/info" : null;
    try {
      const t = (await j(s, { query: { f: "json" }, responseType: "json", signal: this.signal })).data.owningSystemUrl;
      if (t)
        return t;
    } catch (i2) {
      f(i2);
    }
    return null;
  }
  async _findAndLoadRelatedPortalItem(t) {
    try {
      return (await t.fetchRelatedItems({ relationshipType: "Service2Service", direction: "reverse" }, { signal: this.signal })).find((t2) => "Feature Service" === t2.type) || null;
    } catch (r) {
      return f(r), null;
    }
  }
  async _loadFeatureLayerFromPortalItem(t) {
    await t.load({ signal: this.signal });
    const r = await this._findMatchingAssociatedSublayerUrl(t.url ?? "");
    return new Be({ url: r, portalItem: t }).load({ signal: this.signal });
  }
  async _loadFromUrl() {
    var _a;
    const t = await this._findMatchingAssociatedSublayerUrl(`${(_a = this._urlParts) == null ? void 0 : _a.root}/FeatureServer`);
    return new Be({ url: t }).load({ signal: this.signal });
  }
  async _findMatchingAssociatedSublayerUrl(t) {
    var _a;
    const e = t.replace(/^(.*FeatureServer)(\/[\d]*\/?)?$/i, "$1"), a = (_a = this._urlParts) == null ? void 0 : _a.layerId, n2 = this._fetchRootDocument(), s = (t2) => {
      const a2 = { query: { f: "json" }, responseType: "json", authMode: t2, signal: this.signal };
      return j(e, a2);
    }, i2 = s("anonymous").catch(() => s("no-prompt")), [o, l] = await Promise.all([i2, n2]), c = l && l.layers, u = o.data && o.data.layers;
    if (!Array.isArray(u))
      throw new Error("expected layers array");
    if (Array.isArray(c))
      for (let r = 0; r < Math.min(c.length, u.length); r++) {
        if (c[r].id === a)
          return `${e}/${u[r].id}`;
      }
    else if (null != a && a < u.length)
      return `${e}/${u[a].id}`;
    throw new Error("could not find matching associated sublayer");
  }
  async _portalItemFromServiceItemId() {
    const t = (await this._fetchRootDocument()).serviceItemId;
    if (!t)
      return null;
    const r = new x({ id: t, apiKey: this._apiKey }), a = await this._fetchServiceOwningPortalUrl();
    null != a && (r.portal = new j2({ url: a }));
    try {
      return r.load({ signal: this.signal });
    } catch (i2) {
      return f(i2), null;
    }
  }
};

export {
  i
};
//# sourceMappingURL=chunk-5WTMIJW5.js.map
