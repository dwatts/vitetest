import {
  t
} from "./chunk-XKYCNHCM.js";
import {
  I as I2,
  N,
  P,
  a2 as a,
  h,
  i,
  k,
  p2 as p,
  s,
  u
} from "./chunk-3LLZ72VA.js";
import {
  I
} from "./chunk-LVVQ2RQY.js";
import {
  H,
  r
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import {
  has
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/RenderFeature.js
var o;
function t2(t3 = !has("disable-feature:high-quality-idle"), s2 = null) {
  const n2 = new t();
  return t3 ? (n2.set(I.IDLE, o.Antialiasing, "low" !== s2), n2.set(I.IDLE, o.HighResolutionAtmosphere, "low" !== s2), n2.set(I.IDLE, o.HighQualityTransparency, true), n2.set(I.IDLE, o.SSAO, true), n2.set(I.IDLE, o.WaterReflection, true), n2.set(I.IDLE, o.PhysicalPixelRendering, !has("esri-mobile"))) : (n2.set(I.ANIMATING, o.HighResolutionShadows, true), n2.set(I.INTERACTING, o.HighResolutionShadows, true)), n2.set(I.IDLE, o.HighResolutionShadows, true), n2.set(I.IDLE, o.HighResolutionVoxel, true), n2;
}
!function(e) {
  e[e.Antialiasing = 0] = "Antialiasing", e[e.HighQualityTransparency = 1] = "HighQualityTransparency", e[e.HighResolutionVoxel = 2] = "HighResolutionVoxel", e[e.HighResolutionAtmosphere = 3] = "HighResolutionAtmosphere", e[e.SSAO = 4] = "SSAO", e[e.WaterReflection = 5] = "WaterReflection", e[e.HighResolutionShadows = 6] = "HighResolutionShadows", e[e.PhysicalPixelRendering = 7] = "PhysicalPixelRendering";
}(o || (o = {}));

// node_modules/@arcgis/core/views/3d/state/Frustum.js
var d = class {
  get planes() {
    return this.frustum;
  }
  get points() {
    return this._points;
  }
  get mutablePoints() {
    return this._points;
  }
  get direction() {
    return this._direction;
  }
  constructor(t3) {
    this.renderCoordsHelper = t3, this.frustum = I2(), this._points = N(), this.lines = new Array(12), this._origin = n(), this._direction = n(), this._altitude = null;
    for (let i2 = 0; i2 < 12; i2++)
      this.lines[i2] = { origin: null, direction: n(), endpoint: null };
  }
  update(i2) {
    s(i2.viewMatrix, i2.projectionMatrix, this.frustum, this._points), r(this._origin, i2.eye), r(this._direction, i2.viewForward), this._altitude = this.renderCoordsHelper.getAltitude(this._origin), this._updateLines();
  }
  updatePoints(i2) {
    for (let s2 = 0; s2 < this._points.length; s2++)
      r(this._points[s2], i2[s2]);
    u(this.frustum, this._points), this._updateLines();
  }
  get altitude() {
    return this._altitude;
  }
  intersectsSphere(t3) {
    return P(this.frustum, t3);
  }
  intersectsRay(t3) {
    return i(this.frustum, t3);
  }
  intersectsLineSegment(t3, i2) {
    return a(this.frustum, t3, i2);
  }
  intersectsPoint(t3) {
    return p(this.frustum, t3);
  }
  _updateLines() {
    const t3 = this._points;
    for (let i2 = 0; i2 < 4; i2++) {
      const s2 = i2 + 4;
      a2(this.lines[i2], t3[i2], t3[s2]), a2(this.lines[i2 + 4], t3[i2], 3 === i2 ? t3[0] : t3[i2 + 1]), a2(this.lines[i2 + 8], t3[s2], 3 === i2 ? t3[4] : t3[s2 + 1]);
    }
  }
};
function a2(t3, s2, e) {
  t3.origin = s2, t3.endpoint = e, H(t3.direction, s2, e);
}
d.planePointIndices = h, d.nearFarLineIndices = [[k.NEAR_BOTTOM_LEFT, k.FAR_BOTTOM_LEFT], [k.NEAR_BOTTOM_RIGHT, k.FAR_BOTTOM_RIGHT], [k.NEAR_TOP_RIGHT, k.FAR_TOP_RIGHT], [k.NEAR_TOP_LEFT, k.FAR_TOP_LEFT]];

export {
  o,
  t2 as t,
  d
};
//# sourceMappingURL=chunk-5XCEDULD.js.map
