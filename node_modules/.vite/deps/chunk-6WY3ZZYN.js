import {
  P as P2,
  u as u2
} from "./chunk-CS6BZGQO.js";
import {
  a as a4,
  t as t4
} from "./chunk-I7EXY23J.js";
import {
  t as t3
} from "./chunk-SCHIU6CT.js";
import {
  D,
  H as H2
} from "./chunk-5GYSL2SB.js";
import {
  v
} from "./chunk-EPDLDPS4.js";
import {
  N,
  O as O3,
  R as R2,
  b2 as b,
  p,
  y
} from "./chunk-BDX5TRUE.js";
import {
  A
} from "./chunk-LIXBKTBN.js";
import {
  E as E3
} from "./chunk-6LC2JTLC.js";
import {
  s as s6
} from "./chunk-XM3YSFN6.js";
import {
  e as e5,
  i as i3,
  t
} from "./chunk-V6CD66ZZ.js";
import {
  W,
  _,
  a as a3,
  s as s5
} from "./chunk-6FHMQNMS.js";
import {
  r as r7
} from "./chunk-KFDARCTS.js";
import {
  V,
  d,
  d2,
  f,
  o as o2,
  o2 as o3,
  t as t2
} from "./chunk-SMDDCTGQ.js";
import {
  E as E2
} from "./chunk-NU4UASX6.js";
import {
  l as l2,
  r as r6
} from "./chunk-YLTVH2K4.js";
import {
  o as o4
} from "./chunk-SADO52IH.js";
import {
  h as h2
} from "./chunk-73PNWDTS.js";
import {
  H
} from "./chunk-Z7LZRT7C.js";
import {
  s as s4
} from "./chunk-SGBMUZSF.js";
import {
  E,
  I,
  R
} from "./chunk-BCDDCNQ2.js";
import {
  x as x2
} from "./chunk-FIBWCATC.js";
import {
  e as e4
} from "./chunk-CW7LIPBH.js";
import {
  e as e3
} from "./chunk-VN2IXVGV.js";
import {
  O as O2
} from "./chunk-BN6X2OXK.js";
import {
  n as n4,
  r as r4
} from "./chunk-YGUWDSEH.js";
import {
  n as n3,
  r as r3
} from "./chunk-ZWFMUHG3.js";
import {
  a
} from "./chunk-NLWV7Q6F.js";
import {
  l
} from "./chunk-RVS5HU2K.js";
import {
  a as a2
} from "./chunk-JB7FDW5N.js";
import {
  n as n5,
  r as r5
} from "./chunk-SS3YG6J3.js";
import {
  yn,
  zn
} from "./chunk-BNBT4QTW.js";
import {
  h,
  n as n2
} from "./chunk-7EG7BYWF.js";
import {
  i as i4
} from "./chunk-4BXK4H4L.js";
import {
  i as i2
} from "./chunk-EKJ2DJIR.js";
import {
  i
} from "./chunk-TEHNQYQD.js";
import {
  O,
  P,
  S,
  e as e2,
  g,
  o,
  r as r2,
  s as s3,
  u,
  x,
  z
} from "./chunk-TPJLFGOT.js";
import {
  n,
  r
} from "./chunk-CQX57DED.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  s as s2
} from "./chunk-7I33FAWS.js";
import {
  s2 as s
} from "./chunk-HMVAPW5X.js";
import {
  has
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/layers/graphics/elevationAlignmentUtils.js
function u3(e6, t7, n7, r9, i6, s9, a7, l4, u5, c3, f4) {
  const d5 = x3[f4.mode];
  let m3, p4, g4 = 0;
  if (yn(e6, t7, n7, r9, u5.spatialReference, i6, l4))
    return d5.requiresAlignment(f4) ? (g4 = d5.applyElevationAlignmentBuffer(r9, i6, s9, a7, l4, u5, c3, f4), m3 = s9, p4 = a7) : (m3 = r9, p4 = i6), yn(m3, u5.spatialReference, p4, s9, c3.spatialReference, a7, l4) ? g4 : void 0;
}
function c(e6, t7, n7, o7, r9) {
  const s9 = (t3(e6) ? e6.z : t4(e6) ? e6.array[e6.offset + 2] : e6[2]) || 0;
  switch (n7.mode) {
    case "on-the-ground": {
      const n8 = a4(t7, e6, "ground") ?? 0;
      return r9.verticalDistanceToGround = 0, r9.sampledElevation = n8, void (r9.z = n8);
    }
    case "relative-to-ground": {
      const i6 = a4(t7, e6, "ground") ?? 0, a7 = n7.geometryZWithOffset(s9, o7);
      return r9.verticalDistanceToGround = a7, r9.sampledElevation = i6, void (r9.z = a7 + i6);
    }
    case "relative-to-scene": {
      const i6 = a4(t7, e6, "scene") ?? 0, a7 = n7.geometryZWithOffset(s9, o7);
      return r9.verticalDistanceToGround = a7, r9.sampledElevation = i6, void (r9.z = a7 + i6);
    }
    case "absolute-height": {
      const i6 = n7.geometryZWithOffset(s9, o7), a7 = a4(t7, e6, "ground") ?? 0;
      return r9.verticalDistanceToGround = i6 - a7, r9.sampledElevation = a7, void (r9.z = i6);
    }
    default:
      return void (r9.z = 0);
  }
}
function f2(e6, t7, n7, o7) {
  return c(e6, t7, n7, o7, j), j.z;
}
function d3(e6, t7, n7) {
  return null == t7 || null == n7 ? e6.definedChanged : "on-the-ground" === t7 && "on-the-ground" === n7 ? e6.staysOnTheGround : t7 === n7 || "on-the-ground" !== t7 && "on-the-ground" !== n7 ? T.UPDATE : e6.onTheGroundChanged;
}
function m(e6) {
  return "relative-to-ground" === e6 || "relative-to-scene" === e6;
}
function p2(e6) {
  return "absolute-height" !== e6;
}
function g2(t7, n7, o7, i6, a7) {
  c(n7, o7, a7, i6, j), P2(t7, j.verticalDistanceToGround);
  const l4 = j.sampledElevation, u5 = n2(O4, t7.transformation);
  z2[0] = n7.x, z2[1] = n7.y, z2[2] = j.z;
  return zn(n7.spatialReference, z2, u5, i6.spatialReference) ? t7.transformation = u5 : console.warn("Could not locate symbol object properly, it might be misplaced"), l4;
}
function v2(e6, t7, n7, o7, r9, i6) {
  let s9 = 0;
  const a7 = i6.spatialReference;
  t7 *= 3, o7 *= 3;
  for (let l4 = 0; l4 < r9; ++l4) {
    const r10 = e6[t7], l5 = e6[t7 + 1], u5 = e6[t7 + 2], c3 = i6.getElevation(r10, l5, u5, a7, "ground") ?? 0;
    s9 += c3, n7[o7] = r10, n7[o7 + 1] = l5, n7[o7 + 2] = c3, t7 += 3, o7 += 3;
  }
  return s9 / r9;
}
function h3(e6, t7, n7, o7, r9, i6, s9, a7) {
  let l4 = 0;
  const u5 = a7.calculateOffsetRenderUnits(s9), c3 = a7.featureExpressionInfoContext, f4 = i6.spatialReference;
  t7 *= 3, o7 *= 3;
  for (let d5 = 0; d5 < r9; ++d5) {
    const r10 = e6[t7], s10 = e6[t7 + 1], a8 = e6[t7 + 2], d6 = i6.getElevation(r10, s10, a8, f4, "ground") ?? 0;
    l4 += d6, n7[o7] = r10, n7[o7 + 1] = s10, n7[o7 + 2] = null == c3 ? a8 + d6 + u5 : d6 + u5, t7 += 3, o7 += 3;
  }
  return l4 / r9;
}
function E4(e6, t7, n7, o7, r9, i6, s9, a7) {
  let l4 = 0;
  const u5 = a7.calculateOffsetRenderUnits(s9), c3 = a7.featureExpressionInfoContext, f4 = i6.spatialReference;
  t7 *= 3, o7 *= 3;
  for (let d5 = 0; d5 < r9; ++d5) {
    const r10 = e6[t7], s10 = e6[t7 + 1], a8 = e6[t7 + 2], d6 = i6.getElevation(r10, s10, a8, f4, "scene") ?? 0;
    l4 += d6, n7[o7] = r10, n7[o7 + 1] = s10, n7[o7 + 2] = null == c3 ? a8 + d6 + u5 : d6 + u5, t7 += 3, o7 += 3;
  }
  return l4 / r9;
}
function y2(e6) {
  const t7 = e6.meterUnitOffset, n7 = e6.featureExpressionInfoContext;
  return 0 !== t7 || null != n7;
}
function A2(e6, t7, n7, o7, r9, i6, s9, a7) {
  const l4 = a7.calculateOffsetRenderUnits(s9), u5 = a7.featureExpressionInfoContext;
  t7 *= 3, o7 *= 3;
  for (let c3 = 0; c3 < r9; ++c3) {
    const r10 = e6[t7], i7 = e6[t7 + 1], s10 = e6[t7 + 2];
    n7[o7] = r10, n7[o7 + 1] = i7, n7[o7 + 2] = null == u5 ? s10 + l4 : l4, t7 += 3, o7 += 3;
  }
  return 0;
}
var R3 = class {
  constructor() {
    this.verticalDistanceToGround = 0, this.sampledElevation = 0, this.z = 0;
  }
};
var T;
!function(e6) {
  e6[e6.NONE = 0] = "NONE", e6[e6.UPDATE = 1] = "UPDATE", e6[e6.RECREATE = 2] = "RECREATE";
}(T || (T = {}));
var x3 = { "absolute-height": { applyElevationAlignmentBuffer: A2, requiresAlignment: y2 }, "on-the-ground": { applyElevationAlignmentBuffer: v2, requiresAlignment: () => true }, "relative-to-ground": { applyElevationAlignmentBuffer: h3, requiresAlignment: () => true }, "relative-to-scene": { applyElevationAlignmentBuffer: E4, requiresAlignment: () => true } };
var O4 = e4();
var j = new R3();
var z2 = n();

// node_modules/@arcgis/core/views/3d/layers/graphics/featureExpressionInfoUtils.js
var c2 = s.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");
function o5(e6) {
  return { cachedResult: e6.cachedResult, arcade: e6.arcade ? { func: e6.arcade.func, context: e6.arcade.modules.arcadeUtils.createExecContext(null, { sr: e6.arcade.context.spatialReference }), modules: e6.arcade.modules } : null };
}
function u4(e6) {
  const t7 = e6 && e6.expression;
  if ("string" == typeof t7) {
    const e7 = m2(t7);
    if (null != e7)
      return { cachedResult: e7 };
  }
  return null;
}
async function a5(e6, r9, c3, o7) {
  const u5 = e6 && e6.expression;
  if ("string" != typeof u5)
    return null;
  const a7 = m2(u5);
  if (null != a7)
    return { cachedResult: a7 };
  const s9 = await i4();
  s2(c3);
  const l4 = s9.arcadeUtils, i6 = l4.createSyntaxTree(u5);
  return l4.dependsOnView(i6) ? (null != o7 && o7.error("Expressions containing '$view' are not supported on ElevationInfo"), { cachedResult: 0 }) : { arcade: { func: l4.createFunction(i6), context: l4.createExecContext(null, { sr: r9 }), modules: s9 } };
}
function s7(e6, t7, r9) {
  return e6.arcadeUtils.createFeature(t7.attributes, t7.geometry, r9);
}
function l3(e6, t7) {
  if (null != e6 && !p3(e6)) {
    if (!t7 || !e6.arcade)
      return void c2.errorOncePerTick("Arcade support required but not provided");
    const n7 = t7;
    n7._geometry && (n7._geometry = u2(n7._geometry)), e6.arcade.modules.arcadeUtils.updateExecContext(e6.arcade.context, t7);
  }
}
function i5(e6) {
  if (null != e6) {
    if (p3(e6))
      return e6.cachedResult;
    const t7 = e6.arcade;
    let r9 = t7 == null ? void 0 : t7.modules.arcadeUtils.executeFunction(t7.func, t7.context);
    return "number" != typeof r9 && (e6.cachedResult = 0, r9 = 0), r9;
  }
  return 0;
}
function d4(e6, t7 = false) {
  let r9 = e6 && e6.featureExpressionInfo;
  const n7 = r9 && r9.expression;
  return t7 || "0" === n7 || (r9 = null), r9 ?? null;
}
var f3 = { cachedResult: 0 };
function p3(e6) {
  return null != e6.cachedResult;
}
function m2(e6) {
  return "0" === e6 ? 0 : null;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/ElevationContext.js
var o6 = class _o {
  constructor() {
    this._meterUnitOffset = 0, this._renderUnitOffset = 0, this._unit = "meters", this._metersPerElevationInfoUnit = 1, this._featureExpressionInfoContext = null, this.centerPointInElevationSR = null, this.mode = null;
  }
  get featureExpressionInfoContext() {
    return this._featureExpressionInfoContext;
  }
  get meterUnitOffset() {
    return this._meterUnitOffset;
  }
  get unit() {
    return this._unit;
  }
  set unit(e6) {
    this._unit = e6, this._metersPerElevationInfoUnit = r3(e6);
  }
  get requiresSampledElevationInfo() {
    return "absolute-height" !== this.mode;
  }
  reset() {
    this.mode = null, this._meterUnitOffset = 0, this._renderUnitOffset = 0, this._featureExpressionInfoContext = null, this.unit = "meters";
  }
  set offsetMeters(t7) {
    this._meterUnitOffset = t7, this._renderUnitOffset = 0;
  }
  set offsetElevationInfoUnits(t7) {
    this._meterUnitOffset = t7 * this._metersPerElevationInfoUnit, this._renderUnitOffset = 0;
  }
  addOffsetRenderUnits(t7) {
    this._renderUnitOffset += t7;
  }
  geometryZWithOffset(t7, e6) {
    const n7 = this.calculateOffsetRenderUnits(e6);
    return null != this.featureExpressionInfoContext ? n7 : t7 + n7;
  }
  calculateOffsetRenderUnits(t7) {
    let e6 = this._meterUnitOffset;
    const s9 = this.featureExpressionInfoContext;
    return null != s9 && (e6 += i5(s9) * this._metersPerElevationInfoUnit), e6 / t7.unitInMeters + this._renderUnitOffset;
  }
  setFromElevationInfo(t7) {
    this.mode = t7.mode, this.unit = n3(t7.unit) ? t7.unit : "meters", this.offsetElevationInfoUnits = t7.offset ?? 0;
  }
  updateFeatureExpressionInfoContext(t7, e6, n7) {
    if (null == t7)
      return void (this._featureExpressionInfoContext = null);
    const o7 = t7 && t7.arcade;
    o7 && null != e6 && null != n7 ? (this._featureExpressionInfoContext = o5(t7), l3(this._featureExpressionInfoContext, s7(o7.modules, e6, n7))) : this._featureExpressionInfoContext = t7;
  }
  static fromElevationInfo(t7) {
    const e6 = new _o();
    return null != t7 && e6.setFromElevationInfo(t7), e6;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/ScaleInfo.js
var t5 = class {
  constructor() {
    this.factor = new s8(), this.factorAlignment = new s8();
  }
};
var s8 = class {
  constructor() {
    this.scale = 0, this.factor = 0, this.minPixelSize = 0, this.paddingPixels = 0;
  }
};

// node_modules/@arcgis/core/core/libs/gl-matrix-2/types/mat4.js
function n6(n7) {
  return n7 instanceof Float32Array && n7.length >= 16;
}
function r8(n7) {
  return Array.isArray(n7) && n7.length >= 16;
}
function t6(t7) {
  return n6(t7) || r8(t7);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/HUDMaterialTechnique.js
var g3 = class _g extends e5 {
  initializeConfiguration(t7, i6) {
    i6.spherical = t7.viewingMode === l.Global;
  }
  initializeProgram(e6) {
    return new i3(e6.rctx, _g.shader.get().build(this.configuration), E2);
  }
  _setPipelineState(e6) {
    const i6 = this.configuration, r9 = e6 === o4.NONE, o7 = e6 === o4.FrontFace, s9 = this.configuration.hasPolygonOffset ? b2 : null, l4 = (r9 || o7) && i6.output !== h2.Highlight && (i6.depthEnabled || i6.occlusionPass) ? a3 : null;
    return W({ blending: i6.output === h2.Color || i6.output === h2.Alpha || i6.output === h2.Highlight ? r9 ? j2 : A(e6) : null, depthTest: { func: I.LEQUAL }, depthWrite: l4, colorWrite: _, polygonOffset: s9 });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
  get primitiveType() {
    return this.configuration.occlusionPass ? E.POINTS : E.TRIANGLES;
  }
};
g3.shader = new t(H2, () => import("./HUDMaterial.glsl-MNFIC7PY.js"));
var b2 = { factor: 0, units: -4 };
var j2 = s5(R.ONE, R.ONE_MINUS_SRC_ALPHA);

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/HUDMaterialTechniqueConfiguration.js
var a6 = class extends s6 {
  constructor() {
    super(...arguments), this.output = h2.Color, this.screenCenterOffsetUnitsEnabled = v.World, this.transparencyPassType = o4.NONE, this.spherical = false, this.occlusionTestEnabled = true, this.signedDistanceFieldEnabled = false, this.vvSize = false, this.vvColor = false, this.hasVerticalOffset = false, this.hasScreenSizePerspective = false, this.debugDrawLabelBorder = false, this.binaryHighlightOcclusionEnabled = true, this.hasSlicePlane = false, this.hasPolygonOffset = false, this.depthEnabled = true, this.pixelSnappingEnabled = true, this.draped = false, this.hasMultipassGeometry = false, this.hasMultipassTerrain = false, this.cullAboveGround = false, this.occlusionPass = false, this.objectAndLayerIdColorInstanced = false;
  }
};
e([r7({ count: h2.COUNT })], a6.prototype, "output", void 0), e([r7({ count: v.COUNT })], a6.prototype, "screenCenterOffsetUnitsEnabled", void 0), e([r7({ count: o4.COUNT })], a6.prototype, "transparencyPassType", void 0), e([r7()], a6.prototype, "spherical", void 0), e([r7()], a6.prototype, "occlusionTestEnabled", void 0), e([r7()], a6.prototype, "signedDistanceFieldEnabled", void 0), e([r7()], a6.prototype, "vvSize", void 0), e([r7()], a6.prototype, "vvColor", void 0), e([r7()], a6.prototype, "hasVerticalOffset", void 0), e([r7()], a6.prototype, "hasScreenSizePerspective", void 0), e([r7()], a6.prototype, "debugDrawLabelBorder", void 0), e([r7()], a6.prototype, "binaryHighlightOcclusionEnabled", void 0), e([r7()], a6.prototype, "hasSlicePlane", void 0), e([r7()], a6.prototype, "hasPolygonOffset", void 0), e([r7()], a6.prototype, "depthEnabled", void 0), e([r7()], a6.prototype, "pixelSnappingEnabled", void 0), e([r7()], a6.prototype, "draped", void 0), e([r7()], a6.prototype, "hasMultipassGeometry", void 0), e([r7()], a6.prototype, "hasMultipassTerrain", void 0), e([r7()], a6.prototype, "cullAboveGround", void 0), e([r7()], a6.prototype, "occlusionPass", void 0), e([r7()], a6.prototype, "objectAndLayerIdColorInstanced", void 0), e([r7({ constValue: true })], a6.prototype, "hasSliceInVertexProgram", void 0), e([r7({ constValue: false })], a6.prototype, "hasVvInstancing", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/HUDMaterial.js
var K = class extends d2 {
  constructor(e6) {
    super(e6, new ve()), this._configuration = new a6();
  }
  getConfiguration(e6, t7) {
    return this._configuration.output = e6, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.hasVerticalOffset = !!this.parameters.verticalOffset, this._configuration.hasScreenSizePerspective = !!this.parameters.screenSizePerspective, this._configuration.screenCenterOffsetUnitsEnabled = "screen" === this.parameters.centerOffsetUnits ? v.Screen : v.World, this._configuration.hasPolygonOffset = this.parameters.polygonOffset, this._configuration.draped = this.parameters.isDraped, this._configuration.occlusionTestEnabled = this.parameters.occlusionTest, this._configuration.pixelSnappingEnabled = this.parameters.pixelSnappingEnabled, this._configuration.signedDistanceFieldEnabled = this.parameters.textureIsSignedDistanceField, this._configuration.vvSize = !!this.parameters.vvSize, this._configuration.vvColor = !!this.parameters.vvColor, this._configuration.occlusionPass = t7.slot === E3.OCCLUSION_PIXELS && this.parameters.occlusionTest && (e6 === h2.Color || e6 === h2.Alpha), e6 === h2.Color && (this._configuration.debugDrawLabelBorder = !!t2.LABELS_SHOW_BORDER), e6 === h2.Highlight && (this._configuration.binaryHighlightOcclusionEnabled = this.parameters.binaryHighlightOcclusion), this._configuration.depthEnabled = this.parameters.depthEnabled, this._configuration.transparencyPassType = t7.transparencyPassType, this._configuration.hasMultipassGeometry = t7.multipassGeometry.enabled, this._configuration.hasMultipassTerrain = t7.multipassTerrain.enabled, this._configuration.cullAboveGround = t7.multipassTerrain.cullAboveGround, this._configuration;
  }
  intersect(e6, r9, i6, a7, n7, o7) {
    if (!i6.options.selectionMode || !i6.options.hud || !e6.visible)
      return;
    const g4 = this.parameters;
    let O5 = 1, S2 = 1;
    if (a2(le, r9), null != e6.shaderTransformer) {
      const t7 = e6.shaderTransformer(me);
      O5 = t7[0], S2 = t7[5], ee(le);
    }
    const A3 = e6.vertexAttributes.get(O2.POSITION), b3 = e6.vertexAttributes.get(O2.SIZE), P3 = e6.vertexAttributes.get(O2.NORMAL), x4 = e6.vertexAttributes.get(O2.AUXPOS1);
    s4(A3.size >= 3);
    const _2 = i6.point, y3 = i6.camera, I2 = D(g4);
    O5 *= y3.pixelRatio, S2 *= y3.pixelRatio;
    const T2 = "screen" === this.parameters.centerOffsetUnits;
    for (let t7 = 0; t7 < A3.data.length / A3.size; t7++) {
      const e7 = t7 * A3.size;
      o(ie, A3.data[e7], A3.data[e7 + 1], A3.data[e7 + 2]), O(ie, ie, r9);
      const a8 = t7 * b3.size;
      Oe[0] = b3.data[a8] * O5, Oe[1] = b3.data[a8 + 1] * S2, O(ie, ie, y3.viewMatrix);
      const n8 = t7 * x4.size;
      if (o(pe, x4.data[n8], x4.data[n8 + 1], x4.data[n8 + 2]), !T2 && (ie[0] += pe[0], ie[1] += pe[1], 0 !== pe[2])) {
        const e8 = pe[2];
        z(pe, ie), e2(ie, ie, g(pe, pe, e8));
      }
      const j3 = t7 * P3.size;
      if (o(ae, P3.data[j3], P3.data[j3 + 1], P3.data[j3 + 2]), this._normalAndViewAngle(ae, le, y3, he), this._applyVerticalOffsetTransformationView(ie, he, y3, re), y3.applyProjection(ie, ne), ne[0] > -1) {
        ne[0] = Math.floor(ne[0]), ne[1] = Math.floor(ne[1]), T2 && (pe[0] || pe[1]) && (ne[0] += pe[0], 0 !== pe[1] && (ne[1] += o2(pe[1], re.factorAlignment)), y3.unapplyProjection(ne, ie)), ne[0] += this.parameters.screenOffset[0], ne[1] += this.parameters.screenOffset[1], f(Oe, re.factor, Oe);
        const e8 = de * y3.pixelRatio;
        let t8 = 0;
        if (g4.textureIsSignedDistanceField && (t8 = g4.outlineSize * y3.pixelRatio / 2), _2 && te(_2, ne[0], ne[1], Oe, e8, t8, g4, I2)) {
          const e9 = i6.ray;
          if (O(ce, ie, h(ue, y3.viewMatrix)), ne[0] = _2[0], ne[1] = _2[1], y3.unprojectFromRenderScreen(ne, ie)) {
            const t9 = n();
            r2(t9, e9.direction);
            const r10 = 1 / s3(t9);
            g(t9, t9, r10);
            o7(x(e9.origin, ie) * r10, t9, -1, true, 1, ce);
          }
        }
      }
    }
  }
  intersectDraped(e6, t7, r9, s9, i6, a7) {
    const n7 = e6.vertexAttributes.get(O2.POSITION), o7 = e6.vertexAttributes.get(O2.SIZE), c3 = this.parameters, l4 = D(c3);
    let f4 = 1, u5 = 1;
    if (null != e6.shaderTransformer) {
      const t8 = e6.shaderTransformer(me);
      f4 = t8[0], u5 = t8[5];
    }
    f4 *= e6.screenToWorldRatio, u5 *= e6.screenToWorldRatio;
    const p4 = ge * e6.screenToWorldRatio;
    for (let h4 = 0; h4 < n7.data.length / n7.size; h4++) {
      const t8 = h4 * n7.size, r10 = n7.data[t8], m3 = n7.data[t8 + 1], d5 = h4 * o7.size;
      Oe[0] = o7.data[d5] * f4, Oe[1] = o7.data[d5 + 1] * u5;
      let g4 = 0;
      c3.textureIsSignedDistanceField && (g4 = c3.outlineSize * e6.screenToWorldRatio / 2), te(s9, r10, m3, Oe, p4, g4, c3, l4) && i6(a7.dist, a7.normal, -1, false);
    }
  }
  createBufferWriter() {
    return new Pe(this);
  }
  _normalAndViewAngle(e6, r9, s9, i6) {
    return t6(r9) && (r9 = a2(fe, r9)), S(i6.normal, e6, r9), O(i6.normal, i6.normal, s9.viewInverseTransposeMatrix), i6.cosAngle = P(oe, Se), i6;
  }
  _updateScaleInfo(e6, t7, r9) {
    const s9 = this.parameters;
    null != s9.screenSizePerspective ? d(r9, t7, s9.screenSizePerspective, e6.factor) : (e6.factor.scale = 1, e6.factor.factor = 0, e6.factor.minPixelSize = 0, e6.factor.paddingPixels = 0), null != s9.screenSizePerspectiveAlignment ? d(r9, t7, s9.screenSizePerspectiveAlignment, e6.factorAlignment) : (e6.factorAlignment.factor = e6.factor.factor, e6.factorAlignment.scale = e6.factor.scale, e6.factorAlignment.minPixelSize = e6.factor.minPixelSize, e6.factorAlignment.paddingPixels = e6.factor.paddingPixels);
  }
  applyShaderOffsetsView(e6, t7, r9, s9, i6, a7, n7) {
    const o7 = this._normalAndViewAngle(t7, r9, i6, he);
    return this._applyVerticalGroundOffsetView(e6, o7, i6, n7), this._applyVerticalOffsetTransformationView(n7, o7, i6, a7), this._applyPolygonOffsetView(n7, o7, s9[3], i6, n7), this._applyCenterOffsetView(n7, s9, n7), n7;
  }
  applyShaderOffsetsNDC(e6, t7, r9, s9, i6) {
    return this._applyCenterOffsetNDC(e6, t7, r9, s9), null != i6 && r2(i6, s9), this._applyPolygonOffsetNDC(s9, t7, r9, s9), s9;
  }
  _applyPolygonOffsetView(t7, r9, s9, i6, a7) {
    const n7 = i6.aboveGround ? 1 : -1;
    let o7 = Math.sign(s9);
    0 === o7 && (o7 = n7);
    const c3 = n7 * o7;
    if (this.parameters.shaderPolygonOffset <= 0)
      return r2(a7, t7);
    const l4 = i(Math.abs(r9.cosAngle), 0.01, 1), f4 = 1 - Math.sqrt(1 - l4 * l4) / l4 / i6.viewport[2];
    return g(a7, t7, c3 > 0 ? f4 : 1 / f4), a7;
  }
  _applyVerticalGroundOffsetView(e6, t7, r9, s9) {
    const i6 = s3(e6), a7 = r9.aboveGround ? 1 : -1, n7 = 0.5 * r9.computeRenderPixelSizeAtDist(i6), o7 = g(ie, t7.normal, a7 * n7);
    return u(s9, e6, o7), s9;
  }
  _applyVerticalOffsetTransformationView(e6, t7, r9, s9) {
    const i6 = this.parameters;
    if (!i6.verticalOffset || !i6.verticalOffset.screenLength) {
      if (i6.screenSizePerspective || i6.screenSizePerspectiveAlignment) {
        const r10 = s3(e6);
        this._updateScaleInfo(s9, r10, t7.cosAngle);
      } else
        s9.factor.scale = 1, s9.factorAlignment.scale = 1;
      return e6;
    }
    const a7 = s3(e6), n7 = i6.screenSizePerspectiveAlignment ?? i6.screenSizePerspective, o7 = V(r9, a7, i6.verticalOffset, t7.cosAngle, n7);
    return this._updateScaleInfo(s9, a7, t7.cosAngle), g(t7.normal, t7.normal, o7), u(e6, e6, t7.normal);
  }
  _applyCenterOffsetView(e6, t7, r9) {
    const s9 = "screen" !== this.parameters.centerOffsetUnits;
    return r9 !== e6 && r2(r9, e6), s9 && (r9[0] += t7[0], r9[1] += t7[1], t7[2] && (z(ae, r9), u(r9, r9, g(ae, ae, t7[2])))), r9;
  }
  _applyCenterOffsetNDC(e6, t7, r9, s9) {
    const i6 = "screen" !== this.parameters.centerOffsetUnits;
    return s9 !== e6 && r2(s9, e6), i6 || (s9[0] += t7[0] / r9.fullWidth * 2, s9[1] += t7[1] / r9.fullHeight * 2), s9;
  }
  _applyPolygonOffsetNDC(e6, t7, r9, s9) {
    const i6 = this.parameters.shaderPolygonOffset;
    if (e6 !== s9 && r2(s9, e6), i6) {
      const e7 = r9.aboveGround ? 1 : -1, a7 = e7 * Math.sign(t7[3]);
      s9[2] -= (a7 || e7) * i6;
    }
    return s9;
  }
  requiresSlot(e6, t7) {
    if (t7 === h2.Color || t7 === h2.Alpha || t7 === h2.Highlight || t7 === h2.ObjectAndLayerIdColor) {
      if (e6 === E3.DRAPED_MATERIAL)
        return true;
      const { drawInSecondSlot: t8, occlusionTest: r9 } = this.parameters;
      return e6 === (t8 ? E3.LABEL_MATERIAL : E3.HUD_MATERIAL) || r9 && e6 === E3.OCCLUSION_PIXELS;
    }
    return false;
  }
  createGLMaterial(e6) {
    return new Q(e6);
  }
  calculateRelativeScreenBounds(e6, t7, r9 = i2()) {
    return $(this.parameters, e6, t7, r9), r9[2] = r9[0] + e6[0], r9[3] = r9[1] + e6[1], r9;
  }
};
var Q = class extends r6 {
  constructor(e6) {
    super({ ...e6, ...e6.material.parameters });
  }
  selectProgram(e6) {
    return this.ensureTechnique(g3, e6);
  }
  beginSlot(e6) {
    return this.updateTexture(this._material.parameters.textureId), this._material.setParameters(this.textureBindParameters), this.selectProgram(e6);
  }
};
function $(e6, t7, r9, s9 = se) {
  return a(s9, e6.anchorPosition), s9[0] *= -t7[0], s9[1] *= -t7[1], s9[0] += e6.screenOffset[0] * r9, s9[1] += e6.screenOffset[1] * r9, s9;
}
function ee(e6) {
  const t7 = e6[0], r9 = e6[1], s9 = e6[2], i6 = e6[3], a7 = e6[4], n7 = e6[5], o7 = e6[6], c3 = e6[7], l4 = e6[8], f4 = 1 / Math.sqrt(t7 * t7 + r9 * r9 + s9 * s9), u5 = 1 / Math.sqrt(i6 * i6 + a7 * a7 + n7 * n7), p4 = 1 / Math.sqrt(o7 * o7 + c3 * c3 + l4 * l4);
  return e6[0] = t7 * f4, e6[1] = r9 * f4, e6[2] = s9 * f4, e6[3] = i6 * u5, e6[4] = a7 * u5, e6[5] = n7 * u5, e6[6] = o7 * p4, e6[7] = c3 * p4, e6[8] = l4 * p4, e6;
}
function te(e6, t7, r9, s9, i6, a7, n7, o7) {
  let c3 = t7 - i6 - (o7[0] > 0 ? s9[0] * o7[0] : 0), l4 = c3 + s9[0] + 2 * i6, f4 = r9 - i6 - (o7[1] > 0 ? s9[1] * o7[1] : 0), u5 = f4 + s9[1] + 2 * i6;
  const p4 = n7.distanceFieldBoundingBox;
  return n7.textureIsSignedDistanceField && null != p4 && (c3 += s9[0] * p4[0], f4 += s9[1] * p4[1], l4 -= s9[0] * (1 - p4[2]), u5 -= s9[1] * (1 - p4[3]), c3 -= a7, l4 += a7, f4 -= a7, u5 += a7), e6[0] > c3 && e6[0] < l4 && e6[1] > f4 && e6[1] < u5;
}
var re = new t5();
var se = n5();
var ie = n();
var ae = n();
var ne = n4();
var oe = n();
var ce = n();
var le = e3();
var fe = e3();
var ue = e4();
var pe = n();
var he = { normal: oe, cosAngle: 0 };
var me = e4();
var de = 1;
var ge = 2;
var Oe = [0, 0];
var Se = r(0, 0, 1);
var ve = class extends l2 {
  constructor() {
    super(...arguments), this.renderOccluded = o3.Occlude, this.color = r4(1, 1, 1, 1), this.texCoordScale = [1, 1], this.polygonOffset = false, this.anchorPosition = r5(0.5, 0.5), this.screenOffset = [0, 0], this.shaderPolygonOffset = 1e-5, this.textureIsSignedDistanceField = false, this.outlineColor = r4(1, 1, 1, 1), this.outlineSize = 0, this.vvSizeEnabled = false, this.vvSize = null, this.vvColor = null, this.vvOpacity = null, this.vvSymbolAnchor = null, this.vvSymbolRotationMatrix = null, this.hasSlicePlane = false, this.pixelSnappingEnabled = true, this.occlusionTest = true, this.binaryHighlightOcclusion = true, this.centerOffsetUnits = "world", this.drawInSecondSlot = false, this.depthEnabled = true, this.isDraped = false;
  }
};
var Ae = H().vec3f(O2.POSITION).vec3f(O2.NORMAL).vec2f(O2.UV0).vec4u8(O2.COLOR).vec2f(O2.SIZE).vec4f(O2.AUXPOS1).vec4f(O2.AUXPOS2);
var be = Ae.clone().vec4u8(O2.OBJECTANDLAYERIDCOLOR);
var Pe = class {
  constructor(e6) {
    this._material = e6, this.vertexBufferLayout = has("enable-feature:objectAndLayerId-rendering") ? be : Ae;
  }
  elementCount(e6) {
    return 6 * e6.indices.get(O2.POSITION).length;
  }
  write(e6, t7, r9, s9, i6) {
    b(r9.indices.get(O2.POSITION), r9.vertexAttributes.get(O2.POSITION).data, e6, s9.position, i6, 6), O3(r9.indices.get(O2.NORMAL), r9.vertexAttributes.get(O2.NORMAL).data, t7, s9.normal, i6, 6);
    const a7 = r9.vertexAttributes.get(O2.UV0).data;
    let n7, o7, c3, l4;
    if (null == a7 || a7.length < 4) {
      const e7 = this._material.parameters;
      n7 = 0, o7 = 0, c3 = e7.texCoordScale[0], l4 = e7.texCoordScale[1];
    } else
      n7 = a7[0], o7 = a7[1], c3 = a7[2], l4 = a7[3];
    c3 = Math.min(1.99999, c3 + 1), l4 = Math.min(1.99999, l4 + 1);
    let f4 = r9.indices.get(O2.POSITION).length, u5 = i6;
    const p4 = s9.uv0;
    for (let g4 = 0; g4 < f4; ++g4)
      p4.set(u5, 0, n7), p4.set(u5, 1, o7), u5 += 1, p4.set(u5, 0, c3), p4.set(u5, 1, o7), u5 += 1, p4.set(u5, 0, c3), p4.set(u5, 1, l4), u5 += 1, p4.set(u5, 0, c3), p4.set(u5, 1, l4), u5 += 1, p4.set(u5, 0, n7), p4.set(u5, 1, l4), u5 += 1, p4.set(u5, 0, n7), p4.set(u5, 1, o7), u5 += 1;
    N(r9.indices.get(O2.COLOR), r9.vertexAttributes.get(O2.COLOR).data, 4, s9.color, i6, 6);
    const h4 = r9.indices.get(O2.SIZE), m3 = r9.vertexAttributes.get(O2.SIZE).data;
    f4 = h4.length;
    const d5 = s9.size;
    u5 = i6;
    for (let g4 = 0; g4 < f4; ++g4) {
      const e7 = m3[2 * h4[g4]], t8 = m3[2 * h4[g4] + 1];
      for (let r10 = 0; r10 < 6; ++r10)
        d5.set(u5, 0, e7), d5.set(u5, 1, t8), u5 += 1;
    }
    if (r9.indices.get(O2.AUXPOS1) && r9.vertexAttributes.get(O2.AUXPOS1) ? p(r9.indices.get(O2.AUXPOS1), r9.vertexAttributes.get(O2.AUXPOS1).data, s9.auxpos1, i6, 6) : y(s9.auxpos1, i6, 6 * f4), r9.indices.get(O2.AUXPOS2) && r9.vertexAttributes.get(O2.AUXPOS2) ? p(r9.indices.get(O2.AUXPOS2), r9.vertexAttributes.get(O2.AUXPOS2).data, s9.auxpos2, i6, 6) : y(s9.auxpos2, i6, 6 * f4), null != r9.objectAndLayerIdColor) {
      if (r9.indices.get(O2.POSITION)) {
        const e7 = r9.indices.get(O2.POSITION).length, t8 = s9.getField(O2.OBJECTANDLAYERIDCOLOR, x2);
        R2(r9.objectAndLayerIdColor, t8, e7, i6, 6);
      }
    }
  }
};

export {
  u3 as u,
  c,
  f2 as f,
  d3 as d,
  m,
  p2 as p,
  g2 as g,
  R3 as R,
  T,
  u4 as u2,
  a5 as a,
  s7 as s,
  l3 as l,
  d4 as d2,
  f3 as f2,
  o6 as o,
  t5 as t,
  K
};
//# sourceMappingURL=chunk-6WY3ZZYN.js.map
