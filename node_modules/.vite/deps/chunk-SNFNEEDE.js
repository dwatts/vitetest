import {
  r as r2
} from "./chunk-M7PTINEZ.js";
import {
  H as H2
} from "./chunk-Z7LZRT7C.js";
import {
  e as e2
} from "./chunk-OX5TJXHM.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  M,
  l
} from "./chunk-TEHNQYQD.js";
import {
  H,
  P,
  _,
  e,
  o,
  r,
  u,
  x,
  z
} from "./chunk-TPJLFGOT.js";
import {
  n
} from "./chunk-CQX57DED.js";
import {
  t,
  w
} from "./chunk-JZJWZ6DN.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/bufferLayouts.js
var A = H2().vec3f(O.POSITION).u16(O.COMPONENTINDEX).u16(O.U16PADDING);
var e3 = H2().vec2u8(O.SIDENESS);
var T = r2(e3);
var E = H2().vec3f(O.POSITION0).vec3f(O.POSITION1).u16(O.COMPONENTINDEX).u8(O.VARIANTOFFSET, { glNormalized: true }).u8(O.VARIANTSTROKE).u8(O.VARIANTEXTENSION, { glNormalized: true }).u8(O.U8PADDING, { glPadding: true }).u16(O.U16PADDING, { glPadding: true });
var S = E.clone().vec3f(O.NORMAL);
var r3 = E.clone().vec3f(O.NORMALA).vec3f(O.NORMALB);
var o2 = /* @__PURE__ */ new Map([[O.POSITION0, 0], [O.POSITION1, 1], [O.COMPONENTINDEX, 2], [O.VARIANTOFFSET, 3], [O.VARIANTSTROKE, 4], [O.VARIANTEXTENSION, 5], [O.NORMAL, 6], [O.NORMALA, 6], [O.NORMALB, 7], [O.SIDENESS, 8]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgePreprocessing.js
var m = -1;
var u2;
function p(n2, a3, i, l3 = V) {
  const f3 = n2.vertices.position, g3 = n2.vertices.componentIndex, u5 = M(l3.anglePlanar), p4 = M(l3.angleSignificantEdge), y3 = Math.cos(p4), E2 = Math.cos(u5), N = I.edge, S2 = N.position0, x2 = N.position1, j = N.faceNormal0, D = N.faceNormal1, F = w2(n2), L = d(n2), b = L.length / 4, k = a3.allocate(b);
  let C = 0;
  const H3 = b, K = i.allocate(H3);
  let M2 = 0, O2 = 0, P2 = 0;
  const T2 = w(0, b), U = new Float32Array(b);
  U.forEach((e4, t3, n3) => {
    f3.getVec(L[4 * t3], S2), f3.getVec(L[4 * t3 + 1], x2), n3[t3] = x(S2, x2);
  }), T2.sort((e4, t3) => U[t3] - U[e4]);
  const q = new Array(), z2 = new Array();
  for (let e4 = 0; e4 < b; e4++) {
    const t3 = T2[e4], n3 = U[t3], o3 = L[4 * t3], l4 = L[4 * t3 + 1], p5 = L[4 * t3 + 2], d4 = L[4 * t3 + 3], w4 = d4 === m;
    if (f3.getVec(o3, S2), f3.getVec(l4, x2), w4)
      o(j, F[3 * p5], F[3 * p5 + 1], F[3 * p5 + 2]), r(D, j), N.componentIndex = g3.get(o3), N.cosAngle = P(j, D);
    else {
      if (o(j, F[3 * p5], F[3 * p5 + 1], F[3 * p5 + 2]), o(D, F[3 * d4], F[3 * d4 + 1], F[3 * d4 + 2]), N.componentIndex = g3.get(o3), N.cosAngle = P(j, D), v(N, E2))
        continue;
      N.cosAngle < -0.9999 && r(D, j);
    }
    O2 += n3, P2++, w4 || h(N, y3) ? (a3.write(k, C++, N), q.push(n3)) : A2(N, u5) && (i.write(K, M2++, N), z2.push(n3));
  }
  const B = new Float32Array(q.reverse()), G = new Float32Array(z2.reverse());
  return { regular: { instancesData: a3.trim(k, C), lodInfo: { lengths: B } }, silhouette: { instancesData: i.trim(K, M2), lodInfo: { lengths: G } }, averageEdgeLength: O2 / P2 };
}
function h(e4, t3) {
  return e4.cosAngle < t3;
}
function v(e4, t3) {
  return e4.cosAngle > t3;
}
function A2(e4, t3) {
  const o3 = l(e4.cosAngle), r4 = I.fwd, c2 = I.ortho;
  H(r4, e4.position1, e4.position0);
  return o3 * (P(_(c2, e4.faceNormal0, e4.faceNormal1), r4) > 0 ? -1 : 1) > t3;
}
function d(e4) {
  const t3 = e4.faces.length / 3, n2 = e4.faces, o3 = e4.neighbors;
  let r4 = 0;
  for (let a3 = 0; a3 < t3; a3++) {
    const e5 = o3[3 * a3], t4 = o3[3 * a3 + 1], c3 = o3[3 * a3 + 2], s2 = n2[3 * a3], i = n2[3 * a3 + 1], l3 = n2[3 * a3 + 2];
    r4 += e5 === m || s2 < i ? 1 : 0, r4 += t4 === m || i < l3 ? 1 : 0, r4 += c3 === m || l3 < s2 ? 1 : 0;
  }
  const c2 = new Int32Array(4 * r4);
  let s = 0;
  for (let a3 = 0; a3 < t3; a3++) {
    const e5 = o3[3 * a3], t4 = o3[3 * a3 + 1], r5 = o3[3 * a3 + 2], i = n2[3 * a3], l3 = n2[3 * a3 + 1], f3 = n2[3 * a3 + 2];
    (e5 === m || i < l3) && (c2[s++] = i, c2[s++] = l3, c2[s++] = a3, c2[s++] = e5), (t4 === m || l3 < f3) && (c2[s++] = l3, c2[s++] = f3, c2[s++] = a3, c2[s++] = t4), (r5 === m || f3 < i) && (c2[s++] = f3, c2[s++] = i, c2[s++] = a3, c2[s++] = r5);
  }
  return c2;
}
function w2(e4) {
  const t3 = e4.faces.length / 3, n2 = e4.vertices.position, o3 = e4.faces, r4 = y.v0, c2 = y.v1, s = y.v2, a3 = new Float32Array(3 * t3);
  for (let g3 = 0; g3 < t3; g3++) {
    const e5 = o3[3 * g3], t4 = o3[3 * g3 + 1], m4 = o3[3 * g3 + 2];
    n2.getVec(e5, r4), n2.getVec(t4, c2), n2.getVec(m4, s), e(c2, c2, r4), e(s, s, r4), _(r4, c2, s), z(r4, r4), a3[3 * g3] = r4[0], a3[3 * g3 + 1] = r4[1], a3[3 * g3 + 2] = r4[2];
  }
  return a3;
}
!function(e4) {
  e4[e4.SOLID = 0] = "SOLID", e4[e4.SKETCH = 1] = "SKETCH";
}(u2 || (u2 = {}));
var I = { edge: { position0: n(), position1: n(), faceNormal0: n(), faceNormal1: n(), componentIndex: 0, cosAngle: 0 }, ortho: n(), fwd: n() };
var y = { v0: n(), v1: n(), v2: n() };
var V = { anglePlanar: 4, angleSignificantEdge: 35 };

// node_modules/@arcgis/core/views/3d/support/meshProcessing.js
function t2(t3, o3, n2) {
  const r4 = o3 / 3, c2 = new Uint32Array(n2 + 1), e4 = new Uint32Array(n2 + 1), s = (t4, o4) => {
    t4 < o4 ? c2[t4 + 1]++ : e4[o4 + 1]++;
  };
  for (let x2 = 0; x2 < r4; x2++) {
    const o4 = t3[3 * x2], n3 = t3[3 * x2 + 1], r5 = t3[3 * x2 + 2];
    s(o4, n3), s(n3, r5), s(r5, o4);
  }
  let f3 = 0, l3 = 0;
  for (let x2 = 0; x2 < n2; x2++) {
    const t4 = c2[x2 + 1], o4 = e4[x2 + 1];
    c2[x2 + 1] = f3, e4[x2 + 1] = l3, f3 += t4, l3 += o4;
  }
  const i = new Uint32Array(6 * r4), a3 = c2[n2], w4 = (t4, o4, n3) => {
    if (t4 < o4) {
      const r5 = c2[t4 + 1]++;
      i[2 * r5] = o4, i[2 * r5 + 1] = n3;
    } else {
      const r5 = e4[o4 + 1]++;
      i[2 * a3 + 2 * r5] = t4, i[2 * a3 + 2 * r5 + 1] = n3;
    }
  };
  for (let x2 = 0; x2 < r4; x2++) {
    const o4 = t3[3 * x2], n3 = t3[3 * x2 + 1], r5 = t3[3 * x2 + 2];
    w4(o4, n3, x2), w4(n3, r5, x2), w4(r5, o4, x2);
  }
  const y3 = (t4, o4) => {
    const n3 = 2 * t4, r5 = o4 - t4;
    for (let c3 = 1; c3 < r5; c3++) {
      const t5 = i[n3 + 2 * c3], o5 = i[n3 + 2 * c3 + 1];
      let r6 = c3 - 1;
      for (; r6 >= 0 && i[n3 + 2 * r6] > t5; r6--)
        i[n3 + 2 * r6 + 2] = i[n3 + 2 * r6], i[n3 + 2 * r6 + 3] = i[n3 + 2 * r6 + 1];
      i[n3 + 2 * r6 + 2] = t5, i[n3 + 2 * r6 + 3] = o5;
    }
  };
  for (let x2 = 0; x2 < n2; x2++)
    y3(c2[x2], c2[x2 + 1]), y3(a3 + e4[x2], a3 + e4[x2 + 1]);
  const A3 = new Int32Array(3 * r4), U = (o4, n3) => o4 === t3[3 * n3] ? 0 : o4 === t3[3 * n3 + 1] ? 1 : o4 === t3[3 * n3 + 2] ? 2 : -1, u5 = (t4, o4) => {
    const n3 = U(t4, o4);
    A3[3 * o4 + n3] = -1;
  }, p4 = (t4, o4, n3, r5) => {
    const c3 = U(t4, o4);
    A3[3 * o4 + c3] = r5;
    const e5 = U(n3, r5);
    A3[3 * r5 + e5] = o4;
  };
  for (let x2 = 0; x2 < n2; x2++) {
    let t4 = c2[x2];
    const o4 = c2[x2 + 1];
    let n3 = e4[x2];
    const r5 = e4[x2 + 1];
    for (; t4 < o4 && n3 < r5; ) {
      const o5 = i[2 * t4], r6 = i[2 * a3 + 2 * n3];
      o5 === r6 ? (p4(x2, i[2 * t4 + 1], r6, i[2 * a3 + 2 * n3 + 1]), t4++, n3++) : o5 < r6 ? (u5(x2, i[2 * t4 + 1]), t4++) : (u5(r6, i[2 * a3 + 2 * n3 + 1]), n3++);
    }
    for (; t4 < o4; )
      u5(x2, i[2 * t4 + 1]), t4++;
    for (; n3 < r5; ) {
      u5(i[2 * a3 + 2 * n3], i[2 * a3 + 2 * n3 + 1]), n3++;
    }
  }
  return A3;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgeBufferWriters.js
var a = class {
  updateSettings(t3) {
    this.settings = t3, this._edgeHashFunction = t3.reducedPrecision ? f : p2;
  }
  write(t3, o3, e4) {
    const n2 = this._edgeHashFunction(e4);
    y2.seed = n2;
    const i = y2.getIntRange(0, 255), r4 = y2.getIntRange(0, this.settings.variants - 1), s = 0.7, a3 = y2.getFloat(), c2 = 255 * (0.5 * g(-(1 - Math.min(a3 / s, 1)) + Math.max(0, a3 - s) / (1 - s), 1.2) + 0.5);
    t3.position0.setVec(o3, e4.position0), t3.position1.setVec(o3, e4.position1), t3.componentIndex.set(o3, e4.componentIndex), t3.variantOffset.set(o3, i), t3.variantStroke.set(o3, r4), t3.variantExtension.set(o3, c2);
  }
  trim(t3, o3) {
    return t3.slice(0, o3);
  }
};
var c = new Float32Array(6);
var m2 = new Uint32Array(c.buffer);
var u3 = new Uint32Array(1);
function p2(t3) {
  const o3 = c;
  o3[0] = t3.position0[0], o3[1] = t3.position0[1], o3[2] = t3.position0[2], o3[3] = t3.position1[0], o3[4] = t3.position1[1], o3[5] = t3.position1[2], u3[0] = 5381;
  for (let e4 = 0; e4 < m2.length; e4++)
    u3[0] = 31 * u3[0] + m2[e4];
  return u3[0];
}
function f(t3) {
  const o3 = c;
  o3[0] = h2(t3.position0[0]), o3[1] = h2(t3.position0[1]), o3[2] = h2(t3.position0[2]), o3[3] = h2(t3.position1[0]), o3[4] = h2(t3.position1[1]), o3[5] = h2(t3.position1[2]), u3[0] = 5381;
  for (let e4 = 0; e4 < m2.length; e4++)
    u3[0] = 31 * u3[0] + m2[e4];
  return u3[0];
}
var l2 = 1e4;
function h2(t3) {
  return Math.round(t3 * l2) / l2;
}
function g(t3, o3) {
  const e4 = t3 < 0 ? -1 : 1;
  return Math.abs(t3) ** o3 * e4;
}
var d2 = class {
  constructor() {
    this._commonWriter = new a();
  }
  updateSettings(t3) {
    this._commonWriter.updateSettings(t3);
  }
  allocate(t3) {
    return S.createBuffer(t3);
  }
  write(t3, n2, i) {
    this._commonWriter.write(t3, n2, i), u(_2, i.faceNormal0, i.faceNormal1), z(_2, _2), t3.normal.setVec(n2, _2);
  }
  trim(t3, o3) {
    return this._commonWriter.trim(t3, o3);
  }
};
d2.Layout = S, d2.glLayout = r2(S, 1);
var w3 = class {
  constructor() {
    this._commonWriter = new a();
  }
  updateSettings(t3) {
    this._commonWriter.updateSettings(t3);
  }
  allocate(t3) {
    return r3.createBuffer(t3);
  }
  write(t3, o3, e4) {
    this._commonWriter.write(t3, o3, e4), t3.normalA.setVec(o3, e4.faceNormal0), t3.normalB.setVec(o3, e4.faceNormal1);
  }
  trim(t3, o3) {
    return this._commonWriter.trim(t3, o3);
  }
};
w3.Layout = r3, w3.glLayout = r2(r3, 1);
var _2 = n();
var y2 = new t();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgeProcessing.js
function f2(e4) {
  const t3 = u4(e4.data, e4.skipDeduplicate, e4.indices, e4.indicesLength);
  return p3.updateSettings(e4.writerSettings), d3.updateSettings(e4.writerSettings), p(t3, p3, d3);
}
function u4(i, r4, n2, o3) {
  if (r4) {
    const e4 = t2(n2, o3, i.count);
    return new g2(n2, o3, e4, i);
  }
  const c2 = e2(i.buffer, i.stride / 4, { originalIndices: n2, originalIndicesLength: o3 }), f3 = t2(c2.indices, o3, c2.uniqueCount);
  return { faces: c2.indices, facesLength: c2.indices.length, neighbors: f3, vertices: A.createView(c2.buffer) };
}
var g2 = class {
  constructor(e4, t3, i, r4) {
    this.faces = e4, this.facesLength = t3, this.neighbors = i, this.vertices = r4;
  }
};
var p3 = new d2();
var d3 = new w3();
var a2 = H2().vec3f(O.POSITION0).vec3f(O.POSITION1);
var m3 = H2().vec3f(O.POSITION0).vec3f(O.POSITION1).u16(O.COMPONENTINDEX).u16(O.U16PADDING, { glPadding: true });

export {
  A,
  e3 as e,
  T,
  o2 as o,
  u2 as u,
  p,
  d2 as d,
  w3 as w,
  f2 as f,
  u4 as u2,
  a2 as a,
  m3 as m
};
//# sourceMappingURL=chunk-SNFNEEDE.js.map
